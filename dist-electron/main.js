<<<<<<< HEAD
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
import require$$1$8, { app, dialog, Menu, ipcMain, shell, BrowserWindow, globalShortcut } from "electron";
import { createRequire } from "node:module";
import { fileURLToPath } from "node:url";
import require$$1$3 from "util";
import require$$1$2, { Readable as Readable$2 } from "stream";
import require$$1$4 from "path";
import require$$3$2 from "http";
import require$$4$2 from "https";
import require$$0$3 from "url";
import fs$w from "fs";
import require$$0$4 from "crypto";
import require$$2$3 from "assert";
import require$$1$5 from "tty";
import require$$2$2 from "os";
import zlib$4 from "zlib";
import require$$0$6, { EventEmitter as EventEmitter$4 } from "events";
import require$$0$5 from "buffer";
import require$$1$6 from "constants";
import require$$1$7 from "string_decoder";
import require$$1$9, { spawn } from "child_process";
import fs$x from "node:fs";
import path$t from "node:path";
function bind$2(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString$2 } = Object.prototype;
const { getPrototypeOf: getPrototypeOf$1 } = Object;
const { iterator, toStringTag: toStringTag$1 } = Symbol;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str2 = toString$2.call(thing);
  return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray: isArray$1 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer$1(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$1 = typeOfTest("string");
const isFunction$1 = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean$1 = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf$1(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag$1 in val) && !(iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction$1(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest$2, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key2;
    for (i = 0; i < len; i++) {
      key2 = keys[i];
      fn.call(null, obj[key2], key2, obj);
    }
  }
}
function findKey(obj, key2) {
  key2 = key2.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key2 === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge$1() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key2) => {
    const targetKey = caseless && findKey(result, key2) || key2;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge$1(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge$1({}, val);
    } else if (isArray$1(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
=======
var nx = Object.defineProperty;
var rx = (e, t, n) => t in e ? nx(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var be = (e, t, n) => rx(e, typeof t != "symbol" ? t + "" : t, n);
import zn, { app as cn, dialog as _m, Menu as Sm, ipcMain as Vn, shell as ix, BrowserWindow as Am, globalShortcut as ax } from "electron";
import { createRequire as Tm } from "node:module";
import { fileURLToPath as sx } from "node:url";
import De from "util";
import ae, { Readable as ox } from "stream";
import ne from "path";
import Cs from "http";
import Zl from "https";
import $t from "url";
import se from "fs";
import Ur from "crypto";
import Rs from "assert";
import Cm from "tty";
import $s from "os";
import et from "zlib";
import Yn, { EventEmitter as cx } from "events";
import Bt from "buffer";
import Rm from "constants";
import Os from "string_decoder";
import Is, { spawn as Pp } from "child_process";
import kp from "node:fs";
import lt from "node:path";
function $m(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: lx } = Object.prototype, { getPrototypeOf: Ql } = Object, { iterator: Ds, toStringTag: Om } = Symbol, Fs = /* @__PURE__ */ ((e) => (t) => {
  const n = lx.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), vt = (e) => (e = e.toLowerCase(), (t) => Fs(t) === e), Ps = (e) => (t) => typeof t === e, { isArray: Br } = Array, mi = Ps("undefined");
function ux(e) {
  return e !== null && !mi(e) && e.constructor !== null && !mi(e.constructor) && tt(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const Im = vt("ArrayBuffer");
function px(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && Im(e.buffer), t;
}
const fx = Ps("string"), tt = Ps("function"), Dm = Ps("number"), ks = (e) => e !== null && typeof e == "object", dx = (e) => e === !0 || e === !1, Ga = (e) => {
  if (Fs(e) !== "object")
    return !1;
  const t = Ql(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Om in e) && !(Ds in e);
}, hx = vt("Date"), mx = vt("File"), vx = vt("Blob"), gx = vt("FileList"), bx = (e) => ks(e) && tt(e.pipe), xx = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || tt(e.append) && ((t = Fs(e)) === "formdata" || // detect form-data instance
  t === "object" && tt(e.toString) && e.toString() === "[object FormData]"));
}, yx = vt("URLSearchParams"), [wx, Ex, _x, Sx] = ["ReadableStream", "Request", "Response", "Headers"].map(vt), Ax = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Li(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), Br(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e), s = a.length;
    let c;
    for (r = 0; r < s; r++)
      c = a[r], t.call(null, e[c], c, e);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  return result;
}
<<<<<<< HEAD
const extend$2 = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key2) => {
    if (thisArg && isFunction$1(val)) {
      a[key2] = bind$2(val, thisArg);
    } else {
      a[key2] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits$1 = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
=======
function Fm(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const Pn = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, Pm = (e) => !mi(e) && e !== Pn;
function vl() {
  const { caseless: e } = Pm(this) && this || {}, t = {}, n = (r, i) => {
    const a = e && Fm(t, i) || i;
    Ga(t[a]) && Ga(r) ? t[a] = vl(t[a], r) : Ga(r) ? t[a] = vl({}, r) : Br(r) ? t[a] = r.slice() : t[a] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && Li(arguments[r], n);
  return t;
}
const Tx = (e, t, n, { allOwnKeys: r } = {}) => (Li(t, (i, a) => {
  n && tt(i) ? e[a] = $m(i, n) : e[a] = i;
}, { allOwnKeys: r }), e), Cx = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Rx = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, $x = (e, t, n, r) => {
  let i, a, s;
  const c = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), a = i.length; a-- > 0; )
      s = i[a], (!r || r(s, e, t)) && !c[s] && (t[s] = e[s], c[s] = !0);
    e = n !== !1 && Ql(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, Ox = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, Ix = (e) => {
  if (!e) return null;
  if (Br(e)) return e;
  let t = e.length;
  if (!Dm(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, Dx = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Ql(Uint8Array)), Fx = (e, t) => {
  const r = (e && e[Ds]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const a = i.value;
    t.call(e, a[0], a[1]);
  }
}, Px = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, kx = vt("HTMLFormElement"), Lx = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), Lp = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), Nx = vt("RegExp"), km = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  Li(n, (i, a) => {
    let s;
    (s = t(i, a, e)) !== !1 && (r[a] = s || i);
  }), Object.defineProperties(e, r);
}, Ux = (e) => {
  km(e, (t, n) => {
    if (tt(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (tt(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf$1(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str2, searchString, position) => {
  str2 = String(str2);
  if (position === void 0 || position > str2.length) {
    position = str2.length;
  }
  position -= searchString.length;
  const lastIndex = str2.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray$1 = (thing) => {
  if (!thing) return null;
  if (isArray$1(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray2) => {
  return (thing) => {
    return TypedArray2 && thing instanceof TypedArray2;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf$1(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str2) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str2)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str2) => {
  return str2.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty$1 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
<<<<<<< HEAD
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction$1(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$6 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$1(thing.append) && thing[toStringTag$1] === "FormData" && thing[iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray$1(source) ? [] : {};
        forEach(source, (value, key2) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key2] = reducedValue);
        });
        stack[i] = void 0;
        return target;
=======
}, Bx = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((a) => {
      n[a] = !0;
    });
  };
  return Br(e) ? r(e) : r(String(e).split(t)), n;
}, jx = () => {
}, Mx = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function qx(e) {
  return !!(e && tt(e.append) && e[Om] === "FormData" && e[Ds]);
}
const zx = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (ks(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const a = Br(r) ? [] : {};
        return Li(r, (s, c) => {
          const o = n(s, i + 1);
          !mi(o) && (a[c] = o);
        }), t[i] = void 0, a;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    }
    return source;
  };
<<<<<<< HEAD
  return visit(obj, 0);
=======
  return n(e, 0);
}, Hx = vt("AsyncFunction"), Wx = (e) => e && (ks(e) || tt(e)) && tt(e.then) && tt(e.catch), Lm = ((e, t) => e ? setImmediate : t ? ((n, r) => (Pn.addEventListener("message", ({ source: i, data: a }) => {
  i === Pn && a === n && r.length && r.shift()();
}, !1), (i) => {
  r.push(i), Pn.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  tt(Pn.postMessage)
), Gx = typeof queueMicrotask < "u" ? queueMicrotask.bind(Pn) : typeof process < "u" && process.nextTick || Lm, Vx = (e) => e != null && tt(e[Ds]), F = {
  isArray: Br,
  isArrayBuffer: Im,
  isBuffer: ux,
  isFormData: xx,
  isArrayBufferView: px,
  isString: fx,
  isNumber: Dm,
  isBoolean: dx,
  isObject: ks,
  isPlainObject: Ga,
  isReadableStream: wx,
  isRequest: Ex,
  isResponse: _x,
  isHeaders: Sx,
  isUndefined: mi,
  isDate: hx,
  isFile: mx,
  isBlob: vx,
  isRegExp: Nx,
  isFunction: tt,
  isStream: bx,
  isURLSearchParams: yx,
  isTypedArray: Dx,
  isFileList: gx,
  forEach: Li,
  merge: vl,
  extend: Tx,
  trim: Ax,
  stripBOM: Cx,
  inherits: Rx,
  toFlatObject: $x,
  kindOf: Fs,
  kindOfTest: vt,
  endsWith: Ox,
  toArray: Ix,
  forEachEntry: Fx,
  matchAll: Px,
  isHTMLForm: kx,
  hasOwnProperty: Lp,
  hasOwnProp: Lp,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: km,
  freezeMethods: Ux,
  toObjectSet: Bx,
  toCamelCase: Lx,
  noop: jx,
  toFiniteNumber: Mx,
  findKey: Fm,
  global: Pn,
  isContextDefined: Pm,
  isSpecCompliantForm: qx,
  toJSONObject: zx,
  isAsyncFn: Hx,
  isThenable: Wx,
  setImmediate: Lm,
  asap: Gx,
  isIterable: Vx
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction$1(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
const utils$h = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isBoolean: isBoolean$1,
  isObject: isObject$1,
  isPlainObject,
  isReadableStream,
  isRequest: isRequest$2,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend: extend$2,
  trim,
  stripBOM,
  inherits: inherits$1,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$1,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$1,
  hasOwnProp: hasOwnProperty$1,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$6,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};
function AxiosError$1(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
<<<<<<< HEAD
utils$h.inherits(AxiosError$1, Error, {
  toJSON: function toJSON() {
=======
F.inherits(V, Error, {
  toJSON: function() {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
<<<<<<< HEAD
      config: utils$h.toJSONObject(this.config),
=======
      config: F.toJSONObject(this.config),
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      code: this.code,
      status: this.status
    };
  }
});
<<<<<<< HEAD
const prototype$1 = AxiosError$1.prototype;
const descriptors = {};
=======
const Nm = V.prototype, Um = {};
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
<<<<<<< HEAD
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error2, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$h.toFlatObject(error2, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError$1.call(axiosError, error2.message, code, config, request, response);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var Stream$3 = require$$1$2.Stream;
var util$d = require$$1$3;
var delayed_stream = DelayedStream$1;
function DelayedStream$1() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;
  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util$d.inherits(DelayedStream$1, Stream$3);
DelayedStream$1.create = function(source, options) {
  var delayedStream = new this();
  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }
  delayedStream.source = source;
  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };
  source.on("error", function() {
  });
  if (delayedStream.pauseStream) {
    source.pause();
  }
  return delayedStream;
};
Object.defineProperty(DelayedStream$1.prototype, "readable", {
  configurable: true,
  enumerable: true,
=======
].forEach((e) => {
  Um[e] = { value: e };
});
Object.defineProperties(V, Um);
Object.defineProperty(Nm, "isAxiosError", { value: !0 });
V.from = (e, t, n, r, i, a) => {
  const s = Object.create(Nm);
  return F.toFlatObject(e, s, function(o) {
    return o !== Error.prototype;
  }, (c) => c !== "isAxiosError"), V.call(s, e.message, t, n, r, i), s.cause = e, s.name = e.name, a && Object.assign(s, a), s;
};
var Ae = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function eu(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Bm = ae.Stream, Yx = De, Xx = gt;
function gt() {
  this.source = null, this.dataSize = 0, this.maxDataSize = 1024 * 1024, this.pauseStream = !0, this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = [];
}
Yx.inherits(gt, Bm);
gt.create = function(e, t) {
  var n = new this();
  t = t || {};
  for (var r in t)
    n[r] = t[r];
  n.source = e;
  var i = e.emit;
  return e.emit = function() {
    return n._handleEmit(arguments), i.apply(e, arguments);
  }, e.on("error", function() {
  }), n.pauseStream && e.pause(), n;
};
Object.defineProperty(gt.prototype, "readable", {
  configurable: !0,
  enumerable: !0,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  get: function() {
    return this.source.readable;
  }
});
<<<<<<< HEAD
DelayedStream$1.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream$1.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }
  this.source.resume();
};
DelayedStream$1.prototype.pause = function() {
  this.source.pause();
};
DelayedStream$1.prototype.release = function() {
  this._released = true;
  this._bufferedEvents.forEach((function(args) {
    this.emit.apply(this, args);
  }).bind(this));
  this._bufferedEvents = [];
};
DelayedStream$1.prototype.pipe = function() {
  var r = Stream$3.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};
DelayedStream$1.prototype._handleEmit = function(args) {
=======
gt.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
gt.prototype.resume = function() {
  this._released || this.release(), this.source.resume();
};
gt.prototype.pause = function() {
  this.source.pause();
};
gt.prototype.release = function() {
  this._released = !0, this._bufferedEvents.forEach((function(e) {
    this.emit.apply(this, e);
  }).bind(this)), this._bufferedEvents = [];
};
gt.prototype.pipe = function() {
  var e = Bm.prototype.pipe.apply(this, arguments);
  return this.resume(), e;
};
gt.prototype._handleEmit = function(e) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }
<<<<<<< HEAD
  if (args[0] === "data") {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
=======
  e[0] === "data" && (this.dataSize += e[1].length, this._checkIfMaxDataSizeExceeded()), this._bufferedEvents.push(e);
};
gt.prototype._checkIfMaxDataSizeExceeded = function() {
  if (!this._maxDataSizeExceeded && !(this.dataSize <= this.maxDataSize)) {
    this._maxDataSizeExceeded = !0;
    var e = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(e));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  this._bufferedEvents.push(args);
};
<<<<<<< HEAD
DelayedStream$1.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  this._maxDataSizeExceeded = true;
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this.emit("error", new Error(message));
};
var util$c = require$$1$3;
var Stream$2 = require$$1$2.Stream;
var DelayedStream = delayed_stream;
var combined_stream = CombinedStream$1;
function CombinedStream$1() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;
  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util$c.inherits(CombinedStream$1, Stream$2);
CombinedStream$1.create = function(options) {
  var combinedStream = new this();
  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }
  return combinedStream;
=======
var Kx = De, jm = ae.Stream, Np = Xx, Jx = we;
function we() {
  this.writable = !1, this.readable = !0, this.dataSize = 0, this.maxDataSize = 2 * 1024 * 1024, this.pauseStreams = !0, this._released = !1, this._streams = [], this._currentStream = null, this._insideLoop = !1, this._pendingNext = !1;
}
Kx.inherits(we, jm);
we.create = function(e) {
  var t = new this();
  e = e || {};
  for (var n in e)
    t[n] = e[n];
  return t;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
};
CombinedStream$1.isStreamLike = function(stream2) {
  return typeof stream2 !== "function" && typeof stream2 !== "string" && typeof stream2 !== "boolean" && typeof stream2 !== "number" && !Buffer.isBuffer(stream2);
};
<<<<<<< HEAD
CombinedStream$1.prototype.append = function(stream2) {
  var isStreamLike = CombinedStream$1.isStreamLike(stream2);
  if (isStreamLike) {
    if (!(stream2 instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream2, {
        maxDataSize: Infinity,
=======
we.prototype.append = function(e) {
  var t = we.isStreamLike(e);
  if (t) {
    if (!(e instanceof Np)) {
      var n = Np.create(e, {
        maxDataSize: 1 / 0,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        pauseStream: this.pauseStreams
      });
      stream2.on("data", this._checkDataSize.bind(this));
      stream2 = newStream;
    }
    this._handleErrors(stream2);
    if (this.pauseStreams) {
      stream2.pause();
    }
  }
  this._streams.push(stream2);
  return this;
};
<<<<<<< HEAD
CombinedStream$1.prototype.pipe = function(dest, options) {
  Stream$2.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
=======
we.prototype.pipe = function(e, t) {
  return jm.prototype.pipe.call(this, e, t), this.resume(), e;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
};
CombinedStream$1.prototype._getNext = function() {
  this._currentStream = null;
  if (this._insideLoop) {
    this._pendingNext = true;
    return;
  }
  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};
CombinedStream$1.prototype._realGetNext = function() {
  var stream2 = this._streams.shift();
  if (typeof stream2 == "undefined") {
    this.end();
    return;
  }
  if (typeof stream2 !== "function") {
    this._pipeNext(stream2);
    return;
  }
  var getStream = stream2;
  getStream((function(stream3) {
    var isStreamLike = CombinedStream$1.isStreamLike(stream3);
    if (isStreamLike) {
      stream3.on("data", this._checkDataSize.bind(this));
      this._handleErrors(stream3);
    }
    this._pipeNext(stream3);
  }).bind(this));
};
CombinedStream$1.prototype._pipeNext = function(stream2) {
  this._currentStream = stream2;
  var isStreamLike = CombinedStream$1.isStreamLike(stream2);
  if (isStreamLike) {
    stream2.on("end", this._getNext.bind(this));
    stream2.pipe(this, { end: false });
    return;
  }
  var value = stream2;
  this.write(value);
  this._getNext();
};
CombinedStream$1.prototype._handleErrors = function(stream2) {
  var self2 = this;
  stream2.on("error", function(err) {
    self2._emitError(err);
  });
};
CombinedStream$1.prototype.write = function(data) {
  this.emit("data", data);
};
CombinedStream$1.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }
  if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
  this.emit("pause");
};
CombinedStream$1.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }
  if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
  this.emit("resume");
};
CombinedStream$1.prototype.end = function() {
  this._reset();
  this.emit("end");
};
CombinedStream$1.prototype.destroy = function() {
  this._reset();
  this.emit("close");
};
CombinedStream$1.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};
CombinedStream$1.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this._emitError(new Error(message));
};
CombinedStream$1.prototype._updateDataSize = function() {
  this.dataSize = 0;
  var self2 = this;
  this._streams.forEach(function(stream2) {
    if (!stream2.dataSize) {
      return;
    }
    self2.dataSize += stream2.dataSize;
  });
  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};
<<<<<<< HEAD
CombinedStream$1.prototype._emitError = function(err) {
  this._reset();
  this.emit("error", err);
};
var mimeTypes = {};
const require$$0$2 = {
=======
we.prototype._updateDataSize = function() {
  this.dataSize = 0;
  var e = this;
  this._streams.forEach(function(t) {
    t.dataSize && (e.dataSize += t.dataSize);
  }), this._currentStream && this._currentStream.dataSize && (this.dataSize += this._currentStream.dataSize);
};
we.prototype._emitError = function(e) {
  this._reset(), this.emit("error", e);
};
var Mm = {};
const Zx = {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: true
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: true
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: true
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: true
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: true
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: true
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: false
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/calendar+json": {
    source: "iana",
    compressible: true
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: true
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: true
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: true
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: true
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: true
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: true
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: true
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: true
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: true
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/csvm+json": {
    source: "iana",
    compressible: true
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: true
  },
  "application/dash+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: true
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: true
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: true
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: true,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: false
  },
  "application/edifact": {
    source: "iana",
    compressible: false
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/elm+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: true
  },
  "application/emma+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: true
  },
  "application/epub+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: true
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fido.trusted-apps+json": {
    compressible: true
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: false
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: true
  },
  "application/geo+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: false,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: true
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: false,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: false,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: true
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: true
  },
  "application/jrd+json": {
    source: "iana",
    compressible: true
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: true
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: true,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: true
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: true
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/ld+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: true
  },
  "application/lost+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: false
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: true
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: true
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: true
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: true
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msword": {
    source: "iana",
    compressible: false,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: true
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: true
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: false,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: true
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: true
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: false
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: false,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: false,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/postscript": {
    source: "iana",
    compressible: true,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+xml": {
    source: "iana",
    compressible: true
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: false
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: true
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: true,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: true
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: true
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: true
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: true
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/sarif+json": {
    source: "iana",
    compressible: true
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: true
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: true
  },
  "application/scim+json": {
    source: "iana",
    compressible: true
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: true
  },
  "application/senml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: true
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: true
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: true
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: true
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: true
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: true
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: true
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: true
  },
  "application/swid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: true
  },
  "application/taxii+json": {
    source: "iana",
    compressible: true
  },
  "application/td+json": {
    source: "iana",
    compressible: true
  },
  "application/tei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: true
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: true,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: false,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vcard+json": {
    source: "iana",
    compressible: true
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: true
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: false,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: false,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: true,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: false,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: false,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: false,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: false,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: false,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: true,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-outlook": {
    compressible: false,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: false,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: false,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: false,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: false,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: false,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: true
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: true,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: true
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: false,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: false
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: false,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: true,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: false,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: true
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: false,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: false
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: true,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: false,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: true,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: false,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: false,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: true,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: true,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: true,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: true,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: true,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: false,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: true,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: true,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: true,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: true,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: true
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: false,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: true
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: true
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: true,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/xop+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/yin+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: false,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: false,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: false
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: false,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: false
  },
  "audio/vorbis": {
    source: "iana",
    compressible: false
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: false,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: false,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: true,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: false,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: false,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: false,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: false,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: false
  },
  "image/png": {
    source: "iana",
    compressible: false,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: false,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: true,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: true,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: false
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: false
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: true
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: false
  },
  "message/rfc822": {
    source: "iana",
    compressible: true,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: true,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: false,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: false,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: true
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: false,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: false
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: false
  },
  "multipart/form-data": {
    source: "iana",
    compressible: false
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: false
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: false
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: true,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: true
  },
  "text/cmd": {
    compressible: true
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: true,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: true,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: true
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: true,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: true,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: true,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: true,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: true,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: true,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: true,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: true,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: true
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: true
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: true,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: true,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: true,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: true,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: true,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: false,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: false,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: false,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: false,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: true
  },
  "x-shader/x-vertex": {
    compressible: true
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
<<<<<<< HEAD
var mimeDb = require$$0$2;
=======
var Qx = Zx;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
<<<<<<< HEAD
(function(exports) {
  var db = mimeDb;
  var extname = require$$1$4.extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = /* @__PURE__ */ Object.create(null);
  exports.lookup = lookup;
  exports.types = /* @__PURE__ */ Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type2) {
    if (!type2 || typeof type2 !== "string") {
      return false;
=======
(function(e) {
  var t = Qx, n = ne.extname, r = /^\s*([^;\s]*)(?:;|\s|$)/, i = /^text\//i;
  e.charset = a, e.charsets = { lookup: a }, e.contentType = s, e.extension = c, e.extensions = /* @__PURE__ */ Object.create(null), e.lookup = o, e.types = /* @__PURE__ */ Object.create(null), u(e.extensions, e.types);
  function a(l) {
    if (!l || typeof l != "string")
      return !1;
    var p = r.exec(l), f = p && t[p[1].toLowerCase()];
    return f && f.charset ? f.charset : p && i.test(p[1]) ? "UTF-8" : !1;
  }
  function s(l) {
    if (!l || typeof l != "string")
      return !1;
    var p = l.indexOf("/") === -1 ? e.lookup(l) : l;
    if (!p)
      return !1;
    if (p.indexOf("charset") === -1) {
      var f = e.charset(p);
      f && (p += "; charset=" + f.toLowerCase());
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type2);
    var mime2 = match && db[match[1].toLowerCase()];
    if (mime2 && mime2.charset) {
      return mime2.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
<<<<<<< HEAD
  function contentType(str2) {
    if (!str2 || typeof str2 !== "string") {
      return false;
    }
    var mime2 = str2.indexOf("/") === -1 ? exports.lookup(str2) : str2;
    if (!mime2) {
      return false;
    }
    if (mime2.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime2);
      if (charset2) mime2 += "; charset=" + charset2.toLowerCase();
    }
    return mime2;
  }
  function extension(type2) {
    if (!type2 || typeof type2 !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type2);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path2) {
    if (!path2 || typeof path2 !== "string") {
      return false;
    }
    var extension2 = extname("x." + path2).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types2) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type2) {
      var mime2 = db[type2];
      var exts = mime2.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type2] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension2 = exts[i];
        if (types2[extension2]) {
          var from = preference.indexOf(db[types2[extension2]].source);
          var to = preference.indexOf(mime2.source);
          if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
            continue;
          }
=======
  function c(l) {
    if (!l || typeof l != "string")
      return !1;
    var p = r.exec(l), f = p && e.extensions[p[1].toLowerCase()];
    return !f || !f.length ? !1 : f[0];
  }
  function o(l) {
    if (!l || typeof l != "string")
      return !1;
    var p = n("x." + l).toLowerCase().substr(1);
    return p && e.types[p] || !1;
  }
  function u(l, p) {
    var f = ["nginx", "apache", void 0, "iana"];
    Object.keys(t).forEach(function(g) {
      var h = t[g], b = h.extensions;
      if (!(!b || !b.length)) {
        l[g] = b;
        for (var x = 0; x < b.length; x++) {
          var y = b[x];
          if (p[y]) {
            var E = f.indexOf(t[p[y]].source), S = f.indexOf(h.source);
            if (p[y] !== "application/octet-stream" && (E > S || E === S && p[y].substr(0, 12) === "application/"))
              continue;
          }
          p[y] = g;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        }
        types2[extension2] = type2;
      }
    });
  }
<<<<<<< HEAD
})(mimeTypes);
var defer_1 = defer$1;
function defer$1(fn) {
  var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  if (nextTick) {
    nextTick(fn);
  } else {
    setTimeout(fn, 0);
  }
}
var defer = defer_1;
var async_1 = async$2;
function async$2(callback) {
  var isAsync = false;
  defer(function() {
    isAsync = true;
  });
  return function async_callback(err, result) {
    if (isAsync) {
      callback(err, result);
    } else {
      defer(function nextTick_callback() {
        callback(err, result);
      });
    }
  };
}
var abort_1 = abort$2;
function abort$2(state2) {
  Object.keys(state2.jobs).forEach(clean$2.bind(state2));
  state2.jobs = {};
}
function clean$2(key2) {
  if (typeof this.jobs[key2] == "function") {
    this.jobs[key2]();
  }
}
var async$1 = async_1, abort$1 = abort_1;
var iterate_1 = iterate$2;
function iterate$2(list, iterator2, state2, callback) {
  var key2 = state2["keyedList"] ? state2["keyedList"][state2.index] : state2.index;
  state2.jobs[key2] = runJob(iterator2, key2, list[key2], function(error2, output) {
    if (!(key2 in state2.jobs)) {
      return;
    }
    delete state2.jobs[key2];
    if (error2) {
      abort$1(state2);
    } else {
      state2.results[key2] = output;
    }
    callback(error2, state2.results);
  });
}
function runJob(iterator2, key2, item, callback) {
  var aborter;
  if (iterator2.length == 2) {
    aborter = iterator2(item, async$1(callback));
  } else {
    aborter = iterator2(item, key2, async$1(callback));
  }
  return aborter;
}
var state_1 = state;
function state(list, sortMethod) {
  var isNamedList = !Array.isArray(list), initState2 = {
=======
})(Mm);
var ey = ty;
function ty(e) {
  var t = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  t ? t(e) : setTimeout(e, 0);
}
var Up = ey, qm = ny;
function ny(e) {
  var t = !1;
  return Up(function() {
    t = !0;
  }), function(r, i) {
    t ? e(r, i) : Up(function() {
      e(r, i);
    });
  };
}
var zm = ry;
function ry(e) {
  Object.keys(e.jobs).forEach(iy.bind(e)), e.jobs = {};
}
function iy(e) {
  typeof this.jobs[e] == "function" && this.jobs[e]();
}
var Bp = qm, ay = zm, Hm = sy;
function sy(e, t, n, r) {
  var i = n.keyedList ? n.keyedList[n.index] : n.index;
  n.jobs[i] = oy(t, i, e[i], function(a, s) {
    i in n.jobs && (delete n.jobs[i], a ? ay(n) : n.results[i] = s, r(a, n.results));
  });
}
function oy(e, t, n, r) {
  var i;
  return e.length == 2 ? i = e(n, Bp(r)) : i = e(n, t, Bp(r)), i;
}
var Wm = cy;
function cy(e, t) {
  var n = !Array.isArray(e), r = {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    index: 0,
    keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
    jobs: {},
    results: isNamedList ? {} : [],
    size: isNamedList ? Object.keys(list).length : list.length
  };
  if (sortMethod) {
    initState2.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
      return sortMethod(list[a], list[b]);
    });
  }
  return initState2;
}
<<<<<<< HEAD
var abort = abort_1, async = async_1;
var terminator_1 = terminator$2;
function terminator$2(callback) {
  if (!Object.keys(this.jobs).length) {
    return;
  }
  this.index = this.size;
  abort(this);
  async(callback)(null, this.results);
}
var iterate$1 = iterate_1, initState$1 = state_1, terminator$1 = terminator_1;
var parallel_1 = parallel;
function parallel(list, iterator2, callback) {
  var state2 = initState$1(list);
  while (state2.index < (state2["keyedList"] || list).length) {
    iterate$1(list, iterator2, state2, function(error2, result) {
      if (error2) {
        callback(error2, result);
=======
var ly = zm, uy = qm, Gm = py;
function py(e) {
  Object.keys(this.jobs).length && (this.index = this.size, ly(this), uy(e)(null, this.results));
}
var fy = Hm, dy = Wm, hy = Gm, my = vy;
function vy(e, t, n) {
  for (var r = dy(e); r.index < (r.keyedList || e).length; )
    fy(e, t, r, function(i, a) {
      if (i) {
        n(i, a);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        return;
      }
      if (Object.keys(state2.jobs).length === 0) {
        callback(null, state2.results);
        return;
      }
<<<<<<< HEAD
    });
    state2.index++;
  }
  return terminator$1.bind(state2, callback);
}
var serialOrdered$2 = { exports: {} };
var iterate = iterate_1, initState = state_1, terminator = terminator_1;
serialOrdered$2.exports = serialOrdered$1;
serialOrdered$2.exports.ascending = ascending;
serialOrdered$2.exports.descending = descending;
function serialOrdered$1(list, iterator2, sortMethod, callback) {
  var state2 = initState(list, sortMethod);
  iterate(list, iterator2, state2, function iteratorHandler(error2, result) {
    if (error2) {
      callback(error2, result);
      return;
    }
    state2.index++;
    if (state2.index < (state2["keyedList"] || list).length) {
      iterate(list, iterator2, state2, iteratorHandler);
      return;
    }
    callback(null, state2.results);
  });
  return terminator.bind(state2, callback);
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function descending(a, b) {
  return -1 * ascending(a, b);
}
var serialOrderedExports = serialOrdered$2.exports;
var serialOrdered = serialOrderedExports;
var serial_1 = serial;
function serial(list, iterator2, callback) {
  return serialOrdered(list, iterator2, null, callback);
}
var asynckit$1 = {
  parallel: parallel_1,
  serial: serial_1,
  serialOrdered: serialOrderedExports
};
var esObjectAtoms = Object;
var esErrors = Error;
var _eval = EvalError;
var range$1 = RangeError;
var ref = ReferenceError;
var syntax = SyntaxError;
var type$1 = TypeError;
var uri = URIError;
var abs$1 = Math.abs;
var floor$1 = Math.floor;
var max$2 = Math.max;
var min$1 = Math.min;
var pow$1 = Math.pow;
var round$1 = Math.round;
var _isNaN = Number.isNaN || function isNaN2(a) {
  return a !== a;
};
var $isNaN = _isNaN;
var sign$1 = function sign(number) {
  if ($isNaN(number) || number === 0) {
    return number;
  }
  return number < 0 ? -1 : 1;
};
var gOPD = Object.getOwnPropertyDescriptor;
var $gOPD$1 = gOPD;
if ($gOPD$1) {
  try {
    $gOPD$1([], "length");
  } catch (e) {
    $gOPD$1 = null;
  }
}
var gopd = $gOPD$1;
var $defineProperty$2 = Object.defineProperty || false;
if ($defineProperty$2) {
  try {
    $defineProperty$2({}, "a", { value: 1 });
  } catch (e) {
    $defineProperty$2 = false;
  }
}
var esDefineProperty = $defineProperty$2;
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
=======
    }), r.index++;
  return hy.bind(r, n);
}
var Ls = { exports: {} }, jp = Hm, gy = Wm, by = Gm;
Ls.exports = xy;
Ls.exports.ascending = Vm;
Ls.exports.descending = yy;
function xy(e, t, n, r) {
  var i = gy(e, n);
  return jp(e, t, i, function a(s, c) {
    if (s) {
      r(s, c);
      return;
    }
    if (i.index++, i.index < (i.keyedList || e).length) {
      jp(e, t, i, a);
      return;
    }
    r(null, i.results);
  }), by.bind(i, r);
}
function Vm(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function yy(e, t) {
  return -1 * Vm(e, t);
}
var Ym = Ls.exports, wy = Ym, Ey = _y;
function _y(e, t, n) {
  return wy(e, t, null, n);
}
var Sy = {
  parallel: my,
  serial: Ey,
  serialOrdered: Ym
}, Xm = Object, Ay = Error, Ty = EvalError, Cy = RangeError, Ry = ReferenceError, $y = SyntaxError, tu = TypeError, Oy = URIError, Iy = Math.abs, Dy = Math.floor, Fy = Math.max, Py = Math.min, ky = Math.pow, Ly = Math.round, Ny = Number.isNaN || function(t) {
  return t !== t;
}, Uy = Ny, By = function(t) {
  return Uy(t) || t === 0 ? t : t < 0 ? -1 : 1;
}, jy = Object.getOwnPropertyDescriptor, Va = jy;
if (Va)
  try {
    Va([], "length");
  } catch {
    Va = null;
  }
var Km = Va, Ya = Object.defineProperty || !1;
if (Ya)
  try {
    Ya({}, "a", { value: 1 });
  } catch {
    Ya = !1;
  }
var My = Ya, No, Mp;
function Jm() {
  return Mp || (Mp = 1, No = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, n = Symbol("test"), r = Object(n);
    if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
      return !1;
    var i = 42;
    t[n] = i;
    for (var a in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var s = Object.getOwnPropertySymbols(t);
    if (s.length !== 1 || s[0] !== n || !Object.prototype.propertyIsEnumerable.call(t, n))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var c = (
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
<<<<<<< HEAD
    return true;
  };
  return shams$1;
}
var hasSymbols$1;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols$1;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols$1 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols$1;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object2 = esObjectAtoms;
  Object_getPrototypeOf = $Object2.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr = Object.prototype.toString;
var max$1 = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a, b) {
  var arr = [];
  for (var i = 0; i < a.length; i += 1) {
    arr[i] = a[i];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset) {
  var arr = [];
  for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
    arr[j] = arrLike[i];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str2 = "";
  for (var i = 0; i < arr.length; i += 1) {
    str2 += arr[i];
    if (i + 1 < arr.length) {
      str2 += joiner;
    }
  }
  return str2;
};
var implementation$1 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        concatty(args, arguments)
=======
    return !0;
  }), No;
}
var Uo, qp;
function qy() {
  if (qp) return Uo;
  qp = 1;
  var e = typeof Symbol < "u" && Symbol, t = Jm();
  return Uo = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, Uo;
}
var Bo, zp;
function Zm() {
  return zp || (zp = 1, Bo = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Bo;
}
var jo, Hp;
function Qm() {
  if (Hp) return jo;
  Hp = 1;
  var e = Xm;
  return jo = e.getPrototypeOf || null, jo;
}
var zy = "Function.prototype.bind called on incompatible ", Hy = Object.prototype.toString, Wy = Math.max, Gy = "[object Function]", Wp = function(t, n) {
  for (var r = [], i = 0; i < t.length; i += 1)
    r[i] = t[i];
  for (var a = 0; a < n.length; a += 1)
    r[a + t.length] = n[a];
  return r;
}, Vy = function(t, n) {
  for (var r = [], i = n, a = 0; i < t.length; i += 1, a += 1)
    r[a] = t[i];
  return r;
}, Yy = function(e, t) {
  for (var n = "", r = 0; r < e.length; r += 1)
    n += e[r], r + 1 < e.length && (n += t);
  return n;
}, Xy = function(t) {
  var n = this;
  if (typeof n != "function" || Hy.apply(n) !== Gy)
    throw new TypeError(zy + n);
  for (var r = Vy(arguments, 1), i, a = function() {
    if (this instanceof i) {
      var l = n.apply(
        this,
        Wp(r, arguments)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
<<<<<<< HEAD
    return target.apply(
      that,
      concatty(args, arguments)
    );
  };
  var boundLength = max$1(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = "$" + i;
  }
  bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
=======
    return n.apply(
      t,
      Wp(r, arguments)
    );
  }, s = Wy(0, n.length - r.length), c = [], o = 0; o < s; o++)
    c[o] = "$" + o;
  if (i = Function("binder", "return function (" + Yy(c, ",") + "){ return binder.apply(this,arguments); }")(a), n.prototype) {
    var u = function() {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
<<<<<<< HEAD
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
=======
  return i;
}, Ky = Xy, Ns = Function.prototype.bind || Ky, Mo, Gp;
function nu() {
  return Gp || (Gp = 1, Mo = Function.prototype.call), Mo;
}
var qo, Vp;
function e0() {
  return Vp || (Vp = 1, qo = Function.prototype.apply), qo;
}
var zo, Yp;
function Jy() {
  return Yp || (Yp = 1, zo = typeof Reflect < "u" && Reflect && Reflect.apply), zo;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
}
var Ho, Xp;
function Zy() {
  if (Xp) return Ho;
  Xp = 1;
  var e = Ns, t = e0(), n = nu(), r = Jy();
  return Ho = r || e.call(n, t), Ho;
}
<<<<<<< HEAD
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind3 = functionBind;
  var $TypeError2 = type$1;
  var $call2 = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError2("a function is required");
    }
    return $actualApply(bind3, $call2, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = gopd;
  var hasProtoAccessor;
=======
var Wo, Kp;
function Qy() {
  if (Kp) return Wo;
  Kp = 1;
  var e = Ns, t = tu, n = nu(), r = Zy();
  return Wo = function(a) {
    if (a.length < 1 || typeof a[0] != "function")
      throw new t("a function is required");
    return r(e, n, a);
  }, Wo;
}
var Go, Jp;
function ew() {
  if (Jp) return Go;
  Jp = 1;
  var e = Qy(), t = Km, n;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
<<<<<<< HEAD
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
=======
  } catch (s) {
    if (!s || typeof s != "object" || !("code" in s) || s.code !== "ERR_PROTO_ACCESS")
      throw s;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
<<<<<<< HEAD
  );
  var $Object2 = Object;
  var $getPrototypeOf = $Object2.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
=======
  ), i = Object, a = i.getPrototypeOf;
  return Go = r && typeof r.get == "function" ? e([r.get]) : typeof a == "function" ? (
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object2(value));
    }
<<<<<<< HEAD
  ) : false;
  return get;
}
var getProto$1;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto$1;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = requireGet();
  getProto$1 = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto$1;
}
var call$1 = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind$1 = functionBind;
var hasown = bind$1.call(call$1, $hasOwn);
var undefined$1;
var $Object = esObjectAtoms;
var $Error = esErrors;
var $EvalError = _eval;
var $RangeError = range$1;
var $ReferenceError = ref;
var $SyntaxError = syntax;
var $TypeError$1 = type$1;
var $URIError = uri;
var abs = abs$1;
var floor = floor$1;
var max = max$2;
var min = min$1;
var pow = pow$1;
var round = round$1;
var sign2 = sign$1;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD = gopd;
var $defineProperty$1 = esDefineProperty;
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = requireHasSymbols()();
var getProto = requireGetProto();
var $ObjectGPO = requireObject_getPrototypeOf();
var $ReflectGPO = requireReflect_getPrototypeOf();
var $apply = requireFunctionApply();
var $call = requireFunctionCall();
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
=======
  ) : !1, Go;
}
var Vo, Zp;
function tw() {
  if (Zp) return Vo;
  Zp = 1;
  var e = Zm(), t = Qm(), n = ew();
  return Vo = e ? function(i) {
    return e(i);
  } : t ? function(i) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new TypeError("getProto: not an object");
    return t(i);
  } : n ? function(i) {
    return n(i);
  } : null, Vo;
}
var nw = Function.prototype.call, rw = Object.prototype.hasOwnProperty, iw = Ns, ru = iw.call(nw, rw), ie, aw = Xm, sw = Ay, ow = Ty, cw = Cy, lw = Ry, Ir = $y, _r = tu, uw = Oy, pw = Iy, fw = Dy, dw = Fy, hw = Py, mw = ky, vw = Ly, gw = By, t0 = Function, Yo = function(e) {
  try {
    return t0('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, vi = Km, bw = My, Xo = function() {
  throw new _r();
}, xw = vi ? function() {
  try {
    return arguments.callee, Xo;
  } catch {
    try {
      return vi(arguments, "callee").get;
    } catch {
      return Xo;
    }
  }
}() : Xo, nr = qy()(), Oe = tw(), yw = Qm(), ww = Zm(), n0 = e0(), Ni = nu(), pr = {}, Ew = typeof Uint8Array > "u" || !Oe ? ie : Oe(Uint8Array), Nn = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? ie : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? ie : ArrayBuffer,
  "%ArrayIteratorPrototype%": nr && Oe ? Oe([][Symbol.iterator]()) : ie,
  "%AsyncFromSyncIteratorPrototype%": ie,
  "%AsyncFunction%": pr,
  "%AsyncGenerator%": pr,
  "%AsyncGeneratorFunction%": pr,
  "%AsyncIteratorPrototype%": pr,
  "%Atomics%": typeof Atomics > "u" ? ie : Atomics,
  "%BigInt%": typeof BigInt > "u" ? ie : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? ie : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? ie : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? ie : DataView,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
<<<<<<< HEAD
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply,
  "%Object.defineProperty%": $defineProperty$1,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round,
  "%Math.sign%": sign2,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto) {
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
=======
  "%Error%": sw,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": ow,
  "%Float16Array%": typeof Float16Array > "u" ? ie : Float16Array,
  "%Float32Array%": typeof Float32Array > "u" ? ie : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? ie : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? ie : FinalizationRegistry,
  "%Function%": t0,
  "%GeneratorFunction%": pr,
  "%Int8Array%": typeof Int8Array > "u" ? ie : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? ie : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? ie : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": nr && Oe ? Oe(Oe([][Symbol.iterator]())) : ie,
  "%JSON%": typeof JSON == "object" ? JSON : ie,
  "%Map%": typeof Map > "u" ? ie : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !nr || !Oe ? ie : Oe((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": aw,
  "%Object.getOwnPropertyDescriptor%": vi,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? ie : Promise,
  "%Proxy%": typeof Proxy > "u" ? ie : Proxy,
  "%RangeError%": cw,
  "%ReferenceError%": lw,
  "%Reflect%": typeof Reflect > "u" ? ie : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? ie : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !nr || !Oe ? ie : Oe((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? ie : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": nr && Oe ? Oe(""[Symbol.iterator]()) : ie,
  "%Symbol%": nr ? Symbol : ie,
  "%SyntaxError%": Ir,
  "%ThrowTypeError%": xw,
  "%TypedArray%": Ew,
  "%TypeError%": _r,
  "%Uint8Array%": typeof Uint8Array > "u" ? ie : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? ie : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? ie : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? ie : Uint32Array,
  "%URIError%": uw,
  "%WeakMap%": typeof WeakMap > "u" ? ie : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? ie : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? ie : WeakSet,
  "%Function.prototype.call%": Ni,
  "%Function.prototype.apply%": n0,
  "%Object.defineProperty%": bw,
  "%Object.getPrototypeOf%": yw,
  "%Math.abs%": pw,
  "%Math.floor%": fw,
  "%Math.max%": dw,
  "%Math.min%": hw,
  "%Math.pow%": mw,
  "%Math.round%": vw,
  "%Math.sign%": gw,
  "%Reflect.getPrototypeOf%": ww
};
if (Oe)
  try {
    null.error;
  } catch (e) {
    var _w = Oe(Oe(e));
    Nn["%Error.prototype%"] = _w;
  }
var Sw = function e(t) {
  var n;
  if (t === "%AsyncFunction%")
    n = Yo("async function () {}");
  else if (t === "%GeneratorFunction%")
    n = Yo("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    n = Yo("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var r = e("%AsyncGeneratorFunction%");
    r && (n = r.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var i = e("%AsyncGenerator%");
    i && Oe && (n = Oe(i.prototype));
  }
  return Nn[t] = n, n;
}, Qp = {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
<<<<<<< HEAD
};
var bind2 = functionBind;
var hasOwn$2 = hasown;
var $concat = bind2.call($call, Array.prototype.concat);
var $spliceApply = bind2.call($apply, Array.prototype.splice);
var $replace = bind2.call($call, String.prototype.replace);
var $strSlice = bind2.call($call, String.prototype.slice);
var $exec = bind2.call($call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$2(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$2(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
=======
}, Ui = Ns, ss = ru, Aw = Ui.call(Ni, Array.prototype.concat), Tw = Ui.call(n0, Array.prototype.splice), ef = Ui.call(Ni, String.prototype.replace), os = Ui.call(Ni, String.prototype.slice), Cw = Ui.call(Ni, RegExp.prototype.exec), Rw = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, $w = /\\(\\)?/g, Ow = function(t) {
  var n = os(t, 0, 1), r = os(t, -1);
  if (n === "%" && r !== "%")
    throw new Ir("invalid intrinsic syntax, expected closing `%`");
  if (r === "%" && n !== "%")
    throw new Ir("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return ef(t, Rw, function(a, s, c, o) {
    i[i.length] = c ? ef(o, $w, "$1") : s || a;
  }), i;
}, Iw = function(t, n) {
  var r = t, i;
  if (ss(Qp, r) && (i = Qp[r], r = "%" + i[0] + "%"), ss(Nn, r)) {
    var a = Nn[r];
    if (a === pr && (a = Sw(r)), typeof a > "u" && !n)
      throw new _r("intrinsic " + t + " exists, but is not available. Please file an issue!");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
<<<<<<< HEAD
  throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$2(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$2(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var GetIntrinsic2 = getIntrinsic;
var $defineProperty = GetIntrinsic2("%Object.defineProperty%", true);
var hasToStringTag = requireShams()();
var hasOwn$1 = hasown;
var $TypeError = type$1;
var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
var esSetTostringtag = function setToStringTag(object, value) {
  var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
  var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
  if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
    throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
  }
  if (toStringTag && (overrideIfSet || !hasOwn$1(object, toStringTag))) {
    if ($defineProperty) {
      $defineProperty(object, toStringTag, {
        configurable: !nonConfigurable,
        enumerable: false,
        value,
        writable: false
      });
    } else {
      object[toStringTag] = value;
    }
  }
};
var populate$1 = function(dst, src2) {
  Object.keys(src2).forEach(function(prop) {
    dst[prop] = dst[prop] || src2[prop];
  });
  return dst;
};
var CombinedStream = combined_stream;
var util$b = require$$1$3;
var path$s = require$$1$4;
var http$1 = require$$3$2;
var https$1 = require$$4$2;
var parseUrl$2 = require$$0$3.parse;
var fs$v = fs$w;
var Stream$1 = require$$1$2.Stream;
var mime = mimeTypes;
var asynckit = asynckit$1;
var setToStringTag2 = esSetTostringtag;
var hasOwn = hasown;
var populate = populate$1;
function FormData$1(options) {
  if (!(this instanceof FormData$1)) {
    return new FormData$1(options);
  }
  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];
  CombinedStream.call(this);
  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}
util$b.inherits(FormData$1, CombinedStream);
FormData$1.LINE_BREAK = "\r\n";
FormData$1.DEFAULT_CONTENT_TYPE = "application/octet-stream";
FormData$1.prototype.append = function(field, value, options) {
  options = options || {};
  if (typeof options === "string") {
    options = { filename: options };
  }
  var append3 = CombinedStream.prototype.append.bind(this);
  if (typeof value === "number" || value == null) {
    value = String(value);
  }
  if (Array.isArray(value)) {
=======
  throw new Ir("intrinsic " + t + " does not exist!");
}, Dw = function(t, n) {
  if (typeof t != "string" || t.length === 0)
    throw new _r("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new _r('"allowMissing" argument must be a boolean');
  if (Cw(/^%?[^%]*%?$/, t) === null)
    throw new Ir("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var r = Ow(t), i = r.length > 0 ? r[0] : "", a = Iw("%" + i + "%", n), s = a.name, c = a.value, o = !1, u = a.alias;
  u && (i = u[0], Tw(r, Aw([0, 1], u)));
  for (var l = 1, p = !0; l < r.length; l += 1) {
    var f = r[l], m = os(f, 0, 1), g = os(f, -1);
    if ((m === '"' || m === "'" || m === "`" || g === '"' || g === "'" || g === "`") && m !== g)
      throw new Ir("property names with quotes must have matching quotes");
    if ((f === "constructor" || !p) && (o = !0), i += "." + f, s = "%" + i + "%", ss(Nn, s))
      c = Nn[s];
    else if (c != null) {
      if (!(f in c)) {
        if (!n)
          throw new _r("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (vi && l + 1 >= r.length) {
        var h = vi(c, f);
        p = !!h, p && "get" in h && !("originalValue" in h.get) ? c = h.get : c = c[f];
      } else
        p = ss(c, f), c = c[f];
      p && !o && (Nn[s] = c);
    }
  }
  return c;
}, Ko, tf;
function Fw() {
  if (tf) return Ko;
  tf = 1;
  var e = Jm();
  return Ko = function() {
    return e() && !!Symbol.toStringTag;
  }, Ko;
}
var Pw = Dw, nf = Pw("%Object.defineProperty%", !0), kw = Fw()(), Lw = ru, Nw = tu, ma = kw ? Symbol.toStringTag : null, Uw = function(t, n) {
  var r = arguments.length > 2 && !!arguments[2] && arguments[2].force, i = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
  if (typeof r < "u" && typeof r != "boolean" || typeof i < "u" && typeof i != "boolean")
    throw new Nw("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
  ma && (r || !Lw(t, ma)) && (nf ? nf(t, ma, {
    configurable: !i,
    enumerable: !1,
    value: n,
    writable: !1
  }) : t[ma] = n);
}, Bw = function(e, t) {
  return Object.keys(t).forEach(function(n) {
    e[n] = e[n] || t[n];
  }), e;
}, iu = Jx, jw = De, Jo = ne, Mw = Cs, qw = Zl, zw = $t.parse, Hw = se, Ww = ae.Stream, Zo = Mm, Gw = Sy, Vw = Uw, sn = ru, gl = Bw;
function oe(e) {
  if (!(this instanceof oe))
    return new oe(e);
  this._overheadLength = 0, this._valueLength = 0, this._valuesToMeasure = [], iu.call(this), e = e || {};
  for (var t in e)
    this[t] = e[t];
}
jw.inherits(oe, iu);
oe.LINE_BREAK = `\r
`;
oe.DEFAULT_CONTENT_TYPE = "application/octet-stream";
oe.prototype.append = function(e, t, n) {
  n = n || {}, typeof n == "string" && (n = { filename: n });
  var r = iu.prototype.append.bind(this);
  if ((typeof t == "number" || t == null) && (t = String(t)), Array.isArray(t)) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    this._error(new Error("Arrays are not supported."));
    return;
  }
  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();
  append3(header);
  append3(value);
  append3(footer);
  this._trackLength(header, value, options);
};
<<<<<<< HEAD
FormData$1.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;
  if (options.knownLength != null) {
    valueLength += Number(options.knownLength);
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === "string") {
    valueLength = Buffer.byteLength(value);
  }
  this._valueLength += valueLength;
  this._overheadLength += Buffer.byteLength(header) + FormData$1.LINE_BREAK.length;
  if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream$1)) {
    return;
  }
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};
FormData$1.prototype._lengthRetriever = function(value, callback) {
  if (hasOwn(value, "fd")) {
    if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
      callback(null, value.end + 1 - (value.start ? value.start : 0));
    } else {
      fs$v.stat(value.path, function(err, stat2) {
        if (err) {
          callback(err);
          return;
        }
        var fileSize = stat2.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }
  } else if (hasOwn(value, "httpVersion")) {
    callback(null, Number(value.headers["content-length"]));
  } else if (hasOwn(value, "httpModule")) {
    value.on("response", function(response) {
      value.pause();
      callback(null, Number(response.headers["content-length"]));
    });
    value.resume();
  } else {
    callback("Unknown stream");
  }
};
FormData$1.prototype._multiPartHeader = function(field, value, options) {
  if (typeof options.header === "string") {
    return options.header;
  }
  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);
  var contents = "";
  var headers2 = {
    // add custom disposition as third element or keep it two elements if not
    "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    "Content-Type": [].concat(contentType || [])
  };
  if (typeof options.header === "object") {
    populate(headers2, options.header);
  }
  var header;
  for (var prop in headers2) {
    if (hasOwn(headers2, prop)) {
      header = headers2[prop];
      if (header == null) {
        continue;
      }
      if (!Array.isArray(header)) {
        header = [header];
      }
      if (header.length) {
        contents += prop + ": " + header.join("; ") + FormData$1.LINE_BREAK;
      }
    }
  }
  return "--" + this.getBoundary() + FormData$1.LINE_BREAK + contents + FormData$1.LINE_BREAK;
};
FormData$1.prototype._getContentDisposition = function(value, options) {
  var filename;
  if (typeof options.filepath === "string") {
    filename = path$s.normalize(options.filepath).replace(/\\/g, "/");
  } else if (options.filename || value && (value.name || value.path)) {
    filename = path$s.basename(options.filename || value && (value.name || value.path));
  } else if (value && value.readable && hasOwn(value, "httpVersion")) {
    filename = path$s.basename(value.client._httpMessage.path || "");
  }
  if (filename) {
    return 'filename="' + filename + '"';
  }
};
FormData$1.prototype._getContentType = function(value, options) {
  var contentType = options.contentType;
  if (!contentType && value && value.name) {
    contentType = mime.lookup(value.name);
  }
  if (!contentType && value && value.path) {
    contentType = mime.lookup(value.path);
  }
  if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
    contentType = value.headers["content-type"];
  }
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }
  if (!contentType && value && typeof value === "object") {
    contentType = FormData$1.DEFAULT_CONTENT_TYPE;
  }
  return contentType;
};
FormData$1.prototype._multiPartFooter = function() {
  return (function(next) {
    var footer = FormData$1.LINE_BREAK;
    var lastPart = this._streams.length === 0;
    if (lastPart) {
      footer += this._lastBoundary();
    }
    next(footer);
  }).bind(this);
};
FormData$1.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + FormData$1.LINE_BREAK;
};
FormData$1.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    "content-type": "multipart/form-data; boundary=" + this.getBoundary()
  };
  for (header in userHeaders) {
    if (hasOwn(userHeaders, header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }
  return formHeaders;
};
FormData$1.prototype.setBoundary = function(boundary) {
  if (typeof boundary !== "string") {
    throw new TypeError("FormData boundary must be a string");
  }
  this._boundary = boundary;
};
FormData$1.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }
  return this._boundary;
};
FormData$1.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc(0);
  var boundary = this.getBoundary();
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== "function") {
      if (Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
      } else {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
      }
      if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData$1.LINE_BREAK)]);
      }
    }
  }
  return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
};
FormData$1.prototype._generateBoundary = function() {
  var boundary = "--------------------------";
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }
  this._boundary = boundary;
};
FormData$1.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this.hasKnownLength()) {
    this._error(new Error("Cannot calculate proper length in synchronous way."));
  }
  return knownLength;
};
FormData$1.prototype.hasKnownLength = function() {
  var hasKnownLength = true;
  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }
  return hasKnownLength;
};
FormData$1.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }
  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }
    values.forEach(function(length) {
      knownLength += length;
    });
    cb(null, knownLength);
  });
};
FormData$1.prototype.submit = function(params, cb) {
  var request;
  var options;
  var defaults2 = { method: "post" };
  if (typeof params === "string") {
    params = parseUrl$2(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults2);
  } else {
    options = populate(params, defaults2);
    if (!options.port) {
      options.port = options.protocol === "https:" ? 443 : 80;
    }
  }
  options.headers = this.getHeaders(params.headers);
  if (options.protocol === "https:") {
    request = https$1.request(options);
  } else {
    request = http$1.request(options);
  }
  this.getLength((function(err, length) {
    if (err && err !== "Unknown stream") {
      this._error(err);
      return;
    }
    if (length) {
      request.setHeader("Content-Length", length);
=======
oe.prototype._trackLength = function(e, t, n) {
  var r = 0;
  n.knownLength != null ? r += Number(n.knownLength) : Buffer.isBuffer(t) ? r = t.length : typeof t == "string" && (r = Buffer.byteLength(t)), this._valueLength += r, this._overheadLength += Buffer.byteLength(e) + oe.LINE_BREAK.length, !(!t || !t.path && !(t.readable && sn(t, "httpVersion")) && !(t instanceof Ww)) && (n.knownLength || this._valuesToMeasure.push(t));
};
oe.prototype._lengthRetriever = function(e, t) {
  sn(e, "fd") ? e.end != null && e.end != 1 / 0 && e.start != null ? t(null, e.end + 1 - (e.start ? e.start : 0)) : Hw.stat(e.path, function(n, r) {
    if (n) {
      t(n);
      return;
    }
    var i = r.size - (e.start ? e.start : 0);
    t(null, i);
  }) : sn(e, "httpVersion") ? t(null, Number(e.headers["content-length"])) : sn(e, "httpModule") ? (e.on("response", function(n) {
    e.pause(), t(null, Number(n.headers["content-length"]));
  }), e.resume()) : t("Unknown stream");
};
oe.prototype._multiPartHeader = function(e, t, n) {
  if (typeof n.header == "string")
    return n.header;
  var r = this._getContentDisposition(t, n), i = this._getContentType(t, n), a = "", s = {
    // add custom disposition as third element or keep it two elements if not
    "Content-Disposition": ["form-data", 'name="' + e + '"'].concat(r || []),
    // if no content type. allow it to be empty array
    "Content-Type": [].concat(i || [])
  };
  typeof n.header == "object" && gl(s, n.header);
  var c;
  for (var o in s)
    if (sn(s, o)) {
      if (c = s[o], c == null)
        continue;
      Array.isArray(c) || (c = [c]), c.length && (a += o + ": " + c.join("; ") + oe.LINE_BREAK);
    }
  return "--" + this.getBoundary() + oe.LINE_BREAK + a + oe.LINE_BREAK;
};
oe.prototype._getContentDisposition = function(e, t) {
  var n;
  if (typeof t.filepath == "string" ? n = Jo.normalize(t.filepath).replace(/\\/g, "/") : t.filename || e && (e.name || e.path) ? n = Jo.basename(t.filename || e && (e.name || e.path)) : e && e.readable && sn(e, "httpVersion") && (n = Jo.basename(e.client._httpMessage.path || "")), n)
    return 'filename="' + n + '"';
};
oe.prototype._getContentType = function(e, t) {
  var n = t.contentType;
  return !n && e && e.name && (n = Zo.lookup(e.name)), !n && e && e.path && (n = Zo.lookup(e.path)), !n && e && e.readable && sn(e, "httpVersion") && (n = e.headers["content-type"]), !n && (t.filepath || t.filename) && (n = Zo.lookup(t.filepath || t.filename)), !n && e && typeof e == "object" && (n = oe.DEFAULT_CONTENT_TYPE), n;
};
oe.prototype._multiPartFooter = function() {
  return (function(e) {
    var t = oe.LINE_BREAK, n = this._streams.length === 0;
    n && (t += this._lastBoundary()), e(t);
  }).bind(this);
};
oe.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + oe.LINE_BREAK;
};
oe.prototype.getHeaders = function(e) {
  var t, n = {
    "content-type": "multipart/form-data; boundary=" + this.getBoundary()
  };
  for (t in e)
    sn(e, t) && (n[t.toLowerCase()] = e[t]);
  return n;
};
oe.prototype.setBoundary = function(e) {
  if (typeof e != "string")
    throw new TypeError("FormData boundary must be a string");
  this._boundary = e;
};
oe.prototype.getBoundary = function() {
  return this._boundary || this._generateBoundary(), this._boundary;
};
oe.prototype.getBuffer = function() {
  for (var e = new Buffer.alloc(0), t = this.getBoundary(), n = 0, r = this._streams.length; n < r; n++)
    typeof this._streams[n] != "function" && (Buffer.isBuffer(this._streams[n]) ? e = Buffer.concat([e, this._streams[n]]) : e = Buffer.concat([e, Buffer.from(this._streams[n])]), (typeof this._streams[n] != "string" || this._streams[n].substring(2, t.length + 2) !== t) && (e = Buffer.concat([e, Buffer.from(oe.LINE_BREAK)])));
  return Buffer.concat([e, Buffer.from(this._lastBoundary())]);
};
oe.prototype._generateBoundary = function() {
  for (var e = "--------------------------", t = 0; t < 24; t++)
    e += Math.floor(Math.random() * 10).toString(16);
  this._boundary = e;
};
oe.prototype.getLengthSync = function() {
  var e = this._overheadLength + this._valueLength;
  return this._streams.length && (e += this._lastBoundary().length), this.hasKnownLength() || this._error(new Error("Cannot calculate proper length in synchronous way.")), e;
};
oe.prototype.hasKnownLength = function() {
  var e = !0;
  return this._valuesToMeasure.length && (e = !1), e;
};
oe.prototype.getLength = function(e) {
  var t = this._overheadLength + this._valueLength;
  if (this._streams.length && (t += this._lastBoundary().length), !this._valuesToMeasure.length) {
    process.nextTick(e.bind(this, null, t));
    return;
  }
  Gw.parallel(this._valuesToMeasure, this._lengthRetriever, function(n, r) {
    if (n) {
      e(n);
      return;
    }
    r.forEach(function(i) {
      t += i;
    }), e(null, t);
  });
};
oe.prototype.submit = function(e, t) {
  var n, r, i = { method: "post" };
  return typeof e == "string" ? (e = zw(e), r = gl({
    port: e.port,
    path: e.pathname,
    host: e.hostname,
    protocol: e.protocol
  }, i)) : (r = gl(e, i), r.port || (r.port = r.protocol === "https:" ? 443 : 80)), r.headers = this.getHeaders(e.headers), r.protocol === "https:" ? n = qw.request(r) : n = Mw.request(r), this.getLength((function(a, s) {
    if (a && a !== "Unknown stream") {
      this._error(a);
      return;
    }
    if (s && n.setHeader("Content-Length", s), this.pipe(n), t) {
      var c, o = function(u, l) {
        return n.removeListener("error", o), n.removeListener("response", c), t.call(this, u, l);
      };
      c = o.bind(this, null), n.on("error", o), n.on("response", c);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    this.pipe(request);
    if (cb) {
      var onResponse;
      var callback = function(error2, responce) {
        request.removeListener("error", callback);
        request.removeListener("response", onResponse);
        return cb.call(this, error2, responce);
      };
      onResponse = callback.bind(this, null);
      request.on("error", callback);
      request.on("response", onResponse);
    }
  }).bind(this));
  return request;
};
<<<<<<< HEAD
FormData$1.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit("error", err);
  }
};
FormData$1.prototype.toString = function() {
  return "[object FormData]";
};
setToStringTag2(FormData$1, "FormData");
var form_data = FormData$1;
const FormData$2 = /* @__PURE__ */ getDefaultExportFromCjs(form_data);
function isVisitable(thing) {
  return utils$h.isPlainObject(thing) || utils$h.isArray(thing);
=======
oe.prototype._error = function(e) {
  this.error || (this.error = e, this.pause(), this.emit("error", e));
};
oe.prototype.toString = function() {
  return "[object FormData]";
};
Vw(oe, "FormData");
var Yw = oe;
const r0 = /* @__PURE__ */ eu(Yw);
function bl(e) {
  return F.isPlainObject(e) || F.isArray(e);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
}
function i0(e) {
  return F.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
<<<<<<< HEAD
function renderKey(path2, key2, dots) {
  if (!path2) return key2;
  return path2.concat(key2).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$h.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$h.toFlatObject(utils$h, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData$1(obj, formData, options) {
  if (!utils$h.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData$2 || FormData)();
  options = utils$h.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$h.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$h.isSpecCompliantForm(formData);
  if (!utils$h.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils$h.isDate(value)) {
      return value.toISOString();
    }
    if (utils$h.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils$h.isBlob(value)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$h.isArrayBuffer(value) || utils$h.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key2, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils$h.endsWith(key2, "{}")) {
        key2 = metaTokens ? key2 : key2.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$h.isArray(value) && isFlatArray(value) || (utils$h.isFileList(value) || utils$h.endsWith(key2, "[]")) && (arr = utils$h.toArray(value))) {
        key2 = removeBrackets(key2);
        arr.forEach(function each(el, index) {
          !(utils$h.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key2], index, dots) : indexes === null ? key2 : key2 + "[]",
            convertValue(el)
=======
function rf(e, t, n) {
  return e ? e.concat(t).map(function(i, a) {
    return i = i0(i), !n && a ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function Xw(e) {
  return F.isArray(e) && !e.some(bl);
}
const Kw = F.toFlatObject(F, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Us(e, t, n) {
  if (!F.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new (r0 || FormData)(), n = F.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(h, b) {
    return !F.isUndefined(b[h]);
  });
  const r = n.metaTokens, i = n.visitor || l, a = n.dots, s = n.indexes, o = (n.Blob || typeof Blob < "u" && Blob) && F.isSpecCompliantForm(t);
  if (!F.isFunction(i))
    throw new TypeError("visitor must be a function");
  function u(g) {
    if (g === null) return "";
    if (F.isDate(g))
      return g.toISOString();
    if (F.isBoolean(g))
      return g.toString();
    if (!o && F.isBlob(g))
      throw new V("Blob is not supported. Use a Buffer instead.");
    return F.isArrayBuffer(g) || F.isTypedArray(g) ? o && typeof Blob == "function" ? new Blob([g]) : Buffer.from(g) : g;
  }
  function l(g, h, b) {
    let x = g;
    if (g && !b && typeof g == "object") {
      if (F.endsWith(h, "{}"))
        h = r ? h : h.slice(0, -2), g = JSON.stringify(g);
      else if (F.isArray(g) && Xw(g) || (F.isFileList(g) || F.endsWith(h, "[]")) && (x = F.toArray(g)))
        return h = i0(h), x.forEach(function(E, S) {
          !(F.isUndefined(E) || E === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            s === !0 ? rf([h], S, a) : s === null ? h : h + "[]",
            u(E)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          );
        });
        return false;
      }
    }
<<<<<<< HEAD
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key2, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils$h.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils$h.forEach(value, function each(el, key2) {
      const result = !(utils$h.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$h.isString(key2) ? key2.trim() : key2,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key2) : [key2]);
      }
    });
    stack.pop();
  }
  if (!utils$h.isObject(obj)) {
=======
    return bl(g) ? !0 : (t.append(rf(b, h, a), u(g)), !1);
  }
  const p = [], f = Object.assign(Kw, {
    defaultVisitor: l,
    convertValue: u,
    isVisitable: bl
  });
  function m(g, h) {
    if (!F.isUndefined(g)) {
      if (p.indexOf(g) !== -1)
        throw Error("Circular reference detected in " + h.join("."));
      p.push(g), F.forEach(g, function(x, y) {
        (!(F.isUndefined(x) || x === null) && i.call(
          t,
          x,
          F.isString(y) ? y.trim() : y,
          h,
          f
        )) === !0 && m(x, h ? h.concat(y) : [y]);
      }), p.pop();
    }
  }
  if (!F.isObject(e))
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
<<<<<<< HEAD
function encode$1(str2) {
  const charMap = {
=======
function af(e) {
  const t = {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
<<<<<<< HEAD
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData$1(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
=======
function a0(e, t) {
  this._pairs = [], e && Us(e, this, t);
}
const s0 = a0.prototype;
s0.append = function(t, n) {
  this._pairs.push([t, n]);
};
s0.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, af);
  } : af;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function Jw(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function au(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || Jw;
  F.isFunction(n) && (n = {
    serialize: n
  });
  const i = n && n.serialize;
  let a;
  if (i ? a = i(t, n) : a = F.isURLSearchParams(t) ? t.toString() : new a0(t, n).toString(r), a) {
    const s = e.indexOf("#");
    s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  const _encode = options && options.encode || encode;
  if (utils$h.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$h.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
<<<<<<< HEAD
class InterceptorManager {
=======
class sf {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
<<<<<<< HEAD
  forEach(fn) {
    utils$h.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams = require$$0$3.URLSearchParams;
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str2 = "";
  const { length } = alphabet;
  const randomValues = new Uint32Array(size);
  require$$0$4.randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str2 += alphabet[randomValues[i] % length];
  }
  return str2;
};
const platform$2 = {
  isNode: true,
  classes: {
    URLSearchParams,
    FormData: FormData$2,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: ["http", "https", "file", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils$g = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform$1 = {
  ...utils$g,
  ...platform$2
};
function toURLEncodedForm(data, options) {
  return toFormData$1(data, new platform$1.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key2, path2, helpers) {
      if (platform$1.isNode && utils$h.isBuffer(value)) {
        this.append(key2, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$h.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key2;
  for (i = 0; i < len; i++) {
    key2 = keys[i];
    obj[key2] = arr[key2];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name = path2[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path2.length;
    name = !name && utils$h.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$h.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$h.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index);
    if (result && utils$h.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$h.isFormData(formData) && utils$h.isFunction(formData.entries)) {
    const obj = {};
    utils$h.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$h.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$h.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
=======
  forEach(t) {
    F.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const su = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, Zw = $t.URLSearchParams, Qo = "abcdefghijklmnopqrstuvwxyz", of = "0123456789", o0 = {
  DIGIT: of,
  ALPHA: Qo,
  ALPHA_DIGIT: Qo + Qo.toUpperCase() + of
}, Qw = (e = 16, t = o0.ALPHA_DIGIT) => {
  let n = "";
  const { length: r } = t, i = new Uint32Array(e);
  Ur.randomFillSync(i);
  for (let a = 0; a < e; a++)
    n += t[i[a] % r];
  return n;
}, e8 = {
  isNode: !0,
  classes: {
    URLSearchParams: Zw,
    FormData: r0,
    Blob: typeof Blob < "u" && Blob || null
  },
  ALPHABET: o0,
  generateString: Qw,
  protocols: ["http", "https", "file", "data"]
}, ou = typeof window < "u" && typeof document < "u", xl = typeof navigator == "object" && navigator || void 0, t8 = ou && (!xl || ["ReactNative", "NativeScript", "NS"].indexOf(xl.product) < 0), n8 = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", r8 = ou && window.location.href || "http://localhost", i8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: ou,
  hasStandardBrowserEnv: t8,
  hasStandardBrowserWebWorkerEnv: n8,
  navigator: xl,
  origin: r8
}, Symbol.toStringTag, { value: "Module" })), ye = {
  ...i8,
  ...e8
};
function a8(e, t) {
  return Us(e, new ye.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, a) {
      return ye.isNode && F.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function s8(e) {
  return F.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function o8(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let a;
  for (r = 0; r < i; r++)
    a = n[r], t[a] = e[a];
  return t;
}
function c0(e) {
  function t(n, r, i, a) {
    let s = n[a++];
    if (s === "__proto__") return !0;
    const c = Number.isFinite(+s), o = a >= n.length;
    return s = !s && F.isArray(i) ? i.length : s, o ? (F.hasOwnProp(i, s) ? i[s] = [i[s], r] : i[s] = r, !c) : ((!i[s] || !F.isObject(i[s])) && (i[s] = []), t(n, r, i[s], a) && F.isArray(i[s]) && (i[s] = o8(i[s])), !c);
  }
  if (F.isFormData(e) && F.isFunction(e.entries)) {
    const n = {};
    return F.forEachEntry(e, (r, i) => {
      t(s8(r), i, n, 0);
    }), n;
  }
  return null;
}
function c8(e, t, n) {
  if (F.isString(e))
    try {
      return (t || JSON.parse)(e), F.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
<<<<<<< HEAD
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers2) {
    const contentType = headers2.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$h.isObject(data);
    if (isObjectPayload && utils$h.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$h.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$h.isArrayBuffer(data) || utils$h.isBuffer(data) || utils$h.isStream(data) || utils$h.isFile(data) || utils$h.isBlob(data) || utils$h.isReadableStream(data)) {
      return data;
    }
    if (utils$h.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$h.isURLSearchParams(data)) {
      headers2.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$h.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
=======
const Bi = {
  transitional: su,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, a = F.isObject(t);
    if (a && F.isHTMLForm(t) && (t = new FormData(t)), F.isFormData(t))
      return i ? JSON.stringify(c0(t)) : t;
    if (F.isArrayBuffer(t) || F.isBuffer(t) || F.isStream(t) || F.isFile(t) || F.isBlob(t) || F.isReadableStream(t))
      return t;
    if (F.isArrayBufferView(t))
      return t.buffer;
    if (F.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let c;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return a8(t, this.formSerializer).toString();
      if ((c = F.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const o = this.env && this.env.FormData;
        return Us(
          c ? { "files[]": t } : t,
          o && new o(),
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          this.formSerializer
        );
      }
    }
<<<<<<< HEAD
    if (isObjectPayload || hasJSONContentType) {
      headers2.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$h.isResponse(data) || utils$h.isReadableStream(data)) {
      return data;
    }
    if (data && utils$h.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
=======
    return a || i ? (n.setContentType("application/json", !1), c8(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || Bi.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (F.isResponse(t) || F.isReadableStream(t))
      return t;
    if (t && F.isString(t) && (r && !this.responseType || i)) {
      const s = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (c) {
        if (s)
          throw c.name === "SyntaxError" ? V.from(c, V.ERR_BAD_RESPONSE, this, null, this.response) : c;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
<<<<<<< HEAD
    FormData: platform$1.classes.FormData,
    Blob: platform$1.classes.Blob
=======
    FormData: ye.classes.FormData,
    Blob: ye.classes.Blob
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
<<<<<<< HEAD
utils$h.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults$1.headers[method] = {};
});
const ignoreDuplicateOf = utils$h.toObjectSet([
=======
F.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Bi.headers[e] = {};
});
const l8 = F.toObjectSet([
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
<<<<<<< HEAD
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key2;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key2 = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
      return;
    }
    if (key2 === "set-cookie") {
      if (parsed[key2]) {
        parsed[key2].push(val);
      } else {
        parsed[key2] = [val];
      }
    } else {
      parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$h.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str2) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str2)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$h.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$h.isString(value)) return;
  if (utils$h.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$h.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str2) => {
    return char.toUpperCase() + str2;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$h.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
=======
]), u8 = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(s) {
    i = s.indexOf(":"), n = s.substring(0, i).trim().toLowerCase(), r = s.substring(i + 1).trim(), !(!n || t[n] && l8[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, cf = Symbol("internals");
function Xr(e) {
  return e && String(e).trim().toLowerCase();
}
function Xa(e) {
  return e === !1 || e == null ? e : F.isArray(e) ? e.map(Xa) : String(e);
}
function p8(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const f8 = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function ec(e, t, n, r, i) {
  if (F.isFunction(r))
    return r.call(this, t, n);
  if (i && (t = n), !!F.isString(t)) {
    if (F.isString(r))
      return t.indexOf(r) !== -1;
    if (F.isRegExp(r))
      return r.test(t);
  }
}
function d8(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function h8(e, t) {
  const n = F.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, a, s) {
        return this[r].call(this, t, i, a, s);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      },
      configurable: true
    });
  });
}
<<<<<<< HEAD
let AxiosHeaders$1 = class AxiosHeaders {
  constructor(headers2) {
    headers2 && this.set(headers2);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key2 = utils$h.findKey(self2, lHeader);
      if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
        self2[key2 || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers2, _rewrite) => utils$h.forEach(headers2, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$h.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$h.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$h.isObject(header) && utils$h.isIterable(header)) {
      let obj = {}, dest, key2;
      for (const entry of header) {
        if (!utils$h.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key2 = entry[0]] = (dest = obj[key2]) ? utils$h.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key2 = utils$h.findKey(this, header);
      if (key2) {
        const value = this[key2];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$h.isFunction(parser)) {
          return parser.call(this, value, key2);
        }
        if (utils$h.isRegExp(parser)) {
          return parser.exec(value);
        }
=======
let Ne = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function a(c, o, u) {
      const l = Xr(o);
      if (!l)
        throw new Error("header name must be a non-empty string");
      const p = F.findKey(i, l);
      (!p || i[p] === void 0 || u === !0 || u === void 0 && i[p] !== !1) && (i[p || o] = Xa(c));
    }
    const s = (c, o) => F.forEach(c, (u, l) => a(u, l, o));
    if (F.isPlainObject(t) || t instanceof this.constructor)
      s(t, n);
    else if (F.isString(t) && (t = t.trim()) && !f8(t))
      s(u8(t), n);
    else if (F.isObject(t) && F.isIterable(t)) {
      let c = {}, o, u;
      for (const l of t) {
        if (!F.isArray(l))
          throw TypeError("Object iterator must return a key-value pair");
        c[u = l[0]] = (o = c[u]) ? F.isArray(o) ? [...o, l[1]] : [o, l[1]] : l[1];
      }
      s(c, n);
    } else
      t != null && a(n, t, r);
    return this;
  }
  get(t, n) {
    if (t = Xr(t), t) {
      const r = F.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return p8(i);
        if (F.isFunction(n))
          return n.call(this, i, r);
        if (F.isRegExp(n))
          return n.exec(i);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
<<<<<<< HEAD
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key2 = utils$h.findKey(this, header);
      return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
=======
  has(t, n) {
    if (t = Xr(t), t) {
      const r = F.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || ec(this, this[r], r, n)));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    return false;
  }
<<<<<<< HEAD
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key2 = utils$h.findKey(self2, _header);
        if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
          delete self2[key2];
          deleted = true;
        }
      }
    }
    if (utils$h.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key2 = keys[i];
      if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
        delete this[key2];
        deleted = true;
      }
=======
  delete(t, n) {
    const r = this;
    let i = !1;
    function a(s) {
      if (s = Xr(s), s) {
        const c = F.findKey(r, s);
        c && (!n || ec(r, r[c], c, n)) && (delete r[c], i = !0);
      }
    }
    return F.isArray(t) ? t.forEach(a) : a(t), i;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, i = !1;
    for (; r--; ) {
      const a = n[r];
      (!t || ec(this, this[a], a, t, !0)) && (delete this[a], i = !0);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    return deleted;
  }
<<<<<<< HEAD
  normalize(format) {
    const self2 = this;
    const headers2 = {};
    utils$h.forEach(this, (value, header) => {
      const key2 = utils$h.findKey(headers2, header);
      if (key2) {
        self2[key2] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers2[normalized] = true;
    });
    return this;
=======
  normalize(t) {
    const n = this, r = {};
    return F.forEach(this, (i, a) => {
      const s = F.findKey(r, a);
      if (s) {
        n[s] = Xa(i), delete n[a];
        return;
      }
      const c = t ? d8(a) : String(a).trim();
      c !== a && delete n[a], n[c] = Xa(i), r[c] = !0;
    }), this;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
<<<<<<< HEAD
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$h.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$h.isArray(value) ? value.join(", ") : value);
    });
    return obj;
=======
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return F.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && F.isArray(r) ? r.join(", ") : r);
    }), n;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
<<<<<<< HEAD
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$h.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$h.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key2) => {
  let mapped = key2[0].toUpperCase() + key2.slice(1);
=======
  static accessor(t) {
    const r = (this[cf] = this[cf] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function a(s) {
      const c = Xr(s);
      r[c] || (h8(i, s), r[c] = !0);
    }
    return F.isArray(t) ? t.forEach(a) : a(t), this;
  }
};
Ne.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
F.reduceDescriptors(Ne.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
<<<<<<< HEAD
utils$h.freezeMethods(AxiosHeaders$1);
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers2 = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$h.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers2.normalize(), response ? response.status : void 0);
  });
  headers2.normalize();
  return data;
}
function isCancel$1(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError$1(message, config, request) {
  AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$h.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError$1(
      "Request failed with status code " + response.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var proxyFromEnv = {};
var parseUrl$1 = require$$0$3.parse;
var DEFAULT_PORTS = {
=======
F.freezeMethods(Ne);
function tc(e, t) {
  const n = this || Bi, r = t || n, i = Ne.from(r.headers);
  let a = r.data;
  return F.forEach(e, function(c) {
    a = c.call(n, a, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), a;
}
function l0(e) {
  return !!(e && e.__CANCEL__);
}
function ln(e, t, n) {
  V.call(this, e ?? "canceled", V.ERR_CANCELED, t, n), this.name = "CanceledError";
}
F.inherits(ln, V, {
  __CANCEL__: !0
});
function mr(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new V(
    "Request failed with status code " + n.status,
    [V.ERR_BAD_REQUEST, V.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function m8(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function v8(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function cu(e, t, n) {
  let r = !m8(t);
  return e && (r || n == !1) ? v8(e, t) : t;
}
var u0 = {}, g8 = $t.parse, b8 = {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
<<<<<<< HEAD
};
var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
};
function getProxyForUrl(url2) {
  var parsedUrl = typeof url2 === "string" ? parseUrl$1(url2) : url2 || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
    return "";
  }
  proto = proto.split(":", 1)[0];
  hostname = hostname.replace(/:\d*$/, "");
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return "";
  }
  var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
  if (proxy && proxy.indexOf("://") === -1) {
    proxy = proto + "://" + proxy;
  }
  return proxy;
}
function shouldProxy(hostname, port) {
  var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
  if (!NO_PROXY) {
    return true;
  }
  if (NO_PROXY === "*") {
    return false;
  }
  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;
    }
    if (!/^[.*]/.test(parsedProxyHostname)) {
      return hostname !== parsedProxyHostname;
    }
    if (parsedProxyHostname.charAt(0) === "*") {
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}
function getEnv(key2) {
  return process.env[key2.toLowerCase()] || process.env[key2.toUpperCase()] || "";
}
proxyFromEnv.getProxyForUrl = getProxyForUrl;
var followRedirects$1 = { exports: {} };
var src = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
=======
}, x8 = String.prototype.endsWith || function(e) {
  return e.length <= this.length && this.indexOf(e, this.length - e.length) !== -1;
};
function y8(e) {
  var t = typeof e == "string" ? g8(e) : e || {}, n = t.protocol, r = t.host, i = t.port;
  if (typeof r != "string" || !r || typeof n != "string" || (n = n.split(":", 1)[0], r = r.replace(/:\d*$/, ""), i = parseInt(i) || b8[n] || 0, !w8(r, i)))
    return "";
  var a = vr("npm_config_" + n + "_proxy") || vr(n + "_proxy") || vr("npm_config_proxy") || vr("all_proxy");
  return a && a.indexOf("://") === -1 && (a = n + "://" + a), a;
}
function w8(e, t) {
  var n = (vr("npm_config_no_proxy") || vr("no_proxy")).toLowerCase();
  return n ? n === "*" ? !1 : n.split(/[,\s]/).every(function(r) {
    if (!r)
      return !0;
    var i = r.match(/^(.+):(\d+)$/), a = i ? i[1] : r, s = i ? parseInt(i[2]) : 0;
    return s && s !== t ? !0 : /^[.*]/.test(a) ? (a.charAt(0) === "*" && (a = a.slice(1)), !x8.call(e, a)) : e !== a;
  }) : !0;
}
function vr(e) {
  return process.env[e.toLowerCase()] || process.env[e.toUpperCase()] || "";
}
u0.getProxyForUrl = y8;
var lu = { exports: {} }, yl = { exports: {} }, va = { exports: {} }, nc, lf;
function E8() {
  if (lf) return nc;
  lf = 1;
  var e = 1e3, t = e * 60, n = t * 60, r = n * 24, i = r * 7, a = r * 365.25;
  nc = function(l, p) {
    p = p || {};
    var f = typeof l;
    if (f === "string" && l.length > 0)
      return s(l);
    if (f === "number" && isFinite(l))
      return p.long ? o(l) : c(l);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
<<<<<<< HEAD
  function parse2(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
=======
  function s(l) {
    if (l = String(l), !(l.length > 100)) {
      var p = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        l
      );
      if (p) {
        var f = parseFloat(p[1]), m = (p[2] || "ms").toLowerCase();
        switch (m) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return f * a;
          case "weeks":
          case "week":
          case "w":
            return f * i;
          case "days":
          case "day":
          case "d":
            return f * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return f * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return f * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return f * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return f;
          default:
            return;
        }
      }
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
<<<<<<< HEAD
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common$6;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common$6;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy3;
    Object.keys(env).forEach((key2) => {
      createDebug[key2] = env[key2];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend3;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend3(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
=======
  function o(l) {
    var p = Math.abs(l);
    return p >= r ? u(l, p, r, "day") : p >= n ? u(l, p, n, "hour") : p >= t ? u(l, p, t, "minute") : p >= e ? u(l, p, e, "second") : l + " ms";
  }
  function u(l, p, f, m) {
    var g = p >= f * 1.5;
    return Math.round(l / f) + " " + m + (g ? "s" : "");
  }
  return nc;
}
var rc, uf;
function p0() {
  if (uf) return rc;
  uf = 1;
  function e(t) {
    r.debug = r, r.default = r, r.coerce = u, r.disable = c, r.enable = a, r.enabled = o, r.humanize = E8(), r.destroy = l, Object.keys(t).forEach((p) => {
      r[p] = t[p];
    }), r.names = [], r.skips = [], r.formatters = {};
    function n(p) {
      let f = 0;
      for (let m = 0; m < p.length; m++)
        f = (f << 5) - f + p.charCodeAt(m), f |= 0;
      return r.colors[Math.abs(f) % r.colors.length];
    }
    r.selectColor = n;
    function r(p) {
      let f, m = null, g, h;
      function b(...x) {
        if (!b.enabled)
          return;
        const y = b, E = Number(/* @__PURE__ */ new Date()), S = E - (f || E);
        y.diff = S, y.prev = f, y.curr = E, f = E, x[0] = r.coerce(x[0]), typeof x[0] != "string" && x.unshift("%O");
        let D = 0;
        x[0] = x[0].replace(/%([a-zA-Z%])/g, (z, ee) => {
          if (z === "%%")
            return "%";
          D++;
          const C = r.formatters[ee];
          if (typeof C == "function") {
            const H = x[D];
            z = C.call(y, H), x.splice(D, 1), D--;
          }
          return z;
        }), r.formatArgs.call(y, x), (y.log || r.log).apply(y, x);
      }
      return b.namespace = p, b.useColors = r.useColors(), b.color = r.selectColor(p), b.extend = i, b.destroy = r.destroy, Object.defineProperty(b, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => m !== null ? m : (g !== r.namespaces && (g = r.namespaces, h = r.enabled(p)), h),
        set: (x) => {
          m = x;
        }
      }), typeof r.init == "function" && r.init(b), b;
    }
    function i(p, f) {
      const m = r(this.namespace + (typeof f > "u" ? ":" : f) + p);
      return m.log = this.log, m;
    }
    function a(p) {
      r.save(p), r.namespaces = p, r.names = [], r.skips = [];
      const f = (typeof p == "string" ? p : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const m of f)
        m[0] === "-" ? r.skips.push(m.slice(1)) : r.names.push(m);
    }
    function s(p, f) {
      let m = 0, g = 0, h = -1, b = 0;
      for (; m < p.length; )
        if (g < f.length && (f[g] === p[m] || f[g] === "*"))
          f[g] === "*" ? (h = g, b = m, g++) : (m++, g++);
        else if (h !== -1)
          g = h + 1, b++, m = b;
        else
          return !1;
      for (; g < f.length && f[g] === "*"; )
        g++;
      return g === f.length;
    }
    function c() {
      const p = [
        ...r.names,
        ...r.skips.map((f) => "-" + f)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
<<<<<<< HEAD
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
=======
    function o(p) {
      for (const f of r.skips)
        if (s(p, f))
          return !1;
      for (const f of r.names)
        if (s(p, f))
          return !0;
      return !1;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy3() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
<<<<<<< HEAD
  common$6 = setup;
  return common$6;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
=======
  return rc = e, rc;
}
var pf;
function _8() {
  return pf || (pf = 1, function(e, t) {
    t.formatArgs = r, t.save = i, t.load = a, t.useColors = n, t.storage = s(), t.destroy = /* @__PURE__ */ (() => {
      let o = !1;
      return () => {
        o || (o = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
<<<<<<< HEAD
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
=======
    function n() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let o;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (o = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(o[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function r(o) {
      if (o[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + o[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
        return;
      const u = "color: " + this.color;
      o.splice(1, 0, u, "color: inherit");
      let l = 0, p = 0;
      o[0].replace(/%[a-zA-Z%]/g, (f) => {
        f !== "%%" && (l++, f === "%c" && (p = l));
      }), o.splice(p, 0, u);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    exports.log = console.debug || console.log || (() => {
    });
<<<<<<< HEAD
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
=======
    function i(o) {
      try {
        o ? t.storage.setItem("debug", o) : t.storage.removeItem("debug");
      } catch {
      }
    }
    function a() {
      let o;
      try {
        o = t.storage.getItem("debug") || t.storage.getItem("DEBUG");
      } catch {
      }
      return !o && typeof process < "u" && "env" in process && (o = process.env.DEBUG), o;
    }
    function s() {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      try {
        return localStorage;
      } catch (error2) {
      }
    }
<<<<<<< HEAD
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node$1 = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os2 = require$$2$2;
  const tty = require$$1$5;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
=======
    e.exports = p0()(t);
    const { formatters: c } = e.exports;
    c.j = function(o) {
      try {
        return JSON.stringify(o);
      } catch (u) {
        return "[UnexpectedJSONParseError]: " + u.message;
      }
    };
  }(va, va.exports)), va.exports;
}
var ga = { exports: {} }, ic, ff;
function S8() {
  return ff || (ff = 1, ic = (e, t = process.argv) => {
    const n = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", r = t.indexOf(n + e), i = t.indexOf("--");
    return r !== -1 && (i === -1 || r < i);
  }), ic;
}
var ac, df;
function A8() {
  if (df) return ac;
  df = 1;
  const e = $s, t = Cm, n = S8(), { env: r } = process;
  let i;
  n("no-color") || n("no-colors") || n("color=false") || n("color=never") ? i = 0 : (n("color") || n("colors") || n("color=true") || n("color=always")) && (i = 1), "FORCE_COLOR" in r && (r.FORCE_COLOR === "true" ? i = 1 : r.FORCE_COLOR === "false" ? i = 0 : i = r.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(r.FORCE_COLOR, 10), 3));
  function a(o) {
    return o === 0 ? !1 : {
      level: o,
      hasBasic: !0,
      has256: o >= 2,
      has16m: o >= 3
    };
  }
  function s(o, u) {
    if (i === 0)
      return 0;
    if (n("color=16m") || n("color=full") || n("color=truecolor"))
      return 3;
    if (n("color=256"))
      return 2;
    if (o && !u && i === void 0)
      return 0;
    const l = i || 0;
    if (r.TERM === "dumb")
      return l;
    if (process.platform === "win32") {
      const p = e.release().split(".");
      return Number(p[0]) >= 10 && Number(p[2]) >= 10586 ? Number(p[2]) >= 14931 ? 3 : 2 : 1;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min2 = forceColor || 0;
    if (env.TERM === "dumb") {
      return min2;
    }
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign3) => sign3 in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min2;
  }
<<<<<<< HEAD
  function getSupportLevel(stream2) {
    const level = supportsColor(stream2, stream2 && stream2.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1) return node$1.exports;
  hasRequiredNode$1 = 1;
  (function(module, exports) {
    const tty = require$$1$5;
    const util2 = require$$1$3;
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
=======
  function c(o) {
    const u = s(o, o && o.isTTY);
    return a(u);
  }
  return ac = {
    supportsColor: c,
    stdout: a(s(!0, t.isatty(1))),
    stderr: a(s(!0, t.isatty(2)))
  }, ac;
}
var hf;
function T8() {
  return hf || (hf = 1, function(e, t) {
    const n = Cm, r = De;
    t.init = l, t.log = c, t.formatArgs = a, t.save = o, t.load = u, t.useColors = i, t.destroy = r.deprecate(
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
<<<<<<< HEAD
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key2) => {
      return /^debug_/i.test(key2);
    }).reduce((obj, key2) => {
      const prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key2];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
=======
      const f = A8();
      f && (f.stderr || f).level >= 2 && (t.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ]);
    } catch {
    }
    t.inspectOpts = Object.keys(process.env).filter((f) => /^debug_/i.test(f)).reduce((f, m) => {
      const g = m.substring(6).toLowerCase().replace(/_([a-z])/g, (b, x) => x.toUpperCase());
      let h = process.env[m];
      return /^(yes|on|true|enabled)$/i.test(h) ? h = !0 : /^(no|off|false|disabled)$/i.test(h) ? h = !1 : h === "null" ? h = null : h = Number(h), f[g] = h, f;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
<<<<<<< HEAD
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
=======
    function a(f) {
      const { namespace: m, useColors: g } = this;
      if (g) {
        const h = this.color, b = "\x1B[3" + (h < 8 ? h : "8;5;" + h), x = `  ${b};1m${m} \x1B[0m`;
        f[0] = x + f[0].split(`
`).join(`
` + x), f.push(b + "m+" + e.exports.humanize(this.diff) + "\x1B[0m");
      } else
        f[0] = s() + m + " " + f[0];
    }
    function s() {
      return t.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function c(...f) {
      return process.stderr.write(r.formatWithOptions(t.inspectOpts, ...f) + `
`);
    }
    function o(f) {
      f ? process.env.DEBUG = f : delete process.env.DEBUG;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    function load2() {
      return process.env.DEBUG;
    }
<<<<<<< HEAD
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node$1, node$1.exports);
  return node$1.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src.exports = requireBrowser();
} else {
  src.exports = requireNode$1();
}
var srcExports = src.exports;
var debug$5;
var debug_1$2 = function() {
  if (!debug$5) {
    try {
      debug$5 = srcExports("follow-redirects");
    } catch (error2) {
    }
    if (typeof debug$5 !== "function") {
      debug$5 = function() {
      };
    }
  }
  debug$5.apply(null, arguments);
};
var url = require$$0$3;
var URL$1 = url.URL;
var http = require$$3$2;
var https = require$$4$2;
var Writable$5 = require$$1$2.Writable;
var assert$2 = require$$2$3;
var debug$4 = debug_1$2;
(function detectUnsupportedEnvironment() {
  var looksLikeNode = typeof process !== "undefined";
  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var looksLikeV8 = isFunction(Error.captureStackTrace);
  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
    console.warn("The follow-redirects package should be excluded from browser builds.");
  }
})();
var useNativeURL = false;
try {
  assert$2(new URL$1(""));
} catch (error2) {
  useNativeURL = error2.code === "ERR_INVALID_URL";
}
var preservedUrlFields = [
=======
    function l(f) {
      f.inspectOpts = {};
      const m = Object.keys(t.inspectOpts);
      for (let g = 0; g < m.length; g++)
        f.inspectOpts[m[g]] = t.inspectOpts[m[g]];
    }
    e.exports = p0()(t);
    const { formatters: p } = e.exports;
    p.o = function(f) {
      return this.inspectOpts.colors = this.useColors, r.inspect(f, this.inspectOpts).split(`
`).map((m) => m.trim()).join(" ");
    }, p.O = function(f) {
      return this.inspectOpts.colors = this.useColors, r.inspect(f, this.inspectOpts);
    };
  }(ga, ga.exports)), ga.exports;
}
typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? yl.exports = _8() : yl.exports = T8();
var f0 = yl.exports, Kr, C8 = function() {
  if (!Kr) {
    try {
      Kr = f0("follow-redirects");
    } catch {
    }
    typeof Kr != "function" && (Kr = function() {
    });
  }
  Kr.apply(null, arguments);
}, ji = $t, gi = ji.URL, R8 = Cs, $8 = Zl, uu = ae.Writable, pu = Rs, d0 = C8;
(function() {
  var t = typeof process < "u", n = typeof window < "u" && typeof document < "u", r = Hn(Error.captureStackTrace);
  !t && (n || !r) && console.warn("The follow-redirects package should be excluded from browser builds.");
})();
var fu = !1;
try {
  pu(new gi(""));
} catch (e) {
  fu = e.code === "ERR_INVALID_URL";
}
var O8 = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash"
<<<<<<< HEAD
];
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = /* @__PURE__ */ Object.create(null);
events.forEach(function(event) {
  eventHandlers[event] = function(arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
=======
], du = ["abort", "aborted", "connect", "error", "socket", "timeout"], hu = /* @__PURE__ */ Object.create(null);
du.forEach(function(e) {
  hu[e] = function(t, n, r) {
    this._redirectable.emit(e, t, n, r);
  };
});
var wl = Mi(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
), El = Mi(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
), I8 = Mi(
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  El
), D8 = Mi(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
), F8 = Mi(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
<<<<<<< HEAD
);
var destroy = Writable$5.prototype.destroy || noop$5;
function RedirectableRequest(options, responseCallback) {
  Writable$5.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];
  if (responseCallback) {
    this.on("response", responseCallback);
  }
  var self2 = this;
  this._onNativeResponse = function(response) {
    try {
      self2._processResponse(response);
    } catch (cause) {
      self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
=======
), P8 = uu.prototype.destroy || m0;
function nt(e, t) {
  uu.call(this), this._sanitizeOptions(e), this._options = e, this._ended = !1, this._ending = !1, this._redirectCount = 0, this._redirects = [], this._requestBodyLength = 0, this._requestBodyBuffers = [], t && this.on("response", t);
  var n = this;
  this._onNativeResponse = function(r) {
    try {
      n._processResponse(r);
    } catch (i) {
      n.emit("error", i instanceof El ? i : new El({ cause: i }));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
  };
  this._performRequest();
}
<<<<<<< HEAD
RedirectableRequest.prototype = Object.create(Writable$5.prototype);
RedirectableRequest.prototype.abort = function() {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};
RedirectableRequest.prototype.destroy = function(error2) {
  destroyRequest(this._currentRequest, error2);
  destroy.call(this, error2);
  return this;
};
RedirectableRequest.prototype.write = function(data, encoding, callback) {
  if (this._ending) {
    throw new WriteAfterEndError();
  }
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data, encoding });
    this._currentRequest.write(data, encoding, callback);
  } else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};
RedirectableRequest.prototype.end = function(data, encoding, callback) {
  if (isFunction(data)) {
    callback = data;
    data = encoding = null;
  } else if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  } else {
    var self2 = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function() {
      self2._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};
RedirectableRequest.prototype.setHeader = function(name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};
RedirectableRequest.prototype.removeHeader = function(name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
  var self2 = this;
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }
  function startTimer(socket) {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
    }
    self2._timeout = setTimeout(function() {
      self2.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
=======
nt.prototype = Object.create(uu.prototype);
nt.prototype.abort = function() {
  vu(this._currentRequest), this._currentRequest.abort(), this.emit("abort");
};
nt.prototype.destroy = function(e) {
  return vu(this._currentRequest, e), P8.call(this, e), this;
};
nt.prototype.write = function(e, t, n) {
  if (this._ending)
    throw new F8();
  if (!Un(e) && !N8(e))
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  if (Hn(t) && (n = t, t = null), e.length === 0) {
    n && n();
    return;
  }
  this._requestBodyLength + e.length <= this._options.maxBodyLength ? (this._requestBodyLength += e.length, this._requestBodyBuffers.push({ data: e, encoding: t }), this._currentRequest.write(e, t, n)) : (this.emit("error", new D8()), this.abort());
};
nt.prototype.end = function(e, t, n) {
  if (Hn(e) ? (n = e, e = t = null) : Hn(t) && (n = t, t = null), !e)
    this._ended = this._ending = !0, this._currentRequest.end(null, null, n);
  else {
    var r = this, i = this._currentRequest;
    this.write(e, t, function() {
      r._ended = !0, i.end(null, null, n);
    }), this._ending = !0;
  }
};
nt.prototype.setHeader = function(e, t) {
  this._options.headers[e] = t, this._currentRequest.setHeader(e, t);
};
nt.prototype.removeHeader = function(e) {
  delete this._options.headers[e], this._currentRequest.removeHeader(e);
};
nt.prototype.setTimeout = function(e, t) {
  var n = this;
  function r(s) {
    s.setTimeout(e), s.removeListener("timeout", s.destroy), s.addListener("timeout", s.destroy);
  }
  function i(s) {
    n._timeout && clearTimeout(n._timeout), n._timeout = setTimeout(function() {
      n.emit("timeout"), a();
    }, e), r(s);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  function clearTimer() {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
      self2._timeout = null;
    }
    self2.removeListener("abort", clearTimer);
    self2.removeListener("error", clearTimer);
    self2.removeListener("response", clearTimer);
    self2.removeListener("close", clearTimer);
    if (callback) {
      self2.removeListener("timeout", callback);
    }
    if (!self2.socket) {
      self2._currentRequest.removeListener("socket", startTimer);
    }
  }
  if (callback) {
    this.on("timeout", callback);
  }
  if (this.socket) {
    startTimer(this.socket);
  } else {
    this._currentRequest.once("socket", startTimer);
  }
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);
  return this;
};
[
  "flushHeaders",
  "getHeader",
  "setNoDelay",
  "setSocketKeepAlive"
<<<<<<< HEAD
].forEach(function(method) {
  RedirectableRequest.prototype[method] = function(a, b) {
    return this._currentRequest[method](a, b);
  };
});
["aborted", "connection", "socket"].forEach(function(property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
=======
].forEach(function(e) {
  nt.prototype[e] = function(t, n) {
    return this._currentRequest[e](t, n);
  };
});
["aborted", "connection", "socket"].forEach(function(e) {
  Object.defineProperty(nt.prototype, e, {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    get: function() {
      return this._currentRequest[property];
    }
  });
});
<<<<<<< HEAD
RedirectableRequest.prototype._sanitizeOptions = function(options) {
  if (!options.headers) {
    options.headers = {};
  }
  if (options.host) {
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    } else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};
RedirectableRequest.prototype._performRequest = function() {
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }
  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
  request._redirectable = this;
  for (var event of events) {
    request.on(event, eventHandlers[event]);
  }
  this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
    // When making a request to a proxy, []
    // a client MUST send the target URI in absolute-form [].
    this._options.path
  );
  if (this._isRedirect) {
    var i = 0;
    var self2 = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error2) {
      if (request === self2._currentRequest) {
        if (error2) {
          self2.emit("error", error2);
        } else if (i < buffers.length) {
          var buffer2 = buffers[i++];
          if (!request.finished) {
            request.write(buffer2.data, buffer2.encoding, writeNext);
          }
        } else if (self2._ended) {
          request.end();
        }
      }
    })();
  }
};
RedirectableRequest.prototype._processResponse = function(response) {
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode
    });
  }
  var location = response.headers.location;
  if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);
    this._requestBodyBuffers = [];
    return;
  }
  destroyRequest(this._currentRequest);
  response.destroy();
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host")
    }, this._options.headers);
  }
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource []
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) []
  statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
  var redirectUrl = resolveUrl(location, currentUrl);
  debug$4("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);
  if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response.headers,
      statusCode
    };
    var requestDetails = {
      url: currentUrl,
      method,
      headers: requestHeaders
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }
  this._performRequest();
};
function wrap(protocols) {
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  };
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function(scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
    function request(input, options, callback) {
      if (isURL(input)) {
        input = spreadUrlObject(input);
      } else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      } else {
        callback = options;
        options = validateUrl(input);
        input = { protocol };
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }
      assert$2.equal(options.protocol, protocol, "protocol mismatch");
      debug$4("options", options);
      return new RedirectableRequest(options, callback);
    }
    function get3(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get3, configurable: true, enumerable: true, writable: true }
=======
nt.prototype._sanitizeOptions = function(e) {
  if (e.headers || (e.headers = {}), e.host && (e.hostname || (e.hostname = e.host), delete e.host), !e.pathname && e.path) {
    var t = e.path.indexOf("?");
    t < 0 ? e.pathname = e.path : (e.pathname = e.path.substring(0, t), e.search = e.path.substring(t));
  }
};
nt.prototype._performRequest = function() {
  var e = this._options.protocol, t = this._options.nativeProtocols[e];
  if (!t)
    throw new TypeError("Unsupported protocol " + e);
  if (this._options.agents) {
    var n = e.slice(0, -1);
    this._options.agent = this._options.agents[n];
  }
  var r = this._currentRequest = t.request(this._options, this._onNativeResponse);
  r._redirectable = this;
  for (var i of du)
    r.on(i, hu[i]);
  if (this._currentUrl = /^\//.test(this._options.path) ? ji.format(this._options) : (
    // When making a request to a proxy, []
    // a client MUST send the target URI in absolute-form [].
    this._options.path
  ), this._isRedirect) {
    var a = 0, s = this, c = this._requestBodyBuffers;
    (function o(u) {
      if (r === s._currentRequest)
        if (u)
          s.emit("error", u);
        else if (a < c.length) {
          var l = c[a++];
          r.finished || r.write(l.data, l.encoding, o);
        } else s._ended && r.end();
    })();
  }
};
nt.prototype._processResponse = function(e) {
  var t = e.statusCode;
  this._options.trackRedirects && this._redirects.push({
    url: this._currentUrl,
    headers: e.headers,
    statusCode: t
  });
  var n = e.headers.location;
  if (!n || this._options.followRedirects === !1 || t < 300 || t >= 400) {
    e.responseUrl = this._currentUrl, e.redirects = this._redirects, this.emit("response", e), this._requestBodyBuffers = [];
    return;
  }
  if (vu(this._currentRequest), e.destroy(), ++this._redirectCount > this._options.maxRedirects)
    throw new I8();
  var r, i = this._options.beforeRedirect;
  i && (r = Object.assign({
    // The Host header was set by nativeProtocol.request
    Host: e.req.getHeader("host")
  }, this._options.headers));
  var a = this._options.method;
  ((t === 301 || t === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource []
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) []
  t === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) && (this._options.method = "GET", this._requestBodyBuffers = [], sc(/^content-/i, this._options.headers));
  var s = sc(/^host$/i, this._options.headers), c = mu(this._currentUrl), o = s || c.host, u = /^\w+:/.test(n) ? this._currentUrl : ji.format(Object.assign(c, { host: o })), l = k8(n, u);
  if (d0("redirecting to", l.href), this._isRedirect = !0, _l(l, this._options), (l.protocol !== c.protocol && l.protocol !== "https:" || l.host !== o && !L8(l.host, o)) && sc(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers), Hn(i)) {
    var p = {
      headers: e.headers,
      statusCode: t
    }, f = {
      url: u,
      method: a,
      headers: r
    };
    i(this._options, p, f), this._sanitizeOptions(this._options);
  }
  this._performRequest();
};
function h0(e) {
  var t = {
    maxRedirects: 21,
    maxBodyLength: 10485760
  }, n = {};
  return Object.keys(e).forEach(function(r) {
    var i = r + ":", a = n[i] = e[r], s = t[r] = Object.create(a);
    function c(u, l, p) {
      return U8(u) ? u = _l(u) : Un(u) ? u = _l(mu(u)) : (p = l, l = v0(u), u = { protocol: i }), Hn(l) && (p = l, l = null), l = Object.assign({
        maxRedirects: t.maxRedirects,
        maxBodyLength: t.maxBodyLength
      }, u, l), l.nativeProtocols = n, !Un(l.host) && !Un(l.hostname) && (l.hostname = "::1"), pu.equal(l.protocol, i, "protocol mismatch"), d0("options", l), new nt(l, p);
    }
    function o(u, l, p) {
      var f = s.request(u, l, p);
      return f.end(), f;
    }
    Object.defineProperties(s, {
      request: { value: c, configurable: !0, enumerable: !0, writable: !0 },
      get: { value: o, configurable: !0, enumerable: !0, writable: !0 }
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    });
  });
  return exports;
}
<<<<<<< HEAD
function noop$5() {
}
function parseUrl(input) {
  var parsed;
  if (useNativeURL) {
    parsed = new URL$1(input);
  } else {
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}
function resolveUrl(relative, base) {
  return useNativeURL ? new URL$1(relative, base) : parseUrl(url.resolve(base, relative));
}
function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}
function spreadUrlObject(urlObject, target) {
  var spread2 = target || {};
  for (var key2 of preservedUrlFields) {
    spread2[key2] = urlObject[key2];
  }
  if (spread2.hostname.startsWith("[")) {
    spread2.hostname = spread2.hostname.slice(1, -1);
  }
  if (spread2.port !== "") {
    spread2.port = Number(spread2.port);
  }
  spread2.path = spread2.search ? spread2.pathname + spread2.search : spread2.pathname;
  return spread2;
}
function removeMatchingHeaders(regex, headers2) {
  var lastValue;
  for (var header in headers2) {
    if (regex.test(header)) {
      lastValue = headers2[header];
      delete headers2[header];
    }
  }
  return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
}
function createErrorType(code, message, baseClass) {
  function CustomError(properties) {
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    }
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
=======
function m0() {
}
function mu(e) {
  var t;
  if (fu)
    t = new gi(e);
  else if (t = v0(ji.parse(e)), !Un(t.protocol))
    throw new wl({ input: e });
  return t;
}
function k8(e, t) {
  return fu ? new gi(e, t) : mu(ji.resolve(t, e));
}
function v0(e) {
  if (/^\[/.test(e.hostname) && !/^\[[:0-9a-f]+\]$/i.test(e.hostname))
    throw new wl({ input: e.href || e });
  if (/^\[/.test(e.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(e.host))
    throw new wl({ input: e.href || e });
  return e;
}
function _l(e, t) {
  var n = t || {};
  for (var r of O8)
    n[r] = e[r];
  return n.hostname.startsWith("[") && (n.hostname = n.hostname.slice(1, -1)), n.port !== "" && (n.port = Number(n.port)), n.path = n.search ? n.pathname + n.search : n.pathname, n;
}
function sc(e, t) {
  var n;
  for (var r in t)
    e.test(r) && (n = t[r], delete t[r]);
  return n === null || typeof n > "u" ? void 0 : String(n).trim();
}
function Mi(e, t, n) {
  function r(i) {
    Hn(Error.captureStackTrace) && Error.captureStackTrace(this, this.constructor), Object.assign(this, i || {}), this.code = e, this.message = this.cause ? t + ": " + this.cause.message : t;
  }
  return r.prototype = new (n || Error)(), Object.defineProperties(r.prototype, {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    constructor: {
      value: CustomError,
      enumerable: false
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false
    }
  });
  return CustomError;
}
<<<<<<< HEAD
function destroyRequest(request, error2) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
=======
function vu(e, t) {
  for (var n of du)
    e.removeListener(n, hu[n]);
  e.on("error", m0), e.destroy(t);
}
function L8(e, t) {
  pu(Un(e) && Un(t));
  var n = e.length - t.length - 1;
  return n > 0 && e[n] === "." && e.endsWith(t);
}
function Un(e) {
  return typeof e == "string" || e instanceof String;
}
function Hn(e) {
  return typeof e == "function";
}
function N8(e) {
  return typeof e == "object" && "length" in e;
}
function U8(e) {
  return gi && e instanceof gi;
}
lu.exports = h0({ http: R8, https: $8 });
lu.exports.wrap = h0;
var B8 = lu.exports;
const j8 = /* @__PURE__ */ eu(B8), cs = "1.10.0";
function g0(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
const M8 = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function q8(e, t, n) {
  const r = n && n.Blob || ye.classes.Blob, i = g0(e);
  if (t === void 0 && r && (t = !0), i === "data") {
    e = i.length ? e.slice(i.length + 1) : e;
    const a = M8.exec(e);
    if (!a)
      throw new V("Invalid URL", V.ERR_INVALID_URL);
    const s = a[1], c = a[2], o = a[3], u = Buffer.from(decodeURIComponent(o), c ? "base64" : "utf8");
    if (t) {
      if (!r)
        throw new V("Blob is not supported", V.ERR_NOT_SUPPORT);
      return new r([u], { type: s });
    }
    return u;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  request.on("error", noop$5);
  request.destroy(error2);
}
<<<<<<< HEAD
function isSubdomain(subdomain, domain) {
  assert$2(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isFunction(value) {
  return typeof value === "function";
}
function isBuffer(value) {
  return typeof value === "object" && "length" in value;
}
function isURL(value) {
  return URL$1 && value instanceof URL$1;
}
followRedirects$1.exports = wrap({ http, https });
followRedirects$1.exports.wrap = wrap;
var followRedirectsExports = followRedirects$1.exports;
const followRedirects = /* @__PURE__ */ getDefaultExportFromCjs(followRedirectsExports);
const VERSION$1 = "1.10.0";
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}
const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri2, asBlob, options) {
  const _Blob = options && options.Blob || platform$1.classes.Blob;
  const protocol = parseProtocol(uri2);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri2 = protocol.length ? uri2.slice(protocol.length + 1) : uri2;
    const match = DATA_URL_PATTERN.exec(uri2);
    if (!match) {
      throw new AxiosError$1("Invalid URL", AxiosError$1.ERR_INVALID_URL);
    }
    const mime2 = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer2 = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError$1("Blob is not supported", AxiosError$1.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer2], { type: mime2 });
    }
    return buffer2;
  }
  throw new AxiosError$1("Unsupported protocol " + protocol, AxiosError$1.ERR_NOT_SUPPORT);
}
const kInternals = Symbol("internals");
class AxiosTransformStream extends require$$1$2.Transform {
  constructor(options) {
    options = utils$h.toFlatObject(options, {
=======
const oc = Symbol("internals");
class mf extends ae.Transform {
  constructor(t) {
    t = F.toFlatObject(t, {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
<<<<<<< HEAD
    }, null, (prop, source) => {
      return !utils$h.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
=======
    }, null, (r, i) => !F.isUndefined(i[r])), super({
      readableHighWaterMark: t.chunkSize
    });
    const n = this[oc] = {
      timeWindow: t.timeWindow,
      chunkSize: t.chunkSize,
      maxRate: t.maxRate,
      minChunkSize: t.minChunkSize,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }
<<<<<<< HEAD
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      internals.isCaptured && this.emit("progress", internals.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}
const { asyncIterator } = Symbol;
const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
const BOUNDARY_ALPHABET = platform$1.ALPHABET.ALPHA_DIGIT + "-_";
const textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new require$$1$3.TextEncoder();
const CRLF = "\r\n";
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;
class FormDataPart {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils$h.isString(value);
    let headers2 = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers2 += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers2 + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils$h.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
=======
  _read(t) {
    const n = this[oc];
    return n.onReadCallback && n.onReadCallback(), super._read(t);
  }
  _transform(t, n, r) {
    const i = this[oc], a = i.maxRate, s = this.readableHighWaterMark, c = i.timeWindow, o = 1e3 / c, u = a / o, l = i.minChunkSize !== !1 ? Math.max(i.minChunkSize, u * 0.01) : 0, p = (m, g) => {
      const h = Buffer.byteLength(m);
      i.bytesSeen += h, i.bytes += h, i.isCaptured && this.emit("progress", i.bytesSeen), this.push(m) ? process.nextTick(g) : i.onReadCallback = () => {
        i.onReadCallback = null, process.nextTick(g);
      };
    }, f = (m, g) => {
      const h = Buffer.byteLength(m);
      let b = null, x = s, y, E = 0;
      if (a) {
        const S = Date.now();
        (!i.ts || (E = S - i.ts) >= c) && (i.ts = S, y = u - i.bytes, i.bytes = y < 0 ? -y : 0, E = 0), y = u - i.bytes;
      }
      if (a) {
        if (y <= 0)
          return setTimeout(() => {
            g(null, m);
          }, c - E);
        y < x && (x = y);
      }
      x && h > x && h - x > l && (b = m.subarray(x), m = m.subarray(0, x)), p(m, b ? () => {
        process.nextTick(g, null, b);
      } : g);
    };
    f(t, function m(g, h) {
      if (g)
        return r(g);
      h ? f(h, m) : r(null);
    });
  }
}
const { asyncIterator: vf } = Symbol, b0 = async function* (e) {
  e.stream ? yield* e.stream() : e.arrayBuffer ? yield await e.arrayBuffer() : e[vf] ? yield* e[vf]() : yield e;
}, z8 = ye.ALPHABET.ALPHA_DIGIT + "-_", bi = typeof TextEncoder == "function" ? new TextEncoder() : new De.TextEncoder(), kn = `\r
`, H8 = bi.encode(kn), W8 = 2;
class G8 {
  constructor(t, n) {
    const { escapeName: r } = this.constructor, i = F.isString(n);
    let a = `Content-Disposition: form-data; name="${r(t)}"${!i && n.name ? `; filename="${r(n.name)}"` : ""}${kn}`;
    i ? n = bi.encode(String(n).replace(/\r?\n|\r\n?/g, kn)) : a += `Content-Type: ${n.type || "application/octet-stream"}${kn}`, this.headers = bi.encode(a + kn), this.contentLength = i ? n.byteLength : n.size, this.size = this.headers.byteLength + this.contentLength + W8, this.name = t, this.value = n;
  }
  async *encode() {
    yield this.headers;
    const { value: t } = this;
    F.isTypedArray(t) ? yield t : yield* b0(t), yield H8;
  }
  static escapeName(t) {
    return String(t).replace(/[\r\n"]/g, (n) => ({
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
}
<<<<<<< HEAD
const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + platform$1.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils$h.isFormData(form)) {
=======
const V8 = (e, t, n) => {
  const {
    tag: r = "form-data-boundary",
    size: i = 25,
    boundary: a = r + "-" + ye.generateString(i, z8)
  } = n || {};
  if (!F.isFormData(e))
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
<<<<<<< HEAD
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils$h.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return Readable$2.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
class ZlibHeaderTransformStream extends require$$1$2.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
=======
  const s = bi.encode("--" + a + kn), c = bi.encode("--" + a + "--" + kn);
  let o = c.byteLength;
  const u = Array.from(e.entries()).map(([p, f]) => {
    const m = new G8(p, f);
    return o += m.size, m;
  });
  o += s.byteLength * u.length, o = F.toFiniteNumber(o);
  const l = {
    "Content-Type": `multipart/form-data; boundary=${a}`
  };
  return Number.isFinite(o) && (l["Content-Length"] = o), t && t(l), ox.from(async function* () {
    for (const p of u)
      yield s, yield* p.encode();
    yield c;
  }());
};
class Y8 extends ae.Transform {
  __transform(t, n, r) {
    this.push(t), r();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
}
<<<<<<< HEAD
const callbackify = (fn, reducer) => {
  return utils$h.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp2 = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp2 = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp2;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$h.asap(() => fn(...args));
const zlibOptions = {
  flush: zlib$4.constants.Z_SYNC_FLUSH,
  finishFlush: zlib$4.constants.Z_SYNC_FLUSH
};
const brotliOptions = {
  flush: zlib$4.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib$4.constants.BROTLI_OPERATION_FLUSH
};
const isBrotliSupported = utils$h.isFunction(zlib$4.createBrotliDecompress);
const { http: httpFollow, https: httpsFollow } = followRedirects;
const isHttps = /https:?/;
const supportedProtocols = platform$1.protocols.map((protocol) => {
  return protocol + ":";
});
const flushOnFinish = (stream2, [throttled, flush]) => {
  stream2.on("end", flush).on("error", flush);
  return throttled;
};
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnv.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
const isHttpAdapterSupported = typeof process !== "undefined" && utils$h.kindOf(process) === "process";
const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
const resolveFamily = ({ address, family }) => {
  if (!utils$h.isString(address)) {
=======
const X8 = (e, t) => F.isAsyncFn(e) ? function(...n) {
  const r = n.pop();
  e.apply(this, n).then((i) => {
    try {
      t ? r(null, ...t(i)) : r(null, i);
    } catch (a) {
      r(a);
    }
  }, r);
} : e;
function K8(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, a = 0, s;
  return t = t !== void 0 ? t : 1e3, function(o) {
    const u = Date.now(), l = r[a];
    s || (s = u), n[i] = o, r[i] = u;
    let p = a, f = 0;
    for (; p !== i; )
      f += n[p++], p = p % e;
    if (i = (i + 1) % e, i === a && (a = (a + 1) % e), u - s < t)
      return;
    const m = l && u - l;
    return m ? Math.round(f * 1e3 / m) : void 0;
  };
}
function J8(e, t) {
  let n = 0, r = 1e3 / t, i, a;
  const s = (u, l = Date.now()) => {
    n = l, i = null, a && (clearTimeout(a), a = null), e.apply(null, u);
  };
  return [(...u) => {
    const l = Date.now(), p = l - n;
    p >= r ? s(u, l) : (i = u, a || (a = setTimeout(() => {
      a = null, s(i);
    }, r - p)));
  }, () => i && s(i)];
}
const Dr = (e, t, n = 3) => {
  let r = 0;
  const i = K8(50, 250);
  return J8((a) => {
    const s = a.loaded, c = a.lengthComputable ? a.total : void 0, o = s - r, u = i(o), l = s <= c;
    r = s;
    const p = {
      loaded: s,
      total: c,
      progress: c ? s / c : void 0,
      bytes: o,
      rate: u || void 0,
      estimated: u && c && l ? (c - s) / u : void 0,
      event: a,
      lengthComputable: c != null,
      [t ? "download" : "upload"]: !0
    };
    e(p);
  }, n);
}, ls = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, us = (e) => (...t) => F.asap(() => e(...t)), gf = {
  flush: et.constants.Z_SYNC_FLUSH,
  finishFlush: et.constants.Z_SYNC_FLUSH
}, Z8 = {
  flush: et.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: et.constants.BROTLI_OPERATION_FLUSH
}, bf = F.isFunction(et.createBrotliDecompress), { http: Q8, https: e4 } = j8, t4 = /https:?/, xf = ye.protocols.map((e) => e + ":"), yf = (e, [t, n]) => (e.on("end", n).on("error", n), t);
function n4(e, t) {
  e.beforeRedirects.proxy && e.beforeRedirects.proxy(e), e.beforeRedirects.config && e.beforeRedirects.config(e, t);
}
function x0(e, t, n) {
  let r = t;
  if (!r && r !== !1) {
    const i = u0.getProxyForUrl(n);
    i && (r = new URL(i));
  }
  if (r) {
    if (r.username && (r.auth = (r.username || "") + ":" + (r.password || "")), r.auth) {
      (r.auth.username || r.auth.password) && (r.auth = (r.auth.username || "") + ":" + (r.auth.password || ""));
      const a = Buffer.from(r.auth, "utf8").toString("base64");
      e.headers["Proxy-Authorization"] = "Basic " + a;
    }
    e.headers.host = e.hostname + (e.port ? ":" + e.port : "");
    const i = r.hostname || r.host;
    e.hostname = i, e.host = i, e.port = r.port, e.path = n, r.protocol && (e.protocol = r.protocol.includes(":") ? r.protocol : `${r.protocol}:`);
  }
  e.beforeRedirects.proxy = function(a) {
    x0(a, t, a.href);
  };
}
const r4 = typeof process < "u" && F.kindOf(process) === "process", i4 = (e) => new Promise((t, n) => {
  let r, i;
  const a = (o, u) => {
    i || (i = !0, r && r(o, u));
  }, s = (o) => {
    a(o), t(o);
  }, c = (o) => {
    a(o, !0), n(o);
  };
  e(s, c, (o) => r = o).catch(c);
}), a4 = ({ address: e, family: t }) => {
  if (!F.isString(e))
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
<<<<<<< HEAD
};
const buildAddressEntry = (address, family) => resolveFamily(utils$h.isObject(address) ? address : { address, family });
const httpAdapter = isHttpAdapterSupported && function httpAdapter2(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let { data, lookup, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup) {
      const _lookup = callbackify(lookup, (value) => utils$h.isArray(value) ? value : [value]);
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils$h.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new EventEmitter$4();
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort2);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort2);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort2(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError$1(null, config, req) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort2);
      if (config.signal) {
        config.signal.aborted ? abort2() : config.signal.addEventListener("abort", abort2);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform$1.hasBrowserEnv ? platform$1.origin : void 0);
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve, reject, {
=======
}, wf = (e, t) => a4(F.isObject(e) ? e : { address: e, family: t }), s4 = r4 && function(t) {
  return i4(async function(r, i, a) {
    let { data: s, lookup: c, family: o } = t;
    const { responseType: u, responseEncoding: l } = t, p = t.method.toUpperCase();
    let f, m = !1, g;
    if (c) {
      const w = X8(c, (_) => F.isArray(_) ? _ : [_]);
      c = (_, R, L) => {
        w(_, R, (N, j, K) => {
          if (N)
            return L(N);
          const Z = F.isArray(j) ? j.map((q) => wf(q)) : [wf(j, K)];
          R.all ? L(N, Z) : L(N, Z[0].address, Z[0].family);
        });
      };
    }
    const h = new cx(), b = () => {
      t.cancelToken && t.cancelToken.unsubscribe(x), t.signal && t.signal.removeEventListener("abort", x), h.removeAllListeners();
    };
    a((w, _) => {
      f = !0, _ && (m = !0, b());
    });
    function x(w) {
      h.emit("abort", !w || w.type ? new ln(null, t, g) : w);
    }
    h.once("abort", i), (t.cancelToken || t.signal) && (t.cancelToken && t.cancelToken.subscribe(x), t.signal && (t.signal.aborted ? x() : t.signal.addEventListener("abort", x)));
    const y = cu(t.baseURL, t.url, t.allowAbsoluteUrls), E = new URL(y, ye.hasBrowserEnv ? ye.origin : void 0), S = E.protocol || xf[0];
    if (S === "data:") {
      let w;
      if (p !== "GET")
        return mr(r, i, {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
<<<<<<< HEAD
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError$1.from(err, AxiosError$1.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils$h.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = require$$1$2.Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders$1(),
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError$1(
        "Unsupported protocol " + protocol,
        AxiosError$1.ERR_BAD_REQUEST,
        config
      ));
    }
    const headers2 = AxiosHeaders$1.from(config.headers).normalize();
    headers2.set("User-Agent", "axios/" + VERSION$1, false);
    const { onUploadProgress, onDownloadProgress } = config;
    const maxRate = config.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils$h.isSpecCompliantForm(data)) {
      const userBoundary = headers2.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream(data, (formHeaders) => {
        headers2.set(formHeaders);
      }, {
        tag: `axios-${VERSION$1}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils$h.isFormData(data) && utils$h.isFunction(data.getHeaders)) {
      headers2.set(data.getHeaders());
      if (!headers2.hasContentLength()) {
        try {
          const knownLength = await require$$1$3.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers2.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils$h.isBlob(data) || utils$h.isFile(data)) {
      data.size && headers2.setContentType(data.type || "application/octet-stream");
      headers2.setContentLength(data.size || 0);
      data = require$$1$2.Readable.from(readBlob(data));
    } else if (data && !utils$h.isStream(data)) {
      if (Buffer.isBuffer(data)) ;
      else if (utils$h.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils$h.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError$1(
=======
      try {
        w = q8(t.url, u === "blob", {
          Blob: t.env && t.env.Blob
        });
      } catch (_) {
        throw V.from(_, V.ERR_BAD_REQUEST, t);
      }
      return u === "text" ? (w = w.toString(l), (!l || l === "utf8") && (w = F.stripBOM(w))) : u === "stream" && (w = ae.Readable.from(w)), mr(r, i, {
        data: w,
        status: 200,
        statusText: "OK",
        headers: new Ne(),
        config: t
      });
    }
    if (xf.indexOf(S) === -1)
      return i(new V(
        "Unsupported protocol " + S,
        V.ERR_BAD_REQUEST,
        t
      ));
    const D = Ne.from(t.headers).normalize();
    D.set("User-Agent", "axios/" + cs, !1);
    const { onUploadProgress: U, onDownloadProgress: z } = t, ee = t.maxRate;
    let C, H;
    if (F.isSpecCompliantForm(s)) {
      const w = D.getContentType(/boundary=([-_\w\d]{10,70})/i);
      s = V8(s, (_) => {
        D.set(_);
      }, {
        tag: `axios-${cs}-boundary`,
        boundary: w && w[1] || void 0
      });
    } else if (F.isFormData(s) && F.isFunction(s.getHeaders)) {
      if (D.set(s.getHeaders()), !D.hasContentLength())
        try {
          const w = await De.promisify(s.getLength).call(s);
          Number.isFinite(w) && w >= 0 && D.setContentLength(w);
        } catch {
        }
    } else if (F.isBlob(s) || F.isFile(s))
      s.size && D.setContentType(s.type || "application/octet-stream"), D.setContentLength(s.size || 0), s = ae.Readable.from(b0(s));
    else if (s && !F.isStream(s)) {
      if (!Buffer.isBuffer(s)) if (F.isArrayBuffer(s))
        s = Buffer.from(new Uint8Array(s));
      else if (F.isString(s))
        s = Buffer.from(s, "utf-8");
      else
        return i(new V(
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError$1.ERR_BAD_REQUEST,
          config
        ));
<<<<<<< HEAD
      }
      headers2.setContentLength(data.length, false);
      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError$1(
=======
      if (D.setContentLength(s.length, !1), t.maxBodyLength > -1 && s.length > t.maxBodyLength)
        return i(new V(
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          "Request body larger than maxBodyLength limit",
          AxiosError$1.ERR_BAD_REQUEST,
          config
        ));
      }
    }
<<<<<<< HEAD
    const contentLength = utils$h.toFiniteNumber(headers2.getContentLength());
    if (utils$h.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils$h.isStream(data)) {
        data = require$$1$2.Readable.from(data, { objectMode: false });
      }
      data = require$$1$2.pipeline([data, new AxiosTransformStream({
        maxRate: utils$h.toFiniteNumber(maxUploadRate)
      })], utils$h.noop);
      onUploadProgress && data.on("progress", flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }
    let auth = void 0;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers2.delete("authorization");
    let path2;
    try {
      path2 = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers2.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path: path2,
      method,
      headers: headers2.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils$h.isUndefined(lookup) && (options.lookup = lookup);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? require$$4$2 : require$$3$2;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;
      const streams2 = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream({
          maxRate: utils$h.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));
        streams2.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch ((res.headers["content-encoding"] || "").toLowerCase()) {
=======
    const M = F.toFiniteNumber(D.getContentLength());
    F.isArray(ee) ? (C = ee[0], H = ee[1]) : C = H = ee, s && (U || C) && (F.isStream(s) || (s = ae.Readable.from(s, { objectMode: !1 })), s = ae.pipeline([s, new mf({
      maxRate: F.toFiniteNumber(C)
    })], F.noop), U && s.on("progress", yf(
      s,
      ls(
        M,
        Dr(us(U), !1, 3)
      )
    )));
    let J;
    if (t.auth) {
      const w = t.auth.username || "", _ = t.auth.password || "";
      J = w + ":" + _;
    }
    if (!J && E.username) {
      const w = E.username, _ = E.password;
      J = w + ":" + _;
    }
    J && D.delete("authorization");
    let re;
    try {
      re = au(
        E.pathname + E.search,
        t.params,
        t.paramsSerializer
      ).replace(/^\?/, "");
    } catch (w) {
      const _ = new Error(w.message);
      return _.config = t, _.url = t.url, _.exists = !0, i(_);
    }
    D.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (bf ? ", br" : ""),
      !1
    );
    const k = {
      path: re,
      method: p,
      headers: D.toJSON(),
      agents: { http: t.httpAgent, https: t.httpsAgent },
      auth: J,
      protocol: S,
      family: o,
      beforeRedirect: n4,
      beforeRedirects: {}
    };
    !F.isUndefined(c) && (k.lookup = c), t.socketPath ? k.socketPath = t.socketPath : (k.hostname = E.hostname.startsWith("[") ? E.hostname.slice(1, -1) : E.hostname, k.port = E.port, x0(k, t.proxy, S + "//" + E.hostname + (E.port ? ":" + E.port : "") + k.path));
    let O;
    const P = t4.test(k.protocol);
    if (k.agent = P ? t.httpsAgent : t.httpAgent, t.transport ? O = t.transport : t.maxRedirects === 0 ? O = P ? Zl : Cs : (t.maxRedirects && (k.maxRedirects = t.maxRedirects), t.beforeRedirect && (k.beforeRedirects.config = t.beforeRedirect), O = P ? e4 : Q8), t.maxBodyLength > -1 ? k.maxBodyLength = t.maxBodyLength : k.maxBodyLength = 1 / 0, t.insecureHTTPParser && (k.insecureHTTPParser = t.insecureHTTPParser), g = O.request(k, function(_) {
      if (g.destroyed) return;
      const R = [_], L = +_.headers["content-length"];
      if (z || H) {
        const q = new mf({
          maxRate: F.toFiniteNumber(H)
        });
        z && q.on("progress", yf(
          q,
          ls(
            L,
            Dr(us(z), !0, 3)
          )
        )), R.push(q);
      }
      let N = _;
      const j = _.req || g;
      if (t.decompress !== !1 && _.headers["content-encoding"])
        switch ((p === "HEAD" || _.statusCode === 204) && delete _.headers["content-encoding"], (_.headers["content-encoding"] || "").toLowerCase()) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
<<<<<<< HEAD
            streams2.push(zlib$4.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams2.push(new ZlibHeaderTransformStream());
            streams2.push(zlib$4.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
=======
            R.push(et.createUnzip(gf)), delete _.headers["content-encoding"];
            break;
          case "deflate":
            R.push(new Y8()), R.push(et.createUnzip(gf)), delete _.headers["content-encoding"];
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
            break;
          case "br":
            bf && (R.push(et.createBrotliDecompress(Z8)), delete _.headers["content-encoding"]);
        }
<<<<<<< HEAD
      }
      responseStream = streams2.length > 1 ? require$$1$2.pipeline(streams2, utils$h.noop) : streams2[0];
      const offListeners = require$$1$2.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders$1(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError$1(
              "maxContentLength size of " + config.maxContentLength + " exceeded",
              AxiosError$1.ERR_BAD_RESPONSE,
              config,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError$1(
            "stream has been aborted",
            AxiosError$1.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed) return;
          reject(AxiosError$1.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils$h.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError$1.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError$1.from(err, null, config, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError$1(
=======
      N = R.length > 1 ? ae.pipeline(R, F.noop) : R[0];
      const K = ae.finished(N, () => {
        K(), b();
      }), Z = {
        status: _.statusCode,
        statusText: _.statusMessage,
        headers: new Ne(_.headers),
        config: t,
        request: j
      };
      if (u === "stream")
        Z.data = N, mr(r, i, Z);
      else {
        const q = [];
        let le = 0;
        N.on("data", function(d) {
          q.push(d), le += d.length, t.maxContentLength > -1 && le > t.maxContentLength && (m = !0, N.destroy(), i(new V(
            "maxContentLength size of " + t.maxContentLength + " exceeded",
            V.ERR_BAD_RESPONSE,
            t,
            j
          )));
        }), N.on("aborted", function() {
          if (m)
            return;
          const d = new V(
            "stream has been aborted",
            V.ERR_BAD_RESPONSE,
            t,
            j
          );
          N.destroy(d), i(d);
        }), N.on("error", function(d) {
          g.destroyed || i(V.from(d, null, t, j));
        }), N.on("end", function() {
          try {
            let d = q.length === 1 ? q[0] : Buffer.concat(q);
            u !== "arraybuffer" && (d = d.toString(l), (!l || l === "utf8") && (d = F.stripBOM(d))), Z.data = d;
          } catch (d) {
            return i(V.from(d, null, t, Z.request, Z));
          }
          mr(r, i, Z);
        });
      }
      h.once("abort", (q) => {
        N.destroyed || (N.emit("error", q), N.destroy());
      });
    }), h.once("abort", (w) => {
      i(w), g.destroy(w);
    }), g.on("error", function(_) {
      i(V.from(_, null, t, g));
    }), g.on("socket", function(_) {
      _.setKeepAlive(!0, 1e3 * 60);
    }), t.timeout) {
      const w = parseInt(t.timeout, 10);
      if (Number.isNaN(w)) {
        i(new V(
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          "error trying to parse `config.timeout` to int",
          AxiosError$1.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));
        return;
      }
<<<<<<< HEAD
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError$1(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
          config,
          req
        ));
        abort2();
      });
    }
    if (utils$h.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort2(new CanceledError$1("Request stream has been aborted", config, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};
const isURLSameOrigin = platform$1.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
  url2 = new URL(url2, platform$1.origin);
  return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
})(
  new URL(platform$1.origin),
  platform$1.navigator && /(msie|trident)/i.test(platform$1.navigator.userAgent)
) : () => true;
const cookies = platform$1.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$h.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$h.isString(path2) && cookie.push("path=" + path2);
      utils$h.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
=======
      g.setTimeout(w, function() {
        if (f) return;
        let R = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
        const L = t.transitional || su;
        t.timeoutErrorMessage && (R = t.timeoutErrorMessage), i(new V(
          R,
          L.clarifyTimeoutError ? V.ETIMEDOUT : V.ECONNABORTED,
          t,
          g
        )), x();
      });
    }
    if (F.isStream(s)) {
      let w = !1, _ = !1;
      s.on("end", () => {
        w = !0;
      }), s.once("error", (R) => {
        _ = !0, g.destroy(R);
      }), s.on("close", () => {
        !w && !_ && x(new ln("Request stream has been aborted", t, g));
      }), s.pipe(g);
    } else
      g.end(s);
  });
}, o4 = ye.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, ye.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(ye.origin),
  ye.navigator && /(msie|trident)/i.test(ye.navigator.userAgent)
) : () => !0, c4 = ye.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, i, a) {
      const s = [e + "=" + encodeURIComponent(t)];
      F.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()), F.isString(r) && s.push("path=" + r), F.isString(i) && s.push("domain=" + i), a === !0 && s.push("secure"), document.cookie = s.join("; ");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
<<<<<<< HEAD
);
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$h.isPlainObject(target) && utils$h.isPlainObject(source)) {
      return utils$h.merge.call({ caseless }, target, source);
    } else if (utils$h.isPlainObject(source)) {
      return utils$h.merge({}, source);
    } else if (utils$h.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils$h.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils$h.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils$h.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils$h.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$h.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
=======
), Ef = (e) => e instanceof Ne ? { ...e } : e;
function Wn(e, t) {
  t = t || {};
  const n = {};
  function r(u, l, p, f) {
    return F.isPlainObject(u) && F.isPlainObject(l) ? F.merge.call({ caseless: f }, u, l) : F.isPlainObject(l) ? F.merge({}, l) : F.isArray(l) ? l.slice() : l;
  }
  function i(u, l, p, f) {
    if (F.isUndefined(l)) {
      if (!F.isUndefined(u))
        return r(void 0, u, p, f);
    } else return r(u, l, p, f);
  }
  function a(u, l) {
    if (!F.isUndefined(l))
      return r(void 0, l);
  }
  function s(u, l) {
    if (F.isUndefined(l)) {
      if (!F.isUndefined(u))
        return r(void 0, u);
    } else return r(void 0, l);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
<<<<<<< HEAD
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils$h.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$h.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = (config) => {
  const newConfig = mergeConfig$1({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers: headers2, auth } = newConfig;
  newConfig.headers = headers2 = AxiosHeaders$1.from(headers2);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers2.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$h.isFormData(data)) {
    if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv) {
      headers2.setContentType(void 0);
    } else if ((contentType = headers2.getContentType()) !== false) {
      const [type2, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers2.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform$1.hasStandardBrowserEnv) {
    withXSRFToken && utils$h.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers2.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError2() {
      reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$h.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
        request.setRequestHeader(key2, val);
      });
    }
    if (!utils$h.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform$1.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$h.asap(unsubscribe);
    return signal;
  }
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end2;
  while (pos < len) {
    end2 = pos + chunkSize;
    yield chunk.slice(pos, end2);
    pos = end2;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream2) {
  if (stream2[Symbol.asyncIterator]) {
    yield* stream2;
    return;
  }
  const reader = stream2.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream2, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream2, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
=======
  const o = {
    url: a,
    method: a,
    data: a,
    baseURL: s,
    transformRequest: s,
    transformResponse: s,
    paramsSerializer: s,
    timeout: s,
    timeoutMessage: s,
    withCredentials: s,
    withXSRFToken: s,
    adapter: s,
    responseType: s,
    xsrfCookieName: s,
    xsrfHeaderName: s,
    onUploadProgress: s,
    onDownloadProgress: s,
    decompress: s,
    maxContentLength: s,
    maxBodyLength: s,
    beforeRedirect: s,
    transport: s,
    httpAgent: s,
    httpsAgent: s,
    cancelToken: s,
    socketPath: s,
    responseEncoding: s,
    validateStatus: c,
    headers: (u, l, p) => i(Ef(u), Ef(l), p, !0)
  };
  return F.forEach(Object.keys(Object.assign({}, e, t)), function(l) {
    const p = o[l] || i, f = p(e[l], t[l], l);
    F.isUndefined(f) && p !== c || (n[l] = f);
  }), n;
}
const y0 = (e) => {
  const t = Wn({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: a, headers: s, auth: c } = t;
  t.headers = s = Ne.from(s), t.url = au(cu(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), c && s.set(
    "Authorization",
    "Basic " + btoa((c.username || "") + ":" + (c.password ? unescape(encodeURIComponent(c.password)) : ""))
  );
  let o;
  if (F.isFormData(n)) {
    if (ye.hasStandardBrowserEnv || ye.hasStandardBrowserWebWorkerEnv)
      s.setContentType(void 0);
    else if ((o = s.getContentType()) !== !1) {
      const [u, ...l] = o ? o.split(";").map((p) => p.trim()).filter(Boolean) : [];
      s.setContentType([u || "multipart/form-data", ...l].join("; "));
    }
  }
  if (ye.hasStandardBrowserEnv && (r && F.isFunction(r) && (r = r(t)), r || r !== !1 && o4(t.url))) {
    const u = i && a && c4.read(a);
    u && s.set(i, u);
  }
  return t;
}, l4 = typeof XMLHttpRequest < "u", u4 = l4 && function(e) {
  return new Promise(function(n, r) {
    const i = y0(e);
    let a = i.data;
    const s = Ne.from(i.headers).normalize();
    let { responseType: c, onUploadProgress: o, onDownloadProgress: u } = i, l, p, f, m, g;
    function h() {
      m && m(), g && g(), i.cancelToken && i.cancelToken.unsubscribe(l), i.signal && i.signal.removeEventListener("abort", l);
    }
    let b = new XMLHttpRequest();
    b.open(i.method.toUpperCase(), i.url, !0), b.timeout = i.timeout;
    function x() {
      if (!b)
        return;
      const E = Ne.from(
        "getAllResponseHeaders" in b && b.getAllResponseHeaders()
      ), D = {
        data: !c || c === "text" || c === "json" ? b.responseText : b.response,
        status: b.status,
        statusText: b.statusText,
        headers: E,
        config: e,
        request: b
      };
      mr(function(z) {
        n(z), h();
      }, function(z) {
        r(z), h();
      }, D), b = null;
    }
    "onloadend" in b ? b.onloadend = x : b.onreadystatechange = function() {
      !b || b.readyState !== 4 || b.status === 0 && !(b.responseURL && b.responseURL.indexOf("file:") === 0) || setTimeout(x);
    }, b.onabort = function() {
      b && (r(new V("Request aborted", V.ECONNABORTED, e, b)), b = null);
    }, b.onerror = function() {
      r(new V("Network Error", V.ERR_NETWORK, e, b)), b = null;
    }, b.ontimeout = function() {
      let S = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const D = i.transitional || su;
      i.timeoutErrorMessage && (S = i.timeoutErrorMessage), r(new V(
        S,
        D.clarifyTimeoutError ? V.ETIMEDOUT : V.ECONNABORTED,
        e,
        b
      )), b = null;
    }, a === void 0 && s.setContentType(null), "setRequestHeader" in b && F.forEach(s.toJSON(), function(S, D) {
      b.setRequestHeader(D, S);
    }), F.isUndefined(i.withCredentials) || (b.withCredentials = !!i.withCredentials), c && c !== "json" && (b.responseType = i.responseType), u && ([f, g] = Dr(u, !0), b.addEventListener("progress", f)), o && b.upload && ([p, m] = Dr(o), b.upload.addEventListener("progress", p), b.upload.addEventListener("loadend", m)), (i.cancelToken || i.signal) && (l = (E) => {
      b && (r(!E || E.type ? new ln(null, e, b) : E), b.abort(), b = null);
    }, i.cancelToken && i.cancelToken.subscribe(l), i.signal && (i.signal.aborted ? l() : i.signal.addEventListener("abort", l)));
    const y = g0(i.url);
    if (y && ye.protocols.indexOf(y) === -1) {
      r(new V("Unsupported protocol " + y + ":", V.ERR_BAD_REQUEST, e));
      return;
    }
    b.send(a || null);
  });
}, p4 = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), i;
    const a = function(u) {
      if (!i) {
        i = !0, c();
        const l = u instanceof Error ? u : this.reason;
        r.abort(l instanceof V ? l : new ln(l instanceof Error ? l.message : l));
      }
    };
    let s = t && setTimeout(() => {
      s = null, a(new V(`timeout ${t} of ms exceeded`, V.ETIMEDOUT));
    }, t);
    const c = () => {
      e && (s && clearTimeout(s), s = null, e.forEach((u) => {
        u.unsubscribe ? u.unsubscribe(a) : u.removeEventListener("abort", a);
      }), e = null);
    };
    e.forEach((u) => u.addEventListener("abort", a));
    const { signal: o } = r;
    return o.unsubscribe = () => F.asap(c), o;
  }
}, f4 = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let r = 0, i;
  for (; r < n; )
    i = r + t, yield e.slice(r, i), r = i;
}, d4 = async function* (e, t) {
  for await (const n of h4(e))
    yield* f4(n, t);
}, h4 = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, _f = (e, t, n, r) => {
  const i = d4(e, t);
  let a = 0, s, c = (o) => {
    s || (s = !0, r && r(o));
  };
  return new ReadableStream({
    async pull(o) {
      try {
        const { done: u, value: l } = await i.next();
        if (u) {
          c(), o.close();
          return;
        }
        let p = l.byteLength;
        if (n) {
          let f = a += p;
          n(f);
        }
        o.enqueue(new Uint8Array(l));
      } catch (u) {
        throw c(u), u;
      }
    },
    cancel(o) {
      return c(o), i.return();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
  }, {
    highWaterMark: 2
  });
<<<<<<< HEAD
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str2) => encoder.encode(str2))(new TextEncoder()) : async (str2) => new Uint8Array(await new Response(str2).arrayBuffer()));
const test = (fn, ...args) => {
=======
}, Bs = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", w0 = Bs && typeof ReadableStream == "function", m4 = Bs && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), E0 = (e, ...t) => {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
<<<<<<< HEAD
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform$1.origin, {
=======
}, v4 = w0 && E0(() => {
  let e = !1;
  const t = new Request(ye.origin, {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
<<<<<<< HEAD
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$h.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
    !resolvers[type2] && (resolvers[type2] = utils$h.isFunction(res[type2]) ? (res2) => res2[type2]() : (_, config) => {
      throw new AxiosError$1(`Response type '${type2}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$h.isBlob(body)) {
    return body.size;
  }
  if (utils$h.isSpecCompliantForm(body)) {
    const _request = new Request(platform$1.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$h.isArrayBufferView(body) || utils$h.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$h.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$h.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers2, body) => {
  const length = utils$h.toFiniteNumber(headers2.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url: url2,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers: headers2,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers2, data)) !== 0) {
      let _request = new Request(url2, {
=======
  return e && !t;
}), Sf = 64 * 1024, Sl = w0 && E0(() => F.isReadableStream(new Response("").body)), ps = {
  stream: Sl && ((e) => e.body)
};
Bs && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !ps[t] && (ps[t] = F.isFunction(e[t]) ? (n) => n[t]() : (n, r) => {
      throw new V(`Response type '${t}' is not supported`, V.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const g4 = async (e) => {
  if (e == null)
    return 0;
  if (F.isBlob(e))
    return e.size;
  if (F.isSpecCompliantForm(e))
    return (await new Request(ye.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (F.isArrayBufferView(e) || F.isArrayBuffer(e))
    return e.byteLength;
  if (F.isURLSearchParams(e) && (e = e + ""), F.isString(e))
    return (await m4(e)).byteLength;
}, b4 = async (e, t) => {
  const n = F.toFiniteNumber(e.getContentLength());
  return n ?? g4(t);
}, x4 = Bs && (async (e) => {
  let {
    url: t,
    method: n,
    data: r,
    signal: i,
    cancelToken: a,
    timeout: s,
    onDownloadProgress: c,
    onUploadProgress: o,
    responseType: u,
    headers: l,
    withCredentials: p = "same-origin",
    fetchOptions: f
  } = y0(e);
  u = u ? (u + "").toLowerCase() : "text";
  let m = p4([i, a && a.toAbortSignal()], s), g;
  const h = m && m.unsubscribe && (() => {
    m.unsubscribe();
  });
  let b;
  try {
    if (o && v4 && n !== "get" && n !== "head" && (b = await b4(l, r)) !== 0) {
      let D = new Request(t, {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        method: "POST",
        body: data,
        duplex: "half"
<<<<<<< HEAD
      });
      let contentTypeHeader;
      if (utils$h.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers2.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils$h.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url2, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers2.normalize().toJSON(),
      body: data,
=======
      }), U;
      if (F.isFormData(r) && (U = D.headers.get("content-type")) && l.setContentType(U), D.body) {
        const [z, ee] = ls(
          b,
          Dr(us(o))
        );
        r = _f(D.body, Sf, z, ee);
      }
    }
    F.isString(p) || (p = p ? "include" : "omit");
    const x = "credentials" in Request.prototype;
    g = new Request(t, {
      ...f,
      signal: m,
      method: n.toUpperCase(),
      headers: l.normalize().toJSON(),
      body: r,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
<<<<<<< HEAD
    let response = await fetch(request, fetchOptions);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$h.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$h.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
=======
    let y = await fetch(g, f);
    const E = Sl && (u === "stream" || u === "response");
    if (Sl && (c || E && h)) {
      const D = {};
      ["status", "statusText", "headers"].forEach((C) => {
        D[C] = y[C];
      });
      const U = F.toFiniteNumber(y.headers.get("content-length")), [z, ee] = c && ls(
        U,
        Dr(us(c), !0)
      ) || [];
      y = new Response(
        _f(y.body, Sf, z, () => {
          ee && ee(), h && h();
        }),
        D
      );
    }
    u = u || "text";
    let S = await ps[F.findKey(ps, u) || "text"](y, e);
    return !E && h && h(), await new Promise((D, U) => {
      mr(D, U, {
        data: S,
        headers: Ne.from(y.headers),
        status: y.status,
        statusText: y.statusText,
        config: e,
        request: g
      });
    });
  } catch (x) {
    throw h && h(), x && x.name === "TypeError" && /Load failed|fetch/i.test(x.message) ? Object.assign(
      new V("Network Error", V.ERR_NETWORK, e, g),
      {
        cause: x.cause || x
      }
    ) : V.from(x, x && x.code, e, g);
  }
}), Al = {
  http: s4,
  xhr: u4,
  fetch: x4
};
F.forEach(Al, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    throw AxiosError$1.from(err, err && err.code, config, request);
  }
});
<<<<<<< HEAD
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$h.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$h.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$h.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError$1(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state2]) => `adapter ${id} ` + (state2 === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s,
=======
const Af = (e) => `- ${e}`, y4 = (e) => F.isFunction(e) || e === null || e === !1, _0 = {
  getAdapter: (e) => {
    e = F.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const i = {};
    for (let a = 0; a < t; a++) {
      n = e[a];
      let s;
      if (r = n, !y4(n) && (r = Al[(s = String(n)).toLowerCase()], r === void 0))
        throw new V(`Unknown adapter '${s}'`);
      if (r)
        break;
      i[s || "#" + a] = r;
    }
    if (!r) {
      const a = Object.entries(i).map(
        ([c, o]) => `adapter ${c} ` + (o === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let s = t ? a.length > 1 ? `since :
` + a.map(Af).join(`
`) : " " + Af(a[0]) : "as no adapter specified";
      throw new V(
        "There is no suitable adapter to dispatch the request " + s,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
<<<<<<< HEAD
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError$1(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema2, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema2[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
=======
  adapters: Al
};
function cc(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new ln(null, e);
}
function Tf(e) {
  return cc(e), e.headers = Ne.from(e.headers), e.data = tc.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), _0.getAdapter(e.adapter || Bi.adapter)(e).then(function(r) {
    return cc(e), r.data = tc.call(
      e,
      e.transformResponse,
      r
    ), r.headers = Ne.from(r.headers), r;
  }, function(r) {
    return l0(r) || (cc(e), r && r.response && (r.response.data = tc.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = Ne.from(r.response.headers))), Promise.reject(r);
  });
}
const js = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  js[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const Cf = {};
js.transitional = function(t, n, r) {
  function i(a, s) {
    return "[Axios v" + cs + "] Transitional option '" + a + "'" + s + (r ? ". " + r : "");
  }
  return (a, s, c) => {
    if (t === !1)
      throw new V(
        i(s, " has been removed" + (n ? " in " + n : "")),
        V.ERR_DEPRECATED
      );
    return n && !Cf[s] && (Cf[s] = !0, console.warn(
      i(
        s,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(a, s, c) : !0;
  };
};
js.spelling = function(t) {
  return (n, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0);
};
function w4(e, t, n) {
  if (typeof e != "object")
    throw new V("options must be an object", V.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const a = r[i], s = t[a];
    if (s) {
      const c = e[a], o = c === void 0 || s(c, a, e);
      if (o !== !0)
        throw new V("option " + a + " must be " + o, V.ERR_BAD_OPTION_VALUE);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
<<<<<<< HEAD
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
=======
const Ka = {
  assertOptions: w4,
  validators: js
}, _t = Ka.validators;
let Bn = class {
  constructor(t) {
    this.defaults = t || {}, this.interceptors = {
      request: new sf(),
      response: new sf()
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
<<<<<<< HEAD
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig$1(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers: headers2 } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$h.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) ;
    else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator.assertOptions(config, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers2 && utils$h.merge(
      headers2.common,
      headers2[config.method]
    );
    headers2 && utils$h.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers2[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers2);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
=======
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Wn(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: a } = n;
    r !== void 0 && Ka.assertOptions(r, {
      silentJSONParsing: _t.transitional(_t.boolean),
      forcedJSONParsing: _t.transitional(_t.boolean),
      clarifyTimeoutError: _t.transitional(_t.boolean)
    }, !1), i != null && (F.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : Ka.assertOptions(i, {
      encode: _t.function,
      serialize: _t.function
    }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Ka.assertOptions(n, {
      baseUrl: _t.spelling("baseURL"),
      withXsrfToken: _t.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let s = a && F.merge(
      a.common,
      a[n.method]
    );
    a && F.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (g) => {
        delete a[g];
      }
    ), n.headers = Ne.concat(s, a);
    const c = [];
    let o = !0;
    this.interceptors.request.forEach(function(h) {
      typeof h.runWhen == "function" && h.runWhen(n) === !1 || (o = o && h.synchronous, c.unshift(h.fulfilled, h.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(h) {
      u.push(h.fulfilled, h.rejected);
    });
    let l, p = 0, f;
    if (!o) {
      const g = [Tf.bind(this), void 0];
      for (g.unshift.apply(g, c), g.push.apply(g, u), f = g.length, l = Promise.resolve(n); p < f; )
        l = l.then(g[p++], g[p++]);
      return l;
    }
    f = c.length;
    let m = n;
    for (p = 0; p < f; ) {
      const g = c[p++], h = c[p++];
      try {
        m = g(m);
      } catch (b) {
        h.call(this, b);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        break;
      }
    }
    try {
<<<<<<< HEAD
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils$h.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url2, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils$h.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
=======
      l = Tf.call(this, m);
    } catch (g) {
      return Promise.reject(g);
    }
    for (p = 0, f = u.length; p < f; )
      l = l.then(u[p++], u[p++]);
    return l;
  }
  getUri(t) {
    t = Wn(this.defaults, t);
    const n = cu(t.baseURL, t.url, t.allowAbsoluteUrls);
    return au(n, t.params, t.paramsSerializer);
  }
};
F.forEach(["delete", "get", "head", "options"], function(t) {
  Bn.prototype[t] = function(n, r) {
    return this.request(Wn(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
F.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(a, s, c) {
      return this.request(Wn(c || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: s
      }));
    };
  }
  Bn.prototype[t] = n(), Bn.prototype[t + "Form"] = n(!0);
});
let E4 = class S0 {
  constructor(t) {
    if (typeof t != "function")
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
<<<<<<< HEAD
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError$1(message, config, request);
      resolvePromise(token.reason);
=======
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let a;
      const s = new Promise((c) => {
        r.subscribe(c), a = c;
      }).then(i);
      return s.cancel = function() {
        r.unsubscribe(a);
      }, s;
    }, t(function(a, s, c) {
      r.reason || (r.reason = new ln(a, s, c), n(r.reason));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort2 = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort2);
    controller.signal.unsubscribe = () => this.unsubscribe(abort2);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
<<<<<<< HEAD
      token,
      cancel
    };
  }
};
function spread$1(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$h.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode$1 = {
=======
      token: new S0(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
};
function _4(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function S4(e) {
  return F.isObject(e) && e.isAxiosError === !0;
}
const Tl = {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
<<<<<<< HEAD
Object.entries(HttpStatusCode$1).forEach(([key2, value]) => {
  HttpStatusCode$1[value] = key2;
});
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind$2(Axios$1.prototype.request, context);
  utils$h.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$h.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$h.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios: Axios2,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken: CancelToken2,
  VERSION,
  all: all2,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u2 = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t3 % 100;
      return "[" + t3 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m = function(t3, e2, n2) {
      var r2 = String(t3);
      return !r2 || r2.length >= e2 ? t3 : "" + Array(e2 + 1 - r2.length).join(n2) + t3;
    }, v = { s: m, z: function(t3) {
      var e2 = -t3.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t3(e2, n2) {
      if (e2.date() < n2.date()) return -t3(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u3 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c, y: h, w: o, d: a, D: d, h: u2, m: s, s: i, ms: r, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g = "en", D = {};
    D[g] = M;
    var p = "$isDayjsObject", S = function(t3) {
      return t3 instanceof _ || !(!t3 || !t3[p]);
    }, w = function t3(e2, n2, r2) {
      var i2;
      if (!e2) return g;
      if ("string" == typeof e2) {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u3 = e2.split("-");
        if (!i2 && u3.length > 1) return t3(u3[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, O = function(t3, e2) {
      if (S(t3)) return t3.clone();
      var n2 = "object" == typeof e2 ? e2 : {};
      return n2.date = t3, n2.args = arguments, new _(n2);
    }, b = v;
    b.l = w, b.i = S, b.w = function(t3, e2) {
      return O(t3, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t3) {
        this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = true;
      }
      var m2 = M2.prototype;
      return m2.parse = function(t3) {
        this.$d = function(t4) {
          var e2 = t4.date, n2 = t4.utc;
          if (null === e2) return /* @__PURE__ */ new Date(NaN);
          if (b.u(e2)) return /* @__PURE__ */ new Date();
          if (e2 instanceof Date) return new Date(e2);
          if ("string" == typeof e2 && !/Z$/i.test(e2)) {
            var r2 = e2.match($);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t3), this.init();
      }, m2.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m2.$utils = function() {
        return b;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t3, e2) {
        var n2 = O(t3);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t3, e2) {
        return O(t3) < this.startOf(e2);
      }, m2.isBefore = function(t3, e2) {
        return this.endOf(e2) < O(t3);
      }, m2.$g = function(t3, e2, n2) {
        return b.u(t3) ? this[e2] : this.set(n2, t3);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t3, e2) {
        var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t3), l2 = function(t4, e3) {
          var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t4) : new Date(n2.$y, e3, t4), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $2 = function(t4, e3) {
          return b.w(n2.toDate()[t4].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return $2(v2 + "Hours", 0);
          case u2:
            return $2(v2 + "Minutes", 1);
          case s:
            return $2(v2 + "Seconds", 2);
          case i:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m2.$set = function(t3, e2) {
        var n2, o2 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u2] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === c || o2 === h) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else l2 && this.$d[l2]($2);
        return this.init(), this;
      }, m2.set = function(t3, e2) {
        return this.clone().$set(t3, e2);
      }, m2.get = function(t3) {
        return this[b.p(t3)]();
      }, m2.add = function(r2, f2) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $2 = b.p(f2), y2 = function(t3) {
          var e2 = O(l2);
          return b.w(e2.date(e2.date() + Math.round(t3 * r2)), l2);
        };
        if ($2 === c) return this.set(c, this.$M + r2);
        if ($2 === h) return this.set(h, this.$y + r2);
        if ($2 === a) return y2(1);
        if ($2 === o) return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u2] = n, d2[i] = t2, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return b.w(m3, this);
      }, m2.subtract = function(t3, e2) {
        return this.add(-1 * t3, e2);
      }, m2.format = function(t3) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid()) return n2.invalidDate || l;
        var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u3 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t4, n3, i3, s3) {
          return t4 && (t4[n3] || t4(e2, r2)) || i3[n3].slice(0, s3);
        }, d2 = function(t4) {
          return b.s(s2 % 12 || 12, t4, "0");
        }, $2 = f2 || function(t4, e3, n3) {
          var r3 = t4 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y, function(t4, r3) {
          return r3 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e2.$y).slice(-2);
              case "YYYY":
                return b.s(e2.$y, 4, "0");
=======
Object.entries(Tl).forEach(([e, t]) => {
  Tl[t] = e;
});
function A0(e) {
  const t = new Bn(e), n = $m(Bn.prototype.request, t);
  return F.extend(n, Bn.prototype, t, { allOwnKeys: !0 }), F.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return A0(Wn(e, i));
  }, n;
}
const Ee = A0(Bi);
Ee.Axios = Bn;
Ee.CanceledError = ln;
Ee.CancelToken = E4;
Ee.isCancel = l0;
Ee.VERSION = cs;
Ee.toFormData = Us;
Ee.AxiosError = V;
Ee.Cancel = Ee.CanceledError;
Ee.all = function(t) {
  return Promise.all(t);
};
Ee.spread = _4;
Ee.isAxiosError = S4;
Ee.mergeConfig = Wn;
Ee.AxiosHeaders = Ne;
Ee.formToJSON = (e) => c0(F.isHTMLForm(e) ? new FormData(e) : e);
Ee.getAdapter = _0.getAdapter;
Ee.HttpStatusCode = Tl;
Ee.default = Ee;
const {
  Axios: KO,
  AxiosError: JO,
  CanceledError: ZO,
  isCancel: QO,
  CancelToken: eI,
  VERSION: tI,
  all: nI,
  Cancel: rI,
  isAxiosError: iI,
  spread: aI,
  toFormData: sI,
  AxiosHeaders: oI,
  HttpStatusCode: cI,
  formToJSON: lI,
  getAdapter: uI,
  mergeConfig: pI
} = Ee;
var T0 = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(Ae, function() {
    var n = 1e3, r = 6e4, i = 36e5, a = "millisecond", s = "second", c = "minute", o = "hour", u = "day", l = "week", p = "month", f = "quarter", m = "year", g = "date", h = "Invalid Date", b = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, x = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, y = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(k) {
      var O = ["th", "st", "nd", "rd"], P = k % 100;
      return "[" + k + (O[(P - 20) % 10] || O[P] || O[0]) + "]";
    } }, E = function(k, O, P) {
      var w = String(k);
      return !w || w.length >= O ? k : "" + Array(O + 1 - w.length).join(P) + k;
    }, S = { s: E, z: function(k) {
      var O = -k.utcOffset(), P = Math.abs(O), w = Math.floor(P / 60), _ = P % 60;
      return (O <= 0 ? "+" : "-") + E(w, 2, "0") + ":" + E(_, 2, "0");
    }, m: function k(O, P) {
      if (O.date() < P.date()) return -k(P, O);
      var w = 12 * (P.year() - O.year()) + (P.month() - O.month()), _ = O.clone().add(w, p), R = P - _ < 0, L = O.clone().add(w + (R ? -1 : 1), p);
      return +(-(w + (P - _) / (R ? _ - L : L - _)) || 0);
    }, a: function(k) {
      return k < 0 ? Math.ceil(k) || 0 : Math.floor(k);
    }, p: function(k) {
      return { M: p, y: m, w: l, d: u, D: g, h: o, m: c, s, ms: a, Q: f }[k] || String(k || "").toLowerCase().replace(/s$/, "");
    }, u: function(k) {
      return k === void 0;
    } }, D = "en", U = {};
    U[D] = y;
    var z = "$isDayjsObject", ee = function(k) {
      return k instanceof J || !(!k || !k[z]);
    }, C = function k(O, P, w) {
      var _;
      if (!O) return D;
      if (typeof O == "string") {
        var R = O.toLowerCase();
        U[R] && (_ = R), P && (U[R] = P, _ = R);
        var L = O.split("-");
        if (!_ && L.length > 1) return k(L[0]);
      } else {
        var N = O.name;
        U[N] = O, _ = N;
      }
      return !w && _ && (D = _), _ || !w && D;
    }, H = function(k, O) {
      if (ee(k)) return k.clone();
      var P = typeof O == "object" ? O : {};
      return P.date = k, P.args = arguments, new J(P);
    }, M = S;
    M.l = C, M.i = ee, M.w = function(k, O) {
      return H(k, { locale: O.$L, utc: O.$u, x: O.$x, $offset: O.$offset });
    };
    var J = function() {
      function k(P) {
        this.$L = C(P.locale, null, !0), this.parse(P), this.$x = this.$x || P.x || {}, this[z] = !0;
      }
      var O = k.prototype;
      return O.parse = function(P) {
        this.$d = function(w) {
          var _ = w.date, R = w.utc;
          if (_ === null) return /* @__PURE__ */ new Date(NaN);
          if (M.u(_)) return /* @__PURE__ */ new Date();
          if (_ instanceof Date) return new Date(_);
          if (typeof _ == "string" && !/Z$/i.test(_)) {
            var L = _.match(b);
            if (L) {
              var N = L[2] - 1 || 0, j = (L[7] || "0").substring(0, 3);
              return R ? new Date(Date.UTC(L[1], N, L[3] || 1, L[4] || 0, L[5] || 0, L[6] || 0, j)) : new Date(L[1], N, L[3] || 1, L[4] || 0, L[5] || 0, L[6] || 0, j);
            }
          }
          return new Date(_);
        }(P), this.init();
      }, O.init = function() {
        var P = this.$d;
        this.$y = P.getFullYear(), this.$M = P.getMonth(), this.$D = P.getDate(), this.$W = P.getDay(), this.$H = P.getHours(), this.$m = P.getMinutes(), this.$s = P.getSeconds(), this.$ms = P.getMilliseconds();
      }, O.$utils = function() {
        return M;
      }, O.isValid = function() {
        return this.$d.toString() !== h;
      }, O.isSame = function(P, w) {
        var _ = H(P);
        return this.startOf(w) <= _ && _ <= this.endOf(w);
      }, O.isAfter = function(P, w) {
        return H(P) < this.startOf(w);
      }, O.isBefore = function(P, w) {
        return this.endOf(w) < H(P);
      }, O.$g = function(P, w, _) {
        return M.u(P) ? this[w] : this.set(_, P);
      }, O.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, O.valueOf = function() {
        return this.$d.getTime();
      }, O.startOf = function(P, w) {
        var _ = this, R = !!M.u(w) || w, L = M.p(P), N = function($, T) {
          var G = M.w(_.$u ? Date.UTC(_.$y, T, $) : new Date(_.$y, T, $), _);
          return R ? G : G.endOf(u);
        }, j = function($, T) {
          return M.w(_.toDate()[$].apply(_.toDate("s"), (R ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(T)), _);
        }, K = this.$W, Z = this.$M, q = this.$D, le = "set" + (this.$u ? "UTC" : "");
        switch (L) {
          case m:
            return R ? N(1, 0) : N(31, 11);
          case p:
            return R ? N(1, Z) : N(0, Z + 1);
          case l:
            var v = this.$locale().weekStart || 0, d = (K < v ? K + 7 : K) - v;
            return N(R ? q - d : q + (6 - d), Z);
          case u:
          case g:
            return j(le + "Hours", 0);
          case o:
            return j(le + "Minutes", 1);
          case c:
            return j(le + "Seconds", 2);
          case s:
            return j(le + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, O.endOf = function(P) {
        return this.startOf(P, !1);
      }, O.$set = function(P, w) {
        var _, R = M.p(P), L = "set" + (this.$u ? "UTC" : ""), N = (_ = {}, _[u] = L + "Date", _[g] = L + "Date", _[p] = L + "Month", _[m] = L + "FullYear", _[o] = L + "Hours", _[c] = L + "Minutes", _[s] = L + "Seconds", _[a] = L + "Milliseconds", _)[R], j = R === u ? this.$D + (w - this.$W) : w;
        if (R === p || R === m) {
          var K = this.clone().set(g, 1);
          K.$d[N](j), K.init(), this.$d = K.set(g, Math.min(this.$D, K.daysInMonth())).$d;
        } else N && this.$d[N](j);
        return this.init(), this;
      }, O.set = function(P, w) {
        return this.clone().$set(P, w);
      }, O.get = function(P) {
        return this[M.p(P)]();
      }, O.add = function(P, w) {
        var _, R = this;
        P = Number(P);
        var L = M.p(w), N = function(Z) {
          var q = H(R);
          return M.w(q.date(q.date() + Math.round(Z * P)), R);
        };
        if (L === p) return this.set(p, this.$M + P);
        if (L === m) return this.set(m, this.$y + P);
        if (L === u) return N(1);
        if (L === l) return N(7);
        var j = (_ = {}, _[c] = r, _[o] = i, _[s] = n, _)[L] || 1, K = this.$d.getTime() + P * j;
        return M.w(K, this);
      }, O.subtract = function(P, w) {
        return this.add(-1 * P, w);
      }, O.format = function(P) {
        var w = this, _ = this.$locale();
        if (!this.isValid()) return _.invalidDate || h;
        var R = P || "YYYY-MM-DDTHH:mm:ssZ", L = M.z(this), N = this.$H, j = this.$m, K = this.$M, Z = _.weekdays, q = _.months, le = _.meridiem, v = function(T, G, W, X) {
          return T && (T[G] || T(w, R)) || W[G].slice(0, X);
        }, d = function(T) {
          return M.s(N % 12 || 12, T, "0");
        }, $ = le || function(T, G, W) {
          var X = T < 12 ? "AM" : "PM";
          return W ? X.toLowerCase() : X;
        };
        return R.replace(x, function(T, G) {
          return G || function(W) {
            switch (W) {
              case "YY":
                return String(w.$y).slice(-2);
              case "YYYY":
                return M.s(w.$y, 4, "0");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
              case "M":
                return a2 + 1;
              case "MM":
<<<<<<< HEAD
                return b.s(a2 + 1, 2, "0");
              case "MMM":
                return h2(n2.monthsShort, a2, c2, 3);
              case "MMMM":
                return h2(c2, a2);
              case "D":
                return e2.$D;
              case "DD":
                return b.s(e2.$D, 2, "0");
              case "d":
                return String(e2.$W);
              case "dd":
                return h2(n2.weekdaysMin, e2.$W, o2, 2);
              case "ddd":
                return h2(n2.weekdaysShort, e2.$W, o2, 3);
              case "dddd":
                return o2[e2.$W];
              case "H":
                return String(s2);
              case "HH":
                return b.s(s2, 2, "0");
              case "h":
                return d2(1);
              case "hh":
                return d2(2);
              case "a":
                return $2(s2, u3, true);
              case "A":
                return $2(s2, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b.s(u3, 2, "0");
              case "s":
                return String(e2.$s);
              case "ss":
                return b.s(e2.$s, 2, "0");
              case "SSS":
                return b.s(e2.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t4) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
          return b.m(y2, m3);
        };
        switch (M3) {
          case h:
            $2 = D2() / 12;
=======
                return M.s(K + 1, 2, "0");
              case "MMM":
                return v(_.monthsShort, K, q, 3);
              case "MMMM":
                return v(q, K);
              case "D":
                return w.$D;
              case "DD":
                return M.s(w.$D, 2, "0");
              case "d":
                return String(w.$W);
              case "dd":
                return v(_.weekdaysMin, w.$W, Z, 2);
              case "ddd":
                return v(_.weekdaysShort, w.$W, Z, 3);
              case "dddd":
                return Z[w.$W];
              case "H":
                return String(N);
              case "HH":
                return M.s(N, 2, "0");
              case "h":
                return d(1);
              case "hh":
                return d(2);
              case "a":
                return $(N, j, !0);
              case "A":
                return $(N, j, !1);
              case "m":
                return String(j);
              case "mm":
                return M.s(j, 2, "0");
              case "s":
                return String(w.$s);
              case "ss":
                return M.s(w.$s, 2, "0");
              case "SSS":
                return M.s(w.$ms, 3, "0");
              case "Z":
                return L;
            }
            return null;
          }(T) || L.replace(":", "");
        });
      }, O.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, O.diff = function(P, w, _) {
        var R, L = this, N = M.p(w), j = H(P), K = (j.utcOffset() - this.utcOffset()) * r, Z = this - j, q = function() {
          return M.m(L, j);
        };
        switch (N) {
          case m:
            R = q() / 12;
            break;
          case p:
            R = q();
            break;
          case f:
            R = q() / 3;
            break;
          case l:
            R = (Z - K) / 6048e5;
            break;
          case u:
            R = (Z - K) / 864e5;
            break;
          case o:
            R = Z / i;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
            break;
          case c:
            $2 = D2();
            break;
          case f:
            $2 = D2() / 3;
            break;
<<<<<<< HEAD
          case o:
            $2 = (g2 - v2) / 6048e5;
            break;
          case a:
            $2 = (g2 - v2) / 864e5;
            break;
          case u2:
            $2 = g2 / n;
            break;
          case s:
            $2 = g2 / e;
            break;
          case i:
            $2 = g2 / t2;
=======
          case s:
            R = Z / n;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
            break;
          default:
            $2 = g2;
        }
<<<<<<< HEAD
        return l2 ? $2 : b.a($2);
      }, m2.daysInMonth = function() {
        return this.endOf(c).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t3, e2) {
        if (!t3) return this.$L;
        var n2 = this.clone(), r2 = w(t3, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return b.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), k = _.prototype;
    return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u2], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t3) {
      k[t3[1]] = function(e2) {
        return this.$g(e2, t3[0], t3[1]);
      };
    }), O.extend = function(t3, e2) {
      return t3.$i || (t3(e2, _, O), t3.$i = true), O;
    }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
      return O(1e3 * t3);
    }, O.en = D[g], O.Ls = D, O.p = {}, O;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var compressing = {};
var zip = {};
var utils$f = {};
var path$r = require$$1$4;
var fs$u = fs$w;
var _0777 = parseInt("0777", 8);
var mkdirp$2 = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
function mkdirP(p, opts, f, made) {
  if (typeof opts === "function") {
    f = opts;
    opts = {};
  } else if (!opts || typeof opts !== "object") {
    opts = { mode: opts };
  }
  var mode = opts.mode;
  var xfs = opts.fs || fs$u;
  if (mode === void 0) {
    mode = _0777;
  }
  if (!made) made = null;
  var cb = f || /* istanbul ignore next */
  function() {
  };
  p = path$r.resolve(p);
  xfs.mkdir(p, mode, function(er) {
    if (!er) {
      made = made || p;
      return cb(null, made);
    }
    switch (er.code) {
      case "ENOENT":
        if (path$r.dirname(p) === p) return cb(er);
        mkdirP(path$r.dirname(p), opts, function(er2, made2) {
          if (er2) cb(er2, made2);
          else mkdirP(p, opts, cb, made2);
        });
        break;
      default:
        xfs.stat(p, function(er2, stat2) {
          if (er2 || !stat2.isDirectory()) cb(er, made);
          else cb(null, made);
=======
        return _ ? R : M.a(R);
      }, O.daysInMonth = function() {
        return this.endOf(p).$D;
      }, O.$locale = function() {
        return U[this.$L];
      }, O.locale = function(P, w) {
        if (!P) return this.$L;
        var _ = this.clone(), R = C(P, w, !0);
        return R && (_.$L = R), _;
      }, O.clone = function() {
        return M.w(this.$d, this);
      }, O.toDate = function() {
        return new Date(this.valueOf());
      }, O.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, O.toISOString = function() {
        return this.$d.toISOString();
      }, O.toString = function() {
        return this.$d.toUTCString();
      }, k;
    }(), re = J.prototype;
    return H.prototype = re, [["$ms", a], ["$s", s], ["$m", c], ["$H", o], ["$W", u], ["$M", p], ["$y", m], ["$D", g]].forEach(function(k) {
      re[k[1]] = function(O) {
        return this.$g(O, k[0], k[1]);
      };
    }), H.extend = function(k, O) {
      return k.$i || (k(O, J, H), k.$i = !0), H;
    }, H.locale = C, H.isDayjs = ee, H.unix = function(k) {
      return H(1e3 * k);
    }, H.en = U[D], H.Ls = U, H.p = {}, H;
  });
})(T0);
var A4 = T0.exports;
const Rf = /* @__PURE__ */ eu(A4);
var qi = {}, gn = {}, me = {}, li = ne, C0 = se, R0 = parseInt("0777", 8), T4 = Sr.mkdirp = Sr.mkdirP = Sr;
function Sr(e, t, n, r) {
  typeof t == "function" ? (n = t, t = {}) : (!t || typeof t != "object") && (t = { mode: t });
  var i = t.mode, a = t.fs || C0;
  i === void 0 && (i = R0), r || (r = null);
  var s = n || /* istanbul ignore next */
  function() {
  };
  e = li.resolve(e), a.mkdir(e, i, function(c) {
    if (!c)
      return r = r || e, s(null, r);
    switch (c.code) {
      case "ENOENT":
        if (li.dirname(e) === e) return s(c);
        Sr(li.dirname(e), t, function(o, u) {
          o ? s(o, u) : Sr(e, t, s, u);
        });
        break;
      default:
        a.stat(e, function(o, u) {
          o || !u.isDirectory() ? s(c, r) : s(null, r);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        });
        break;
    }
  });
}
<<<<<<< HEAD
mkdirP.sync = function sync(p, opts, made) {
  if (!opts || typeof opts !== "object") {
    opts = { mode: opts };
  }
  var mode = opts.mode;
  var xfs = opts.fs || fs$u;
  if (mode === void 0) {
    mode = _0777;
  }
  if (!made) made = null;
  p = path$r.resolve(p);
=======
Sr.sync = function e(t, n, r) {
  (!n || typeof n != "object") && (n = { mode: n });
  var i = n.mode, a = n.fs || C0;
  i === void 0 && (i = R0), r || (r = null), t = li.resolve(t);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  try {
    xfs.mkdirSync(p, mode);
    made = made || p;
  } catch (err0) {
    switch (err0.code) {
      case "ENOENT":
<<<<<<< HEAD
        made = sync(path$r.dirname(p), opts, made);
        sync(p, opts, made);
        break;
      default:
        var stat2;
        try {
          stat2 = xfs.statSync(p);
        } catch (err1) {
          throw err0;
        }
        if (!stat2.isDirectory()) throw err0;
=======
        r = e(li.dirname(t), n, r), e(t, n, r);
        break;
      default:
        var s;
        try {
          s = a.statSync(t);
        } catch {
          throw c;
        }
        if (!s.isDirectory()) throw c;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        break;
    }
  }
  return made;
};
<<<<<<< HEAD
var once$3 = { exports: {} };
var wrappy_1 = wrappy$1;
function wrappy$1(fn, cb) {
  if (fn && cb) return wrappy$1(fn)(cb);
  if (typeof fn !== "function")
    throw new TypeError("need wrapper function");
  Object.keys(fn).forEach(function(k) {
    wrapper[k] = fn[k];
  });
  return wrapper;
  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb2 = args[args.length - 1];
    if (typeof ret === "function" && ret !== cb2) {
      Object.keys(cb2).forEach(function(k) {
        ret[k] = cb2[k];
      });
    }
    return ret;
  }
}
var wrappy = wrappy_1;
once$3.exports = wrappy(once$2);
once$3.exports.strict = wrappy(onceStrict);
once$2.proto = once$2(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return once$2(this);
=======
var gu = { exports: {} }, C4 = $0;
function $0(e, t) {
  if (e && t) return $0(e)(t);
  if (typeof e != "function")
    throw new TypeError("need wrapper function");
  return Object.keys(e).forEach(function(r) {
    n[r] = e[r];
  }), n;
  function n() {
    for (var r = new Array(arguments.length), i = 0; i < r.length; i++)
      r[i] = arguments[i];
    var a = e.apply(this, r), s = r[r.length - 1];
    return typeof a == "function" && a !== s && Object.keys(s).forEach(function(c) {
      a[c] = s[c];
    }), a;
  }
}
var O0 = C4;
gu.exports = O0(Ja);
gu.exports.strict = O0(I0);
Ja.proto = Ja(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return Ja(this);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    },
    configurable: true
  });
  Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
<<<<<<< HEAD
      return onceStrict(this);
=======
      return I0(this);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    },
    configurable: true
  });
});
<<<<<<< HEAD
function once$2(fn) {
  var f = function() {
    if (f.called) return f.value;
    f.called = true;
    return f.value = fn.apply(this, arguments);
=======
function Ja(e) {
  var t = function() {
    return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  };
  f.called = false;
  return f;
}
<<<<<<< HEAD
function onceStrict(fn) {
  var f = function() {
    if (f.called)
      throw new Error(f.onceError);
    f.called = true;
    return f.value = fn.apply(this, arguments);
  };
  var name = fn.name || "Function wrapped with `once`";
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f;
}
var onceExports = once$3.exports;
var once$1 = onceExports;
var noop$4 = function() {
};
var qnt = commonjsGlobal.Bare ? queueMicrotask : process.nextTick.bind(process);
var isRequest$1 = function(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
};
var isChildProcess = function(stream2) {
  return stream2.stdio && Array.isArray(stream2.stdio) && stream2.stdio.length === 3;
};
var eos$2 = function(stream2, opts, callback) {
  if (typeof opts === "function") return eos$2(stream2, null, opts);
  if (!opts) opts = {};
  callback = once$1(callback || noop$4);
  var ws = stream2._writableState;
  var rs = stream2._readableState;
  var readable2 = opts.readable || opts.readable !== false && stream2.readable;
  var writable = opts.writable || opts.writable !== false && stream2.writable;
  var cancelled = false;
  var onlegacyfinish = function() {
    if (!stream2.writable) onfinish();
  };
  var onfinish = function() {
    writable = false;
    if (!readable2) callback.call(stream2);
  };
  var onend = function() {
    readable2 = false;
    if (!writable) callback.call(stream2);
  };
  var onexit = function(exitCode) {
    callback.call(stream2, exitCode ? new Error("exited with error code: " + exitCode) : null);
  };
  var onerror = function(err) {
    callback.call(stream2, err);
  };
  var onclose = function() {
    qnt(onclosenexttick);
  };
  var onclosenexttick = function() {
    if (cancelled) return;
    if (readable2 && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream2, new Error("premature close"));
    if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream2, new Error("premature close"));
  };
  var onrequest = function() {
    stream2.req.on("finish", onfinish);
  };
  if (isRequest$1(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req) onrequest();
    else stream2.on("request", onrequest);
  } else if (writable && !ws) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  if (isChildProcess(stream2)) stream2.on("exit", onexit);
  stream2.on("end", onend);
  stream2.on("finish", onfinish);
  if (opts.error !== false) stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    cancelled = true;
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req) stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("exit", onexit);
    stream2.removeListener("end", onend);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
};
var endOfStream = eos$2;
var once = onceExports;
var eos$1 = endOfStream;
var fs$t;
try {
  fs$t = require("fs");
} catch (e) {
}
var noop$3 = function() {
};
var ancient = typeof process === "undefined" ? false : /^v?\.0/.test(process.version);
var isFn = function(fn) {
  return typeof fn === "function";
};
var isFS = function(stream2) {
  if (!ancient) return false;
  if (!fs$t) return false;
  return (stream2 instanceof (fs$t.ReadStream || noop$3) || stream2 instanceof (fs$t.WriteStream || noop$3)) && isFn(stream2.close);
};
var isRequest = function(stream2) {
  return stream2.setHeader && isFn(stream2.abort);
};
var destroyer = function(stream2, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream2.on("close", function() {
    closed = true;
  });
  eos$1(stream2, { readable: reading, writable: writing }, function(err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;
    if (isFS(stream2)) return stream2.close(noop$3);
    if (isRequest(stream2)) return stream2.abort();
    if (isFn(stream2.destroy)) return stream2.destroy();
    callback(err || new Error("stream was destroyed"));
  };
};
var call = function(fn) {
  fn();
};
var pipe = function(from, to) {
  return from.pipe(to);
};
var pump$2 = function() {
  var streams2 = Array.prototype.slice.call(arguments);
  var callback = isFn(streams2[streams2.length - 1] || noop$3) && streams2.pop() || noop$3;
  if (Array.isArray(streams2[0])) streams2 = streams2[0];
  if (streams2.length < 2) throw new Error("pump requires two streams per minimum");
  var error2;
  var destroys = streams2.map(function(stream2, i) {
    var reading = i < streams2.length - 1;
    var writing = i > 0;
    return destroyer(stream2, reading, writing, function(err) {
      if (!error2) error2 = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error2);
    });
  });
  return streams2.reduce(pipe);
};
var pump_1 = pump$2;
const fs$s = fs$w;
const path$q = require$$1$4;
const mkdirp$1 = mkdirp$2;
const pump$1 = pump_1;
utils$f.sourceType = (source) => {
  if (!source) return void 0;
  if (source instanceof Buffer) return "buffer";
  if (typeof source._read === "function" || typeof source._transform === "function") return "stream";
  if (typeof source !== "string") {
    const err = new Error("Type is not supported, must be a file path, file buffer, or a readable stream");
    err.name = "IlligalSourceError";
    throw err;
  }
  return "file";
};
function destType(dest) {
  if (typeof dest._write === "function" || typeof dest._transform === "function") return "stream";
  if (typeof dest !== "string") {
    const err = new Error("Type is not supported, must be a file path, or a writable stream");
    err.name = "IlligalDestinationError";
    throw err;
  }
  return "path";
}
utils$f.destType = destType;
const illigalEntryError = new Error("Type is not supported, must be a file path, directory path, file buffer, or a readable stream");
illigalEntryError.name = "IlligalEntryError";
utils$f.entryType = (entry) => {
  if (!entry) return;
  if (entry instanceof Buffer) return "buffer";
  if (typeof entry._read === "function" || typeof entry._transform === "function") return "stream";
  if (typeof entry !== "string") throw illigalEntryError;
  return "fileOrDir";
};
utils$f.clone = (obj) => {
  const newObj = {};
  for (const i in obj) {
    newObj[i] = obj[i];
=======
function I0(e) {
  var t = function() {
    if (t.called)
      throw new Error(t.onceError);
    return t.called = !0, t.value = e.apply(this, arguments);
  }, n = e.name || "Function wrapped with `once`";
  return t.onceError = n + " shouldn't be called more than once", t.called = !1, t;
}
var D0 = gu.exports, R4 = D0, $4 = function() {
}, O4 = Ae.Bare ? queueMicrotask : process.nextTick.bind(process), I4 = function(e) {
  return e.setHeader && typeof e.abort == "function";
}, D4 = function(e) {
  return e.stdio && Array.isArray(e.stdio) && e.stdio.length === 3;
}, F0 = function(e, t, n) {
  if (typeof t == "function") return F0(e, null, t);
  t || (t = {}), n = R4(n || $4);
  var r = e._writableState, i = e._readableState, a = t.readable || t.readable !== !1 && e.readable, s = t.writable || t.writable !== !1 && e.writable, c = !1, o = function() {
    e.writable || u();
  }, u = function() {
    s = !1, a || n.call(e);
  }, l = function() {
    a = !1, s || n.call(e);
  }, p = function(b) {
    n.call(e, b ? new Error("exited with error code: " + b) : null);
  }, f = function(b) {
    n.call(e, b);
  }, m = function() {
    O4(g);
  }, g = function() {
    if (!c) {
      if (a && !(i && i.ended && !i.destroyed)) return n.call(e, new Error("premature close"));
      if (s && !(r && r.ended && !r.destroyed)) return n.call(e, new Error("premature close"));
    }
  }, h = function() {
    e.req.on("finish", u);
  };
  return I4(e) ? (e.on("complete", u), e.on("abort", m), e.req ? h() : e.on("request", h)) : s && !r && (e.on("end", o), e.on("close", o)), D4(e) && e.on("exit", p), e.on("end", l), e.on("finish", u), t.error !== !1 && e.on("error", f), e.on("close", m), function() {
    c = !0, e.removeListener("complete", u), e.removeListener("abort", m), e.removeListener("request", h), e.req && e.req.removeListener("finish", u), e.removeListener("end", o), e.removeListener("close", o), e.removeListener("finish", u), e.removeListener("exit", p), e.removeListener("end", l), e.removeListener("error", f), e.removeListener("close", m);
  };
}, P0 = F0, F4 = D0, P4 = P0, Za;
try {
  Za = require("fs");
} catch {
}
var xi = function() {
}, k4 = typeof process > "u" ? !1 : /^v?\.0/.test(process.version), Ms = function(e) {
  return typeof e == "function";
}, L4 = function(e) {
  return !k4 || !Za ? !1 : (e instanceof (Za.ReadStream || xi) || e instanceof (Za.WriteStream || xi)) && Ms(e.close);
}, N4 = function(e) {
  return e.setHeader && Ms(e.abort);
}, U4 = function(e, t, n, r) {
  r = F4(r);
  var i = !1;
  e.on("close", function() {
    i = !0;
  }), P4(e, { readable: t, writable: n }, function(s) {
    if (s) return r(s);
    i = !0, r();
  });
  var a = !1;
  return function(s) {
    if (!i && !a) {
      if (a = !0, L4(e)) return e.close(xi);
      if (N4(e)) return e.abort();
      if (Ms(e.destroy)) return e.destroy();
      r(s || new Error("stream was destroyed"));
    }
  };
}, $f = function(e) {
  e();
}, B4 = function(e, t) {
  return e.pipe(t);
}, j4 = function() {
  var e = Array.prototype.slice.call(arguments), t = Ms(e[e.length - 1] || xi) && e.pop() || xi;
  if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new Error("pump requires two streams per minimum");
  var n, r = e.map(function(i, a) {
    var s = a < e.length - 1, c = a > 0;
    return U4(i, s, c, function(o) {
      n || (n = o), o && r.forEach($f), !s && (r.forEach($f), t(n));
    });
  });
  return e.reduce(B4);
}, k0 = j4;
const fs = se, fr = ne, ba = T4, L0 = k0;
me.sourceType = (e) => {
  if (e) {
    if (e instanceof Buffer) return "buffer";
    if (typeof e._read == "function" || typeof e._transform == "function") return "stream";
    if (typeof e != "string") {
      const t = new Error("Type is not supported, must be a file path, file buffer, or a readable stream");
      throw t.name = "IlligalSourceError", t;
    }
    return "file";
  }
};
function qs(e) {
  if (typeof e._write == "function" || typeof e._transform == "function") return "stream";
  if (typeof e != "string") {
    const t = new Error("Type is not supported, must be a file path, or a writable stream");
    throw t.name = "IlligalDestinationError", t;
  }
  return "path";
}
me.destType = qs;
const N0 = new Error("Type is not supported, must be a file path, directory path, file buffer, or a readable stream");
N0.name = "IlligalEntryError";
me.entryType = (e) => {
  if (e) {
    if (e instanceof Buffer) return "buffer";
    if (typeof e._read == "function" || typeof e._transform == "function") return "stream";
    if (typeof e != "string") throw N0;
    return "fileOrDir";
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  return newObj;
};
utils$f.makeFileProcessFn = (StreamClass) => {
  return (source, dest, opts) => {
    opts = opts || {};
    opts.source = source;
    const destStream = destType(dest) === "path" ? fs$s.createWriteStream(dest) : dest;
    const compressStream = new StreamClass(opts);
    return safePipe([compressStream, destStream]);
  };
};
<<<<<<< HEAD
utils$f.makeCompressDirFn = (StreamClass) => {
  return (dir, dest, opts) => {
    const destStream = destType(dest) === "path" ? fs$s.createWriteStream(dest) : dest;
    const compressStream = new StreamClass();
    compressStream.addEntry(dir, opts);
    return safePipe([compressStream, destStream]);
  };
};
utils$f.makeUncompressFn = (StreamClass) => {
  return (source, destDir, opts) => {
    opts = opts || {};
    opts.source = source;
    if (!source) {
      const error2 = new Error("Type is not supported, must be a file path, file buffer, or a readable stream");
      error2.name = "IlligalSourceError";
      throw error2;
    }
    if (destType(destDir) !== "path") {
      const error2 = new Error("uncompress destination must be a directory");
      error2.name = "IlligalDestError";
      throw error2;
    }
    return new Promise((resolve, reject) => {
      mkdirp$1(destDir, (err) => {
        if (err) return reject(err);
        let entryCount = 0;
        let successCount = 0;
        let isFinish = false;
        function done() {
          if (isFinish && entryCount === successCount) resolve();
        }
        new StreamClass(opts).on("finish", () => {
          isFinish = true;
          done();
        }).on("error", reject).on("entry", (header, stream2, next) => {
          stream2.on("end", next);
          const destFilePath = path$q.join(destDir, header.name);
          if (header.type === "file") {
            const dir = path$q.dirname(destFilePath);
            mkdirp$1(dir, (err2) => {
              if (err2) return reject(err2);
              entryCount++;
              pump$1(stream2, fs$s.createWriteStream(destFilePath, { mode: opts.mode || header.mode }), (err3) => {
                if (err3) return reject(err3);
                successCount++;
                done();
              });
            });
          } else if (header.type === "symlink") {
            const dir = path$q.dirname(destFilePath);
            const target = path$q.resolve(dir, header.linkname);
            entryCount++;
            mkdirp$1(dir, (err2) => {
              if (err2) return reject(err2);
              const relativeTarget = path$q.relative(dir, target);
              fs$s.symlink(relativeTarget, destFilePath, (err3) => {
                if (err3) return reject(err3);
                successCount++;
                stream2.resume();
              });
            });
          } else {
            mkdirp$1(destFilePath, (err2) => {
              if (err2) return reject(err2);
              stream2.resume();
            });
          }
        });
=======
me.makeFileProcessFn = (e) => (t, n, r) => {
  r = r || {}, r.source = t;
  const i = qs(n) === "path" ? fs.createWriteStream(n) : n, a = new e(r);
  return bu([a, i]);
};
me.makeCompressDirFn = (e) => (t, n, r) => {
  const i = qs(n) === "path" ? fs.createWriteStream(n) : n, a = new e();
  return a.addEntry(t, r), bu([a, i]);
};
me.makeUncompressFn = (e) => (t, n, r) => {
  if (r = r || {}, r.source = t, !t) {
    const i = new Error("Type is not supported, must be a file path, file buffer, or a readable stream");
    throw i.name = "IlligalSourceError", i;
  }
  if (qs(n) !== "path") {
    const i = new Error("uncompress destination must be a directory");
    throw i.name = "IlligalDestError", i;
  }
  return new Promise((i, a) => {
    ba(n, (s) => {
      if (s) return a(s);
      let c = 0, o = 0, u = !1;
      function l() {
        u && c === o && i();
      }
      new e(r).on("finish", () => {
        u = !0, l();
      }).on("error", a).on("entry", (p, f, m) => {
        f.on("end", m);
        const g = fr.join(n, p.name);
        if (p.type === "file") {
          const h = fr.dirname(g);
          ba(h, (b) => {
            if (b) return a(b);
            c++, L0(f, fs.createWriteStream(g, { mode: r.mode || p.mode }), (x) => {
              if (x) return a(x);
              o++, l();
            });
          });
        } else if (p.type === "symlink") {
          const h = fr.dirname(g), b = fr.resolve(h, p.linkname);
          c++, ba(h, (x) => {
            if (x) return a(x);
            const y = fr.relative(h, b);
            fs.symlink(y, g, (E) => {
              if (E) return a(E);
              o++, f.resume();
            });
          });
        } else
          ba(g, (h) => {
            if (h) return a(h);
            f.resume();
          });
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      });
    });
  };
};
utils$f.streamToBuffer = (stream2) => {
  return new Promise((resolve, reject) => {
    const chunks = [];
    stream2.on("readable", () => {
      let chunk;
      while (chunk = stream2.read()) chunks.push(chunk);
    }).on("end", () => resolve(Buffer.concat(chunks))).on("error", (err) => reject(err));
  });
};
<<<<<<< HEAD
function safePipe(streams2) {
  return new Promise((resolve, reject) => {
    pump$1(streams2[0], streams2[1], (err) => {
      if (err) return reject(err);
      resolve();
    });
  });
}
utils$f.safePipe = safePipe;
function normalizePath(fileName) {
  fileName = path$q.normalize(fileName);
  if (process.platform === "win32") fileName = fileName.replace(/\\+/g, "/");
  return fileName;
}
function stripFileName(strip, fileName, type2) {
  if (Buffer.isBuffer(fileName)) fileName = fileName.toString();
  if (fileName.indexOf("\\") !== -1) fileName = fileName.replace(/\\+/g, "/");
  if (fileName[0] === "/") fileName = fileName.replace(/^\/+/, "");
  if (fileName) {
    fileName = normalizePath(fileName);
  }
  let s = fileName.split("/");
  if (s.indexOf("..") !== -1) {
    fileName = fileName.replace(/(\.\.\/)+/, "");
    if (type2 === "directory" && fileName && fileName[fileName.length - 1] !== "/") {
      fileName += "/";
    }
    s = fileName.split("/");
  }
  strip = Math.min(strip, s.length - 1);
  return s.slice(strip).join("/") || "/";
}
utils$f.stripFileName = stripFileName;
var yazl$2 = {};
var Buffer$4 = require$$0$5.Buffer;
var CRC_TABLE = [
=======
me.streamToBuffer = (e) => new Promise((t, n) => {
  const r = [];
  e.on("readable", () => {
    let i;
    for (; i = e.read(); ) r.push(i);
  }).on("end", () => t(Buffer.concat(r))).on("error", (i) => n(i));
});
function bu(e) {
  return new Promise((t, n) => {
    L0(e[0], e[1], (r) => {
      if (r) return n(r);
      t();
    });
  });
}
me.safePipe = bu;
function M4(e) {
  return e = fr.normalize(e), process.platform === "win32" && (e = e.replace(/\\+/g, "/")), e;
}
function q4(e, t, n) {
  Buffer.isBuffer(t) && (t = t.toString()), t.indexOf("\\") !== -1 && (t = t.replace(/\\+/g, "/")), t[0] === "/" && (t = t.replace(/^\/+/, "")), t && (t = M4(t));
  let r = t.split("/");
  return r.indexOf("..") !== -1 && (t = t.replace(/(\.\.\/)+/, ""), n === "directory" && t && t[t.length - 1] !== "/" && (t += "/"), r = t.split("/")), e = Math.min(e, r.length - 1), r.slice(e).join("/") || "/";
}
me.stripFileName = q4;
var zs = {}, Qt = Bt.Buffer, Cl = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
<<<<<<< HEAD
if (typeof Int32Array !== "undefined") {
  CRC_TABLE = new Int32Array(CRC_TABLE);
}
function ensureBuffer(input) {
  if (Buffer$4.isBuffer(input)) {
    return input;
  }
  var hasNewBufferAPI = typeof Buffer$4.alloc === "function" && typeof Buffer$4.from === "function";
  if (typeof input === "number") {
    return hasNewBufferAPI ? Buffer$4.alloc(input) : new Buffer$4(input);
  } else if (typeof input === "string") {
    return hasNewBufferAPI ? Buffer$4.from(input) : new Buffer$4(input);
  } else {
    throw new Error("input must be buffer, number, or string, received " + typeof input);
  }
}
function bufferizeInt(num) {
  var tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}
function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if (Buffer$4.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  var crc = ~~previous ^ -1;
  for (var n = 0; n < buf.length; n++) {
    crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
  }
  return crc ^ -1;
}
function crc32$2() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
crc32$2.signed = function() {
  return _crc32.apply(null, arguments);
};
crc32$2.unsigned = function() {
  return _crc32.apply(null, arguments) >>> 0;
};
var bufferCrc32 = crc32$2;
var fs$r = fs$w;
var Transform$1 = require$$1$2.Transform;
var PassThrough$3 = require$$1$2.PassThrough;
var zlib$3 = zlib$4;
var util$a = require$$1$3;
var EventEmitter$3 = require$$0$6.EventEmitter;
var crc32$1 = bufferCrc32;
yazl$2.ZipFile = ZipFile$1;
yazl$2.dateToDosDateTime = dateToDosDateTime;
util$a.inherits(ZipFile$1, EventEmitter$3);
function ZipFile$1() {
  this.outputStream = new PassThrough$3();
  this.entries = [];
  this.outputStreamCursor = 0;
  this.ended = false;
  this.allDone = false;
  this.forceZip64Eocd = false;
}
ZipFile$1.prototype.addFile = function(realPath, metadataPath, options) {
  var self2 = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (options == null) options = {};
  var entry = new Entry$1(metadataPath, false, options);
  self2.entries.push(entry);
  fs$r.stat(realPath, function(err, stats) {
    if (err) return self2.emit("error", err);
    if (!stats.isFile()) return self2.emit("error", new Error("not a file: " + realPath));
    entry.uncompressedSize = stats.size;
    if (options.mtime == null) entry.setLastModDate(stats.mtime);
    if (options.mode == null) entry.setFileAttributesMode(stats.mode);
    entry.setFileDataPumpFunction(function() {
      var readStream2 = fs$r.createReadStream(realPath);
      entry.state = Entry$1.FILE_DATA_IN_PROGRESS;
      readStream2.on("error", function(err2) {
        self2.emit("error", err2);
      });
      pumpFileDataReadStream(self2, entry, readStream2);
    });
    pumpEntries(self2);
  });
};
ZipFile$1.prototype.addReadStream = function(readStream2, metadataPath, options) {
  var self2 = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (options == null) options = {};
  var entry = new Entry$1(metadataPath, false, options);
  self2.entries.push(entry);
  entry.setFileDataPumpFunction(function() {
    entry.state = Entry$1.FILE_DATA_IN_PROGRESS;
    pumpFileDataReadStream(self2, entry, readStream2);
  });
  pumpEntries(self2);
};
ZipFile$1.prototype.addBuffer = function(buffer2, metadataPath, options) {
  var self2 = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (buffer2.length > 1073741823) throw new Error("buffer too large: " + buffer2.length + " > 1073741823");
  if (options == null) options = {};
  if (options.size != null) throw new Error("options.size not allowed");
  var entry = new Entry$1(metadataPath, false, options);
  entry.uncompressedSize = buffer2.length;
  entry.crc32 = crc32$1.unsigned(buffer2);
  entry.crcAndFileSizeKnown = true;
  self2.entries.push(entry);
  if (!entry.compress) {
    setCompressedBuffer(buffer2);
  } else {
    zlib$3.deflateRaw(buffer2, function(err, compressedBuffer) {
      setCompressedBuffer(compressedBuffer);
    });
  }
  function setCompressedBuffer(compressedBuffer) {
    entry.compressedSize = compressedBuffer.length;
    entry.setFileDataPumpFunction(function() {
      writeToOutputStream(self2, compressedBuffer);
      writeToOutputStream(self2, entry.getDataDescriptor());
      entry.state = Entry$1.FILE_DATA_DONE;
      setImmediate(function() {
        pumpEntries(self2);
      });
    });
    pumpEntries(self2);
  }
};
ZipFile$1.prototype.addEmptyDirectory = function(metadataPath, options) {
  var self2 = this;
  metadataPath = validateMetadataPath(metadataPath, true);
  if (options == null) options = {};
  if (options.size != null) throw new Error("options.size not allowed");
  if (options.compress != null) throw new Error("options.compress not allowed");
  var entry = new Entry$1(metadataPath, true, options);
  self2.entries.push(entry);
  entry.setFileDataPumpFunction(function() {
    writeToOutputStream(self2, entry.getDataDescriptor());
    entry.state = Entry$1.FILE_DATA_DONE;
    pumpEntries(self2);
  });
  pumpEntries(self2);
};
var eocdrSignatureBuffer = bufferFrom([80, 75, 5, 6]);
ZipFile$1.prototype.end = function(options, finalSizeCallback) {
  if (typeof options === "function") {
    finalSizeCallback = options;
    options = null;
=======
typeof Int32Array < "u" && (Cl = new Int32Array(Cl));
function U0(e) {
  if (Qt.isBuffer(e))
    return e;
  var t = typeof Qt.alloc == "function" && typeof Qt.from == "function";
  if (typeof e == "number")
    return t ? Qt.alloc(e) : new Qt(e);
  if (typeof e == "string")
    return t ? Qt.from(e) : new Qt(e);
  throw new Error("input must be buffer, number, or string, received " + typeof e);
}
function z4(e) {
  var t = U0(4);
  return t.writeInt32BE(e, 0), t;
}
function xu(e, t) {
  e = U0(e), Qt.isBuffer(t) && (t = t.readUInt32BE(0));
  for (var n = ~~t ^ -1, r = 0; r < e.length; r++)
    n = Cl[(n ^ e[r]) & 255] ^ n >>> 8;
  return n ^ -1;
}
function yu() {
  return z4(xu.apply(null, arguments));
}
yu.signed = function() {
  return xu.apply(null, arguments);
};
yu.unsigned = function() {
  return xu.apply(null, arguments) >>> 0;
};
var B0 = yu, Of = se, Hs = ae.Transform, j0 = ae.PassThrough, M0 = et, wu = De, H4 = Yn.EventEmitter, q0 = B0;
zs.ZipFile = Xn;
zs.dateToDosDateTime = t1;
wu.inherits(Xn, H4);
function Xn() {
  this.outputStream = new j0(), this.entries = [], this.outputStreamCursor = 0, this.ended = !1, this.allDone = !1, this.forceZip64Eocd = !1;
}
Xn.prototype.addFile = function(e, t, n) {
  var r = this;
  t = Ws(t, !1), n == null && (n = {});
  var i = new pe(t, !1, n);
  r.entries.push(i), Of.stat(e, function(a, s) {
    if (a) return r.emit("error", a);
    if (!s.isFile()) return r.emit("error", new Error("not a file: " + e));
    i.uncompressedSize = s.size, n.mtime == null && i.setLastModDate(s.mtime), n.mode == null && i.setFileAttributesMode(s.mode), i.setFileDataPumpFunction(function() {
      var c = Of.createReadStream(e);
      i.state = pe.FILE_DATA_IN_PROGRESS, c.on("error", function(o) {
        r.emit("error", o);
      }), z0(r, i, c);
    }), un(r);
  });
};
Xn.prototype.addReadStream = function(e, t, n) {
  var r = this;
  t = Ws(t, !1), n == null && (n = {});
  var i = new pe(t, !1, n);
  r.entries.push(i), i.setFileDataPumpFunction(function() {
    i.state = pe.FILE_DATA_IN_PROGRESS, z0(r, i, e);
  }), un(r);
};
Xn.prototype.addBuffer = function(e, t, n) {
  var r = this;
  if (t = Ws(t, !1), e.length > 1073741823) throw new Error("buffer too large: " + e.length + " > 1073741823");
  if (n == null && (n = {}), n.size != null) throw new Error("options.size not allowed");
  var i = new pe(t, !1, n);
  i.uncompressedSize = e.length, i.crc32 = q0.unsigned(e), i.crcAndFileSizeKnown = !0, r.entries.push(i), i.compress ? M0.deflateRaw(e, function(s, c) {
    a(c);
  }) : a(e);
  function a(s) {
    i.compressedSize = s.length, i.setFileDataPumpFunction(function() {
      jn(r, s), jn(r, i.getDataDescriptor()), i.state = pe.FILE_DATA_DONE, setImmediate(function() {
        un(r);
      });
    }), un(r);
  }
};
Xn.prototype.addEmptyDirectory = function(e, t) {
  var n = this;
  if (e = Ws(e, !0), t == null && (t = {}), t.size != null) throw new Error("options.size not allowed");
  if (t.compress != null) throw new Error("options.compress not allowed");
  var r = new pe(e, !0, t);
  n.entries.push(r), r.setFileDataPumpFunction(function() {
    jn(n, r.getDataDescriptor()), r.state = pe.FILE_DATA_DONE, un(n);
  }), un(n);
};
var W4 = nn([80, 75, 5, 6]);
Xn.prototype.end = function(e, t) {
  if (typeof e == "function" && (t = e, e = null), e == null && (e = {}), !this.ended) {
    if (this.ended = !0, this.finalSizeCallback = t, this.forceZip64Eocd = !!e.forceZip64Format, e.comment) {
      if (typeof e.comment == "string" ? this.comment = Y4(e.comment) : this.comment = e.comment, this.comment.length > 65535) throw new Error("comment is too large");
      if (si(this.comment, W4)) throw new Error("comment contains end of central directory record signature");
    } else
      this.comment = Gs;
    un(this);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  if (options == null) options = {};
  if (this.ended) return;
  this.ended = true;
  this.finalSizeCallback = finalSizeCallback;
  this.forceZip64Eocd = !!options.forceZip64Format;
  if (options.comment) {
    if (typeof options.comment === "string") {
      this.comment = encodeCp437(options.comment);
    } else {
      this.comment = options.comment;
    }
    if (this.comment.length > 65535) throw new Error("comment is too large");
    if (bufferIncludes(this.comment, eocdrSignatureBuffer)) throw new Error("comment contains end of central directory record signature");
  } else {
    this.comment = EMPTY_BUFFER;
  }
  pumpEntries(this);
};
<<<<<<< HEAD
function writeToOutputStream(self2, buffer2) {
  self2.outputStream.write(buffer2);
  self2.outputStreamCursor += buffer2.length;
}
function pumpFileDataReadStream(self2, entry, readStream2) {
  var crc32Watcher = new Crc32Watcher();
  var uncompressedSizeCounter = new ByteCounter();
  var compressor = entry.compress ? new zlib$3.DeflateRaw() : new PassThrough$3();
  var compressedSizeCounter = new ByteCounter();
  readStream2.pipe(crc32Watcher).pipe(uncompressedSizeCounter).pipe(compressor).pipe(compressedSizeCounter).pipe(self2.outputStream, { end: false });
  compressedSizeCounter.on("end", function() {
    entry.crc32 = crc32Watcher.crc32;
    if (entry.uncompressedSize == null) {
      entry.uncompressedSize = uncompressedSizeCounter.byteCount;
    } else {
      if (entry.uncompressedSize !== uncompressedSizeCounter.byteCount) return self2.emit("error", new Error("file data stream has unexpected number of bytes"));
    }
    entry.compressedSize = compressedSizeCounter.byteCount;
    self2.outputStreamCursor += entry.compressedSize;
    writeToOutputStream(self2, entry.getDataDescriptor());
    entry.state = Entry$1.FILE_DATA_DONE;
    pumpEntries(self2);
  });
}
function pumpEntries(self2) {
  if (self2.allDone) return;
  if (self2.ended && self2.finalSizeCallback != null) {
    var finalSize = calculateFinalSize(self2);
    if (finalSize != null) {
      self2.finalSizeCallback(finalSize);
      self2.finalSizeCallback = null;
    }
  }
  var entry = getFirstNotDoneEntry();
  function getFirstNotDoneEntry() {
    for (var i = 0; i < self2.entries.length; i++) {
      var entry2 = self2.entries[i];
      if (entry2.state < Entry$1.FILE_DATA_DONE) return entry2;
    }
    return null;
  }
  if (entry != null) {
    if (entry.state < Entry$1.READY_TO_PUMP_FILE_DATA) return;
    if (entry.state === Entry$1.FILE_DATA_IN_PROGRESS) return;
    entry.relativeOffsetOfLocalHeader = self2.outputStreamCursor;
    var localFileHeader = entry.getLocalFileHeader();
    writeToOutputStream(self2, localFileHeader);
    entry.doFileDataPump();
  } else {
    if (self2.ended) {
      self2.offsetOfStartOfCentralDirectory = self2.outputStreamCursor;
      self2.entries.forEach(function(entry2) {
        var centralDirectoryRecord = entry2.getCentralDirectoryRecord();
        writeToOutputStream(self2, centralDirectoryRecord);
      });
      writeToOutputStream(self2, getEndOfCentralDirectoryRecord(self2));
      self2.outputStream.end();
      self2.allDone = true;
    }
  }
}
function calculateFinalSize(self2) {
  var pretendOutputCursor = 0;
  var centralDirectorySize = 0;
  for (var i = 0; i < self2.entries.length; i++) {
    var entry = self2.entries[i];
    if (entry.compress) return -1;
    if (entry.state >= Entry$1.READY_TO_PUMP_FILE_DATA) {
      if (entry.uncompressedSize == null) return -1;
    } else {
      if (entry.uncompressedSize == null) return null;
    }
    entry.relativeOffsetOfLocalHeader = pretendOutputCursor;
    var useZip64Format = entry.useZip64Format();
    pretendOutputCursor += LOCAL_FILE_HEADER_FIXED_SIZE + entry.utf8FileName.length;
    pretendOutputCursor += entry.uncompressedSize;
    if (!entry.crcAndFileSizeKnown) {
      if (useZip64Format) {
        pretendOutputCursor += ZIP64_DATA_DESCRIPTOR_SIZE;
      } else {
        pretendOutputCursor += DATA_DESCRIPTOR_SIZE;
      }
    }
    centralDirectorySize += CENTRAL_DIRECTORY_RECORD_FIXED_SIZE + entry.utf8FileName.length + entry.fileComment.length;
    if (useZip64Format) {
      centralDirectorySize += ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE;
    }
  }
  var endOfCentralDirectorySize = 0;
  if (self2.forceZip64Eocd || self2.entries.length >= 65535 || centralDirectorySize >= 65535 || pretendOutputCursor >= 4294967295) {
    endOfCentralDirectorySize += ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE;
  }
  endOfCentralDirectorySize += END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length;
  return pretendOutputCursor + centralDirectorySize + endOfCentralDirectorySize;
}
var ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 56;
var ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE = 20;
var END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 22;
function getEndOfCentralDirectoryRecord(self2, actuallyJustTellMeHowLongItWouldBe) {
  var needZip64Format = false;
  var normalEntriesLength = self2.entries.length;
  if (self2.forceZip64Eocd || self2.entries.length >= 65535) {
    normalEntriesLength = 65535;
    needZip64Format = true;
  }
  var sizeOfCentralDirectory = self2.outputStreamCursor - self2.offsetOfStartOfCentralDirectory;
  var normalSizeOfCentralDirectory = sizeOfCentralDirectory;
  if (self2.forceZip64Eocd || sizeOfCentralDirectory >= 4294967295) {
    normalSizeOfCentralDirectory = 4294967295;
    needZip64Format = true;
  }
  var normalOffsetOfStartOfCentralDirectory = self2.offsetOfStartOfCentralDirectory;
  if (self2.forceZip64Eocd || self2.offsetOfStartOfCentralDirectory >= 4294967295) {
    normalOffsetOfStartOfCentralDirectory = 4294967295;
    needZip64Format = true;
  }
  var eocdrBuffer = bufferAlloc$1(END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length);
  eocdrBuffer.writeUInt32LE(101010256, 0);
  eocdrBuffer.writeUInt16LE(0, 4);
  eocdrBuffer.writeUInt16LE(0, 6);
  eocdrBuffer.writeUInt16LE(normalEntriesLength, 8);
  eocdrBuffer.writeUInt16LE(normalEntriesLength, 10);
  eocdrBuffer.writeUInt32LE(normalSizeOfCentralDirectory, 12);
  eocdrBuffer.writeUInt32LE(normalOffsetOfStartOfCentralDirectory, 16);
  eocdrBuffer.writeUInt16LE(self2.comment.length, 20);
  self2.comment.copy(eocdrBuffer, 22);
  if (!needZip64Format) return eocdrBuffer;
  var zip64EocdrBuffer = bufferAlloc$1(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE);
  zip64EocdrBuffer.writeUInt32LE(101075792, 0);
  writeUInt64LE(zip64EocdrBuffer, ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE - 12, 4);
  zip64EocdrBuffer.writeUInt16LE(VERSION_MADE_BY, 12);
  zip64EocdrBuffer.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_ZIP64, 14);
  zip64EocdrBuffer.writeUInt32LE(0, 16);
  zip64EocdrBuffer.writeUInt32LE(0, 20);
  writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 24);
  writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 32);
  writeUInt64LE(zip64EocdrBuffer, sizeOfCentralDirectory, 40);
  writeUInt64LE(zip64EocdrBuffer, self2.offsetOfStartOfCentralDirectory, 48);
  var zip64EocdlBuffer = bufferAlloc$1(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE);
  zip64EocdlBuffer.writeUInt32LE(117853008, 0);
  zip64EocdlBuffer.writeUInt32LE(0, 4);
  writeUInt64LE(zip64EocdlBuffer, self2.outputStreamCursor, 8);
  zip64EocdlBuffer.writeUInt32LE(1, 16);
  return Buffer.concat([
    zip64EocdrBuffer,
    zip64EocdlBuffer,
    eocdrBuffer
  ]);
}
function validateMetadataPath(metadataPath, isDirectory) {
  if (metadataPath === "") throw new Error("empty metadataPath");
  metadataPath = metadataPath.replace(/\\/g, "/");
  if (/^[a-zA-Z]:/.test(metadataPath) || /^\//.test(metadataPath)) throw new Error("absolute path: " + metadataPath);
  if (metadataPath.split("/").indexOf("..") !== -1) throw new Error("invalid relative path: " + metadataPath);
  var looksLikeDirectory = /\/$/.test(metadataPath);
  if (isDirectory) {
    if (!looksLikeDirectory) metadataPath += "/";
  } else {
    if (looksLikeDirectory) throw new Error("file path cannot end with '/': " + metadataPath);
  }
  return metadataPath;
}
var EMPTY_BUFFER = bufferAlloc$1(0);
function Entry$1(metadataPath, isDirectory, options) {
  this.utf8FileName = bufferFrom(metadataPath);
  if (this.utf8FileName.length > 65535) throw new Error("utf8 file name too long. " + utf8FileName.length + " > 65535");
  this.isDirectory = isDirectory;
  this.state = Entry$1.WAITING_FOR_METADATA;
  this.setLastModDate(options.mtime != null ? options.mtime : /* @__PURE__ */ new Date());
  if (options.mode != null) {
    this.setFileAttributesMode(options.mode);
  } else {
    this.setFileAttributesMode(isDirectory ? 16893 : 33204);
  }
  if (isDirectory) {
    this.crcAndFileSizeKnown = true;
    this.crc32 = 0;
    this.uncompressedSize = 0;
    this.compressedSize = 0;
  } else {
    this.crcAndFileSizeKnown = false;
    this.crc32 = null;
    this.uncompressedSize = null;
    this.compressedSize = null;
    if (options.size != null) this.uncompressedSize = options.size;
  }
  if (isDirectory) {
    this.compress = false;
  } else {
    this.compress = true;
    if (options.compress != null) this.compress = !!options.compress;
  }
  this.forceZip64Format = !!options.forceZip64Format;
  if (options.fileComment) {
    if (typeof options.fileComment === "string") {
      this.fileComment = bufferFrom(options.fileComment, "utf-8");
    } else {
      this.fileComment = options.fileComment;
    }
    if (this.fileComment.length > 65535) throw new Error("fileComment is too large");
  } else {
    this.fileComment = EMPTY_BUFFER;
  }
}
Entry$1.WAITING_FOR_METADATA = 0;
Entry$1.READY_TO_PUMP_FILE_DATA = 1;
Entry$1.FILE_DATA_IN_PROGRESS = 2;
Entry$1.FILE_DATA_DONE = 3;
Entry$1.prototype.setLastModDate = function(date) {
  var dosDateTime = dateToDosDateTime(date);
  this.lastModFileTime = dosDateTime.time;
  this.lastModFileDate = dosDateTime.date;
=======
function jn(e, t) {
  e.outputStream.write(t), e.outputStreamCursor += t.length;
}
function z0(e, t, n) {
  var r = new Eu(), i = new ds(), a = t.compress ? new M0.DeflateRaw() : new j0(), s = new ds();
  n.pipe(r).pipe(i).pipe(a).pipe(s).pipe(e.outputStream, { end: !1 }), s.on("end", function() {
    if (t.crc32 = r.crc32, t.uncompressedSize == null)
      t.uncompressedSize = i.byteCount;
    else if (t.uncompressedSize !== i.byteCount) return e.emit("error", new Error("file data stream has unexpected number of bytes"));
    t.compressedSize = s.byteCount, e.outputStreamCursor += t.compressedSize, jn(e, t.getDataDescriptor()), t.state = pe.FILE_DATA_DONE, un(e);
  });
}
function un(e) {
  if (e.allDone) return;
  if (e.ended && e.finalSizeCallback != null) {
    var t = G4(e);
    t != null && (e.finalSizeCallback(t), e.finalSizeCallback = null);
  }
  var n = r();
  function r() {
    for (var a = 0; a < e.entries.length; a++) {
      var s = e.entries[a];
      if (s.state < pe.FILE_DATA_DONE) return s;
    }
    return null;
  }
  if (n != null) {
    if (n.state < pe.READY_TO_PUMP_FILE_DATA || n.state === pe.FILE_DATA_IN_PROGRESS) return;
    n.relativeOffsetOfLocalHeader = e.outputStreamCursor;
    var i = n.getLocalFileHeader();
    jn(e, i), n.doFileDataPump();
  } else
    e.ended && (e.offsetOfStartOfCentralDirectory = e.outputStreamCursor, e.entries.forEach(function(a) {
      var s = a.getCentralDirectoryRecord();
      jn(e, s);
    }), jn(e, V4(e)), e.outputStream.end(), e.allDone = !0);
}
function G4(e) {
  for (var t = 0, n = 0, r = 0; r < e.entries.length; r++) {
    var i = e.entries[r];
    if (i.compress) return -1;
    if (i.state >= pe.READY_TO_PUMP_FILE_DATA) {
      if (i.uncompressedSize == null) return -1;
    } else if (i.uncompressedSize == null) return null;
    i.relativeOffsetOfLocalHeader = t;
    var a = i.useZip64Format();
    t += G0 + i.utf8FileName.length, t += i.uncompressedSize, i.crcAndFileSizeKnown || (a ? t += Q0 : t += Z0), n += e1 + i.utf8FileName.length + i.fileComment.length, a && (n += $l);
  }
  var s = 0;
  return (e.forceZip64Eocd || e.entries.length >= 65535 || n >= 65535 || t >= 4294967295) && (s += Rl + H0), s += W0 + e.comment.length, t + n + s;
}
var Rl = 56, H0 = 20, W0 = 22;
function V4(e, t) {
  var n = !1, r = e.entries.length;
  (e.forceZip64Eocd || e.entries.length >= 65535) && (r = 65535, n = !0);
  var i = e.outputStreamCursor - e.offsetOfStartOfCentralDirectory, a = i;
  (e.forceZip64Eocd || i >= 4294967295) && (a = 4294967295, n = !0);
  var s = e.offsetOfStartOfCentralDirectory;
  (e.forceZip64Eocd || e.offsetOfStartOfCentralDirectory >= 4294967295) && (s = 4294967295, n = !0);
  var c = Je(W0 + e.comment.length);
  if (c.writeUInt32LE(101010256, 0), c.writeUInt16LE(0, 4), c.writeUInt16LE(0, 6), c.writeUInt16LE(r, 8), c.writeUInt16LE(r, 10), c.writeUInt32LE(a, 12), c.writeUInt32LE(s, 16), c.writeUInt16LE(e.comment.length, 20), e.comment.copy(c, 22), !n) return c;
  var o = Je(Rl);
  o.writeUInt32LE(101075792, 0), ht(o, Rl - 12, 4), o.writeUInt16LE(X0, 12), o.writeUInt16LE(Y0, 14), o.writeUInt32LE(0, 16), o.writeUInt32LE(0, 20), ht(o, e.entries.length, 24), ht(o, e.entries.length, 32), ht(o, i, 40), ht(o, e.offsetOfStartOfCentralDirectory, 48);
  var u = Je(H0);
  return u.writeUInt32LE(117853008, 0), u.writeUInt32LE(0, 4), ht(u, e.outputStreamCursor, 8), u.writeUInt32LE(1, 16), Buffer.concat([
    o,
    u,
    c
  ]);
}
function Ws(e, t) {
  if (e === "") throw new Error("empty metadataPath");
  if (e = e.replace(/\\/g, "/"), /^[a-zA-Z]:/.test(e) || /^\//.test(e)) throw new Error("absolute path: " + e);
  if (e.split("/").indexOf("..") !== -1) throw new Error("invalid relative path: " + e);
  var n = /\/$/.test(e);
  if (t)
    n || (e += "/");
  else if (n) throw new Error("file path cannot end with '/': " + e);
  return e;
}
var Gs = Je(0);
function pe(e, t, n) {
  if (this.utf8FileName = nn(e), this.utf8FileName.length > 65535) throw new Error("utf8 file name too long. " + utf8FileName.length + " > 65535");
  if (this.isDirectory = t, this.state = pe.WAITING_FOR_METADATA, this.setLastModDate(n.mtime != null ? n.mtime : /* @__PURE__ */ new Date()), n.mode != null ? this.setFileAttributesMode(n.mode) : this.setFileAttributesMode(t ? 16893 : 33204), t ? (this.crcAndFileSizeKnown = !0, this.crc32 = 0, this.uncompressedSize = 0, this.compressedSize = 0) : (this.crcAndFileSizeKnown = !1, this.crc32 = null, this.uncompressedSize = null, this.compressedSize = null, n.size != null && (this.uncompressedSize = n.size)), t ? this.compress = !1 : (this.compress = !0, n.compress != null && (this.compress = !!n.compress)), this.forceZip64Format = !!n.forceZip64Format, n.fileComment) {
    if (typeof n.fileComment == "string" ? this.fileComment = nn(n.fileComment, "utf-8") : this.fileComment = n.fileComment, this.fileComment.length > 65535) throw new Error("fileComment is too large");
  } else
    this.fileComment = Gs;
}
pe.WAITING_FOR_METADATA = 0;
pe.READY_TO_PUMP_FILE_DATA = 1;
pe.FILE_DATA_IN_PROGRESS = 2;
pe.FILE_DATA_DONE = 3;
pe.prototype.setLastModDate = function(e) {
  var t = t1(e);
  this.lastModFileTime = t.time, this.lastModFileDate = t.date;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
};
Entry$1.prototype.setFileAttributesMode = function(mode) {
  if ((mode & 65535) !== mode) throw new Error("invalid mode. expected: 0 <= " + mode + " <= 65535");
  this.externalFileAttributes = mode << 16 >>> 0;
};
Entry$1.prototype.setFileDataPumpFunction = function(doFileDataPump) {
  this.doFileDataPump = doFileDataPump;
  this.state = Entry$1.READY_TO_PUMP_FILE_DATA;
};
Entry$1.prototype.useZip64Format = function() {
  return this.forceZip64Format || this.uncompressedSize != null && this.uncompressedSize > 4294967294 || this.compressedSize != null && this.compressedSize > 4294967294 || this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 4294967294;
};
<<<<<<< HEAD
var LOCAL_FILE_HEADER_FIXED_SIZE = 30;
var VERSION_NEEDED_TO_EXTRACT_UTF8 = 20;
var VERSION_NEEDED_TO_EXTRACT_ZIP64 = 45;
var VERSION_MADE_BY = 3 << 8 | 63;
var FILE_NAME_IS_UTF8 = 1 << 11;
var UNKNOWN_CRC32_AND_FILE_SIZES = 1 << 3;
Entry$1.prototype.getLocalFileHeader = function() {
  var crc322 = 0;
  var compressedSize = 0;
  var uncompressedSize = 0;
  if (this.crcAndFileSizeKnown) {
    crc322 = this.crc32;
    compressedSize = this.compressedSize;
    uncompressedSize = this.uncompressedSize;
  }
  var fixedSizeStuff = bufferAlloc$1(LOCAL_FILE_HEADER_FIXED_SIZE);
  var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
  if (!this.crcAndFileSizeKnown) generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
  fixedSizeStuff.writeUInt32LE(67324752, 0);
  fixedSizeStuff.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_UTF8, 4);
  fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 6);
  fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 8);
  fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 10);
  fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 12);
  fixedSizeStuff.writeUInt32LE(crc322, 14);
  fixedSizeStuff.writeUInt32LE(compressedSize, 18);
  fixedSizeStuff.writeUInt32LE(uncompressedSize, 22);
  fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 26);
  fixedSizeStuff.writeUInt16LE(0, 28);
  return Buffer.concat([
    fixedSizeStuff,
=======
var G0 = 30, V0 = 20, Y0 = 45, X0 = 831, K0 = 2048, J0 = 8;
pe.prototype.getLocalFileHeader = function() {
  var e = 0, t = 0, n = 0;
  this.crcAndFileSizeKnown && (e = this.crc32, t = this.compressedSize, n = this.uncompressedSize);
  var r = Je(G0), i = K0;
  return this.crcAndFileSizeKnown || (i |= J0), r.writeUInt32LE(67324752, 0), r.writeUInt16LE(V0, 4), r.writeUInt16LE(i, 6), r.writeUInt16LE(this.getCompressionMethod(), 8), r.writeUInt16LE(this.lastModFileTime, 10), r.writeUInt16LE(this.lastModFileDate, 12), r.writeUInt32LE(e, 14), r.writeUInt32LE(t, 18), r.writeUInt32LE(n, 22), r.writeUInt16LE(this.utf8FileName.length, 26), r.writeUInt16LE(0, 28), Buffer.concat([
    r,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    // file name (variable size)
    this.utf8FileName
    // extra field (variable size)
    // no extra fields
  ]);
};
<<<<<<< HEAD
var DATA_DESCRIPTOR_SIZE = 16;
var ZIP64_DATA_DESCRIPTOR_SIZE = 24;
Entry$1.prototype.getDataDescriptor = function() {
  if (this.crcAndFileSizeKnown) {
    return EMPTY_BUFFER;
  }
  if (!this.useZip64Format()) {
    var buffer2 = bufferAlloc$1(DATA_DESCRIPTOR_SIZE);
    buffer2.writeUInt32LE(134695760, 0);
    buffer2.writeUInt32LE(this.crc32, 4);
    buffer2.writeUInt32LE(this.compressedSize, 8);
    buffer2.writeUInt32LE(this.uncompressedSize, 12);
    return buffer2;
  } else {
    var buffer2 = bufferAlloc$1(ZIP64_DATA_DESCRIPTOR_SIZE);
    buffer2.writeUInt32LE(134695760, 0);
    buffer2.writeUInt32LE(this.crc32, 4);
    writeUInt64LE(buffer2, this.compressedSize, 8);
    writeUInt64LE(buffer2, this.uncompressedSize, 16);
    return buffer2;
  }
};
var CENTRAL_DIRECTORY_RECORD_FIXED_SIZE = 46;
var ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE = 28;
Entry$1.prototype.getCentralDirectoryRecord = function() {
  var fixedSizeStuff = bufferAlloc$1(CENTRAL_DIRECTORY_RECORD_FIXED_SIZE);
  var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
  if (!this.crcAndFileSizeKnown) generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
  var normalCompressedSize = this.compressedSize;
  var normalUncompressedSize = this.uncompressedSize;
  var normalRelativeOffsetOfLocalHeader = this.relativeOffsetOfLocalHeader;
  var versionNeededToExtract;
  var zeiefBuffer;
  if (this.useZip64Format()) {
    normalCompressedSize = 4294967295;
    normalUncompressedSize = 4294967295;
    normalRelativeOffsetOfLocalHeader = 4294967295;
    versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_ZIP64;
    zeiefBuffer = bufferAlloc$1(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE);
    zeiefBuffer.writeUInt16LE(1, 0);
    zeiefBuffer.writeUInt16LE(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE - 4, 2);
    writeUInt64LE(zeiefBuffer, this.uncompressedSize, 4);
    writeUInt64LE(zeiefBuffer, this.compressedSize, 12);
    writeUInt64LE(zeiefBuffer, this.relativeOffsetOfLocalHeader, 20);
  } else {
    versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_UTF8;
    zeiefBuffer = EMPTY_BUFFER;
  }
  fixedSizeStuff.writeUInt32LE(33639248, 0);
  fixedSizeStuff.writeUInt16LE(VERSION_MADE_BY, 4);
  fixedSizeStuff.writeUInt16LE(versionNeededToExtract, 6);
  fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 8);
  fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 10);
  fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 12);
  fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 14);
  fixedSizeStuff.writeUInt32LE(this.crc32, 16);
  fixedSizeStuff.writeUInt32LE(normalCompressedSize, 20);
  fixedSizeStuff.writeUInt32LE(normalUncompressedSize, 24);
  fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 28);
  fixedSizeStuff.writeUInt16LE(zeiefBuffer.length, 30);
  fixedSizeStuff.writeUInt16LE(this.fileComment.length, 32);
  fixedSizeStuff.writeUInt16LE(0, 34);
  fixedSizeStuff.writeUInt16LE(0, 36);
  fixedSizeStuff.writeUInt32LE(this.externalFileAttributes, 38);
  fixedSizeStuff.writeUInt32LE(normalRelativeOffsetOfLocalHeader, 42);
  return Buffer.concat([
    fixedSizeStuff,
    // file name (variable size)
    this.utf8FileName,
    // extra field (variable size)
    zeiefBuffer,
=======
var Z0 = 16, Q0 = 24;
pe.prototype.getDataDescriptor = function() {
  if (this.crcAndFileSizeKnown)
    return Gs;
  if (this.useZip64Format()) {
    var e = Je(Q0);
    return e.writeUInt32LE(134695760, 0), e.writeUInt32LE(this.crc32, 4), ht(e, this.compressedSize, 8), ht(e, this.uncompressedSize, 16), e;
  } else {
    var e = Je(Z0);
    return e.writeUInt32LE(134695760, 0), e.writeUInt32LE(this.crc32, 4), e.writeUInt32LE(this.compressedSize, 8), e.writeUInt32LE(this.uncompressedSize, 12), e;
  }
};
var e1 = 46, $l = 28;
pe.prototype.getCentralDirectoryRecord = function() {
  var e = Je(e1), t = K0;
  this.crcAndFileSizeKnown || (t |= J0);
  var n = this.compressedSize, r = this.uncompressedSize, i = this.relativeOffsetOfLocalHeader, a, s;
  return this.useZip64Format() ? (n = 4294967295, r = 4294967295, i = 4294967295, a = Y0, s = Je($l), s.writeUInt16LE(1, 0), s.writeUInt16LE($l - 4, 2), ht(s, this.uncompressedSize, 4), ht(s, this.compressedSize, 12), ht(s, this.relativeOffsetOfLocalHeader, 20)) : (a = V0, s = Gs), e.writeUInt32LE(33639248, 0), e.writeUInt16LE(X0, 4), e.writeUInt16LE(a, 6), e.writeUInt16LE(t, 8), e.writeUInt16LE(this.getCompressionMethod(), 10), e.writeUInt16LE(this.lastModFileTime, 12), e.writeUInt16LE(this.lastModFileDate, 14), e.writeUInt32LE(this.crc32, 16), e.writeUInt32LE(n, 20), e.writeUInt32LE(r, 24), e.writeUInt16LE(this.utf8FileName.length, 28), e.writeUInt16LE(s.length, 30), e.writeUInt16LE(this.fileComment.length, 32), e.writeUInt16LE(0, 34), e.writeUInt16LE(0, 36), e.writeUInt32LE(this.externalFileAttributes, 38), e.writeUInt32LE(i, 42), Buffer.concat([
    e,
    // file name (variable size)
    this.utf8FileName,
    // extra field (variable size)
    s,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    // file comment (variable size)
    this.fileComment
  ]);
};
Entry$1.prototype.getCompressionMethod = function() {
  var NO_COMPRESSION = 0;
  var DEFLATE_COMPRESSION = 8;
  return this.compress ? DEFLATE_COMPRESSION : NO_COMPRESSION;
};
<<<<<<< HEAD
function dateToDosDateTime(jsDate) {
  var date = 0;
  date |= jsDate.getDate() & 31;
  date |= (jsDate.getMonth() + 1 & 15) << 5;
  date |= (jsDate.getFullYear() - 1980 & 127) << 9;
  var time = 0;
  time |= Math.floor(jsDate.getSeconds() / 2);
  time |= (jsDate.getMinutes() & 63) << 5;
  time |= (jsDate.getHours() & 31) << 11;
  return { date, time };
}
function writeUInt64LE(buffer2, n, offset) {
  var high = Math.floor(n / 4294967296);
  var low = n % 4294967296;
  buffer2.writeUInt32LE(low, offset);
  buffer2.writeUInt32LE(high, offset + 4);
}
util$a.inherits(ByteCounter, Transform$1);
function ByteCounter(options) {
  Transform$1.call(this, options);
  this.byteCount = 0;
}
ByteCounter.prototype._transform = function(chunk, encoding, cb) {
  this.byteCount += chunk.length;
  cb(null, chunk);
};
util$a.inherits(Crc32Watcher, Transform$1);
function Crc32Watcher(options) {
  Transform$1.call(this, options);
  this.crc32 = 0;
}
Crc32Watcher.prototype._transform = function(chunk, encoding, cb) {
  this.crc32 = crc32$1.unsigned(chunk, this.crc32);
  cb(null, chunk);
};
var cp437$1 = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
if (cp437$1.length !== 256) throw new Error("assertion failure");
var reverseCp437 = null;
function encodeCp437(string) {
  if (/^[\x20-\x7e]*$/.test(string)) {
    return bufferFrom(string, "utf-8");
  }
  if (reverseCp437 == null) {
    reverseCp437 = {};
    for (var i = 0; i < cp437$1.length; i++) {
      reverseCp437[cp437$1[i]] = i;
    }
=======
function t1(e) {
  var t = 0;
  t |= e.getDate() & 31, t |= (e.getMonth() + 1 & 15) << 5, t |= (e.getFullYear() - 1980 & 127) << 9;
  var n = 0;
  return n |= Math.floor(e.getSeconds() / 2), n |= (e.getMinutes() & 63) << 5, n |= (e.getHours() & 31) << 11, { date: t, time: n };
}
function ht(e, t, n) {
  var r = Math.floor(t / 4294967296), i = t % 4294967296;
  e.writeUInt32LE(i, n), e.writeUInt32LE(r, n + 4);
}
wu.inherits(ds, Hs);
function ds(e) {
  Hs.call(this, e), this.byteCount = 0;
}
ds.prototype._transform = function(e, t, n) {
  this.byteCount += e.length, n(null, e);
};
wu.inherits(Eu, Hs);
function Eu(e) {
  Hs.call(this, e), this.crc32 = 0;
}
Eu.prototype._transform = function(e, t, n) {
  this.crc32 = q0.unsigned(e, this.crc32), n(null, e);
};
var Ol = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
if (Ol.length !== 256) throw new Error("assertion failure");
var xa = null;
function Y4(e) {
  if (/^[\x20-\x7e]*$/.test(e))
    return nn(e, "utf-8");
  if (xa == null) {
    xa = {};
    for (var t = 0; t < Ol.length; t++)
      xa[Ol[t]] = t;
  }
  for (var n = Je(e.length), t = 0; t < e.length; t++) {
    var r = xa[e[t]];
    if (r == null) throw new Error("character not encodable in CP437: " + JSON.stringify(e[t]));
    n[t] = r;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  var result = bufferAlloc$1(string.length);
  for (var i = 0; i < string.length; i++) {
    var b = reverseCp437[string[i]];
    if (b == null) throw new Error("character not encodable in CP437: " + JSON.stringify(string[i]));
    result[i] = b;
  }
  return result;
}
<<<<<<< HEAD
function bufferAlloc$1(size) {
  bufferAlloc$1 = modern;
  try {
    return bufferAlloc$1(size);
  } catch (e) {
    bufferAlloc$1 = legacy2;
    return bufferAlloc$1(size);
=======
function Je(e) {
  Je = t;
  try {
    return Je(e);
  } catch {
    return Je = n, Je(e);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  function modern(size2) {
    return Buffer.allocUnsafe(size2);
  }
  function legacy2(size2) {
    return new Buffer(size2);
  }
}
<<<<<<< HEAD
function bufferFrom(something, encoding) {
  bufferFrom = modern;
  try {
    return bufferFrom(something, encoding);
  } catch (e) {
    bufferFrom = legacy2;
    return bufferFrom(something, encoding);
=======
function nn(e, t) {
  nn = n;
  try {
    return nn(e, t);
  } catch {
    return nn = r, nn(e, t);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  function modern(something2, encoding2) {
    return Buffer.from(something2, encoding2);
  }
  function legacy2(something2, encoding2) {
    return new Buffer(something2, encoding2);
  }
}
<<<<<<< HEAD
function bufferIncludes(buffer2, content) {
  bufferIncludes = modern;
  try {
    return bufferIncludes(buffer2, content);
  } catch (e) {
    bufferIncludes = legacy2;
    return bufferIncludes(buffer2, content);
  }
  function modern(buffer3, content2) {
    return buffer3.includes(content2);
  }
  function legacy2(buffer3, content2) {
    for (var i = 0; i <= buffer3.length - content2.length; i++) {
      for (var j = 0; ; j++) {
        if (j === content2.length) return true;
        if (buffer3[i + j] !== content2[j]) break;
=======
function si(e, t) {
  si = n;
  try {
    return si(e, t);
  } catch {
    return si = r, si(e, t);
  }
  function n(i, a) {
    return i.includes(a);
  }
  function r(i, a) {
    for (var s = 0; s <= i.length - a.length; s++)
      for (var c = 0; ; c++) {
        if (c === a.length) return !0;
        if (i[s + c] !== a[c]) break;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    }
    return false;
  }
}
<<<<<<< HEAD
var tarStream = {};
var readable = { exports: {} };
var processNextickArgs = { exports: {} };
var hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1;
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    processNextickArgs.exports = { nextTick };
  } else {
    processNextickArgs.exports = process;
  }
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
=======
var zi = {}, Il = { exports: {} }, ya = { exports: {} }, If;
function Vs() {
  if (If) return ya.exports;
  If = 1, typeof process > "u" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0 ? ya.exports = { nextTick: e } : ya.exports = process;
  function e(t, n, r, i) {
    if (typeof t != "function")
      throw new TypeError('"callback" argument must be a function');
    var a = arguments.length, s, c;
    switch (a) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
<<<<<<< HEAD
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray$1;
var hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray$1;
  hasRequiredIsarray = 1;
  var toString5 = {}.toString;
  isarray$1 = Array.isArray || function(arr) {
    return toString5.call(arr) == "[object Array]";
  };
  return isarray$1;
}
var stream$a;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream$a;
  hasRequiredStream = 1;
  stream$a = require$$1$2;
  return stream$a;
}
var safeBuffer$1 = { exports: {} };
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer$1.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer2 = require$$0$5;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key2 in src2) {
        dst[key2] = src2[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill2, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill2 !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill2, encoding);
        } else {
          buf.fill(fill2);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer$1, safeBuffer$1.exports);
  return safeBuffer$1.exports;
}
var util$9 = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util$9;
  hasRequiredUtil = 1;
  function isArray2(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString2(arg) === "[object Array]";
  }
  util$9.isArray = isArray2;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  util$9.isBoolean = isBoolean2;
  function isNull2(arg) {
    return arg === null;
  }
  util$9.isNull = isNull2;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  util$9.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  util$9.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  util$9.isString = isString2;
  function isSymbol2(arg) {
    return typeof arg === "symbol";
  }
  util$9.isSymbol = isSymbol2;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  util$9.isUndefined = isUndefined2;
  function isRegExp2(re2) {
    return objectToString2(re2) === "[object RegExp]";
  }
  util$9.isRegExp = isRegExp2;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util$9.isObject = isObject2;
  function isDate2(d) {
    return objectToString2(d) === "[object Date]";
  }
  util$9.isDate = isDate2;
  function isError(e) {
    return objectToString2(e) === "[object Error]" || e instanceof Error;
  }
  util$9.isError = isError;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  util$9.isFunction = isFunction2;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util$9.isPrimitive = isPrimitive;
  util$9.isBuffer = require$$0$5.Buffer.isBuffer;
  function objectToString2(o) {
    return Object.prototype.toString.call(o);
  }
  return util$9;
}
var inherits = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits.exports;
  hasRequiredInherits = 1;
  try {
    var util2 = require("util");
    if (typeof util2.inherits !== "function") throw "";
    inherits.exports = util2.inherits;
  } catch (e) {
    inherits.exports = requireInherits_browser();
  }
  return inherits.exports;
}
var BufferList$1 = { exports: {} };
var hasRequiredBufferList;
function requireBufferList() {
  if (hasRequiredBufferList) return BufferList$1.exports;
  hasRequiredBufferList = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer().Buffer;
    var util2 = require$$1$3;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList$1);
  return BufferList$1.exports;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var pna = requireProcessNextickArgs();
  function destroy3(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  destroy_1 = {
    destroy: destroy3,
    undestroy
  };
  return destroy_1;
}
var node;
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  node = require$$1$3.deprecate;
  return node;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable = Writable2;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable2.WritableState = WritableState;
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream2 = requireStream();
  var Buffer2 = requireSafeBuffer().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  util2.inherits(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out2 = [];
    while (current) {
      out2.push(current);
      current = current.next;
    }
    return out2;
  };
  (function() {
=======
        for (s = new Array(a - 1), c = 0; c < s.length; )
          s[c++] = arguments[c];
        return process.nextTick(function() {
          t.apply(null, s);
        });
    }
  }
  return ya.exports;
}
var lc, Df;
function X4() {
  if (Df) return lc;
  Df = 1;
  var e = {}.toString;
  return lc = Array.isArray || function(t) {
    return e.call(t) == "[object Array]";
  }, lc;
}
var uc, Ff;
function n1() {
  return Ff || (Ff = 1, uc = ae), uc;
}
var wa = { exports: {} }, Pf;
function Ys() {
  return Pf || (Pf = 1, function(e, t) {
    var n = Bt, r = n.Buffer;
    function i(s, c) {
      for (var o in s)
        c[o] = s[o];
    }
    r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? e.exports = n : (i(n, t), t.Buffer = a);
    function a(s, c, o) {
      return r(s, c, o);
    }
    i(r, a), a.from = function(s, c, o) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return r(s, c, o);
    }, a.alloc = function(s, c, o) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var u = r(s);
      return c !== void 0 ? typeof o == "string" ? u.fill(c, o) : u.fill(c) : u.fill(0), u;
    }, a.allocUnsafe = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return r(s);
    }, a.allocUnsafeSlow = function(s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return n.SlowBuffer(s);
    };
  }(wa, wa.exports)), wa.exports;
}
var ke = {}, kf;
function Hi() {
  if (kf) return ke;
  kf = 1;
  function e(h) {
    return Array.isArray ? Array.isArray(h) : g(h) === "[object Array]";
  }
  ke.isArray = e;
  function t(h) {
    return typeof h == "boolean";
  }
  ke.isBoolean = t;
  function n(h) {
    return h === null;
  }
  ke.isNull = n;
  function r(h) {
    return h == null;
  }
  ke.isNullOrUndefined = r;
  function i(h) {
    return typeof h == "number";
  }
  ke.isNumber = i;
  function a(h) {
    return typeof h == "string";
  }
  ke.isString = a;
  function s(h) {
    return typeof h == "symbol";
  }
  ke.isSymbol = s;
  function c(h) {
    return h === void 0;
  }
  ke.isUndefined = c;
  function o(h) {
    return g(h) === "[object RegExp]";
  }
  ke.isRegExp = o;
  function u(h) {
    return typeof h == "object" && h !== null;
  }
  ke.isObject = u;
  function l(h) {
    return g(h) === "[object Date]";
  }
  ke.isDate = l;
  function p(h) {
    return g(h) === "[object Error]" || h instanceof Error;
  }
  ke.isError = p;
  function f(h) {
    return typeof h == "function";
  }
  ke.isFunction = f;
  function m(h) {
    return h === null || typeof h == "boolean" || typeof h == "number" || typeof h == "string" || typeof h == "symbol" || // ES6 symbol
    typeof h > "u";
  }
  ke.isPrimitive = m, ke.isBuffer = Bt.Buffer.isBuffer;
  function g(h) {
    return Object.prototype.toString.call(h);
  }
  return ke;
}
var Ea = { exports: {} }, _a = { exports: {} }, Lf;
function K4() {
  return Lf || (Lf = 1, typeof Object.create == "function" ? _a.exports = function(t, n) {
    n && (t.super_ = n, t.prototype = Object.create(n.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : _a.exports = function(t, n) {
    if (n) {
      t.super_ = n;
      var r = function() {
      };
      r.prototype = n.prototype, t.prototype = new r(), t.prototype.constructor = t;
    }
  }), _a.exports;
}
var Nf;
function Wi() {
  if (Nf) return Ea.exports;
  Nf = 1;
  try {
    var e = require("util");
    if (typeof e.inherits != "function") throw "";
    Ea.exports = e.inherits;
  } catch {
    Ea.exports = K4();
  }
  return Ea.exports;
}
var pc = { exports: {} }, Uf;
function J4() {
  return Uf || (Uf = 1, function(e) {
    function t(a, s) {
      if (!(a instanceof s))
        throw new TypeError("Cannot call a class as a function");
    }
    var n = Ys().Buffer, r = De;
    function i(a, s, c) {
      a.copy(s, c);
    }
    e.exports = function() {
      function a() {
        t(this, a), this.head = null, this.tail = null, this.length = 0;
      }
      return a.prototype.push = function(c) {
        var o = { data: c, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      }, a.prototype.unshift = function(c) {
        var o = { data: c, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      }, a.prototype.shift = function() {
        if (this.length !== 0) {
          var c = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, c;
        }
      }, a.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, a.prototype.join = function(c) {
        if (this.length === 0) return "";
        for (var o = this.head, u = "" + o.data; o = o.next; )
          u += c + o.data;
        return u;
      }, a.prototype.concat = function(c) {
        if (this.length === 0) return n.alloc(0);
        for (var o = n.allocUnsafe(c >>> 0), u = this.head, l = 0; u; )
          i(u.data, o, l), l += u.data.length, u = u.next;
        return o;
      }, a;
    }(), r && r.inspect && r.inspect.custom && (e.exports.prototype[r.inspect.custom] = function() {
      var a = r.inspect({ length: this.length });
      return this.constructor.name + " " + a;
    });
  }(pc)), pc.exports;
}
var fc, Bf;
function r1() {
  if (Bf) return fc;
  Bf = 1;
  var e = Vs();
  function t(i, a) {
    var s = this, c = this._readableState && this._readableState.destroyed, o = this._writableState && this._writableState.destroyed;
    return c || o ? (a ? a(i) : i && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(r, this, i)) : e.nextTick(r, this, i)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(i || null, function(u) {
      !a && u ? s._writableState ? s._writableState.errorEmitted || (s._writableState.errorEmitted = !0, e.nextTick(r, s, u)) : e.nextTick(r, s, u) : a && a(u);
    }), this);
  }
  function n() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function r(i, a) {
    i.emit("error", a);
  }
  return fc = {
    destroy: t,
    undestroy: n
  }, fc;
}
var dc, jf;
function Z4() {
  return jf || (jf = 1, dc = De.deprecate), dc;
}
var hc, Mf;
function i1() {
  if (Mf) return hc;
  Mf = 1;
  var e = Vs();
  hc = h;
  function t(w) {
    var _ = this;
    this.next = null, this.entry = null, this.finish = function() {
      P(_, w);
    };
  }
  var n = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, r;
  h.WritableState = m;
  var i = Object.create(Hi());
  i.inherits = Wi();
  var a = {
    deprecate: Z4()
  }, s = n1(), c = Ys().Buffer, o = (typeof Ae < "u" ? Ae : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function u(w) {
    return c.from(w);
  }
  function l(w) {
    return c.isBuffer(w) || w instanceof o;
  }
  var p = r1();
  i.inherits(h, s);
  function f() {
  }
  function m(w, _) {
    r = r || Fr(), w = w || {};
    var R = _ instanceof r;
    this.objectMode = !!w.objectMode, R && (this.objectMode = this.objectMode || !!w.writableObjectMode);
    var L = w.highWaterMark, N = w.writableHighWaterMark, j = this.objectMode ? 16 : 16 * 1024;
    L || L === 0 ? this.highWaterMark = L : R && (N || N === 0) ? this.highWaterMark = N : this.highWaterMark = j, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var K = w.decodeStrings === !1;
    this.decodeStrings = !K, this.defaultEncoding = w.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Z) {
      z(_, Z);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  m.prototype.getBuffer = function() {
    for (var _ = this.bufferedRequest, R = []; _; )
      R.push(_), _ = _.next;
    return R;
  }, function() {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
<<<<<<< HEAD
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable2, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable2) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object) {
      return object instanceof this;
    };
  }
  function Writable2(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!realHasInstance.call(Writable2, this) && !(this instanceof Duplex)) {
      return new Writable2(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream2.call(this);
  }
  Writable2.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid2 = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid2 = false;
    }
    return valid2;
  }
  Writable2.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable2.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable2.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
=======
  }();
  var g;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (g = Function.prototype[Symbol.hasInstance], Object.defineProperty(h, Symbol.hasInstance, {
    value: function(w) {
      return g.call(this, w) ? !0 : this !== h ? !1 : w && w._writableState instanceof m;
    }
  })) : g = function(w) {
    return w instanceof this;
  };
  function h(w) {
    if (r = r || Fr(), !g.call(h, this) && !(this instanceof r))
      return new h(w);
    this._writableState = new m(w, this), this.writable = !0, w && (typeof w.write == "function" && (this._write = w.write), typeof w.writev == "function" && (this._writev = w.writev), typeof w.destroy == "function" && (this._destroy = w.destroy), typeof w.final == "function" && (this._final = w.final)), s.call(this);
  }
  h.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function b(w, _) {
    var R = new Error("write after end");
    w.emit("error", R), e.nextTick(_, R);
  }
  function x(w, _, R, L) {
    var N = !0, j = !1;
    return R === null ? j = new TypeError("May not write null values to stream") : typeof R != "string" && R !== void 0 && !_.objectMode && (j = new TypeError("Invalid non-string/buffer chunk")), j && (w.emit("error", j), e.nextTick(L, j), N = !1), N;
  }
  h.prototype.write = function(w, _, R) {
    var L = this._writableState, N = !1, j = !L.objectMode && l(w);
    return j && !c.isBuffer(w) && (w = u(w)), typeof _ == "function" && (R = _, _ = null), j ? _ = "buffer" : _ || (_ = L.defaultEncoding), typeof R != "function" && (R = f), L.ended ? b(this, R) : (j || x(this, L, w, R)) && (L.pendingcb++, N = E(this, L, j, w, _, R)), N;
  }, h.prototype.cork = function() {
    var w = this._writableState;
    w.corked++;
  }, h.prototype.uncork = function() {
    var w = this._writableState;
    w.corked && (w.corked--, !w.writing && !w.corked && !w.bufferProcessing && w.bufferedRequest && H(this, w));
  }, h.prototype.setDefaultEncoding = function(_) {
    if (typeof _ == "string" && (_ = _.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((_ + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + _);
    return this._writableState.defaultEncoding = _, this;
  };
  function y(w, _, R) {
    return !w.objectMode && w.decodeStrings !== !1 && typeof _ == "string" && (_ = c.from(_, R)), _;
  }
  Object.defineProperty(h.prototype, "writableHighWaterMark", {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
<<<<<<< HEAD
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync2, er, cb) {
    --state2.pendingcb;
    if (sync2) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync2 = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync2, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync2) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
=======
  function E(w, _, R, L, N, j) {
    if (!R) {
      var K = y(_, L, N);
      L !== K && (R = !0, N = "buffer", L = K);
    }
    var Z = _.objectMode ? 1 : L.length;
    _.length += Z;
    var q = _.length < _.highWaterMark;
    if (q || (_.needDrain = !0), _.writing || _.corked) {
      var le = _.lastBufferedRequest;
      _.lastBufferedRequest = {
        chunk: L,
        encoding: N,
        isBuf: R,
        callback: j,
        next: null
      }, le ? le.next = _.lastBufferedRequest : _.bufferedRequest = _.lastBufferedRequest, _.bufferedRequestCount += 1;
    } else
      S(w, _, !1, Z, L, N, j);
    return q;
  }
  function S(w, _, R, L, N, j, K) {
    _.writelen = L, _.writecb = K, _.writing = !0, _.sync = !0, R ? w._writev(N, _.onwrite) : w._write(N, j, _.onwrite), _.sync = !1;
  }
  function D(w, _, R, L, N) {
    --_.pendingcb, R ? (e.nextTick(N, L), e.nextTick(k, w, _), w._writableState.errorEmitted = !0, w.emit("error", L)) : (N(L), w._writableState.errorEmitted = !0, w.emit("error", L), k(w, _));
  }
  function U(w) {
    w.writing = !1, w.writecb = null, w.length -= w.writelen, w.writelen = 0;
  }
  function z(w, _) {
    var R = w._writableState, L = R.sync, N = R.writecb;
    if (U(R), _) D(w, R, L, _, N);
    else {
      var j = M(R);
      !j && !R.corked && !R.bufferProcessing && R.bufferedRequest && H(w, R), L ? n(ee, w, R, j, N) : ee(w, R, j, N);
    }
  }
  function ee(w, _, R, L) {
    R || C(w, _), _.pendingcb--, L(), k(w, _);
  }
  function C(w, _) {
    _.length === 0 && _.needDrain && (_.needDrain = !1, w.emit("drain"));
  }
  function H(w, _) {
    _.bufferProcessing = !0;
    var R = _.bufferedRequest;
    if (w._writev && R && R.next) {
      var L = _.bufferedRequestCount, N = new Array(L), j = _.corkedRequestsFree;
      j.entry = R;
      for (var K = 0, Z = !0; R; )
        N[K] = R, R.isBuf || (Z = !1), R = R.next, K += 1;
      N.allBuffers = Z, S(w, _, !0, _.length, N, "", j.finish), _.pendingcb++, _.lastBufferedRequest = null, j.next ? (_.corkedRequestsFree = j.next, j.next = null) : _.corkedRequestsFree = new t(_), _.bufferedRequestCount = 0;
    } else {
      for (; R; ) {
        var q = R.chunk, le = R.encoding, v = R.callback, d = _.objectMode ? 1 : q.length;
        if (S(w, _, !1, d, q, le, v), R = R.next, _.bufferedRequestCount--, _.writing)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          break;
        }
      }
<<<<<<< HEAD
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable2.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable2.prototype._writev = null;
  Writable2.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        stream2.emit("error", err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable2.prototype, "destroyed", {
=======
      R === null && (_.lastBufferedRequest = null);
    }
    _.bufferedRequest = R, _.bufferProcessing = !1;
  }
  h.prototype._write = function(w, _, R) {
    R(new Error("_write() is not implemented"));
  }, h.prototype._writev = null, h.prototype.end = function(w, _, R) {
    var L = this._writableState;
    typeof w == "function" ? (R = w, w = null, _ = null) : typeof _ == "function" && (R = _, _ = null), w != null && this.write(w, _), L.corked && (L.corked = 1, this.uncork()), L.ending || O(this, L, R);
  };
  function M(w) {
    return w.ending && w.length === 0 && w.bufferedRequest === null && !w.finished && !w.writing;
  }
  function J(w, _) {
    w._final(function(R) {
      _.pendingcb--, R && w.emit("error", R), _.prefinished = !0, w.emit("prefinish"), k(w, _);
    });
  }
  function re(w, _) {
    !_.prefinished && !_.finalCalled && (typeof w._final == "function" ? (_.pendingcb++, _.finalCalled = !0, e.nextTick(J, w, _)) : (_.prefinished = !0, w.emit("prefinish")));
  }
  function k(w, _) {
    var R = M(_);
    return R && (re(w, _), _.pendingcb === 0 && (_.finished = !0, w.emit("finish"))), R;
  }
  function O(w, _, R) {
    _.ending = !0, k(w, _), R && (_.finished ? e.nextTick(R) : w.once("finish", R)), _.ended = !0, w.writable = !1;
  }
  function P(w, _, R) {
    var L = w.entry;
    for (w.entry = null; L; ) {
      var N = L.callback;
      _.pendingcb--, N(R), L = L.next;
    }
    _.corkedRequestsFree.next = w;
  }
  return Object.defineProperty(h.prototype, "destroyed", {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
<<<<<<< HEAD
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable2.prototype.destroy = destroyImpl.destroy;
  Writable2.prototype._undestroy = destroyImpl.undestroy;
  Writable2.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key2 in obj) {
      keys2.push(key2);
    }
    return keys2;
  };
  _stream_duplex = Duplex;
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  var Readable2 = require_stream_readable();
  var Writable2 = require_stream_writable();
  util2.inherits(Duplex, Readable2);
  {
    var keys = objectKeys(Writable2.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable2.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable2.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
=======
    set: function(w) {
      this._writableState && (this._writableState.destroyed = w);
    }
  }), h.prototype.destroy = p.destroy, h.prototype._undestroy = p.undestroy, h.prototype._destroy = function(w, _) {
    this.end(), _(w);
  }, hc;
}
var mc, qf;
function Fr() {
  if (qf) return mc;
  qf = 1;
  var e = Vs(), t = Object.keys || function(p) {
    var f = [];
    for (var m in p)
      f.push(m);
    return f;
  };
  mc = o;
  var n = Object.create(Hi());
  n.inherits = Wi();
  var r = a1(), i = i1();
  n.inherits(o, r);
  for (var a = t(i.prototype), s = 0; s < a.length; s++) {
    var c = a[s];
    o.prototype[c] || (o.prototype[c] = i.prototype[c]);
  }
  function o(p) {
    if (!(this instanceof o)) return new o(p);
    r.call(this, p), i.call(this, p), p && p.readable === !1 && (this.readable = !1), p && p.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, p && p.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", u);
  }
  Object.defineProperty(o.prototype, "writableHighWaterMark", {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
<<<<<<< HEAD
  Object.defineProperty(Duplex.prototype, "destroyed", {
=======
  return Object.defineProperty(o.prototype, "destroyed", {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
<<<<<<< HEAD
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
  return _stream_duplex;
}
var string_decoder = {};
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
=======
  }), o.prototype._destroy = function(p, f) {
    this.push(null), this.end(), e.nextTick(f, p);
  }, mc;
}
var vc = {}, zf;
function Hf() {
  if (zf) return vc;
  zf = 1;
  var e = Ys().Buffer, t = e.isEncoding || function(x) {
    switch (x = "" + x, x && x.toLowerCase()) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
<<<<<<< HEAD
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
=======
  function n(x) {
    if (!x) return "utf8";
    for (var y; ; )
      switch (x) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
<<<<<<< HEAD
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
=======
          if (y) return;
          x = ("" + x).toLowerCase(), y = !0;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    }
  }
<<<<<<< HEAD
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder2;
  function StringDecoder2(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder2.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder2.prototype.end = utf8End;
  StringDecoder2.prototype.text = utf8Text;
  StringDecoder2.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
=======
  function r(x) {
    var y = n(x);
    if (typeof y != "string" && (e.isEncoding === t || !t(x))) throw new Error("Unknown encoding: " + x);
    return y || x;
  }
  vc.StringDecoder = i;
  function i(x) {
    this.encoding = r(x);
    var y;
    switch (this.encoding) {
      case "utf16le":
        this.text = p, this.end = f, y = 4;
        break;
      case "utf8":
        this.fillLast = o, y = 4;
        break;
      case "base64":
        this.text = m, this.end = g, y = 3;
        break;
      default:
        this.write = h, this.end = b;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(y);
  }
  i.prototype.write = function(x) {
    if (x.length === 0) return "";
    var y, E;
    if (this.lastNeed) {
      if (y = this.fillLast(x), y === void 0) return "";
      E = this.lastNeed, this.lastNeed = 0;
    } else
      E = 0;
    return E < x.length ? y ? y + this.text(x, E) : this.text(x, E) : y || "";
  }, i.prototype.end = l, i.prototype.text = u, i.prototype.fillLast = function(x) {
    if (this.lastNeed <= x.length)
      return x.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    x.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, x.length), this.lastNeed -= x.length;
  };
  function a(x) {
    return x <= 127 ? 0 : x >> 5 === 6 ? 2 : x >> 4 === 14 ? 3 : x >> 3 === 30 ? 4 : x >> 6 === 2 ? -1 : -2;
  }
  function s(x, y, E) {
    var S = y.length - 1;
    if (S < E) return 0;
    var D = a(y[S]);
    return D >= 0 ? (D > 0 && (x.lastNeed = D - 1), D) : --S < E || D === -2 ? 0 : (D = a(y[S]), D >= 0 ? (D > 0 && (x.lastNeed = D - 2), D) : --S < E || D === -2 ? 0 : (D = a(y[S]), D >= 0 ? (D > 0 && (D === 2 ? D = 0 : x.lastNeed = D - 3), D) : 0));
  }
  function c(x, y, E) {
    if ((y[0] & 192) !== 128)
      return x.lastNeed = 0, "";
    if (x.lastNeed > 1 && y.length > 1) {
      if ((y[1] & 192) !== 128)
        return x.lastNeed = 1, "";
      if (x.lastNeed > 2 && y.length > 2 && (y[2] & 192) !== 128)
        return x.lastNeed = 2, "";
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
<<<<<<< HEAD
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end2 = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end2);
    return buf.toString("utf8", i, end2);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end2 = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end2);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable = Readable2;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$0$6.EventEmitter;
  var EElistenerCount = function(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream2 = requireStream();
  var Buffer2 = requireSafeBuffer().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  var debugUtil = require$$1$3;
  var debug2 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function() {
    };
  }
  var BufferList2 = requireBufferList();
  var destroyImpl = requireDestroy();
  var StringDecoder2;
  util2.inherits(Readable2, Stream2);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray2(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder2) StringDecoder2 = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder2(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable2)) return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream2.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder2) StringDecoder2 = requireString_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder2(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug2("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug2("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug2("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug2("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug2("reading or ended", doRead);
    } else if (doRead) {
      debug2("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug2("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream2);
      else emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug2("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug2("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug2("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug2("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug2("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug2("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug2("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug2("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug2("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug2("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug2("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug2("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index = indexOf2(state2.pipes, dest);
    if (index === -1) return this;
    state2.pipes.splice(index, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream2.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug2("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug2("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug2("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug2("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug2("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug2("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug2("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug2("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function(method) {
          return function() {
            return stream2[method].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug2("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
=======
  function o(x) {
    var y = this.lastTotal - this.lastNeed, E = c(this, x);
    if (E !== void 0) return E;
    if (this.lastNeed <= x.length)
      return x.copy(this.lastChar, y, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    x.copy(this.lastChar, y, 0, x.length), this.lastNeed -= x.length;
  }
  function u(x, y) {
    var E = s(this, x, y);
    if (!this.lastNeed) return x.toString("utf8", y);
    this.lastTotal = E;
    var S = x.length - (E - this.lastNeed);
    return x.copy(this.lastChar, 0, S), x.toString("utf8", y, S);
  }
  function l(x) {
    var y = x && x.length ? this.write(x) : "";
    return this.lastNeed ? y + "" : y;
  }
  function p(x, y) {
    if ((x.length - y) % 2 === 0) {
      var E = x.toString("utf16le", y);
      if (E) {
        var S = E.charCodeAt(E.length - 1);
        if (S >= 55296 && S <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = x[x.length - 2], this.lastChar[1] = x[x.length - 1], E.slice(0, -1);
      }
      return E;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = x[x.length - 1], x.toString("utf16le", y, x.length - 1);
  }
  function f(x) {
    var y = x && x.length ? this.write(x) : "";
    if (this.lastNeed) {
      var E = this.lastTotal - this.lastNeed;
      return y + this.lastChar.toString("utf16le", 0, E);
    }
    return y;
  }
  function m(x, y) {
    var E = (x.length - y) % 3;
    return E === 0 ? x.toString("base64", y) : (this.lastNeed = 3 - E, this.lastTotal = 3, E === 1 ? this.lastChar[0] = x[x.length - 1] : (this.lastChar[0] = x[x.length - 2], this.lastChar[1] = x[x.length - 1]), x.toString("base64", y, x.length - E));
  }
  function g(x) {
    var y = x && x.length ? this.write(x) : "";
    return this.lastNeed ? y + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : y;
  }
  function h(x) {
    return x.toString(this.encoding);
  }
  function b(x) {
    return x && x.length ? this.write(x) : "";
  }
  return vc;
}
var gc, Wf;
function a1() {
  if (Wf) return gc;
  Wf = 1;
  var e = Vs();
  gc = y;
  var t = X4(), n;
  y.ReadableState = x, Yn.EventEmitter;
  var r = function(v, d) {
    return v.listeners(d).length;
  }, i = n1(), a = Ys().Buffer, s = (typeof Ae < "u" ? Ae : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function c(v) {
    return a.from(v);
  }
  function o(v) {
    return a.isBuffer(v) || v instanceof s;
  }
  var u = Object.create(Hi());
  u.inherits = Wi();
  var l = De, p = void 0;
  l && l.debuglog ? p = l.debuglog("stream") : p = function() {
  };
  var f = J4(), m = r1(), g;
  u.inherits(y, i);
  var h = ["error", "close", "destroy", "pause", "resume"];
  function b(v, d, $) {
    if (typeof v.prependListener == "function") return v.prependListener(d, $);
    !v._events || !v._events[d] ? v.on(d, $) : t(v._events[d]) ? v._events[d].unshift($) : v._events[d] = [$, v._events[d]];
  }
  function x(v, d) {
    n = n || Fr(), v = v || {};
    var $ = d instanceof n;
    this.objectMode = !!v.objectMode, $ && (this.objectMode = this.objectMode || !!v.readableObjectMode);
    var T = v.highWaterMark, G = v.readableHighWaterMark, W = this.objectMode ? 16 : 16 * 1024;
    T || T === 0 ? this.highWaterMark = T : $ && (G || G === 0) ? this.highWaterMark = G : this.highWaterMark = W, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new f(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = v.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, v.encoding && (g || (g = Hf().StringDecoder), this.decoder = new g(v.encoding), this.encoding = v.encoding);
  }
  function y(v) {
    if (n = n || Fr(), !(this instanceof y)) return new y(v);
    this._readableState = new x(v, this), this.readable = !0, v && (typeof v.read == "function" && (this._read = v.read), typeof v.destroy == "function" && (this._destroy = v.destroy)), i.call(this);
  }
  Object.defineProperty(y.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(v) {
      this._readableState && (this._readableState.destroyed = v);
    }
  }), y.prototype.destroy = m.destroy, y.prototype._undestroy = m.undestroy, y.prototype._destroy = function(v, d) {
    this.push(null), d(v);
  }, y.prototype.push = function(v, d) {
    var $ = this._readableState, T;
    return $.objectMode ? T = !0 : typeof v == "string" && (d = d || $.defaultEncoding, d !== $.encoding && (v = a.from(v, d), d = ""), T = !0), E(this, v, d, !1, T);
  }, y.prototype.unshift = function(v) {
    return E(this, v, null, !0, !1);
  };
  function E(v, d, $, T, G) {
    var W = v._readableState;
    if (d === null)
      W.reading = !1, H(v, W);
    else {
      var X;
      G || (X = D(W, d)), X ? v.emit("error", X) : W.objectMode || d && d.length > 0 ? (typeof d != "string" && !W.objectMode && Object.getPrototypeOf(d) !== a.prototype && (d = c(d)), T ? W.endEmitted ? v.emit("error", new Error("stream.unshift() after end event")) : S(v, W, d, !0) : W.ended ? v.emit("error", new Error("stream.push() after EOF")) : (W.reading = !1, W.decoder && !$ ? (d = W.decoder.write(d), W.objectMode || d.length !== 0 ? S(v, W, d, !1) : re(v, W)) : S(v, W, d, !1))) : T || (W.reading = !1);
    }
    return U(W);
  }
  function S(v, d, $, T) {
    d.flowing && d.length === 0 && !d.sync ? (v.emit("data", $), v.read(0)) : (d.length += d.objectMode ? 1 : $.length, T ? d.buffer.unshift($) : d.buffer.push($), d.needReadable && M(v)), re(v, d);
  }
  function D(v, d) {
    var $;
    return !o(d) && typeof d != "string" && d !== void 0 && !v.objectMode && ($ = new TypeError("Invalid non-string/buffer chunk")), $;
  }
  function U(v) {
    return !v.ended && (v.needReadable || v.length < v.highWaterMark || v.length === 0);
  }
  y.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, y.prototype.setEncoding = function(v) {
    return g || (g = Hf().StringDecoder), this._readableState.decoder = new g(v), this._readableState.encoding = v, this;
  };
  var z = 8388608;
  function ee(v) {
    return v >= z ? v = z : (v--, v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, v |= v >>> 16, v++), v;
  }
  function C(v, d) {
    return v <= 0 || d.length === 0 && d.ended ? 0 : d.objectMode ? 1 : v !== v ? d.flowing && d.length ? d.buffer.head.data.length : d.length : (v > d.highWaterMark && (d.highWaterMark = ee(v)), v <= d.length ? v : d.ended ? d.length : (d.needReadable = !0, 0));
  }
  y.prototype.read = function(v) {
    p("read", v), v = parseInt(v, 10);
    var d = this._readableState, $ = v;
    if (v !== 0 && (d.emittedReadable = !1), v === 0 && d.needReadable && (d.length >= d.highWaterMark || d.ended))
      return p("read: emitReadable", d.length, d.ended), d.length === 0 && d.ended ? Z(this) : M(this), null;
    if (v = C(v, d), v === 0 && d.ended)
      return d.length === 0 && Z(this), null;
    var T = d.needReadable;
    p("need readable", T), (d.length === 0 || d.length - v < d.highWaterMark) && (T = !0, p("length less than watermark", T)), d.ended || d.reading ? (T = !1, p("reading or ended", T)) : T && (p("do read"), d.reading = !0, d.sync = !0, d.length === 0 && (d.needReadable = !0), this._read(d.highWaterMark), d.sync = !1, d.reading || (v = C($, d)));
    var G;
    return v > 0 ? G = L(v, d) : G = null, G === null ? (d.needReadable = !0, v = 0) : d.length -= v, d.length === 0 && (d.ended || (d.needReadable = !0), $ !== v && d.ended && Z(this)), G !== null && this.emit("data", G), G;
  };
  function H(v, d) {
    if (!d.ended) {
      if (d.decoder) {
        var $ = d.decoder.end();
        $ && $.length && (d.buffer.push($), d.length += d.objectMode ? 1 : $.length);
      }
      d.ended = !0, M(v);
    }
  }
  function M(v) {
    var d = v._readableState;
    d.needReadable = !1, d.emittedReadable || (p("emitReadable", d.flowing), d.emittedReadable = !0, d.sync ? e.nextTick(J, v) : J(v));
  }
  function J(v) {
    p("emit readable"), v.emit("readable"), R(v);
  }
  function re(v, d) {
    d.readingMore || (d.readingMore = !0, e.nextTick(k, v, d));
  }
  function k(v, d) {
    for (var $ = d.length; !d.reading && !d.flowing && !d.ended && d.length < d.highWaterMark && (p("maybeReadMore read 0"), v.read(0), $ !== d.length); )
      $ = d.length;
    d.readingMore = !1;
  }
  y.prototype._read = function(v) {
    this.emit("error", new Error("_read() is not implemented"));
  }, y.prototype.pipe = function(v, d) {
    var $ = this, T = this._readableState;
    switch (T.pipesCount) {
      case 0:
        T.pipes = v;
        break;
      case 1:
        T.pipes = [T.pipes, v];
        break;
      default:
        T.pipes.push(v);
        break;
    }
    T.pipesCount += 1, p("pipe count=%d opts=%j", T.pipesCount, d);
    var G = (!d || d.end !== !1) && v !== process.stdout && v !== process.stderr, W = G ? ve : En;
    T.endEmitted ? e.nextTick(W) : $.once("end", W), v.on("unpipe", X);
    function X(Gt, _n) {
      p("onunpipe"), Gt === $ && _n && _n.hasUnpiped === !1 && (_n.hasUnpiped = !0, Se());
    }
    function ve() {
      p("onend"), v.end();
    }
    var Te = O($);
    v.on("drain", Te);
    var pt = !1;
    function Se() {
      p("cleanup"), v.removeListener("close", Dt), v.removeListener("finish", Wt), v.removeListener("drain", Te), v.removeListener("error", Ht), v.removeListener("unpipe", X), $.removeListener("end", ve), $.removeListener("end", En), $.removeListener("data", er), pt = !0, T.awaitDrain && (!v._writableState || v._writableState.needDrain) && Te();
    }
    var qe = !1;
    $.on("data", er);
    function er(Gt) {
      p("ondata"), qe = !1;
      var _n = v.write(Gt);
      _n === !1 && !qe && ((T.pipesCount === 1 && T.pipes === v || T.pipesCount > 1 && le(T.pipes, v) !== -1) && !pt && (p("false write response, pause", T.awaitDrain), T.awaitDrain++, qe = !0), $.pause());
    }
    function Ht(Gt) {
      p("onerror", Gt), En(), v.removeListener("error", Ht), r(v, "error") === 0 && v.emit("error", Gt);
    }
    b(v, "error", Ht);
    function Dt() {
      v.removeListener("finish", Wt), En();
    }
    v.once("close", Dt);
    function Wt() {
      p("onfinish"), v.removeListener("close", Dt), En();
    }
    v.once("finish", Wt);
    function En() {
      p("unpipe"), $.unpipe(v);
    }
    return v.emit("pipe", $), T.flowing || (p("pipe resume"), $.resume()), v;
  };
  function O(v) {
    return function() {
      var d = v._readableState;
      p("pipeOnDrain", d.awaitDrain), d.awaitDrain && d.awaitDrain--, d.awaitDrain === 0 && r(v, "data") && (d.flowing = !0, R(v));
    };
  }
  y.prototype.unpipe = function(v) {
    var d = this._readableState, $ = { hasUnpiped: !1 };
    if (d.pipesCount === 0) return this;
    if (d.pipesCount === 1)
      return v && v !== d.pipes ? this : (v || (v = d.pipes), d.pipes = null, d.pipesCount = 0, d.flowing = !1, v && v.emit("unpipe", this, $), this);
    if (!v) {
      var T = d.pipes, G = d.pipesCount;
      d.pipes = null, d.pipesCount = 0, d.flowing = !1;
      for (var W = 0; W < G; W++)
        T[W].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var X = le(d.pipes, v);
    return X === -1 ? this : (d.pipes.splice(X, 1), d.pipesCount -= 1, d.pipesCount === 1 && (d.pipes = d.pipes[0]), v.emit("unpipe", this, $), this);
  }, y.prototype.on = function(v, d) {
    var $ = i.prototype.on.call(this, v, d);
    if (v === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (v === "readable") {
      var T = this._readableState;
      !T.endEmitted && !T.readableListening && (T.readableListening = T.needReadable = !0, T.emittedReadable = !1, T.reading ? T.length && M(this) : e.nextTick(P, this));
    }
    return $;
  }, y.prototype.addListener = y.prototype.on;
  function P(v) {
    p("readable nexttick read 0"), v.read(0);
  }
  y.prototype.resume = function() {
    var v = this._readableState;
    return v.flowing || (p("resume"), v.flowing = !0, w(this, v)), this;
  };
  function w(v, d) {
    d.resumeScheduled || (d.resumeScheduled = !0, e.nextTick(_, v, d));
  }
  function _(v, d) {
    d.reading || (p("resume read 0"), v.read(0)), d.resumeScheduled = !1, d.awaitDrain = 0, v.emit("resume"), R(v), d.flowing && !d.reading && v.read(0);
  }
  y.prototype.pause = function() {
    return p("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (p("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function R(v) {
    var d = v._readableState;
    for (p("flow", d.flowing); d.flowing && v.read() !== null; )
      ;
  }
  y.prototype.wrap = function(v) {
    var d = this, $ = this._readableState, T = !1;
    v.on("end", function() {
      if (p("wrapped end"), $.decoder && !$.ended) {
        var X = $.decoder.end();
        X && X.length && d.push(X);
      }
      d.push(null);
    }), v.on("data", function(X) {
      if (p("wrapped data"), $.decoder && (X = $.decoder.write(X)), !($.objectMode && X == null) && !(!$.objectMode && (!X || !X.length))) {
        var ve = d.push(X);
        ve || (T = !0, v.pause());
      }
    });
    for (var G in v)
      this[G] === void 0 && typeof v[G] == "function" && (this[G] = /* @__PURE__ */ function(X) {
        return function() {
          return v[X].apply(v, arguments);
        };
      }(G));
    for (var W = 0; W < h.length; W++)
      v.on(h[W], this.emit.bind(this, h[W]));
    return this._read = function(X) {
      p("wrapped _read", X), T && (T = !1, v.resume());
    }, this;
  }, Object.defineProperty(y.prototype, "readableHighWaterMark", {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
<<<<<<< HEAD
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str2 = p.data;
      var nb = n > str2.length ? str2.length : n;
      if (nb === str2.length) ret += str2;
      else ret += str2.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str2.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str2.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
=======
  }), y._fromList = L;
  function L(v, d) {
    if (d.length === 0) return null;
    var $;
    return d.objectMode ? $ = d.buffer.shift() : !v || v >= d.length ? (d.decoder ? $ = d.buffer.join("") : d.buffer.length === 1 ? $ = d.buffer.head.data : $ = d.buffer.concat(d.length), d.buffer.clear()) : $ = N(v, d.buffer, d.decoder), $;
  }
  function N(v, d, $) {
    var T;
    return v < d.head.data.length ? (T = d.head.data.slice(0, v), d.head.data = d.head.data.slice(v)) : v === d.head.data.length ? T = d.shift() : T = $ ? j(v, d) : K(v, d), T;
  }
  function j(v, d) {
    var $ = d.head, T = 1, G = $.data;
    for (v -= G.length; $ = $.next; ) {
      var W = $.data, X = v > W.length ? W.length : v;
      if (X === W.length ? G += W : G += W.slice(0, v), v -= X, v === 0) {
        X === W.length ? (++T, $.next ? d.head = $.next : d.head = d.tail = null) : (d.head = $, $.data = W.slice(X));
        break;
      }
      ++T;
    }
    return d.length -= T, G;
  }
  function K(v, d) {
    var $ = a.allocUnsafe(v), T = d.head, G = 1;
    for (T.data.copy($), v -= T.data.length; T = T.next; ) {
      var W = T.data, X = v > W.length ? W.length : v;
      if (W.copy($, $.length - v, 0, X), v -= X, v === 0) {
        X === W.length ? (++G, T.next ? d.head = T.next : d.head = d.tail = null) : (d.head = T, T.data = W.slice(X));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        break;
      }
      ++c;
    }
<<<<<<< HEAD
    list.length -= c;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf2(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform2;
  var Duplex = require_stream_duplex();
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  util2.inherits(Transform2, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2)) return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream2, er, data) {
    if (er) return stream2.emit("error", er);
    if (data != null)
      stream2.push(data);
    if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough2;
  var Transform2 = require_stream_transform();
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough2, Transform2);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2)) return new PassThrough2(options);
    Transform2.call(this, options);
  }
  PassThrough2.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
(function(module, exports) {
  var Stream2 = require$$1$2;
  if (process.env.READABLE_STREAM === "disable" && Stream2) {
    module.exports = Stream2;
    exports = module.exports = Stream2.Readable;
    exports.Readable = Stream2.Readable;
    exports.Writable = Stream2.Writable;
    exports.Duplex = Stream2.Duplex;
    exports.Transform = Stream2.Transform;
    exports.PassThrough = Stream2.PassThrough;
    exports.Stream = Stream2;
  } else {
    exports = module.exports = require_stream_readable();
    exports.Stream = Stream2 || exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
  }
})(readable, readable.exports);
var readableExports = readable.exports;
var duplex = readableExports.Duplex;
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module, exports) {
  var buffer2 = require$$0$5;
  var Buffer2 = buffer2.Buffer;
  function copyProps(src2, dst) {
    for (var key2 in src2) {
      dst[key2] = src2[key2];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer2;
  } else {
    copyProps(buffer2, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill2, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill2 !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill2, encoding);
      } else {
        buf.fill(fill2);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports;
var DuplexStream = duplex, util$8 = require$$1$3, Buffer$3 = safeBufferExports.Buffer;
function BufferList(callback) {
  if (!(this instanceof BufferList))
    return new BufferList(callback);
  this._bufs = [];
  this.length = 0;
  if (typeof callback == "function") {
    this._callback = callback;
    var piper = (function piper2(err) {
      if (this._callback) {
        this._callback(err);
        this._callback = null;
      }
=======
    return d.length -= G, $;
  }
  function Z(v) {
    var d = v._readableState;
    if (d.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    d.endEmitted || (d.ended = !0, e.nextTick(q, d, v));
  }
  function q(v, d) {
    !v.endEmitted && v.length === 0 && (v.endEmitted = !0, d.readable = !1, d.emit("end"));
  }
  function le(v, d) {
    for (var $ = 0, T = v.length; $ < T; $++)
      if (v[$] === d) return $;
    return -1;
  }
  return gc;
}
var bc, Gf;
function s1() {
  if (Gf) return bc;
  Gf = 1, bc = r;
  var e = Fr(), t = Object.create(Hi());
  t.inherits = Wi(), t.inherits(r, e);
  function n(s, c) {
    var o = this._transformState;
    o.transforming = !1;
    var u = o.writecb;
    if (!u)
      return this.emit("error", new Error("write callback called multiple times"));
    o.writechunk = null, o.writecb = null, c != null && this.push(c), u(s);
    var l = this._readableState;
    l.reading = !1, (l.needReadable || l.length < l.highWaterMark) && this._read(l.highWaterMark);
  }
  function r(s) {
    if (!(this instanceof r)) return new r(s);
    e.call(this, s), this._transformState = {
      afterTransform: n.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, s && (typeof s.transform == "function" && (this._transform = s.transform), typeof s.flush == "function" && (this._flush = s.flush)), this.on("prefinish", i);
  }
  function i() {
    var s = this;
    typeof this._flush == "function" ? this._flush(function(c, o) {
      a(s, c, o);
    }) : a(this, null, null);
  }
  r.prototype.push = function(s, c) {
    return this._transformState.needTransform = !1, e.prototype.push.call(this, s, c);
  }, r.prototype._transform = function(s, c, o) {
    throw new Error("_transform() is not implemented");
  }, r.prototype._write = function(s, c, o) {
    var u = this._transformState;
    if (u.writecb = o, u.writechunk = s, u.writeencoding = c, !u.transforming) {
      var l = this._readableState;
      (u.needTransform || l.needReadable || l.length < l.highWaterMark) && this._read(l.highWaterMark);
    }
  }, r.prototype._read = function(s) {
    var c = this._transformState;
    c.writechunk !== null && c.writecb && !c.transforming ? (c.transforming = !0, this._transform(c.writechunk, c.writeencoding, c.afterTransform)) : c.needTransform = !0;
  }, r.prototype._destroy = function(s, c) {
    var o = this;
    e.prototype._destroy.call(this, s, function(u) {
      c(u), o.emit("close");
    });
  };
  function a(s, c, o) {
    if (c) return s.emit("error", c);
    if (o != null && s.push(o), s._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (s._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return s.push(null);
  }
  return bc;
}
var xc, Vf;
function Q4() {
  if (Vf) return xc;
  Vf = 1, xc = n;
  var e = s1(), t = Object.create(Hi());
  t.inherits = Wi(), t.inherits(n, e);
  function n(r) {
    if (!(this instanceof n)) return new n(r);
    e.call(this, r);
  }
  return n.prototype._transform = function(r, i, a) {
    a(null, r);
  }, xc;
}
(function(e, t) {
  var n = ae;
  process.env.READABLE_STREAM === "disable" && n ? (e.exports = n, t = e.exports = n.Readable, t.Readable = n.Readable, t.Writable = n.Writable, t.Duplex = n.Duplex, t.Transform = n.Transform, t.PassThrough = n.PassThrough, t.Stream = n) : (t = e.exports = a1(), t.Stream = n || t, t.Readable = t, t.Writable = i1(), t.Duplex = Fr(), t.Transform = s1(), t.PassThrough = Q4());
})(Il, Il.exports);
var Gi = Il.exports, eE = Gi.Duplex, Dl = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
  var n = Bt, r = n.Buffer;
  function i(s, c) {
    for (var o in s)
      c[o] = s[o];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? e.exports = n : (i(n, t), t.Buffer = a);
  function a(s, c, o) {
    return r(s, c, o);
  }
  a.prototype = Object.create(r.prototype), i(r, a), a.from = function(s, c, o) {
    if (typeof s == "number")
      throw new TypeError("Argument must not be a number");
    return r(s, c, o);
  }, a.alloc = function(s, c, o) {
    if (typeof s != "number")
      throw new TypeError("Argument must be a number");
    var u = r(s);
    return c !== void 0 ? typeof o == "string" ? u.fill(c, o) : u.fill(c) : u.fill(0), u;
  }, a.allocUnsafe = function(s) {
    if (typeof s != "number")
      throw new TypeError("Argument must be a number");
    return r(s);
  }, a.allocUnsafeSlow = function(s) {
    if (typeof s != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(s);
  };
})(Dl, Dl.exports);
var o1 = Dl.exports, _u = eE, tE = De, gr = o1.Buffer;
function _e(e) {
  if (!(this instanceof _e))
    return new _e(e);
  if (this._bufs = [], this.length = 0, typeof e == "function") {
    this._callback = e;
    var t = (function(r) {
      this._callback && (this._callback(r), this._callback = null);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }).bind(this);
    this.on("pipe", function onPipe(src2) {
      src2.on("error", piper);
    });
<<<<<<< HEAD
    this.on("unpipe", function onUnpipe(src2) {
      src2.removeListener("error", piper);
    });
  } else {
    this.append(callback);
  }
  DuplexStream.call(this);
}
util$8.inherits(BufferList, DuplexStream);
BufferList.prototype._offset = function _offset(offset) {
  var tot = 0, i = 0, _t;
  if (offset === 0) return [0, 0];
  for (; i < this._bufs.length; i++) {
    _t = tot + this._bufs[i].length;
    if (offset < _t || i == this._bufs.length - 1)
      return [i, offset - tot];
    tot = _t;
  }
};
BufferList.prototype.append = function append2(buf) {
  var i = 0;
  if (Buffer$3.isBuffer(buf)) {
    this._appendBuffer(buf);
  } else if (Array.isArray(buf)) {
    for (; i < buf.length; i++)
      this.append(buf[i]);
  } else if (buf instanceof BufferList) {
    for (; i < buf._bufs.length; i++)
      this.append(buf._bufs[i]);
  } else if (buf != null) {
    if (typeof buf == "number")
      buf = buf.toString();
    this._appendBuffer(Buffer$3.from(buf));
  }
=======
  } else
    this.append(e);
  _u.call(this);
}
tE.inherits(_e, _u);
_e.prototype._offset = function(t) {
  var n = 0, r = 0, i;
  if (t === 0) return [0, 0];
  for (; r < this._bufs.length; r++) {
    if (i = n + this._bufs[r].length, t < i || r == this._bufs.length - 1)
      return [r, t - n];
    n = i;
  }
};
_e.prototype.append = function(t) {
  var n = 0;
  if (gr.isBuffer(t))
    this._appendBuffer(t);
  else if (Array.isArray(t))
    for (; n < t.length; n++)
      this.append(t[n]);
  else if (t instanceof _e)
    for (; n < t._bufs.length; n++)
      this.append(t._bufs[n]);
  else t != null && (typeof t == "number" && (t = t.toString()), this._appendBuffer(gr.from(t)));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  return this;
};
BufferList.prototype._appendBuffer = function appendBuffer(buf) {
  this._bufs.push(buf);
  this.length += buf.length;
};
BufferList.prototype._write = function _write(buf, encoding, callback) {
  this._appendBuffer(buf);
  if (typeof callback == "function")
    callback();
};
BufferList.prototype._read = function _read(size) {
  if (!this.length)
    return this.push(null);
  size = Math.min(size, this.length);
  this.push(this.slice(0, size));
  this.consume(size);
};
<<<<<<< HEAD
BufferList.prototype.end = function end(chunk) {
  DuplexStream.prototype.end.call(this, chunk);
  if (this._callback) {
    this._callback(null, this.slice());
    this._callback = null;
  }
};
BufferList.prototype.get = function get2(index) {
  return this.slice(index, index + 1)[0];
};
BufferList.prototype.slice = function slice(start, end2) {
  if (typeof start == "number" && start < 0)
    start += this.length;
  if (typeof end2 == "number" && end2 < 0)
    end2 += this.length;
  return this.copy(null, 0, start, end2);
};
BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart != "number" || srcStart < 0)
    srcStart = 0;
  if (typeof srcEnd != "number" || srcEnd > this.length)
    srcEnd = this.length;
  if (srcStart >= this.length)
    return dst || Buffer$3.alloc(0);
  if (srcEnd <= 0)
    return dst || Buffer$3.alloc(0);
  var copy3 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy3 && dstStart || 0, start = off[1], l, i;
  if (srcStart === 0 && srcEnd == this.length) {
    if (!copy3) {
      return this._bufs.length === 1 ? this._bufs[0] : Buffer$3.concat(this._bufs, this.length);
    }
    for (i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff);
      bufoff += this._bufs[i].length;
    }
    return dst;
  }
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy3 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
  }
  if (!copy3)
    dst = Buffer$3.allocUnsafe(len);
  for (i = off[0]; i < this._bufs.length; i++) {
    l = this._bufs[i].length - start;
    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start);
      bufoff += l;
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes);
      bufoff += l;
      break;
    }
    bytes -= l;
    if (start)
      start = 0;
=======
_e.prototype.end = function(t) {
  _u.prototype.end.call(this, t), this._callback && (this._callback(null, this.slice()), this._callback = null);
};
_e.prototype.get = function(t) {
  return this.slice(t, t + 1)[0];
};
_e.prototype.slice = function(t, n) {
  return typeof t == "number" && t < 0 && (t += this.length), typeof n == "number" && n < 0 && (n += this.length), this.copy(null, 0, t, n);
};
_e.prototype.copy = function(t, n, r, i) {
  if ((typeof r != "number" || r < 0) && (r = 0), (typeof i != "number" || i > this.length) && (i = this.length), r >= this.length || i <= 0)
    return t || gr.alloc(0);
  var a = !!t, s = this._offset(r), c = i - r, o = c, u = a && n || 0, l = s[1], p, f;
  if (r === 0 && i == this.length) {
    if (!a)
      return this._bufs.length === 1 ? this._bufs[0] : gr.concat(this._bufs, this.length);
    for (f = 0; f < this._bufs.length; f++)
      this._bufs[f].copy(t, u), u += this._bufs[f].length;
    return t;
  }
  if (o <= this._bufs[s[0]].length - l)
    return a ? this._bufs[s[0]].copy(t, n, l, l + o) : this._bufs[s[0]].slice(l, l + o);
  for (a || (t = gr.allocUnsafe(c)), f = s[0]; f < this._bufs.length; f++) {
    if (p = this._bufs[f].length - l, o > p)
      this._bufs[f].copy(t, u, l), u += p;
    else {
      this._bufs[f].copy(t, u, l, l + o), u += p;
      break;
    }
    o -= p, l && (l = 0);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  if (dst.length > bufoff) return dst.slice(0, bufoff);
  return dst;
};
BufferList.prototype.shallowSlice = function shallowSlice(start, end2) {
  start = start || 0;
  end2 = end2 || this.length;
  if (start < 0)
    start += this.length;
  if (end2 < 0)
    end2 += this.length;
  var startOffset = this._offset(start), endOffset = this._offset(end2), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
  if (endOffset[1] == 0)
    buffers.pop();
  else
    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
  if (startOffset[1] != 0)
    buffers[0] = buffers[0].slice(startOffset[1]);
  return new BufferList(buffers);
};
BufferList.prototype.toString = function toString2(encoding, start, end2) {
  return this.slice(start, end2).toString(encoding);
};
BufferList.prototype.consume = function consume(bytes) {
  bytes = Math.trunc(bytes);
  if (Number.isNaN(bytes) || bytes <= 0) return this;
  while (this._bufs.length) {
    if (bytes >= this._bufs[0].length) {
      bytes -= this._bufs[0].length;
      this.length -= this._bufs[0].length;
      this._bufs.shift();
    } else {
      this._bufs[0] = this._bufs[0].slice(bytes);
      this.length -= bytes;
      break;
    }
  }
  return this;
};
BufferList.prototype.duplicate = function duplicate() {
  var i = 0, copy3 = new BufferList();
  for (; i < this._bufs.length; i++)
    copy3.append(this._bufs[i]);
  return copy3;
};
BufferList.prototype.destroy = function destroy2() {
  this._bufs.length = 0;
  this.length = 0;
  this.push(null);
};
(function() {
  var methods = {
    "readDoubleBE": 8,
    "readDoubleLE": 8,
    "readFloatBE": 4,
    "readFloatLE": 4,
    "readInt32BE": 4,
    "readInt32LE": 4,
    "readUInt32BE": 4,
    "readUInt32LE": 4,
    "readInt16BE": 2,
    "readInt16LE": 2,
    "readUInt16BE": 2,
    "readUInt16LE": 2,
    "readInt8": 1,
    "readUInt8": 1
  };
  for (var m in methods) {
    (function(m2) {
      BufferList.prototype[m2] = function(offset) {
        return this.slice(offset, offset + methods[m2])[m2](0);
      };
    })(m);
  }
})();
<<<<<<< HEAD
var bl$1 = BufferList;
var immutable = extend$1;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function extend$1() {
  var target = {};
  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key2 in source) {
      if (hasOwnProperty.call(source, key2)) {
        target[key2] = source[key2];
      }
    }
  }
  return target;
}
var headers$2 = {};
var toString$1 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$1.call(arr) == "[object Array]";
};
var Buffer$2 = safeBufferExports.Buffer;
var isArray = isarray;
var useUint8Array = typeof Uint8Array !== "undefined";
var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && ArrayBuffer.isView && (Buffer$2.prototype instanceof Uint8Array || Buffer$2.TYPED_ARRAY_SUPPORT);
var toBuffer$2 = function toBuffer(data, encoding) {
  if (data instanceof Buffer$2) {
    return data;
  }
  if (typeof data === "string") {
    return Buffer$2.from(data, encoding);
  }
  if (useArrayBuffer && ArrayBuffer.isView(data)) {
    if (data.byteLength === 0) {
      return Buffer$2.alloc(0);
    }
    var res = Buffer$2.from(data.buffer, data.byteOffset, data.byteLength);
    if (res.byteLength === data.byteLength) {
      return res;
    }
  }
  if (useUint8Array && data instanceof Uint8Array) {
    return Buffer$2.from(data);
  }
  var isArr = isArray(data);
  if (isArr) {
    for (var i = 0; i < data.length; i += 1) {
      var x = data[i];
      if (typeof x !== "number" || x < 0 || x > 255 || ~~x !== x) {
        throw new RangeError("Array items must be numbers in the range 0-255.");
      }
    }
  }
  if (isArr || Buffer$2.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data)) {
    return Buffer$2.from(data);
  }
  throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a TypedArray, or a DataView.');
};
var hasFullSupport = function() {
=======
var nE = _e, rE = aE, iE = Object.prototype.hasOwnProperty;
function aE() {
  for (var e = {}, t = 0; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      iE.call(n, r) && (e[r] = n[r]);
  }
  return e;
}
var Kn = {}, sE = {}.toString, oE = Array.isArray || function(e) {
  return sE.call(e) == "[object Array]";
}, Nt = o1.Buffer, cE = oE, lE = typeof Uint8Array < "u", uE = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (Nt.prototype instanceof Uint8Array || Nt.TYPED_ARRAY_SUPPORT), c1 = function(t, n) {
  if (t instanceof Nt)
    return t;
  if (typeof t == "string")
    return Nt.from(t, n);
  if (uE && ArrayBuffer.isView(t)) {
    if (t.byteLength === 0)
      return Nt.alloc(0);
    var r = Nt.from(t.buffer, t.byteOffset, t.byteLength);
    if (r.byteLength === t.byteLength)
      return r;
  }
  if (lE && t instanceof Uint8Array)
    return Nt.from(t);
  var i = cE(t);
  if (i)
    for (var a = 0; a < t.length; a += 1) {
      var s = t[a];
      if (typeof s != "number" || s < 0 || s > 255 || ~~s !== s)
        throw new RangeError("Array items must be numbers in the range 0-255.");
    }
  if (i || Nt.isBuffer(t) && t.constructor && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t))
    return Nt.from(t);
  throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a TypedArray, or a DataView.');
}, pE = function() {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  try {
    if (!Buffer.isEncoding("latin1")) {
      return false;
    }
    var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
    buf.fill("ab", "ucs2");
    return buf.toString("hex") === "61006200";
  } catch (_) {
    return false;
  }
}();
<<<<<<< HEAD
function isSingleByte(val) {
  return val.length === 1 && val.charCodeAt(0) < 256;
}
function fillWithNumber(buffer2, val, start, end2) {
  if (start < 0 || end2 > buffer2.length) {
    throw new RangeError("Out of range index");
  }
  start = start >>> 0;
  end2 = end2 === void 0 ? buffer2.length : end2 >>> 0;
  if (end2 > start) {
    buffer2.fill(val, start, end2);
  }
  return buffer2;
}
function fillWithBuffer(buffer2, val, start, end2) {
  if (start < 0 || end2 > buffer2.length) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start) {
    return buffer2;
  }
  start = start >>> 0;
  end2 = end2 === void 0 ? buffer2.length : end2 >>> 0;
  var pos = start;
  var len = val.length;
  while (pos <= end2 - len) {
    val.copy(buffer2, pos);
    pos += len;
  }
  if (pos !== end2) {
    val.copy(buffer2, pos, 0, end2 - pos);
  }
  return buffer2;
}
function fill(buffer2, val, start, end2, encoding) {
  if (hasFullSupport) {
    return buffer2.fill(val, start, end2, encoding);
  }
  if (typeof val === "number") {
    return fillWithNumber(buffer2, val, start, end2);
  }
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end2 = buffer2.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = buffer2.length;
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (encoding === "latin1") {
      encoding = "binary";
    }
    if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val === "") {
      return fillWithNumber(buffer2, 0, start, end2);
    }
    if (isSingleByte(val)) {
      return fillWithNumber(buffer2, val.charCodeAt(0), start, end2);
    }
    val = new Buffer(val, encoding);
  }
  if (Buffer.isBuffer(val)) {
    return fillWithBuffer(buffer2, val, start, end2);
  }
  return fillWithNumber(buffer2, 0, start, end2);
}
var bufferFill$1 = fill;
function allocUnsafe$1(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  }
  if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
  if (Buffer.allocUnsafe) {
    return Buffer.allocUnsafe(size);
  } else {
    return new Buffer(size);
  }
}
var bufferAllocUnsafe = allocUnsafe$1;
var bufferFill = bufferFill$1;
var allocUnsafe = bufferAllocUnsafe;
var bufferAlloc = function alloc(size, fill2, encoding) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  }
  if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
  if (Buffer.alloc) {
    return Buffer.alloc(size, fill2, encoding);
  }
  var buffer2 = allocUnsafe(size);
  if (size === 0) {
    return buffer2;
  }
  if (fill2 === void 0) {
    return bufferFill(buffer2, 0);
  }
  if (typeof encoding !== "string") {
    encoding = void 0;
  }
  return bufferFill(buffer2, fill2, encoding);
};
var toBuffer$1 = toBuffer$2;
var alloc$1 = bufferAlloc;
var ZEROS = "0000000000000000000";
var SEVENS = "7777777777777777777";
var ZERO_OFFSET = "0".charCodeAt(0);
var USTAR = "ustar\x0000";
var MASK = parseInt("7777", 8);
var clamp = function(index, len, defaultValue) {
  if (typeof index !== "number") return defaultValue;
  index = ~~index;
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
};
var toType = function(flag) {
  switch (flag) {
=======
function fE(e) {
  return e.length === 1 && e.charCodeAt(0) < 256;
}
function Sa(e, t, n, r) {
  if (n < 0 || r > e.length)
    throw new RangeError("Out of range index");
  return n = n >>> 0, r = r === void 0 ? e.length : r >>> 0, r > n && e.fill(t, n, r), e;
}
function dE(e, t, n, r) {
  if (n < 0 || r > e.length)
    throw new RangeError("Out of range index");
  if (r <= n)
    return e;
  n = n >>> 0, r = r === void 0 ? e.length : r >>> 0;
  for (var i = n, a = t.length; i <= r - a; )
    t.copy(e, i), i += a;
  return i !== r && t.copy(e, i, 0, r - i), e;
}
function hE(e, t, n, r, i) {
  if (pE)
    return e.fill(t, n, r, i);
  if (typeof t == "number")
    return Sa(e, t, n, r);
  if (typeof t == "string") {
    if (typeof n == "string" ? (i = n, n = 0, r = e.length) : typeof r == "string" && (i = r, r = e.length), i !== void 0 && typeof i != "string")
      throw new TypeError("encoding must be a string");
    if (i === "latin1" && (i = "binary"), typeof i == "string" && !Buffer.isEncoding(i))
      throw new TypeError("Unknown encoding: " + i);
    if (t === "")
      return Sa(e, 0, n, r);
    if (fE(t))
      return Sa(e, t.charCodeAt(0), n, r);
    t = new Buffer(t, i);
  }
  return Buffer.isBuffer(t) ? dE(e, t, n, r) : Sa(e, 0, n, r);
}
var mE = hE;
function vE(e) {
  if (typeof e != "number")
    throw new TypeError('"size" argument must be a number');
  if (e < 0)
    throw new RangeError('"size" argument must not be negative');
  return Buffer.allocUnsafe ? Buffer.allocUnsafe(e) : new Buffer(e);
}
var gE = vE, Yf = mE, bE = gE, l1 = function(t, n, r) {
  if (typeof t != "number")
    throw new TypeError('"size" argument must be a number');
  if (t < 0)
    throw new RangeError('"size" argument must not be negative');
  if (Buffer.alloc)
    return Buffer.alloc(t, n, r);
  var i = bE(t);
  return t === 0 ? i : n === void 0 ? Yf(i, 0) : (typeof r != "string" && (r = void 0), Yf(i, n, r));
}, xE = c1, yE = l1, wE = "0000000000000000000", EE = "7777777777777777777", u1 = 48, _E = "ustar\x0000", SE = parseInt("7777", 8), AE = function(e, t, n) {
  return typeof e != "number" ? n : (e = ~~e, e >= t ? t : e >= 0 || (e += t, e >= 0) ? e : 0);
}, TE = function(e) {
  switch (e) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    case 0:
      return "file";
    case 1:
      return "link";
    case 2:
      return "symlink";
    case 3:
      return "character-device";
    case 4:
      return "block-device";
    case 5:
      return "directory";
    case 6:
      return "fifo";
    case 7:
      return "contiguous-file";
    case 72:
      return "pax-header";
    case 55:
      return "pax-global-header";
    case 27:
      return "gnu-long-link-path";
    case 28:
    case 30:
      return "gnu-long-path";
  }
  return null;
<<<<<<< HEAD
};
var toTypeflag = function(flag) {
  switch (flag) {
=======
}, CE = function(e) {
  switch (e) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    case "file":
      return 0;
    case "link":
      return 1;
    case "symlink":
      return 2;
    case "character-device":
      return 3;
    case "block-device":
      return 4;
    case "directory":
      return 5;
    case "fifo":
      return 6;
    case "contiguous-file":
      return 7;
    case "pax-header":
      return 72;
  }
  return 0;
<<<<<<< HEAD
};
var indexOf = function(block, num, offset, end2) {
  for (; offset < end2; offset++) {
    if (block[offset] === num) return offset;
  }
  return end2;
};
var cksum = function(block) {
  var sum = 8 * 32;
  for (var i = 0; i < 148; i++) sum += block[i];
  for (var j = 156; j < 512; j++) sum += block[j];
  return sum;
};
var encodeOct = function(val, n) {
  val = val.toString(8);
  if (val.length > n) return SEVENS.slice(0, n) + " ";
  else return ZEROS.slice(0, n - val.length) + val + " ";
};
function parse256(buf) {
  var positive;
  if (buf[0] === 128) positive = true;
  else if (buf[0] === 255) positive = false;
=======
}, p1 = function(e, t, n, r) {
  for (; n < r; n++)
    if (e[n] === t) return n;
  return r;
}, f1 = function(e) {
  for (var t = 256, n = 0; n < 148; n++) t += e[n];
  for (var r = 156; r < 512; r++) t += e[r];
  return t;
}, Kt = function(e, t) {
  return e = e.toString(8), e.length > t ? EE.slice(0, t) + " " : wE.slice(0, t - e.length) + e + " ";
};
function RE(e) {
  var t;
  if (e[0] === 128) t = !0;
  else if (e[0] === 255) t = !1;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  else return null;
  var tuple = [];
  for (var i = buf.length - 1; i > 0; i--) {
    var byte = buf[i];
    if (positive) tuple.push(byte);
    else tuple.push(255 - byte);
  }
<<<<<<< HEAD
  var sum = 0;
  var l = tuple.length;
  for (i = 0; i < l; i++) {
    sum += tuple[i] * Math.pow(256, i);
  }
  return positive ? sum : -1 * sum;
}
var decodeOct = function(val, offset, length) {
  val = val.slice(offset, offset + length);
  offset = 0;
  if (val[offset] & 128) {
    return parse256(val);
  } else {
    while (offset < val.length && val[offset] === 32) offset++;
    var end2 = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
    while (offset < end2 && val[offset] === 0) offset++;
    if (end2 === offset) return 0;
    return parseInt(val.slice(offset, end2).toString(), 8);
=======
  var a = 0, s = n.length;
  for (r = 0; r < s; r++)
    a += n[r] * Math.pow(256, r);
  return t ? a : -1 * a;
}
var Jt = function(e, t, n) {
  if (e = e.slice(t, t + n), t = 0, e[t] & 128)
    return RE(e);
  for (; t < e.length && e[t] === 32; ) t++;
  for (var r = AE(p1(e, 32, t, e.length), e.length, e.length); t < r && e[t] === 0; ) t++;
  return r === t ? 0 : parseInt(e.slice(t, r).toString(), 8);
}, dr = function(e, t, n, r) {
  return e.slice(t, p1(e, 0, t, t + n)).toString(r);
}, yc = function(e) {
  var t = Buffer.byteLength(e), n = Math.floor(Math.log(t) / Math.log(10)) + 1;
  return t + n >= Math.pow(10, n) && n++, t + n + e;
};
Kn.decodeLongPath = function(e, t) {
  return dr(e, 0, e.length, t);
};
Kn.encodePax = function(e) {
  var t = "";
  e.name && (t += yc(" path=" + e.name + `
`)), e.linkname && (t += yc(" linkpath=" + e.linkname + `
`));
  var n = e.pax;
  if (n)
    for (var r in n)
      t += yc(" " + r + "=" + n[r] + `
`);
  return xE(t);
};
Kn.decodePax = function(e) {
  for (var t = {}; e.length; ) {
    for (var n = 0; n < e.length && e[n] !== 32; ) n++;
    var r = parseInt(e.slice(0, n).toString(), 10);
    if (!r) return t;
    var i = e.slice(n + 1, r - 1).toString(), a = i.indexOf("=");
    if (a === -1) return t;
    t[i.slice(0, a)] = i.slice(a + 1), e = e.slice(r);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
};
<<<<<<< HEAD
var decodeStr = function(val, offset, length, encoding) {
  return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
};
var addLength = function(str2) {
  var len = Buffer.byteLength(str2);
  var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
  if (len + digits >= Math.pow(10, digits)) digits++;
  return len + digits + str2;
};
headers$2.decodeLongPath = function(buf, encoding) {
  return decodeStr(buf, 0, buf.length, encoding);
};
headers$2.encodePax = function(opts) {
  var result = "";
  if (opts.name) result += addLength(" path=" + opts.name + "\n");
  if (opts.linkname) result += addLength(" linkpath=" + opts.linkname + "\n");
  var pax = opts.pax;
  if (pax) {
    for (var key2 in pax) {
      result += addLength(" " + key2 + "=" + pax[key2] + "\n");
    }
  }
  return toBuffer$1(result);
};
headers$2.decodePax = function(buf) {
  var result = {};
  while (buf.length) {
    var i = 0;
    while (i < buf.length && buf[i] !== 32) i++;
    var len = parseInt(buf.slice(0, i).toString(), 10);
    if (!len) return result;
    var b = buf.slice(i + 1, len - 1).toString();
    var keyIndex = b.indexOf("=");
    if (keyIndex === -1) return result;
    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
    buf = buf.slice(len);
  }
  return result;
};
headers$2.encode = function(opts) {
  var buf = alloc$1(512);
  var name = opts.name;
  var prefix = "";
  if (opts.typeflag === 5 && name[name.length - 1] !== "/") name += "/";
  if (Buffer.byteLength(name) !== name.length) return null;
  while (Buffer.byteLength(name) > 100) {
    var i = name.indexOf("/");
=======
Kn.encode = function(e) {
  var t = yE(512), n = e.name, r = "";
  if (e.typeflag === 5 && n[n.length - 1] !== "/" && (n += "/"), Buffer.byteLength(n) !== n.length) return null;
  for (; Buffer.byteLength(n) > 100; ) {
    var i = n.indexOf("/");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    if (i === -1) return null;
    prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
    name = name.slice(i + 1);
  }
<<<<<<< HEAD
  if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null;
  if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null;
  buf.write(name);
  buf.write(encodeOct(opts.mode & MASK, 6), 100);
  buf.write(encodeOct(opts.uid, 6), 108);
  buf.write(encodeOct(opts.gid, 6), 116);
  buf.write(encodeOct(opts.size, 11), 124);
  buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
  buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
  if (opts.linkname) buf.write(opts.linkname, 157);
  buf.write(USTAR, 257);
  if (opts.uname) buf.write(opts.uname, 265);
  if (opts.gname) buf.write(opts.gname, 297);
  buf.write(encodeOct(opts.devmajor || 0, 6), 329);
  buf.write(encodeOct(opts.devminor || 0, 6), 337);
  if (prefix) buf.write(prefix, 345);
  buf.write(encodeOct(cksum(buf), 6), 148);
  return buf;
};
headers$2.decode = function(buf, filenameEncoding) {
  var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
  var name = decodeStr(buf, 0, 100, filenameEncoding);
  var mode = decodeOct(buf, 100, 8);
  var uid = decodeOct(buf, 108, 8);
  var gid = decodeOct(buf, 116, 8);
  var size = decodeOct(buf, 124, 12);
  var mtime = decodeOct(buf, 136, 12);
  var type2 = toType(typeflag);
  var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
  var uname = decodeStr(buf, 265, 32);
  var gname = decodeStr(buf, 297, 32);
  var devmajor = decodeOct(buf, 329, 8);
  var devminor = decodeOct(buf, 337, 8);
  if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
  if (typeflag === 0 && name && name[name.length - 1] === "/") typeflag = 5;
  var c = cksum(buf);
  if (c === 8 * 32) return null;
  if (c !== decodeOct(buf, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
  return {
    name,
    mode,
    uid,
    gid,
    size,
    mtime: new Date(1e3 * mtime),
    type: type2,
    linkname,
    uname,
    gname,
    devmajor,
    devminor
  };
};
var util$7 = require$$1$3;
var bl = bl$1;
var xtend = immutable;
var headers$1 = headers$2;
var Writable$4 = readableExports.Writable;
var PassThrough$2 = readableExports.PassThrough;
var noop$2 = function() {
};
var overflow$1 = function(size) {
  size &= 511;
  return size && 512 - size;
};
var emptyStream = function(self2, offset) {
  var s = new Source(self2, offset);
  s.end();
  return s;
};
var mixinPax = function(header, pax) {
  if (pax.path) header.name = pax.path;
  if (pax.linkpath) header.linkname = pax.linkpath;
  if (pax.size) header.size = parseInt(pax.size, 10);
  header.pax = pax;
  return header;
};
var Source = function(self2, offset) {
  this._parent = self2;
  this.offset = offset;
  PassThrough$2.call(this);
};
util$7.inherits(Source, PassThrough$2);
Source.prototype.destroy = function(err) {
  this._parent.destroy(err);
};
var Extract = function(opts) {
  if (!(this instanceof Extract)) return new Extract(opts);
  Writable$4.call(this, opts);
  opts = opts || {};
  this._offset = 0;
  this._buffer = bl();
  this._missing = 0;
  this._partial = false;
  this._onparse = noop$2;
  this._header = null;
  this._stream = null;
  this._overflow = null;
  this._cb = null;
  this._locked = false;
  this._destroyed = false;
  this._pax = null;
  this._paxGlobal = null;
  this._gnuLongPath = null;
  this._gnuLongLinkPath = null;
  var self2 = this;
  var b = self2._buffer;
  var oncontinue = function() {
    self2._continue();
  };
  var onunlock = function(err) {
    self2._locked = false;
    if (err) return self2.destroy(err);
    if (!self2._stream) oncontinue();
  };
  var onstreamend = function() {
    self2._stream = null;
    var drain = overflow$1(self2._header.size);
    if (drain) self2._parse(drain, ondrain);
    else self2._parse(512, onheader);
    if (!self2._locked) oncontinue();
  };
  var ondrain = function() {
    self2._buffer.consume(overflow$1(self2._header.size));
    self2._parse(512, onheader);
    oncontinue();
  };
  var onpaxglobalheader = function() {
    var size = self2._header.size;
    self2._paxGlobal = headers$1.decodePax(b.slice(0, size));
    b.consume(size);
    onstreamend();
  };
  var onpaxheader = function() {
    var size = self2._header.size;
    self2._pax = headers$1.decodePax(b.slice(0, size));
    if (self2._paxGlobal) self2._pax = xtend(self2._paxGlobal, self2._pax);
    b.consume(size);
    onstreamend();
  };
  var ongnulongpath = function() {
    var size = self2._header.size;
    this._gnuLongPath = headers$1.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
    b.consume(size);
    onstreamend();
  };
  var ongnulonglinkpath = function() {
    var size = self2._header.size;
    this._gnuLongLinkPath = headers$1.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
    b.consume(size);
    onstreamend();
  };
  var onheader = function() {
    var offset = self2._offset;
    var header;
    try {
      header = self2._header = headers$1.decode(b.slice(0, 512), opts.filenameEncoding);
    } catch (err) {
      self2.emit("error", err);
=======
  return Buffer.byteLength(n) > 100 || Buffer.byteLength(r) > 155 || e.linkname && Buffer.byteLength(e.linkname) > 100 ? null : (t.write(n), t.write(Kt(e.mode & SE, 6), 100), t.write(Kt(e.uid, 6), 108), t.write(Kt(e.gid, 6), 116), t.write(Kt(e.size, 11), 124), t.write(Kt(e.mtime.getTime() / 1e3 | 0, 11), 136), t[156] = u1 + CE(e.type), e.linkname && t.write(e.linkname, 157), t.write(_E, 257), e.uname && t.write(e.uname, 265), e.gname && t.write(e.gname, 297), t.write(Kt(e.devmajor || 0, 6), 329), t.write(Kt(e.devminor || 0, 6), 337), r && t.write(r, 345), t.write(Kt(f1(t), 6), 148), t);
};
Kn.decode = function(e, t) {
  var n = e[156] === 0 ? 0 : e[156] - u1, r = dr(e, 0, 100, t), i = Jt(e, 100, 8), a = Jt(e, 108, 8), s = Jt(e, 116, 8), c = Jt(e, 124, 12), o = Jt(e, 136, 12), u = TE(n), l = e[157] === 0 ? null : dr(e, 157, 100, t), p = dr(e, 265, 32), f = dr(e, 297, 32), m = Jt(e, 329, 8), g = Jt(e, 337, 8);
  e[345] && (r = dr(e, 345, 155, t) + "/" + r), n === 0 && r && r[r.length - 1] === "/" && (n = 5);
  var h = f1(e);
  if (h === 8 * 32) return null;
  if (h !== Jt(e, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
  return {
    name: r,
    mode: i,
    uid: a,
    gid: s,
    size: c,
    mtime: new Date(1e3 * o),
    type: u,
    linkname: l,
    uname: p,
    gname: f,
    devmajor: m,
    devminor: g
  };
};
var d1 = De, $E = nE, OE = rE, Jr = Kn, h1 = Gi.Writable, m1 = Gi.PassThrough, v1 = function() {
}, Xf = function(e) {
  return e &= 511, e && 512 - e;
}, IE = function(e, t) {
  var n = new Xs(e, t);
  return n.end(), n;
}, DE = function(e, t) {
  return t.path && (e.name = t.path), t.linkpath && (e.linkname = t.linkpath), t.size && (e.size = parseInt(t.size, 10)), e.pax = t, e;
}, Xs = function(e, t) {
  this._parent = e, this.offset = t, m1.call(this);
};
d1.inherits(Xs, m1);
Xs.prototype.destroy = function(e) {
  this._parent.destroy(e);
};
var jt = function(e) {
  if (!(this instanceof jt)) return new jt(e);
  h1.call(this, e), e = e || {}, this._offset = 0, this._buffer = $E(), this._missing = 0, this._partial = !1, this._onparse = v1, this._header = null, this._stream = null, this._overflow = null, this._cb = null, this._locked = !1, this._destroyed = !1, this._pax = null, this._paxGlobal = null, this._gnuLongPath = null, this._gnuLongLinkPath = null;
  var t = this, n = t._buffer, r = function() {
    t._continue();
  }, i = function(f) {
    if (t._locked = !1, f) return t.destroy(f);
    t._stream || r();
  }, a = function() {
    t._stream = null;
    var f = Xf(t._header.size);
    f ? t._parse(f, s) : t._parse(512, p), t._locked || r();
  }, s = function() {
    t._buffer.consume(Xf(t._header.size)), t._parse(512, p), r();
  }, c = function() {
    var f = t._header.size;
    t._paxGlobal = Jr.decodePax(n.slice(0, f)), n.consume(f), a();
  }, o = function() {
    var f = t._header.size;
    t._pax = Jr.decodePax(n.slice(0, f)), t._paxGlobal && (t._pax = OE(t._paxGlobal, t._pax)), n.consume(f), a();
  }, u = function() {
    var f = t._header.size;
    this._gnuLongPath = Jr.decodeLongPath(n.slice(0, f), e.filenameEncoding), n.consume(f), a();
  }, l = function() {
    var f = t._header.size;
    this._gnuLongLinkPath = Jr.decodeLongPath(n.slice(0, f), e.filenameEncoding), n.consume(f), a();
  }, p = function() {
    var f = t._offset, m;
    try {
      m = t._header = Jr.decode(n.slice(0, 512), e.filenameEncoding);
    } catch (g) {
      t.emit("error", g);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    b.consume(512);
    if (!header) {
      self2._parse(512, onheader);
      oncontinue();
      return;
    }
    if (header.type === "gnu-long-path") {
      self2._parse(header.size, ongnulongpath);
      oncontinue();
      return;
    }
    if (header.type === "gnu-long-link-path") {
      self2._parse(header.size, ongnulonglinkpath);
      oncontinue();
      return;
    }
    if (header.type === "pax-global-header") {
      self2._parse(header.size, onpaxglobalheader);
      oncontinue();
      return;
    }
<<<<<<< HEAD
    if (header.type === "pax-header") {
      self2._parse(header.size, onpaxheader);
      oncontinue();
      return;
    }
    if (self2._gnuLongPath) {
      header.name = self2._gnuLongPath;
      self2._gnuLongPath = null;
    }
    if (self2._gnuLongLinkPath) {
      header.linkname = self2._gnuLongLinkPath;
      self2._gnuLongLinkPath = null;
    }
    if (self2._pax) {
      self2._header = header = mixinPax(header, self2._pax);
      self2._pax = null;
    }
    self2._locked = true;
    if (!header.size || header.type === "directory") {
      self2._parse(512, onheader);
      self2.emit("entry", header, emptyStream(self2, offset), onunlock);
      return;
    }
    self2._stream = new Source(self2, offset);
    self2.emit("entry", header, self2._stream, onunlock);
    self2._parse(header.size, onstreamend);
    oncontinue();
=======
    if (m.type === "pax-header") {
      t._parse(m.size, o), r();
      return;
    }
    if (t._gnuLongPath && (m.name = t._gnuLongPath, t._gnuLongPath = null), t._gnuLongLinkPath && (m.linkname = t._gnuLongLinkPath, t._gnuLongLinkPath = null), t._pax && (t._header = m = DE(m, t._pax), t._pax = null), t._locked = !0, !m.size || m.type === "directory") {
      t._parse(512, p), t.emit("entry", m, IE(t, f), i);
      return;
    }
    t._stream = new Xs(t, f), t.emit("entry", m, t._stream, i), t._parse(m.size, a), r();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  };
  this._onheader = onheader;
  this._parse(512, onheader);
};
<<<<<<< HEAD
util$7.inherits(Extract, Writable$4);
Extract.prototype.destroy = function(err) {
  if (this._destroyed) return;
  this._destroyed = true;
  if (err) this.emit("error", err);
  this.emit("close");
  if (this._stream) this._stream.emit("close");
};
Extract.prototype._parse = function(size, onparse) {
  if (this._destroyed) return;
  this._offset += size;
  this._missing = size;
  if (onparse === this._onheader) this._partial = false;
  this._onparse = onparse;
};
Extract.prototype._continue = function() {
  if (this._destroyed) return;
  var cb = this._cb;
  this._cb = noop$2;
  if (this._overflow) this._write(this._overflow, void 0, cb);
  else cb();
};
Extract.prototype._write = function(data, enc, cb) {
  if (this._destroyed) return;
  var s = this._stream;
  var b = this._buffer;
  var missing = this._missing;
  if (data.length) this._partial = true;
  if (data.length < missing) {
    this._missing -= data.length;
    this._overflow = null;
    if (s) return s.write(data, cb);
    b.append(data);
    return cb();
  }
  this._cb = cb;
  this._missing = 0;
  var overflow2 = null;
  if (data.length > missing) {
    overflow2 = data.slice(missing);
    data = data.slice(0, missing);
=======
d1.inherits(jt, h1);
jt.prototype.destroy = function(e) {
  this._destroyed || (this._destroyed = !0, e && this.emit("error", e), this.emit("close"), this._stream && this._stream.emit("close"));
};
jt.prototype._parse = function(e, t) {
  this._destroyed || (this._offset += e, this._missing = e, t === this._onheader && (this._partial = !1), this._onparse = t);
};
jt.prototype._continue = function() {
  if (!this._destroyed) {
    var e = this._cb;
    this._cb = v1, this._overflow ? this._write(this._overflow, void 0, e) : e();
  }
};
jt.prototype._write = function(e, t, n) {
  if (!this._destroyed) {
    var r = this._stream, i = this._buffer, a = this._missing;
    if (e.length && (this._partial = !0), e.length < a)
      return this._missing -= e.length, this._overflow = null, r ? r.write(e, n) : (i.append(e), n());
    this._cb = n, this._missing = 0;
    var s = null;
    e.length > a && (s = e.slice(a), e = e.slice(0, a)), r ? r.end(e) : i.append(e), this._overflow = s, this._onparse();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  if (s) s.end(data);
  else b.append(data);
  this._overflow = overflow2;
  this._onparse();
};
<<<<<<< HEAD
Extract.prototype._final = function(cb) {
=======
jt.prototype._final = function(e) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  if (this._partial) return this.destroy(new Error("Unexpected end of data"));
  cb();
};
<<<<<<< HEAD
var extract = Extract;
var fsConstants = fs$w.constants || require$$1$6;
var constants$3 = fsConstants;
var eos = endOfStream;
var util$6 = require$$1$3;
var alloc2 = bufferAlloc;
var toBuffer2 = toBuffer$2;
var Readable$1 = readableExports.Readable;
var Writable$3 = readableExports.Writable;
var StringDecoder = require$$1$7.StringDecoder;
var headers = headers$2;
var DMODE = parseInt("755", 8);
var FMODE = parseInt("644", 8);
var END_OF_TAR = alloc2(1024);
var noop$1 = function() {
};
var overflow = function(self2, size) {
  size &= 511;
  if (size) self2.push(END_OF_TAR.slice(0, 512 - size));
};
function modeToType(mode) {
  switch (mode & constants$3.S_IFMT) {
    case constants$3.S_IFBLK:
      return "block-device";
    case constants$3.S_IFCHR:
      return "character-device";
    case constants$3.S_IFDIR:
      return "directory";
    case constants$3.S_IFIFO:
      return "fifo";
    case constants$3.S_IFLNK:
=======
var FE = jt, PE = se.constants || Rm, rr = PE, Kf = P0, Ks = De, kE = l1, LE = c1, g1 = Gi.Readable, jr = Gi.Writable, NE = Os.StringDecoder, Qa = Kn, UE = parseInt("755", 8), BE = parseInt("644", 8), b1 = kE(1024), Su = function() {
}, Fl = function(e, t) {
  t &= 511, t && e.push(b1.slice(0, 512 - t));
};
function jE(e) {
  switch (e & rr.S_IFMT) {
    case rr.S_IFBLK:
      return "block-device";
    case rr.S_IFCHR:
      return "character-device";
    case rr.S_IFDIR:
      return "directory";
    case rr.S_IFIFO:
      return "fifo";
    case rr.S_IFLNK:
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      return "symlink";
  }
  return "file";
}
<<<<<<< HEAD
var Sink = function(to) {
  Writable$3.call(this);
  this.written = 0;
  this._to = to;
  this._destroyed = false;
};
util$6.inherits(Sink, Writable$3);
Sink.prototype._write = function(data, enc, cb) {
  this.written += data.length;
  if (this._to.push(data)) return cb();
  this._to._drain = cb;
};
Sink.prototype.destroy = function() {
  if (this._destroyed) return;
  this._destroyed = true;
  this.emit("close");
};
var LinkSink = function() {
  Writable$3.call(this);
  this.linkname = "";
  this._decoder = new StringDecoder("utf-8");
  this._destroyed = false;
};
util$6.inherits(LinkSink, Writable$3);
LinkSink.prototype._write = function(data, enc, cb) {
  this.linkname += this._decoder.write(data);
  cb();
};
LinkSink.prototype.destroy = function() {
  if (this._destroyed) return;
  this._destroyed = true;
  this.emit("close");
};
var Void = function() {
  Writable$3.call(this);
  this._destroyed = false;
};
util$6.inherits(Void, Writable$3);
Void.prototype._write = function(data, enc, cb) {
  cb(new Error("No body allowed for this entry"));
};
Void.prototype.destroy = function() {
  if (this._destroyed) return;
  this._destroyed = true;
  this.emit("close");
};
var Pack = function(opts) {
  if (!(this instanceof Pack)) return new Pack(opts);
  Readable$1.call(this, opts);
  this._drain = noop$1;
  this._finalized = false;
  this._finalizing = false;
  this._destroyed = false;
  this._stream = null;
};
util$6.inherits(Pack, Readable$1);
Pack.prototype.entry = function(header, buffer2, callback) {
  if (this._stream) throw new Error("already piping an entry");
  if (this._finalized || this._destroyed) return;
  if (typeof buffer2 === "function") {
    callback = buffer2;
    buffer2 = null;
  }
  if (!callback) callback = noop$1;
  var self2 = this;
  if (!header.size || header.type === "symlink") header.size = 0;
  if (!header.type) header.type = modeToType(header.mode);
  if (!header.mode) header.mode = header.type === "directory" ? DMODE : FMODE;
  if (!header.uid) header.uid = 0;
  if (!header.gid) header.gid = 0;
  if (!header.mtime) header.mtime = /* @__PURE__ */ new Date();
  if (typeof buffer2 === "string") buffer2 = toBuffer2(buffer2);
  if (Buffer.isBuffer(buffer2)) {
    header.size = buffer2.length;
    this._encode(header);
    this.push(buffer2);
    overflow(self2, header.size);
    process.nextTick(callback);
    return new Void();
  }
  if (header.type === "symlink" && !header.linkname) {
    var linkSink = new LinkSink();
    eos(linkSink, function(err) {
      if (err) {
        self2.destroy();
        return callback(err);
      }
      header.linkname = linkSink.linkname;
      self2._encode(header);
      callback();
    });
    return linkSink;
  }
  this._encode(header);
  if (header.type !== "file" && header.type !== "contiguous-file") {
    process.nextTick(callback);
    return new Void();
  }
  var sink = new Sink(this);
  this._stream = sink;
  eos(sink, function(err) {
    self2._stream = null;
    if (err) {
      self2.destroy();
      return callback(err);
    }
    if (sink.written !== header.size) {
      self2.destroy();
      return callback(new Error("size mismatch"));
    }
    overflow(self2, header.size);
    if (self2._finalizing) self2.finalize();
    callback();
  });
  return sink;
};
Pack.prototype.finalize = function() {
=======
var Js = function(e) {
  jr.call(this), this.written = 0, this._to = e, this._destroyed = !1;
};
Ks.inherits(Js, jr);
Js.prototype._write = function(e, t, n) {
  if (this.written += e.length, this._to.push(e)) return n();
  this._to._drain = n;
};
Js.prototype.destroy = function() {
  this._destroyed || (this._destroyed = !0, this.emit("close"));
};
var Zs = function() {
  jr.call(this), this.linkname = "", this._decoder = new NE("utf-8"), this._destroyed = !1;
};
Ks.inherits(Zs, jr);
Zs.prototype._write = function(e, t, n) {
  this.linkname += this._decoder.write(e), n();
};
Zs.prototype.destroy = function() {
  this._destroyed || (this._destroyed = !0, this.emit("close"));
};
var yi = function() {
  jr.call(this), this._destroyed = !1;
};
Ks.inherits(yi, jr);
yi.prototype._write = function(e, t, n) {
  n(new Error("No body allowed for this entry"));
};
yi.prototype.destroy = function() {
  this._destroyed || (this._destroyed = !0, this.emit("close"));
};
var Rt = function(e) {
  if (!(this instanceof Rt)) return new Rt(e);
  g1.call(this, e), this._drain = Su, this._finalized = !1, this._finalizing = !1, this._destroyed = !1, this._stream = null;
};
Ks.inherits(Rt, g1);
Rt.prototype.entry = function(e, t, n) {
  if (this._stream) throw new Error("already piping an entry");
  if (!(this._finalized || this._destroyed)) {
    typeof t == "function" && (n = t, t = null), n || (n = Su);
    var r = this;
    if ((!e.size || e.type === "symlink") && (e.size = 0), e.type || (e.type = jE(e.mode)), e.mode || (e.mode = e.type === "directory" ? UE : BE), e.uid || (e.uid = 0), e.gid || (e.gid = 0), e.mtime || (e.mtime = /* @__PURE__ */ new Date()), typeof t == "string" && (t = LE(t)), Buffer.isBuffer(t))
      return e.size = t.length, this._encode(e), this.push(t), Fl(r, e.size), process.nextTick(n), new yi();
    if (e.type === "symlink" && !e.linkname) {
      var i = new Zs();
      return Kf(i, function(s) {
        if (s)
          return r.destroy(), n(s);
        e.linkname = i.linkname, r._encode(e), n();
      }), i;
    }
    if (this._encode(e), e.type !== "file" && e.type !== "contiguous-file")
      return process.nextTick(n), new yi();
    var a = new Js(this);
    return this._stream = a, Kf(a, function(s) {
      if (r._stream = null, s)
        return r.destroy(), n(s);
      if (a.written !== e.size)
        return r.destroy(), n(new Error("size mismatch"));
      Fl(r, e.size), r._finalizing && r.finalize(), n();
    }), a;
  }
};
Rt.prototype.finalize = function() {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  if (this._stream) {
    this._finalizing = true;
    return;
  }
<<<<<<< HEAD
  if (this._finalized) return;
  this._finalized = true;
  this.push(END_OF_TAR);
  this.push(null);
};
Pack.prototype.destroy = function(err) {
  if (this._destroyed) return;
  this._destroyed = true;
  if (err) this.emit("error", err);
  this.emit("close");
  if (this._stream && this._stream.destroy) this._stream.destroy();
};
Pack.prototype._encode = function(header) {
  if (!header.pax) {
    var buf = headers.encode(header);
    if (buf) {
      this.push(buf);
=======
  this._finalized || (this._finalized = !0, this.push(b1), this.push(null));
};
Rt.prototype.destroy = function(e) {
  this._destroyed || (this._destroyed = !0, e && this.emit("error", e), this.emit("close"), this._stream && this._stream.destroy && this._stream.destroy());
};
Rt.prototype._encode = function(e) {
  if (!e.pax) {
    var t = Qa.encode(e);
    if (t) {
      this.push(t);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      return;
    }
  }
  this._encodePax(header);
};
<<<<<<< HEAD
Pack.prototype._encodePax = function(header) {
  var paxHeader = headers.encodePax({
    name: header.name,
    linkname: header.linkname,
    pax: header.pax
  });
  var newHeader = {
=======
Rt.prototype._encodePax = function(e) {
  var t = Qa.encodePax({
    name: e.name,
    linkname: e.linkname,
    pax: e.pax
  }), n = {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    name: "PaxHeader",
    mode: header.mode,
    uid: header.uid,
    gid: header.gid,
    size: paxHeader.length,
    mtime: header.mtime,
    type: "pax-header",
    linkname: header.linkname && "PaxHeader",
    uname: header.uname,
    gname: header.gname,
    devmajor: header.devmajor,
    devminor: header.devminor
  };
<<<<<<< HEAD
  this.push(headers.encode(newHeader));
  this.push(paxHeader);
  overflow(this, paxHeader.length);
  newHeader.size = header.size;
  newHeader.type = header.type;
  this.push(headers.encode(newHeader));
};
Pack.prototype._read = function(n) {
  var drain = this._drain;
  this._drain = noop$1;
  drain();
};
var pack = Pack;
tarStream.extract = extract;
tarStream.pack = pack;
const stream$9 = require$$1$2;
let BaseStream$2 = class BaseStream extends stream$9.Readable {
=======
  this.push(Qa.encode(n)), this.push(t), Fl(this, t.length), n.size = e.size, n.type = e.type, this.push(Qa.encode(n));
};
Rt.prototype._read = function(e) {
  var t = this._drain;
  this._drain = Su, t();
};
var ME = Rt;
zi.extract = FE;
zi.pack = ME;
const qE = ae;
let zE = class extends qE.Readable {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  addEntry() {
    throw new Error(".addEntry not implemented in sub class!");
  }
  _read() {
  }
  emit(event, data) {
    if (event === "error") {
      const error2 = data;
      if (error2.name === "Error") {
        error2.name = this.constructor.name + "Error";
      }
    }
    super.emit(event, data);
  }
};
<<<<<<< HEAD
var base_stream = BaseStream$2;
const fs$q = fs$w;
const path$p = require$$1$4;
const stream$8 = require$$1$2;
const tar$5 = tarStream;
const utils$e = utils$f;
const BaseStream$1 = base_stream;
let TarStream$2 = class TarStream extends BaseStream$1 {
  constructor(opts) {
    super(opts);
    this._waitingEntries = [];
    this._processing = false;
    this._init(opts);
  }
  _init() {
    const pack2 = this._pack = tar$5.pack();
    pack2.on("end", () => this.push(null));
    pack2.on("data", (chunk) => this.push(chunk));
    pack2.on("error", (err) => this.emit("error", err));
  }
  addEntry(entry, opts) {
    if (this._processing) {
      return this._waitingEntries.push([entry, opts]);
    }
    opts = opts || {};
    this._processing = true;
    const entryType = utils$e.entryType(entry);
    if (!entryType) return;
    if (entryType === "fileOrDir") {
      this._addFileOrDirEntry(entry, opts);
    } else if (entryType === "buffer") {
      this._addBufferEntry(entry, opts);
    } else {
      this._addStreamEntry(entry, opts);
    }
  }
  _addFileOrDirEntry(entry, opts) {
    fs$q.stat(entry, (err, stat2) => {
      if (err) return this.emit("error", err);
      if (stat2.isDirectory()) return this._addDirEntry(entry, opts);
      if (stat2.isFile()) return this._addFileEntry(entry, opts);
      const illigalEntryError2 = new Error("Type is not supported, must be a file path, directory path, file buffer, or a readable stream");
      illigalEntryError2.name = "IlligalEntryError";
      this.emit("error", illigalEntryError2);
    });
  }
  _addFileEntry(entry, opts) {
    fs$q.stat(entry, (err, stat2) => {
      if (err) return this.emit("error", err);
      const entryStream = this._pack.entry({ name: opts.relativePath || path$p.basename(entry), size: stat2.size, mode: stat2.mode & 511 }, this._onEntryFinish.bind(this));
      const stream2 = fs$q.createReadStream(entry, opts.fs);
      stream2.on("error", (err2) => this.emit("error", err2));
      stream2.pipe(entryStream);
    });
  }
  _addDirEntry(entry, opts) {
    fs$q.readdir(entry, (err, files) => {
      if (err) return this.emit("error", err);
      const relativePath = opts.relativePath || "";
      files.forEach((fileOrDir) => {
        const newOpts = utils$e.clone(opts);
        if (opts.ignoreBase) {
          newOpts.relativePath = path$p.posix.join(relativePath, fileOrDir);
        } else {
          newOpts.relativePath = path$p.posix.join(relativePath, path$p.basename(entry), fileOrDir);
        }
        newOpts.ignoreBase = true;
        this.addEntry(path$p.posix.join(entry, fileOrDir), newOpts);
      });
      this._onEntryFinish();
    });
  }
  _addBufferEntry(entry, opts) {
    if (!opts.relativePath) return this.emit("error", "opts.relativePath is required if entry is a buffer");
    this._pack.entry({ name: opts.relativePath }, entry, this._onEntryFinish.bind(this));
  }
  _addStreamEntry(entry, opts) {
    entry.on("error", (err) => this.emit("error", err));
    if (!opts.relativePath) return this.emit("error", new Error("opts.relativePath is required"));
    if (opts.size) {
      const entryStream = this._pack.entry({ name: opts.relativePath, size: opts.size }, this._onEntryFinish.bind(this));
      entry.pipe(entryStream);
    } else {
      if (!opts.suppressSizeWarning) {
        console.warn("You should specify the size of streamming data by opts.size to prevent all streaming data from loading into memory. If you are sure about memory cost, pass opts.suppressSizeWarning: true to suppress this warning");
      }
      const buf = [];
      const collectStream = new stream$8.Writable({
        write(chunk, _, callback) {
          buf.push(chunk);
          callback();
=======
var x1 = zE;
const Aa = se, Zr = ne, HE = ae, WE = zi, Jf = me, GE = x1;
let VE = class extends GE {
  constructor(t) {
    super(t), this._waitingEntries = [], this._processing = !1, this._init(t);
  }
  _init() {
    const t = this._pack = WE.pack();
    t.on("end", () => this.push(null)), t.on("data", (n) => this.push(n)), t.on("error", (n) => this.emit("error", n));
  }
  addEntry(t, n) {
    if (this._processing)
      return this._waitingEntries.push([t, n]);
    n = n || {}, this._processing = !0;
    const r = Jf.entryType(t);
    r && (r === "fileOrDir" ? this._addFileOrDirEntry(t, n) : r === "buffer" ? this._addBufferEntry(t, n) : this._addStreamEntry(t, n));
  }
  _addFileOrDirEntry(t, n) {
    Aa.stat(t, (r, i) => {
      if (r) return this.emit("error", r);
      if (i.isDirectory()) return this._addDirEntry(t, n);
      if (i.isFile()) return this._addFileEntry(t, n);
      const a = new Error("Type is not supported, must be a file path, directory path, file buffer, or a readable stream");
      a.name = "IlligalEntryError", this.emit("error", a);
    });
  }
  _addFileEntry(t, n) {
    Aa.stat(t, (r, i) => {
      if (r) return this.emit("error", r);
      const a = this._pack.entry({ name: n.relativePath || Zr.basename(t), size: i.size, mode: i.mode & 511 }, this._onEntryFinish.bind(this)), s = Aa.createReadStream(t, n.fs);
      s.on("error", (c) => this.emit("error", c)), s.pipe(a);
    });
  }
  _addDirEntry(t, n) {
    Aa.readdir(t, (r, i) => {
      if (r) return this.emit("error", r);
      const a = n.relativePath || "";
      i.forEach((s) => {
        const c = Jf.clone(n);
        n.ignoreBase ? c.relativePath = Zr.posix.join(a, s) : c.relativePath = Zr.posix.join(a, Zr.basename(t), s), c.ignoreBase = !0, this.addEntry(Zr.posix.join(t, s), c);
      }), this._onEntryFinish();
    });
  }
  _addBufferEntry(t, n) {
    if (!n.relativePath) return this.emit("error", "opts.relativePath is required if entry is a buffer");
    this._pack.entry({ name: n.relativePath }, t, this._onEntryFinish.bind(this));
  }
  _addStreamEntry(t, n) {
    if (t.on("error", (r) => this.emit("error", r)), !n.relativePath) return this.emit("error", new Error("opts.relativePath is required"));
    if (n.size) {
      const r = this._pack.entry({ name: n.relativePath, size: n.size }, this._onEntryFinish.bind(this));
      t.pipe(r);
    } else {
      n.suppressSizeWarning || console.warn("You should specify the size of streamming data by opts.size to prevent all streaming data from loading into memory. If you are sure about memory cost, pass opts.suppressSizeWarning: true to suppress this warning");
      const r = [], i = new HE.Writable({
        write(a, s, c) {
          r.push(a), c();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        }
      });
      collectStream.on("error", (err) => this.emit("error", err));
      collectStream.on("finish", () => {
        this._pack.entry({ name: opts.relativePath }, Buffer.concat(buf), this._onEntryFinish.bind(this));
      });
      entry.pipe(collectStream);
    }
  }
  _read() {
  }
  _onEntryFinish(err) {
    if (err) return this.emit("error", err);
    this._processing = false;
    const waitingEntry = this._waitingEntries.shift();
    if (waitingEntry) {
      this.addEntry.apply(this, waitingEntry);
    } else {
      this._finalize();
    }
  }
  _finalize() {
    this._pack.finalize();
  }
};
<<<<<<< HEAD
var stream_1$4 = TarStream$2;
const path$o = require$$1$4;
const yazl$1 = yazl$2;
const TarStream$1 = stream_1$4;
let ZipStream$1 = class ZipStream extends TarStream$1 {
  _init() {
    const zipfile = this._zipfile = new yazl$1.ZipFile();
    const stream2 = zipfile.outputStream;
    stream2.on("end", () => this.push(null));
    stream2.on("data", (chunk) => this.push(chunk));
    stream2.on("error", (err) => this.emit("error", err));
  }
  _addFileEntry(entry, opts) {
    this._zipfile.addFile(entry, opts.relativePath || path$o.basename(entry), opts);
    this._onEntryFinish();
  }
  _addBufferEntry(entry, opts) {
    if (!opts.relativePath) return this.emit("error", new Error("opts.relativePath is required if entry is a buffer"));
    this._zipfile.addBuffer(entry, opts.relativePath, opts);
    this._onEntryFinish();
=======
var y1 = VE;
const YE = ne, XE = zs, KE = y1;
let JE = class extends KE {
  _init() {
    const n = (this._zipfile = new XE.ZipFile()).outputStream;
    n.on("end", () => this.push(null)), n.on("data", (r) => this.push(r)), n.on("error", (r) => this.emit("error", r));
  }
  _addFileEntry(t, n) {
    this._zipfile.addFile(t, n.relativePath || YE.basename(t), n), this._onEntryFinish();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  _addStreamEntry(entry, opts) {
    if (!opts.relativePath) return this.emit("error", new Error("opts.relativePath is required if entry is a stream"));
    entry.on("error", (err) => this.emit("error", err));
    this._zipfile.addReadStream(entry, opts.relativePath, opts);
    this._onEntryFinish();
  }
  _finalize() {
    this._zipfile.end();
  }
};
<<<<<<< HEAD
var stream$7 = ZipStream$1;
var getReady = { exports: {} };
function ready$4(flagOrFunction) {
  this._ready = !!this._ready;
  this._readyCallbacks = this._readyCallbacks || [];
  if (arguments.length === 0) {
    return new Promise((function(resolve) {
      if (this._ready) {
        return resolve();
      }
      this._readyCallbacks.push(resolve);
=======
var ZE = JE, Au = { exports: {} };
function QE(e) {
  if (this._ready = !!this._ready, this._readyCallbacks = this._readyCallbacks || [], arguments.length === 0)
    return new Promise((function(t) {
      if (this._ready)
        return t();
      this._readyCallbacks.push(t);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }).bind(this));
  } else if (typeof flagOrFunction === "function") {
    this._readyCallbacks.push(flagOrFunction);
  } else {
    this._ready = !!flagOrFunction;
  }
  if (this._ready) {
    this._readyCallbacks.splice(0, Infinity).forEach(function(callback) {
      process.nextTick(callback);
    });
  }
}
<<<<<<< HEAD
function mixin(object) {
  object.ready = ready$4;
}
getReady.exports = mixin;
getReady.exports.mixin = mixin;
var getReadyExports = getReady.exports;
const path$n = require$$1$4;
const yazl = yazl$2;
const assert$1 = require$$2$3;
const stream$6 = require$$1$2;
const utils$d = utils$f;
const ready$3 = getReadyExports;
let ZipFileStream$1 = class ZipFileStream extends stream$6.Transform {
  constructor(opts) {
    super(opts);
    const sourceType = utils$d.sourceType(opts.source);
    const zipfile = new yazl.ZipFile();
    const zipStream = zipfile.outputStream;
    zipStream.on("data", (data) => this.push(data));
    zipStream.on("end", () => this.ready(true));
    zipfile.on("error", (err) => this.emit("error", err));
    if (sourceType !== "file") {
      assert$1(opts.relativePath, "opts.relativePath is required when compressing a buffer, or a stream");
=======
function w1(e) {
  e.ready = QE;
}
Au.exports = w1;
Au.exports.mixin = w1;
var Qs = Au.exports;
const e_ = ne, t_ = zs, n_ = Rs, Zf = ae, r_ = me, i_ = Qs;
let E1 = class extends Zf.Transform {
  constructor(t) {
    super(t);
    const n = r_.sourceType(t.source), r = new t_.ZipFile(), i = r.outputStream;
    if (i.on("data", (a) => this.push(a)), i.on("end", () => this.ready(!0)), r.on("error", (a) => this.emit("error", a)), n !== "file" && n_(t.relativePath, "opts.relativePath is required when compressing a buffer, or a stream"), n && this.end(), n === "file")
      r.addFile(t.source, t.relativePath || e_.basename(t.source), t.yazl);
    else if (n === "buffer")
      r.addBuffer(t.source, t.relativePath, t.yazl);
    else if (n === "stream")
      r.addReadStream(t.source, t.relativePath, t.yazl);
    else {
      const a = this._passThrough = new Zf.PassThrough();
      this.on("finish", () => a.end()), r.addReadStream(a, t.relativePath, t.yazl);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    if (sourceType) {
      this.end();
    }
    if (sourceType === "file") {
      zipfile.addFile(opts.source, opts.relativePath || path$n.basename(opts.source), opts.yazl);
    } else if (sourceType === "buffer") {
      zipfile.addBuffer(opts.source, opts.relativePath, opts.yazl);
    } else if (sourceType === "stream") {
      zipfile.addReadStream(opts.source, opts.relativePath, opts.yazl);
    } else {
      const passThrough = this._passThrough = new stream$6.PassThrough();
      this.on("finish", () => passThrough.end());
      zipfile.addReadStream(passThrough, opts.relativePath, opts.yazl);
    }
    zipfile.end(opts.yazl);
  }
<<<<<<< HEAD
  _transform(chunk, encoding, callback) {
    if (this._passThrough) {
      this._passThrough.write(chunk, encoding, callback);
=======
  _transform(t, n, r) {
    this._passThrough && this._passThrough.write(t, n, r);
  }
  _flush(t) {
    this.ready(t);
  }
};
i_.mixin(E1.prototype);
var a_ = E1, Ot = {}, Vi = {}, s_ = eo;
function eo() {
  this.pending = 0, this.max = 1 / 0, this.listeners = [], this.waiting = [], this.error = null;
}
eo.prototype.go = function(e) {
  this.pending < this.max ? S1(this, e) : this.waiting.push(e);
};
eo.prototype.wait = function(e) {
  this.pending === 0 ? e(this.error) : this.listeners.push(e);
};
eo.prototype.hold = function() {
  return _1(this);
};
function _1(e) {
  e.pending += 1;
  var t = !1;
  return n;
  function n(i) {
    if (t) throw new Error("callback called twice");
    if (t = !0, e.error = e.error || i, e.pending -= 1, e.waiting.length > 0 && e.pending < e.max)
      S1(e, e.waiting.shift());
    else if (e.pending === 0) {
      var a = e.listeners;
      e.listeners = [], a.forEach(r);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
  }
  _flush(callback) {
    this.ready(callback);
  }
};
ready$3.mixin(ZipFileStream$1.prototype);
var file_stream$3 = ZipFileStream$1;
var yauzl$1 = {};
var fdSlicer2 = {};
var pend = Pend$1;
function Pend$1() {
  this.pending = 0;
  this.max = Infinity;
  this.listeners = [];
  this.waiting = [];
  this.error = null;
}
Pend$1.prototype.go = function(fn) {
  if (this.pending < this.max) {
    pendGo(this, fn);
  } else {
    this.waiting.push(fn);
  }
};
Pend$1.prototype.wait = function(cb) {
  if (this.pending === 0) {
    cb(this.error);
  } else {
    this.listeners.push(cb);
  }
};
Pend$1.prototype.hold = function() {
  return pendHold(this);
};
function pendHold(self2) {
  self2.pending += 1;
  var called = false;
  return onCb;
  function onCb(err) {
    if (called) throw new Error("callback called twice");
    called = true;
    self2.error = self2.error || err;
    self2.pending -= 1;
    if (self2.waiting.length > 0 && self2.pending < self2.max) {
      pendGo(self2, self2.waiting.shift());
    } else if (self2.pending === 0) {
      var listeners = self2.listeners;
      self2.listeners = [];
      listeners.forEach(cbListener);
    }
  }
  function cbListener(listener) {
    listener(self2.error);
  }
}
<<<<<<< HEAD
function pendGo(self2, fn) {
  fn(pendHold(self2));
}
const fs$p = fs$w;
const { Readable, Writable: Writable$2, PassThrough: PassThrough$1 } = require$$1$2;
const Pend = pend;
const { EventEmitter: EventEmitter$2 } = require$$0$6;
class FdSlicer extends EventEmitter$2 {
  constructor(fd, options = {}) {
    super();
    this.fd = fd;
    this.pend = new Pend();
    this.pend.max = 1;
    this.refCount = 0;
    this.autoClose = !!options.autoClose;
  }
  read(buffer2, offset, length, position, callback) {
    this.pend.go((cb) => {
      fs$p.read(this.fd, buffer2, offset, length, position, (err, bytesRead, buffer3) => {
        cb();
        callback(err, bytesRead, buffer3);
      });
    });
  }
  write(buffer2, offset, length, position, callback) {
    this.pend.go((cb) => {
      fs$p.write(this.fd, buffer2, offset, length, position, (err, written, buffer3) => {
        cb();
        callback(err, written, buffer3);
      });
    });
  }
  createReadStream(options) {
    return new ReadStream(this, options);
  }
  createWriteStream(options) {
    return new WriteStream(this, options);
=======
function S1(e, t) {
  t(_1(e));
}
const ui = se, { Readable: o_, Writable: A1, PassThrough: c_ } = ae, l_ = s_, { EventEmitter: T1 } = Yn;
class C1 extends T1 {
  constructor(t, n = {}) {
    super(), this.fd = t, this.pend = new l_(), this.pend.max = 1, this.refCount = 0, this.autoClose = !!n.autoClose;
  }
  read(t, n, r, i, a) {
    this.pend.go((s) => {
      ui.read(this.fd, t, n, r, i, (c, o, u) => {
        s(), a(c, o, u);
      });
    });
  }
  write(t, n, r, i, a) {
    this.pend.go((s) => {
      ui.write(this.fd, t, n, r, i, (c, o, u) => {
        s(), a(c, o, u);
      });
    });
  }
  createReadStream(t) {
    return new u_(this, t);
  }
  createWriteStream(t) {
    return new p_(this, t);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  ref() {
    this.refCount += 1;
  }
  unref() {
<<<<<<< HEAD
    this.refCount -= 1;
    if (this.refCount > 0) return;
    if (this.refCount < 0) throw new Error("invalid unref");
    if (this.autoClose) {
      fs$p.close(this.fd, (err) => {
        if (err) {
          this.emit("error", err);
        } else {
          this.emit("close");
        }
=======
    if (this.refCount -= 1, !(this.refCount > 0)) {
      if (this.refCount < 0) throw new Error("invalid unref");
      this.autoClose && ui.close(this.fd, (t) => {
        t ? this.emit("error", t) : this.emit("close");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      });
    }
  }
}
<<<<<<< HEAD
class ReadStream extends Readable {
  constructor(context, options = {}) {
    super(options);
    this.context = context;
    this.context.ref();
    this.start = options.start || 0;
    this.endOffset = options.end;
    this.pos = this.start;
    this.destroyed = false;
=======
class u_ extends o_ {
  constructor(t, n = {}) {
    super(n), this.context = t, this.context.ref(), this.start = n.start || 0, this.endOffset = n.end, this.pos = this.start, this.destroyed = !1;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  _read(n) {
    if (this.destroyed) return;
    let toRead = Math.min(this._readableState.highWaterMark, n);
    if (this.endOffset != null) {
      toRead = Math.min(toRead, this.endOffset - this.pos);
    }
    if (toRead <= 0) {
      this.destroyed = true;
      this.push(null);
      this.context.unref();
      return;
    }
<<<<<<< HEAD
    this.context.pend.go((cb) => {
      if (this.destroyed) return cb();
      const buffer2 = Buffer.alloc(toRead);
      fs$p.read(this.context.fd, buffer2, 0, toRead, this.pos, (err, bytesRead) => {
        if (err) {
          this.destroy(err);
        } else if (bytesRead === 0) {
          this.destroyed = true;
          this.push(null);
          this.context.unref();
        } else {
          this.pos += bytesRead;
          this.push(buffer2.slice(0, bytesRead));
        }
        cb();
=======
    this.context.pend.go((r) => {
      if (this.destroyed) return r();
      const i = Buffer.alloc(n);
      ui.read(this.context.fd, i, 0, n, this.pos, (a, s) => {
        a ? this.destroy(a) : s === 0 ? (this.destroyed = !0, this.push(null), this.context.unref()) : (this.pos += s, this.push(i.slice(0, s))), r();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      });
    });
  }
  destroy(err) {
    if (this.destroyed) return;
    err = err || new Error("stream destroyed");
    this.destroyed = true;
    this.emit("error", err);
    this.context.unref();
  }
}
<<<<<<< HEAD
class WriteStream extends Writable$2 {
  constructor(context, options = {}) {
    super(options);
    this.context = context;
    this.context.ref();
    this.start = options.start || 0;
    this.endOffset = options.end == null ? Infinity : +options.end;
    this.bytesWritten = 0;
    this.pos = this.start;
    this.destroyed = false;
    this.on("finish", this.destroy.bind(this));
  }
  _write(buffer2, _encoding, callback) {
    if (this.destroyed) return;
    if (this.pos + buffer2.length > this.endOffset) {
      const err = new Error("maximum file length exceeded");
      err.code = "ETOOBIG";
      this.destroy();
      callback(err);
      return;
    }
    this.context.pend.go((cb) => {
      if (this.destroyed) return cb();
      fs$p.write(this.context.fd, buffer2, 0, buffer2.length, this.pos, (err, bytes) => {
        if (err) {
          this.destroy();
          cb();
          callback(err);
        } else {
          this.bytesWritten += bytes;
          this.pos += bytes;
          this.emit("progress");
          cb();
          callback();
        }
=======
class p_ extends A1 {
  constructor(t, n = {}) {
    super(n), this.context = t, this.context.ref(), this.start = n.start || 0, this.endOffset = n.end == null ? 1 / 0 : +n.end, this.bytesWritten = 0, this.pos = this.start, this.destroyed = !1, this.on("finish", this.destroy.bind(this));
  }
  _write(t, n, r) {
    if (!this.destroyed) {
      if (this.pos + t.length > this.endOffset) {
        const i = new Error("maximum file length exceeded");
        i.code = "ETOOBIG", this.destroy(), r(i);
        return;
      }
      this.context.pend.go((i) => {
        if (this.destroyed) return i();
        ui.write(this.context.fd, t, 0, t.length, this.pos, (a, s) => {
          a ? (this.destroy(), i(), r(a)) : (this.bytesWritten += s, this.pos += s, this.emit("progress"), i(), r());
        });
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      });
    });
  }
  destroy() {
    if (this.destroyed) return;
    this.destroyed = true;
    this.context.unref();
  }
}
<<<<<<< HEAD
const { MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2 } = Number;
class BufferSlicer extends EventEmitter$2 {
  constructor(buffer2, options) {
    super();
    options = options || {};
    this.refCount = 0;
    this.buffer = buffer2;
    this.maxChunkSize = options.maxChunkSize || MAX_SAFE_INTEGER$2;
  }
  read(buffer2, offset, length, position, callback) {
    const end2 = position + length;
    const delta = end2 - this.buffer.length;
    const written = delta > 0 ? delta : length;
    this.buffer.copy(buffer2, offset, position, end2);
    setImmediate(() => {
      callback(null, written);
    });
  }
  write(buffer2, offset, length, position, callback) {
    buffer2.copy(this.buffer, position, offset, offset + length);
    setImmediate(() => {
      callback(null, length, buffer2);
    });
  }
  createReadStream(options = {}) {
    const readStream2 = new PassThrough$1(options);
    readStream2.destroyed = false;
    readStream2.start = options.start || 0;
    readStream2.endOffset = options.end;
    readStream2.pos = readStream2.endOffset || this.buffer.length;
    const entireSlice = this.buffer.slice(readStream2.start, readStream2.pos);
    let offset = 0;
    while (true) {
      const nextOffset = offset + this.maxChunkSize;
      if (nextOffset >= entireSlice.length) {
        if (offset < entireSlice.length) {
          readStream2.write(entireSlice.slice(offset, entireSlice.length));
        }
=======
const { MAX_SAFE_INTEGER: f_ } = Number;
class R1 extends T1 {
  constructor(t, n) {
    super(), n = n || {}, this.refCount = 0, this.buffer = t, this.maxChunkSize = n.maxChunkSize || f_;
  }
  read(t, n, r, i, a) {
    const s = i + r, c = s - this.buffer.length, o = c > 0 ? c : r;
    this.buffer.copy(t, n, i, s), setImmediate(() => {
      a(null, o);
    });
  }
  write(t, n, r, i, a) {
    t.copy(this.buffer, i, n, n + r), setImmediate(() => {
      a(null, r, t);
    });
  }
  createReadStream(t = {}) {
    const n = new c_(t);
    n.destroyed = !1, n.start = t.start || 0, n.endOffset = t.end, n.pos = n.endOffset || this.buffer.length;
    const r = this.buffer.slice(n.start, n.pos);
    let i = 0;
    for (; ; ) {
      const a = i + this.maxChunkSize;
      if (a >= r.length) {
        i < r.length && n.write(r.slice(i, r.length));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        break;
      }
      readStream2.write(entireSlice.slice(offset, nextOffset));
      offset = nextOffset;
    }
    readStream2.end();
    readStream2.destroy = () => {
      readStream2.destroyed = true;
    };
    return readStream2;
  }
<<<<<<< HEAD
  createWriteStream(options) {
    const bufferSlicer = this;
    options = options || {};
    const writeStream = new Writable$2(options);
    writeStream.start = options.start || 0;
    writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
    writeStream.bytesWritten = 0;
    writeStream.pos = writeStream.start;
    writeStream.destroyed = false;
    writeStream._write = (buffer2, encoding, callback) => {
      if (writeStream.destroyed) return;
      const end2 = writeStream.pos + buffer2.length;
      if (end2 > writeStream.endOffset) {
        const err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        writeStream.destroyed = true;
        callback(err);
        return;
      }
      buffer2.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer2.length);
      writeStream.bytesWritten += buffer2.length;
      writeStream.pos = end2;
      writeStream.emit("progress");
      callback();
    };
    writeStream.destroy = () => {
      writeStream.destroyed = true;
    };
    return writeStream;
=======
  createWriteStream(t) {
    const n = this;
    t = t || {};
    const r = new A1(t);
    return r.start = t.start || 0, r.endOffset = t.end == null ? this.buffer.length : +t.end, r.bytesWritten = 0, r.pos = r.start, r.destroyed = !1, r._write = (i, a, s) => {
      if (r.destroyed) return;
      const c = r.pos + i.length;
      if (c > r.endOffset) {
        const o = new Error("maximum file length exceeded");
        o.code = "ETOOBIG", r.destroyed = !0, s(o);
        return;
      }
      i.copy(n.buffer, r.pos, 0, i.length), r.bytesWritten += i.length, r.pos = c, r.emit("progress"), s();
    }, r.destroy = () => {
      r.destroyed = !0;
    }, r;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  ref() {
    this.refCount += 1;
  }
  unref() {
    this.refCount -= 1;
    if (this.refCount < 0) {
      throw new Error("invalid unref");
    }
  }
}
<<<<<<< HEAD
function createFromBuffer(buffer2, options) {
  return new BufferSlicer(buffer2, options);
=======
function d_(e, t) {
  return new R1(e, t);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
}
function h_(e, t) {
  return new C1(e, t);
}
<<<<<<< HEAD
fdSlicer2.createFromBuffer = createFromBuffer;
fdSlicer2.createFromFd = createFromFd;
fdSlicer2.BufferSlicer = BufferSlicer;
fdSlicer2.FdSlicer = FdSlicer;
var fs$o = fs$w;
var zlib$2 = zlib$4;
var fd_slicer = fdSlicer2;
var crc32 = bufferCrc32;
var util$5 = require$$1$3;
var EventEmitter$1 = require$$0$6.EventEmitter;
var Transform = require$$1$2.Transform;
var PassThrough = require$$1$2.PassThrough;
var Writable$1 = require$$1$2.Writable;
yauzl$1.open = open;
yauzl$1.fromFd = fromFd;
yauzl$1.fromBuffer = fromBuffer;
yauzl$1.fromRandomAccessReader = fromRandomAccessReader;
yauzl$1.dosDateTimeToDate = dosDateTimeToDate;
yauzl$1.validateFileName = validateFileName;
yauzl$1.ZipFile = ZipFile;
yauzl$1.Entry = Entry;
yauzl$1.RandomAccessReader = RandomAccessReader;
function open(path2, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs$o.open(path2, "r", function(err, fd) {
    if (err) return callback(err);
    fromFd(fd, options, function(err2, zipfile) {
      if (err2) fs$o.close(fd, defaultCallback);
      callback(err2, zipfile);
    });
  });
}
function fromFd(fd, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs$o.fstat(fd, function(err, stats) {
    if (err) return callback(err);
    var reader = fd_slicer.createFromFd(fd, { autoClose: true });
    fromRandomAccessReader(reader, stats.size, options, callback);
  });
}
function fromBuffer(buffer2, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  var reader = fd_slicer.createFromBuffer(buffer2, { maxChunkSize: 65536 });
  fromRandomAccessReader(reader, buffer2.length, options, callback);
}
function fromRandomAccessReader(reader, totalSize, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  var decodeStrings = !!options.decodeStrings;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
  if (totalSize > Number.MAX_SAFE_INTEGER) {
    throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
  }
  reader.ref();
  var eocdrWithoutCommentSize = 22;
  var maxCommentSize = 65535;
  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
  var buffer2 = newBuffer(bufferSize);
  var bufferReadStart = totalSize - buffer2.length;
  readAndAssertNoEof(reader, buffer2, 0, bufferSize, bufferReadStart, function(err) {
    if (err) return callback(err);
    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
      if (buffer2.readUInt32LE(i) !== 101010256) continue;
      var eocdrBuffer = buffer2.slice(i);
      var diskNumber = eocdrBuffer.readUInt16LE(4);
      if (diskNumber !== 0) {
        return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
=======
Vi.createFromBuffer = d_;
Vi.createFromFd = h_;
Vi.BufferSlicer = R1;
Vi.FdSlicer = C1;
var Pl = se, m_ = et, $1 = Vi, v_ = B0, to = De, no = Yn.EventEmitter, O1 = ae.Transform, Tu = ae.PassThrough, g_ = ae.Writable;
Ot.open = b_;
Ot.fromFd = I1;
Ot.fromBuffer = x_;
Ot.fromRandomAccessReader = Cu;
Ot.dosDateTimeToDate = F1;
Ot.validateFileName = P1;
Ot.ZipFile = pn;
Ot.Entry = Yi;
Ot.RandomAccessReader = bn;
function b_(e, t, n) {
  typeof t == "function" && (n = t, t = null), t == null && (t = {}), t.autoClose == null && (t.autoClose = !0), t.lazyEntries == null && (t.lazyEntries = !1), t.decodeStrings == null && (t.decodeStrings = !0), t.validateEntrySizes == null && (t.validateEntrySizes = !0), t.strictFileNames == null && (t.strictFileNames = !1), n == null && (n = hs), Pl.open(e, "r", function(r, i) {
    if (r) return n(r);
    I1(i, t, function(a, s) {
      a && Pl.close(i, hs), n(a, s);
    });
  });
}
function I1(e, t, n) {
  typeof t == "function" && (n = t, t = null), t == null && (t = {}), t.autoClose == null && (t.autoClose = !1), t.lazyEntries == null && (t.lazyEntries = !1), t.decodeStrings == null && (t.decodeStrings = !0), t.validateEntrySizes == null && (t.validateEntrySizes = !0), t.strictFileNames == null && (t.strictFileNames = !1), n == null && (n = hs), Pl.fstat(e, function(r, i) {
    if (r) return n(r);
    var a = $1.createFromFd(e, { autoClose: !0 });
    Cu(a, i.size, t, n);
  });
}
function x_(e, t, n) {
  typeof t == "function" && (n = t, t = null), t == null && (t = {}), t.autoClose = !1, t.lazyEntries == null && (t.lazyEntries = !1), t.decodeStrings == null && (t.decodeStrings = !0), t.validateEntrySizes == null && (t.validateEntrySizes = !0), t.strictFileNames == null && (t.strictFileNames = !1);
  var r = $1.createFromBuffer(e, { maxChunkSize: 65536 });
  Cu(r, e.length, t, n);
}
function Cu(e, t, n, r) {
  typeof n == "function" && (r = n, n = null), n == null && (n = {}), n.autoClose == null && (n.autoClose = !0), n.lazyEntries == null && (n.lazyEntries = !1), n.decodeStrings == null && (n.decodeStrings = !0);
  var i = !!n.decodeStrings;
  if (n.validateEntrySizes == null && (n.validateEntrySizes = !0), n.strictFileNames == null && (n.strictFileNames = !1), r == null && (r = hs), typeof t != "number") throw new Error("expected totalSize parameter to be a number");
  if (t > Number.MAX_SAFE_INTEGER)
    throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
  e.ref();
  var a = 22, s = 65535, c = Math.min(a + s, t), o = Tt(c), u = t - o.length;
  Ar(e, o, 0, c, u, function(l) {
    if (l) return r(l);
    for (var p = c - a; p >= 0; p -= 1)
      if (o.readUInt32LE(p) === 101010256) {
        var f = o.slice(p), m = f.readUInt16LE(4);
        if (m !== 0)
          return r(new Error("multi-disk zip files are not supported: found disk number: " + m));
        var g = f.readUInt16LE(10), h = f.readUInt32LE(16), b = f.readUInt16LE(20), x = f.length - a;
        if (b !== x)
          return r(new Error("invalid comment length. expected: " + x + ". found: " + b));
        var y = i ? es(f, 22, f.length, !1) : f.slice(22);
        if (!(g === 65535 || h === 4294967295))
          return r(null, new pn(e, h, t, g, y, n.autoClose, n.lazyEntries, i, n.validateEntrySizes, n.strictFileNames));
        var E = Tt(20), S = u + p - E.length;
        Ar(e, E, 0, E.length, S, function(D) {
          if (D) return r(D);
          if (E.readUInt32LE(0) !== 117853008)
            return r(new Error("invalid zip64 end of central directory locator signature"));
          var U = Tr(E, 8), z = Tt(56);
          Ar(e, z, 0, z.length, U, function(ee) {
            return ee ? r(ee) : z.readUInt32LE(0) !== 101075792 ? r(new Error("invalid zip64 end of central directory record signature")) : (g = Tr(z, 32), h = Tr(z, 48), r(null, new pn(e, h, t, g, y, n.autoClose, n.lazyEntries, i, n.validateEntrySizes, n.strictFileNames)));
          });
        });
        return;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
      var entryCount = eocdrBuffer.readUInt16LE(10);
      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
      var commentLength = eocdrBuffer.readUInt16LE(20);
      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
      if (commentLength !== expectedCommentLength) {
        return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
      }
      var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
      if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
      }
      var zip64EocdlBuffer = newBuffer(20);
      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
        if (err2) return callback(err2);
        if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
          return callback(new Error("invalid zip64 end of central directory locator signature"));
        }
        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
        var zip64EocdrBuffer = newBuffer(56);
        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
          if (err3) return callback(err3);
          if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
            return callback(new Error("invalid zip64 end of central directory record signature"));
          }
          entryCount = readUInt64LE(zip64EocdrBuffer, 32);
          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
        });
      });
      return;
    }
    callback(new Error("end of central directory record signature not found"));
  });
}
<<<<<<< HEAD
util$5.inherits(ZipFile, EventEmitter$1);
function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
  var self2 = this;
  EventEmitter$1.call(self2);
  self2.reader = reader;
  self2.reader.on("error", function(err) {
    emitError(self2, err);
  });
  self2.reader.once("close", function() {
    self2.emit("close");
  });
  self2.readEntryCursor = centralDirectoryOffset;
  self2.fileSize = fileSize;
  self2.entryCount = entryCount;
  self2.comment = comment;
  self2.entriesRead = 0;
  self2.autoClose = !!autoClose;
  self2.lazyEntries = !!lazyEntries;
  self2.decodeStrings = !!decodeStrings;
  self2.validateEntrySizes = !!validateEntrySizes;
  self2.strictFileNames = !!strictFileNames;
  self2.isOpen = true;
  self2.emittedError = false;
  if (!self2.lazyEntries) self2._readEntry();
}
ZipFile.prototype.close = function() {
  if (!this.isOpen) return;
  this.isOpen = false;
  this.reader.unref();
};
function emitErrorAndAutoClose(self2, err) {
  if (self2.autoClose) self2.close();
  emitError(self2, err);
}
function emitError(self2, err) {
  if (self2.emittedError) return;
  self2.emittedError = true;
  self2.emit("error", err);
}
ZipFile.prototype.readEntry = function() {
  if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
  this._readEntry();
};
ZipFile.prototype._readEntry = function() {
  var self2 = this;
  if (self2.entryCount === self2.entriesRead) {
=======
to.inherits(pn, no);
function pn(e, t, n, r, i, a, s, c, o, u) {
  var l = this;
  no.call(l), l.reader = e, l.reader.on("error", function(p) {
    D1(l, p);
  }), l.reader.once("close", function() {
    l.emit("close");
  }), l.readEntryCursor = t, l.fileSize = n, l.entryCount = r, l.comment = i, l.entriesRead = 0, l.autoClose = !!a, l.lazyEntries = !!s, l.decodeStrings = !!c, l.validateEntrySizes = !!o, l.strictFileNames = !!u, l.isOpen = !0, l.emittedError = !1, l.lazyEntries || l._readEntry();
}
pn.prototype.close = function() {
  this.isOpen && (this.isOpen = !1, this.reader.unref());
};
function dt(e, t) {
  e.autoClose && e.close(), D1(e, t);
}
function D1(e, t) {
  e.emittedError || (e.emittedError = !0, e.emit("error", t));
}
pn.prototype.readEntry = function() {
  if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
  this._readEntry();
};
pn.prototype._readEntry = function() {
  var e = this;
  if (e.entryCount === e.entriesRead) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    setImmediate(function() {
      if (self2.autoClose) self2.close();
      if (self2.emittedError) return;
      self2.emit("end");
    });
    return;
  }
<<<<<<< HEAD
  if (self2.emittedError) return;
  var buffer2 = newBuffer(46);
  readAndAssertNoEof(self2.reader, buffer2, 0, buffer2.length, self2.readEntryCursor, function(err) {
    if (err) return emitErrorAndAutoClose(self2, err);
    if (self2.emittedError) return;
    var entry = new Entry();
    var signature = buffer2.readUInt32LE(0);
    if (signature !== 33639248) return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
    entry.versionMadeBy = buffer2.readUInt16LE(4);
    entry.versionNeededToExtract = buffer2.readUInt16LE(6);
    entry.generalPurposeBitFlag = buffer2.readUInt16LE(8);
    entry.compressionMethod = buffer2.readUInt16LE(10);
    entry.lastModFileTime = buffer2.readUInt16LE(12);
    entry.lastModFileDate = buffer2.readUInt16LE(14);
    entry.crc32 = buffer2.readUInt32LE(16);
    entry.compressedSize = buffer2.readUInt32LE(20);
    entry.uncompressedSize = buffer2.readUInt32LE(24);
    entry.fileNameLength = buffer2.readUInt16LE(28);
    entry.extraFieldLength = buffer2.readUInt16LE(30);
    entry.fileCommentLength = buffer2.readUInt16LE(32);
    entry.internalFileAttributes = buffer2.readUInt16LE(36);
    entry.externalFileAttributes = buffer2.readUInt32LE(38);
    entry.relativeOffsetOfLocalHeader = buffer2.readUInt32LE(42);
    if (entry.generalPurposeBitFlag & 64) return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
    self2.readEntryCursor += 46;
    buffer2 = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
    readAndAssertNoEof(self2.reader, buffer2, 0, buffer2.length, self2.readEntryCursor, function(err2) {
      if (err2) return emitErrorAndAutoClose(self2, err2);
      if (self2.emittedError) return;
      var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
      entry.fileName = self2.decodeStrings ? decodeBuffer(buffer2, 0, entry.fileNameLength, isUtf8) : buffer2.slice(0, entry.fileNameLength);
      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
      var extraFieldBuffer = buffer2.slice(entry.fileNameLength, fileCommentStart);
      entry.extraFields = [];
      var i = 0;
      while (i < extraFieldBuffer.length - 3) {
        var headerId = extraFieldBuffer.readUInt16LE(i + 0);
        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
        var dataStart = i + 4;
        var dataEnd = dataStart + dataSize;
        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
        var dataBuffer = newBuffer(dataSize);
        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
        entry.extraFields.push({
          id: headerId,
          data: dataBuffer
=======
  if (!e.emittedError) {
    var t = Tt(46);
    Ar(e.reader, t, 0, t.length, e.readEntryCursor, function(n) {
      if (n) return dt(e, n);
      if (!e.emittedError) {
        var r = new Yi(), i = t.readUInt32LE(0);
        if (i !== 33639248) return dt(e, new Error("invalid central directory file header signature: 0x" + i.toString(16)));
        if (r.versionMadeBy = t.readUInt16LE(4), r.versionNeededToExtract = t.readUInt16LE(6), r.generalPurposeBitFlag = t.readUInt16LE(8), r.compressionMethod = t.readUInt16LE(10), r.lastModFileTime = t.readUInt16LE(12), r.lastModFileDate = t.readUInt16LE(14), r.crc32 = t.readUInt32LE(16), r.compressedSize = t.readUInt32LE(20), r.uncompressedSize = t.readUInt32LE(24), r.fileNameLength = t.readUInt16LE(28), r.extraFieldLength = t.readUInt16LE(30), r.fileCommentLength = t.readUInt16LE(32), r.internalFileAttributes = t.readUInt16LE(36), r.externalFileAttributes = t.readUInt32LE(38), r.relativeOffsetOfLocalHeader = t.readUInt32LE(42), r.generalPurposeBitFlag & 64) return dt(e, new Error("strong encryption is not supported"));
        e.readEntryCursor += 46, t = Tt(r.fileNameLength + r.extraFieldLength + r.fileCommentLength), Ar(e.reader, t, 0, t.length, e.readEntryCursor, function(a) {
          if (a) return dt(e, a);
          if (!e.emittedError) {
            var s = (r.generalPurposeBitFlag & 2048) !== 0;
            r.fileName = e.decodeStrings ? es(t, 0, r.fileNameLength, s) : t.slice(0, r.fileNameLength);
            var c = r.fileNameLength + r.extraFieldLength, o = t.slice(r.fileNameLength, c);
            r.extraFields = [];
            for (var u = 0; u < o.length - 3; ) {
              var l = o.readUInt16LE(u + 0), p = o.readUInt16LE(u + 2), f = u + 4, m = f + p;
              if (m > o.length) return dt(e, new Error("extra field length exceeds extra field buffer size"));
              var g = Tt(p);
              o.copy(g, 0, f, m), r.extraFields.push({
                id: l,
                data: g
              }), u = m;
            }
            if (r.fileComment = e.decodeStrings ? es(t, c, c + r.fileCommentLength, s) : t.slice(c, c + r.fileCommentLength), r.comment = r.fileComment, e.readEntryCursor += t.length, e.entriesRead += 1, r.uncompressedSize === 4294967295 || r.compressedSize === 4294967295 || r.relativeOffsetOfLocalHeader === 4294967295) {
              for (var h = null, u = 0; u < r.extraFields.length; u++) {
                var b = r.extraFields[u];
                if (b.id === 1) {
                  h = b.data;
                  break;
                }
              }
              if (h == null)
                return dt(e, new Error("expected zip64 extended information extra field"));
              var x = 0;
              if (r.uncompressedSize === 4294967295) {
                if (x + 8 > h.length)
                  return dt(e, new Error("zip64 extended information extra field does not include uncompressed size"));
                r.uncompressedSize = Tr(h, x), x += 8;
              }
              if (r.compressedSize === 4294967295) {
                if (x + 8 > h.length)
                  return dt(e, new Error("zip64 extended information extra field does not include compressed size"));
                r.compressedSize = Tr(h, x), x += 8;
              }
              if (r.relativeOffsetOfLocalHeader === 4294967295) {
                if (x + 8 > h.length)
                  return dt(e, new Error("zip64 extended information extra field does not include relative header offset"));
                r.relativeOffsetOfLocalHeader = Tr(h, x), x += 8;
              }
            }
            if (e.decodeStrings)
              for (var u = 0; u < r.extraFields.length; u++) {
                var b = r.extraFields[u];
                if (b.id === 28789) {
                  if (b.data.length < 6 || b.data.readUInt8(0) !== 1)
                    continue;
                  var y = b.data.readUInt32LE(1);
                  if (v_.unsigned(t.slice(0, r.fileNameLength)) !== y)
                    continue;
                  r.fileName = es(b.data, 5, b.data.length, !0);
                  break;
                }
              }
            if (e.validateEntrySizes && r.compressionMethod === 0) {
              var E = r.uncompressedSize;
              if (r.isEncrypted() && (E += 12), r.compressedSize !== E) {
                var S = "compressed/uncompressed size mismatch for stored file: " + r.compressedSize + " != " + r.uncompressedSize;
                return dt(e, new Error(S));
              }
            }
            if (e.decodeStrings) {
              e.strictFileNames || (r.fileName = r.fileName.replace(/\\/g, "/"));
              var D = P1(r.fileName, e.validateFileNameOptions);
              if (D != null) return dt(e, new Error(D));
            }
            e.emit("entry", r), e.lazyEntries || e._readEntry();
          }
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        });
        i = dataEnd;
      }
<<<<<<< HEAD
      entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer2, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer2.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
      entry.comment = entry.fileComment;
      self2.readEntryCursor += buffer2.length;
      self2.entriesRead += 1;
      if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
        var zip64EiefBuffer = null;
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id === 1) {
            zip64EiefBuffer = extraField.data;
            break;
          }
        }
        if (zip64EiefBuffer == null) {
          return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
        }
        var index = 0;
        if (entry.uncompressedSize === 4294967295) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
          }
          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        if (entry.compressedSize === 4294967295) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
          }
          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        if (entry.relativeOffsetOfLocalHeader === 4294967295) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
          }
          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
      }
      if (self2.decodeStrings) {
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id === 28789) {
            if (extraField.data.length < 6) {
              continue;
            }
            if (extraField.data.readUInt8(0) !== 1) {
              continue;
            }
            var oldNameCrc32 = extraField.data.readUInt32LE(1);
            if (crc32.unsigned(buffer2.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
              continue;
            }
            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
            break;
          }
        }
      }
      if (self2.validateEntrySizes && entry.compressionMethod === 0) {
        var expectedCompressedSize = entry.uncompressedSize;
        if (entry.isEncrypted()) {
          expectedCompressedSize += 12;
        }
        if (entry.compressedSize !== expectedCompressedSize) {
          var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
          return emitErrorAndAutoClose(self2, new Error(msg));
        }
      }
      if (self2.decodeStrings) {
        if (!self2.strictFileNames) {
          entry.fileName = entry.fileName.replace(/\\/g, "/");
        }
        var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
        if (errorMessage != null) return emitErrorAndAutoClose(self2, new Error(errorMessage));
      }
      self2.emit("entry", entry);
      if (!self2.lazyEntries) self2._readEntry();
=======
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    });
  });
};
<<<<<<< HEAD
ZipFile.prototype.openReadStream = function(entry, options, callback) {
  var self2 = this;
  var relativeStart = 0;
  var relativeEnd = entry.compressedSize;
  if (callback == null) {
    callback = options;
    options = {};
  } else {
    if (options.decrypt != null) {
      if (!entry.isEncrypted()) {
=======
pn.prototype.openReadStream = function(e, t, n) {
  var r = this, i = 0, a = e.compressedSize;
  if (n == null)
    n = t, t = {};
  else {
    if (t.decrypt != null) {
      if (!e.isEncrypted())
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        throw new Error("options.decrypt can only be specified for encrypted entries");
      }
      if (options.decrypt !== false) throw new Error("invalid options.decrypt value: " + options.decrypt);
      if (entry.isCompressed()) {
        if (options.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
      }
    }
    if (options.decompress != null) {
      if (!entry.isCompressed()) {
        throw new Error("options.decompress can only be specified for compressed entries");
      }
      if (!(options.decompress === false || options.decompress === true)) {
        throw new Error("invalid options.decompress value: " + options.decompress);
      }
    }
    if (options.start != null || options.end != null) {
      if (entry.isCompressed() && options.decompress !== false) {
        throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
      }
      if (entry.isEncrypted() && options.decrypt !== false) {
        throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
      }
    }
    if (options.start != null) {
      relativeStart = options.start;
      if (relativeStart < 0) throw new Error("options.start < 0");
      if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
    }
    if (options.end != null) {
      relativeEnd = options.end;
      if (relativeEnd < 0) throw new Error("options.end < 0");
      if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
      if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
    }
  }
<<<<<<< HEAD
  if (!self2.isOpen) return callback(new Error("closed"));
  if (entry.isEncrypted()) {
    if (options.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
  }
  self2.reader.ref();
  var buffer2 = newBuffer(30);
  readAndAssertNoEof(self2.reader, buffer2, 0, buffer2.length, entry.relativeOffsetOfLocalHeader, function(err) {
    try {
      if (err) return callback(err);
      var signature = buffer2.readUInt32LE(0);
      if (signature !== 67324752) {
        return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
      }
      var fileNameLength = buffer2.readUInt16LE(26);
      var extraFieldLength = buffer2.readUInt16LE(28);
      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer2.length + fileNameLength + extraFieldLength;
      var decompress;
      if (entry.compressionMethod === 0) {
        decompress = false;
      } else if (entry.compressionMethod === 8) {
        decompress = options.decompress != null ? options.decompress : true;
      } else {
        return callback(new Error("unsupported compression method: " + entry.compressionMethod));
      }
      var fileDataStart = localFileHeaderEnd;
      var fileDataEnd = fileDataStart + entry.compressedSize;
      if (entry.compressedSize !== 0) {
        if (fileDataEnd > self2.fileSize) {
          return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
        }
      }
      var readStream2 = self2.reader.createReadStream({
        start: fileDataStart + relativeStart,
        end: fileDataStart + relativeEnd
      });
      var endpointStream = readStream2;
      if (decompress) {
        var destroyed = false;
        var inflateFilter = zlib$2.createInflateRaw();
        readStream2.on("error", function(err2) {
          setImmediate(function() {
            if (!destroyed) inflateFilter.emit("error", err2);
          });
        });
        readStream2.pipe(inflateFilter);
        if (self2.validateEntrySizes) {
          endpointStream = new AssertByteCountStream(entry.uncompressedSize);
          inflateFilter.on("error", function(err2) {
            setImmediate(function() {
              if (!destroyed) endpointStream.emit("error", err2);
            });
          });
          inflateFilter.pipe(endpointStream);
        } else {
          endpointStream = inflateFilter;
        }
        endpointStream.destroy = function() {
          destroyed = true;
          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
          readStream2.unpipe(inflateFilter);
          readStream2.destroy();
        };
      }
      callback(null, endpointStream);
=======
  if (!r.isOpen) return n(new Error("closed"));
  if (e.isEncrypted() && t.decrypt !== !1)
    return n(new Error("entry is encrypted, and options.decrypt !== false"));
  r.reader.ref();
  var s = Tt(30);
  Ar(r.reader, s, 0, s.length, e.relativeOffsetOfLocalHeader, function(c) {
    try {
      if (c) return n(c);
      var o = s.readUInt32LE(0);
      if (o !== 67324752)
        return n(new Error("invalid local file header signature: 0x" + o.toString(16)));
      var u = s.readUInt16LE(26), l = s.readUInt16LE(28), p = e.relativeOffsetOfLocalHeader + s.length + u + l, f;
      if (e.compressionMethod === 0)
        f = !1;
      else if (e.compressionMethod === 8)
        f = t.decompress != null ? t.decompress : !0;
      else
        return n(new Error("unsupported compression method: " + e.compressionMethod));
      var m = p, g = m + e.compressedSize;
      if (e.compressedSize !== 0 && g > r.fileSize)
        return n(new Error("file data overflows file bounds: " + m + " + " + e.compressedSize + " > " + r.fileSize));
      var h = r.reader.createReadStream({
        start: m + i,
        end: m + a
      }), b = h;
      if (f) {
        var x = !1, y = m_.createInflateRaw();
        h.on("error", function(E) {
          setImmediate(function() {
            x || y.emit("error", E);
          });
        }), h.pipe(y), r.validateEntrySizes ? (b = new Xi(e.uncompressedSize), y.on("error", function(E) {
          setImmediate(function() {
            x || b.emit("error", E);
          });
        }), y.pipe(b)) : b = y, b.destroy = function() {
          x = !0, y !== b && y.unpipe(b), h.unpipe(y), h.destroy();
        };
      }
      n(null, b);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    } finally {
      self2.reader.unref();
    }
  });
};
<<<<<<< HEAD
function Entry() {
}
Entry.prototype.getLastModDate = function() {
  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
};
Entry.prototype.isEncrypted = function() {
  return (this.generalPurposeBitFlag & 1) !== 0;
};
Entry.prototype.isCompressed = function() {
  return this.compressionMethod === 8;
};
function dosDateTimeToDate(date, time) {
  var day = date & 31;
  var month = (date >> 5 & 15) - 1;
  var year = (date >> 9 & 127) + 1980;
  var millisecond = 0;
  var second = (time & 31) * 2;
  var minute = time >> 5 & 63;
  var hour = time >> 11 & 31;
  return new Date(year, month, day, hour, minute, second, millisecond);
}
function validateFileName(fileName) {
  if (fileName.indexOf("\\") !== -1) {
    return "invalid characters in fileName: " + fileName;
  }
  if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
    return "absolute path: " + fileName;
  }
  if (fileName.split("/").indexOf("..") !== -1) {
    return "invalid relative path: " + fileName;
  }
  return null;
}
function readAndAssertNoEof(reader, buffer2, offset, length, position, callback) {
  if (length === 0) {
    return setImmediate(function() {
      callback(null, newBuffer(0));
    });
  }
  reader.read(buffer2, offset, length, position, function(err, bytesRead) {
    if (err) return callback(err);
    if (bytesRead < length) {
      return callback(new Error("unexpected EOF"));
    }
    callback();
  });
}
util$5.inherits(AssertByteCountStream, Transform);
function AssertByteCountStream(byteCount) {
  Transform.call(this);
  this.actualByteCount = 0;
  this.expectedByteCount = byteCount;
}
AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
  this.actualByteCount += chunk.length;
  if (this.actualByteCount > this.expectedByteCount) {
    var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
    return cb(new Error(msg));
=======
function Yi() {
}
Yi.prototype.getLastModDate = function() {
  return F1(this.lastModFileDate, this.lastModFileTime);
};
Yi.prototype.isEncrypted = function() {
  return (this.generalPurposeBitFlag & 1) !== 0;
};
Yi.prototype.isCompressed = function() {
  return this.compressionMethod === 8;
};
function F1(e, t) {
  var n = e & 31, r = (e >> 5 & 15) - 1, i = (e >> 9 & 127) + 1980, a = 0, s = (t & 31) * 2, c = t >> 5 & 63, o = t >> 11 & 31;
  return new Date(i, r, n, o, c, s, a);
}
function P1(e) {
  return e.indexOf("\\") !== -1 ? "invalid characters in fileName: " + e : /^[a-zA-Z]:/.test(e) || /^\//.test(e) ? "absolute path: " + e : e.split("/").indexOf("..") !== -1 ? "invalid relative path: " + e : null;
}
function Ar(e, t, n, r, i, a) {
  if (r === 0)
    return setImmediate(function() {
      a(null, Tt(0));
    });
  e.read(t, n, r, i, function(s, c) {
    if (s) return a(s);
    if (c < r)
      return a(new Error("unexpected EOF"));
    a();
  });
}
to.inherits(Xi, O1);
function Xi(e) {
  O1.call(this), this.actualByteCount = 0, this.expectedByteCount = e;
}
Xi.prototype._transform = function(e, t, n) {
  if (this.actualByteCount += e.length, this.actualByteCount > this.expectedByteCount) {
    var r = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
    return n(new Error(r));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  cb(null, chunk);
};
<<<<<<< HEAD
AssertByteCountStream.prototype._flush = function(cb) {
=======
Xi.prototype._flush = function(e) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  if (this.actualByteCount < this.expectedByteCount) {
    var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
    return cb(new Error(msg));
  }
  cb();
};
<<<<<<< HEAD
util$5.inherits(RandomAccessReader, EventEmitter$1);
function RandomAccessReader() {
  EventEmitter$1.call(this);
  this.refCount = 0;
}
RandomAccessReader.prototype.ref = function() {
  this.refCount += 1;
};
RandomAccessReader.prototype.unref = function() {
  var self2 = this;
  self2.refCount -= 1;
  if (self2.refCount > 0) return;
  if (self2.refCount < 0) throw new Error("invalid unref");
  self2.close(onCloseDone);
  function onCloseDone(err) {
    if (err) return self2.emit("error", err);
    self2.emit("close");
  }
};
RandomAccessReader.prototype.createReadStream = function(options) {
  var start = options.start;
  var end2 = options.end;
  if (start === end2) {
    var emptyStream2 = new PassThrough();
    setImmediate(function() {
      emptyStream2.end();
    });
    return emptyStream2;
  }
  var stream2 = this._readStreamForRange(start, end2);
  var destroyed = false;
  var refUnrefFilter = new RefUnrefFilter(this);
  stream2.on("error", function(err) {
    setImmediate(function() {
      if (!destroyed) refUnrefFilter.emit("error", err);
    });
  });
  refUnrefFilter.destroy = function() {
    stream2.unpipe(refUnrefFilter);
    refUnrefFilter.unref();
    stream2.destroy();
  };
  var byteCounter = new AssertByteCountStream(end2 - start);
  refUnrefFilter.on("error", function(err) {
    setImmediate(function() {
      if (!destroyed) byteCounter.emit("error", err);
    });
  });
  byteCounter.destroy = function() {
    destroyed = true;
    refUnrefFilter.unpipe(byteCounter);
    refUnrefFilter.destroy();
  };
  return stream2.pipe(refUnrefFilter).pipe(byteCounter);
};
RandomAccessReader.prototype._readStreamForRange = function(start, end2) {
  throw new Error("not implemented");
};
RandomAccessReader.prototype.read = function(buffer2, offset, length, position, callback) {
  var readStream2 = this.createReadStream({ start: position, end: position + length });
  var writeStream = new Writable$1();
  var written = 0;
  writeStream._write = function(chunk, encoding, cb) {
    chunk.copy(buffer2, offset + written, 0, chunk.length);
    written += chunk.length;
    cb();
  };
  writeStream.on("finish", callback);
  readStream2.on("error", function(error2) {
    callback(error2);
  });
  readStream2.pipe(writeStream);
};
RandomAccessReader.prototype.close = function(callback) {
  setImmediate(callback);
};
util$5.inherits(RefUnrefFilter, PassThrough);
function RefUnrefFilter(context) {
  PassThrough.call(this);
  this.context = context;
  this.context.ref();
  this.unreffedYet = false;
}
RefUnrefFilter.prototype._flush = function(cb) {
  this.unref();
  cb();
};
RefUnrefFilter.prototype.unref = function(cb) {
  if (this.unreffedYet) return;
  this.unreffedYet = true;
  this.context.unref();
};
var cp437 = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
function decodeBuffer(buffer2, start, end2, isUtf8) {
  if (isUtf8) {
    return buffer2.toString("utf8", start, end2);
  } else {
    var result = "";
    for (var i = start; i < end2; i++) {
      result += cp437[buffer2[i]];
    }
    return result;
  }
}
function readUInt64LE(buffer2, offset) {
  var lower32 = buffer2.readUInt32LE(offset);
  var upper32 = buffer2.readUInt32LE(offset + 4);
  return upper32 * 4294967296 + lower32;
}
var newBuffer;
if (typeof Buffer.allocUnsafe === "function") {
  newBuffer = function(len) {
    return Buffer.allocUnsafe(len);
  };
} else {
  newBuffer = function(len) {
    return new Buffer(len);
  };
}
function defaultCallback(err) {
  if (err) throw err;
}
const stream$5 = require$$1$2;
let UncompressBaseStream$1 = class UncompressBaseStream extends stream$5.Writable {
  emit(event, data) {
    if (event === "error") {
      const error2 = data;
      if (error2.name === "Error") {
        error2.name = this.constructor.name + "Error";
      }
=======
to.inherits(bn, no);
function bn() {
  no.call(this), this.refCount = 0;
}
bn.prototype.ref = function() {
  this.refCount += 1;
};
bn.prototype.unref = function() {
  var e = this;
  if (e.refCount -= 1, e.refCount > 0) return;
  if (e.refCount < 0) throw new Error("invalid unref");
  e.close(t);
  function t(n) {
    if (n) return e.emit("error", n);
    e.emit("close");
  }
};
bn.prototype.createReadStream = function(e) {
  var t = e.start, n = e.end;
  if (t === n) {
    var r = new Tu();
    return setImmediate(function() {
      r.end();
    }), r;
  }
  var i = this._readStreamForRange(t, n), a = !1, s = new ro(this);
  i.on("error", function(o) {
    setImmediate(function() {
      a || s.emit("error", o);
    });
  }), s.destroy = function() {
    i.unpipe(s), s.unref(), i.destroy();
  };
  var c = new Xi(n - t);
  return s.on("error", function(o) {
    setImmediate(function() {
      a || c.emit("error", o);
    });
  }), c.destroy = function() {
    a = !0, s.unpipe(c), s.destroy();
  }, i.pipe(s).pipe(c);
};
bn.prototype._readStreamForRange = function(e, t) {
  throw new Error("not implemented");
};
bn.prototype.read = function(e, t, n, r, i) {
  var a = this.createReadStream({ start: r, end: r + n }), s = new g_(), c = 0;
  s._write = function(o, u, l) {
    o.copy(e, t + c, 0, o.length), c += o.length, l();
  }, s.on("finish", i), a.on("error", function(o) {
    i(o);
  }), a.pipe(s);
};
bn.prototype.close = function(e) {
  setImmediate(e);
};
to.inherits(ro, Tu);
function ro(e) {
  Tu.call(this), this.context = e, this.context.ref(), this.unreffedYet = !1;
}
ro.prototype._flush = function(e) {
  this.unref(), e();
};
ro.prototype.unref = function(e) {
  this.unreffedYet || (this.unreffedYet = !0, this.context.unref());
};
var y_ = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
function es(e, t, n, r) {
  if (r)
    return e.toString("utf8", t, n);
  for (var i = "", a = t; a < n; a++)
    i += y_[e[a]];
  return i;
}
function Tr(e, t) {
  var n = e.readUInt32LE(t), r = e.readUInt32LE(t + 4);
  return r * 4294967296 + n;
}
var Tt;
typeof Buffer.allocUnsafe == "function" ? Tt = function(e) {
  return Buffer.allocUnsafe(e);
} : Tt = function(e) {
  return new Buffer(e);
};
function hs(e) {
  if (e) throw e;
}
const w_ = ae;
let E_ = class extends w_.Writable {
  emit(t, n) {
    if (t === "error") {
      const r = n;
      r.name === "Error" && (r.name = this.constructor.name + "Error");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    super.emit.apply(this, arguments);
  }
};
<<<<<<< HEAD
var base_write_stream = UncompressBaseStream$1;
var lib$3 = { exports: {} };
var buffer = require$$0$5;
var Buffer$1 = buffer.Buffer;
var safer = {};
var key;
for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue;
  if (key === "SlowBuffer" || key === "Buffer") continue;
  safer[key] = buffer[key];
}
var Safer = safer.Buffer = {};
for (key in Buffer$1) {
  if (!Buffer$1.hasOwnProperty(key)) continue;
  if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
  Safer[key] = Buffer$1[key];
}
safer.Buffer.prototype = Buffer$1.prototype;
if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function(value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
    }
    if (value && typeof value.length === "undefined") {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    return Buffer$1(value, encodingOrOffset, length);
  };
}
if (!Safer.alloc) {
  Safer.alloc = function(size, fill2, encoding) {
    if (typeof size !== "number") {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
    var buf = Buffer$1(size);
    if (!fill2 || fill2.length === 0) {
      buf.fill(0);
    } else if (typeof encoding === "string") {
      buf.fill(fill2, encoding);
    } else {
      buf.fill(fill2);
    }
    return buf;
  };
}
if (!safer.kStringMaxLength) {
=======
var __ = E_, wc = { exports: {} }, ts = Bt, Cr = ts.Buffer, ot = {}, ct;
for (ct in ts)
  ts.hasOwnProperty(ct) && (ct === "SlowBuffer" || ct === "Buffer" || (ot[ct] = ts[ct]));
var Rr = ot.Buffer = {};
for (ct in Cr)
  Cr.hasOwnProperty(ct) && (ct === "allocUnsafe" || ct === "allocUnsafeSlow" || (Rr[ct] = Cr[ct]));
ot.Buffer.prototype = Cr.prototype;
(!Rr.from || Rr.from === Uint8Array.from) && (Rr.from = function(e, t, n) {
  if (typeof e == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof e);
  if (e && typeof e.length > "u")
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
  return Cr(e, t, n);
});
Rr.alloc || (Rr.alloc = function(e, t, n) {
  if (typeof e != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof e);
  if (e < 0 || e >= 2 * (1 << 30))
    throw new RangeError('The value "' + e + '" is invalid for option "size"');
  var r = Cr(e);
  return !t || t.length === 0 ? r.fill(0) : typeof n == "string" ? r.fill(t, n) : r.fill(t), r;
});
if (!ot.kStringMaxLength)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  try {
    ot.kStringMaxLength = process.binding("buffer").kStringMaxLength;
  } catch {
  }
<<<<<<< HEAD
}
if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  };
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
  }
}
var safer_1 = safer;
var bomHandling$1 = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling$1;
  hasRequiredBomHandling = 1;
  var BOMChar2 = "\uFEFF";
  bomHandling$1.PrependBOM = PrependBOMWrapper2;
  function PrependBOMWrapper2(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper2.prototype.write = function(str2) {
    if (this.addBOM) {
      str2 = BOMChar2 + str2;
      this.addBOM = false;
    }
    return this.encoder.write(str2);
  };
  PrependBOMWrapper2.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling$1.StripBOM = StripBOMWrapper2;
  function StripBOMWrapper2(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper2.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar2) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper2.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling$1;
}
var encodings$1 = {};
var internal$1;
var hasRequiredInternal$1;
function requireInternal$1() {
  if (hasRequiredInternal$1) return internal$1;
  hasRequiredInternal$1 = 1;
  var Buffer2 = safer_1.Buffer;
  internal$1 = {
=======
ot.constants || (ot.constants = {
  MAX_LENGTH: ot.kMaxLength
}, ot.kStringMaxLength && (ot.constants.MAX_STRING_LENGTH = ot.kStringMaxLength));
var Ge = ot, Ta = {}, Qf;
function S_() {
  if (Qf) return Ta;
  Qf = 1;
  var e = "\uFEFF";
  Ta.PrependBOM = t;
  function t(r, i) {
    this.encoder = r, this.addBOM = !0;
  }
  t.prototype.write = function(r) {
    return this.addBOM && (r = e + r, this.addBOM = !1), this.encoder.write(r);
  }, t.prototype.end = function() {
    return this.encoder.end();
  }, Ta.StripBOM = n;
  function n(r, i) {
    this.decoder = r, this.pass = !1, this.options = i || {};
  }
  return n.prototype.write = function(r) {
    var i = this.decoder.write(r);
    return this.pass || !i || (i[0] === e && (i = i.slice(1), typeof this.options.stripBOM == "function" && this.options.stripBOM()), this.pass = !0), i;
  }, n.prototype.end = function() {
    return this.decoder.end();
  }, Ta;
}
var Ec = {}, _c, ed;
function A_() {
  if (ed) return _c;
  ed = 1;
  var e = Ge.Buffer;
  _c = {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
<<<<<<< HEAD
  function InternalCodec(codecOptions, iconv2) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv2.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder2 = require$$1$7.StringDecoder;
  if (!StringDecoder2.prototype.end)
    StringDecoder2.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    StringDecoder2.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder2.prototype;
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str2) {
    return Buffer2.from(str2, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str2) {
    str2 = this.prevStr + str2;
    var completeQuads = str2.length - str2.length % 4;
    this.prevStr = str2.slice(completeQuads);
    str2 = str2.slice(0, completeQuads);
    return Buffer2.from(str2, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length * 3), bufIdx = 0;
    for (var i = 0; i < str2.length; i++) {
      var charCode = str2.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
  return internal$1;
}
var utf32$1 = {};
var hasRequiredUtf32$1;
function requireUtf32$1() {
  if (hasRequiredUtf32$1) return utf32$1;
  hasRequiredUtf32$1 = 1;
  var Buffer2 = safer_1.Buffer;
  utf32$1._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv2) {
    this.iconv = iconv2;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32$1.utf32le = { type: "_utf32", isLE: true };
  utf32$1.utf32be = { type: "_utf32", isLE: false };
  utf32$1.ucs4le = "utf32le";
  utf32$1.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str2) {
    var src2 = Buffer2.from(str2, "ucs2");
    var dst = Buffer2.alloc(src2.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src2.length; i += 2) {
      var code = src2.readUInt16LE(i);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer2.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = null;
  }
  Utf32Decoder.prototype.write = function(src2) {
    if (src2.length === 0)
      return "";
    if (this.overflow)
      src2 = Buffer2.concat([this.overflow, src2]);
    var goodLength = src2.length - src2.length % 4;
    if (src2.length !== goodLength) {
      this.overflow = src2.slice(goodLength);
      src2 = src2.slice(0, goodLength);
    } else
      this.overflow = null;
    var dst = Buffer2.alloc(goodLength);
    var offset = 0;
    for (var i = 0; i < goodLength; i += 4) {
      var codepoint = this.isLE ? src2.readUInt32LE(i) : src2.readUInt32BE(i);
      if (codepoint < 65536) {
        dst.writeUInt16LE(codepoint, offset);
        offset += 2;
      } else {
        if (codepoint > 1114111) {
          dst.writeUInt16LE(this.badChar, offset);
          offset += 2;
        } else {
          codepoint -= 65536;
          var high = 55296 | codepoint >> 10;
          var low = 56320 + (codepoint & 1023);
          dst.writeUInt16LE(high, offset);
          offset += 2;
          dst.writeUInt16LE(low, offset);
          offset += 2;
        }
      }
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  Utf32Decoder.prototype.end = function() {
    this.overflow = null;
  };
  utf32$1.utf32 = Utf32AutoCodec;
  utf32$1.ucs4 = Utf32AutoCodec;
  function Utf32AutoCodec(options, iconv2) {
    this.iconv = iconv2;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 32)
=======
  function t(o, u) {
    this.enc = o.encodingName, this.bomAware = o.bomAware, this.enc === "base64" ? this.encoder = a : this.enc === "cesu8" && (this.enc = "utf8", this.encoder = s, e.from("eda0bdedb2a9", "hex").toString() !== "" && (this.decoder = c, this.defaultCharUnicode = u.defaultCharUnicode));
  }
  t.prototype.encoder = i, t.prototype.decoder = r;
  var n = Os.StringDecoder;
  n.prototype.end || (n.prototype.end = function() {
  });
  function r(o, u) {
    n.call(this, u.enc);
  }
  r.prototype = n.prototype;
  function i(o, u) {
    this.enc = u.enc;
  }
  i.prototype.write = function(o) {
    return e.from(o, this.enc);
  }, i.prototype.end = function() {
  };
  function a(o, u) {
    this.prevStr = "";
  }
  a.prototype.write = function(o) {
    o = this.prevStr + o;
    var u = o.length - o.length % 4;
    return this.prevStr = o.slice(u), o = o.slice(0, u), e.from(o, "base64");
  }, a.prototype.end = function() {
    return e.from(this.prevStr, "base64");
  };
  function s(o, u) {
  }
  s.prototype.write = function(o) {
    for (var u = e.alloc(o.length * 3), l = 0, p = 0; p < o.length; p++) {
      var f = o.charCodeAt(p);
      f < 128 ? u[l++] = f : f < 2048 ? (u[l++] = 192 + (f >>> 6), u[l++] = 128 + (f & 63)) : (u[l++] = 224 + (f >>> 12), u[l++] = 128 + (f >>> 6 & 63), u[l++] = 128 + (f & 63));
    }
    return u.slice(0, l);
  }, s.prototype.end = function() {
  };
  function c(o, u) {
    this.acc = 0, this.contBytes = 0, this.accBytes = 0, this.defaultCharUnicode = u.defaultCharUnicode;
  }
  return c.prototype.write = function(o) {
    for (var u = this.acc, l = this.contBytes, p = this.accBytes, f = "", m = 0; m < o.length; m++) {
      var g = o[m];
      (g & 192) !== 128 ? (l > 0 && (f += this.defaultCharUnicode, l = 0), g < 128 ? f += String.fromCharCode(g) : g < 224 ? (u = g & 31, l = 1, p = 1) : g < 240 ? (u = g & 15, l = 2, p = 1) : f += this.defaultCharUnicode) : l > 0 ? (u = u << 6 | g & 63, l--, p++, l === 0 && (p === 2 && u < 128 && u > 0 ? f += this.defaultCharUnicode : p === 3 && u < 2048 ? f += this.defaultCharUnicode : f += String.fromCharCode(u))) : f += this.defaultCharUnicode;
    }
    return this.acc = u, this.contBytes = l, this.accBytes = p, f;
  }, c.prototype.end = function() {
    var o = 0;
    return this.contBytes > 0 && (o += this.defaultCharUnicode), o;
  }, _c;
}
var kt = {}, td;
function T_() {
  if (td) return kt;
  td = 1;
  var e = Ge.Buffer;
  kt._utf32 = t;
  function t(o, u) {
    this.iconv = u, this.bomAware = !0, this.isLE = o.isLE;
  }
  kt.utf32le = { type: "_utf32", isLE: !0 }, kt.utf32be = { type: "_utf32", isLE: !1 }, kt.ucs4le = "utf32le", kt.ucs4be = "utf32be", t.prototype.encoder = n, t.prototype.decoder = r;
  function n(o, u) {
    this.isLE = u.isLE, this.highSurrogate = 0;
  }
  n.prototype.write = function(o) {
    for (var u = e.from(o, "ucs2"), l = e.alloc(u.length * 2), p = this.isLE ? l.writeUInt32LE : l.writeUInt32BE, f = 0, m = 0; m < u.length; m += 2) {
      var g = u.readUInt16LE(m), h = 55296 <= g && g < 56320, b = 56320 <= g && g < 57344;
      if (this.highSurrogate)
        if (h || !b)
          p.call(l, this.highSurrogate, f), f += 4;
        else {
          var x = (this.highSurrogate - 55296 << 10 | g - 56320) + 65536;
          p.call(l, x, f), f += 4, this.highSurrogate = 0;
          continue;
        }
      h ? this.highSurrogate = g : (p.call(l, g, f), f += 4, this.highSurrogate = 0);
    }
    return f < l.length && (l = l.slice(0, f)), l;
  }, n.prototype.end = function() {
    if (this.highSurrogate) {
      var o = e.alloc(4);
      return this.isLE ? o.writeUInt32LE(this.highSurrogate, 0) : o.writeUInt32BE(this.highSurrogate, 0), this.highSurrogate = 0, o;
    }
  };
  function r(o, u) {
    this.isLE = u.isLE, this.badChar = u.iconv.defaultCharUnicode.charCodeAt(0), this.overflow = null;
  }
  r.prototype.write = function(o) {
    if (o.length === 0)
      return "";
    this.overflow && (o = e.concat([this.overflow, o]));
    var u = o.length - o.length % 4;
    o.length !== u ? (this.overflow = o.slice(u), o = o.slice(0, u)) : this.overflow = null;
    for (var l = e.alloc(u), p = 0, f = 0; f < u; f += 4) {
      var m = this.isLE ? o.readUInt32LE(f) : o.readUInt32BE(f);
      if (m < 65536)
        l.writeUInt16LE(m, p), p += 2;
      else if (m > 1114111)
        l.writeUInt16LE(this.badChar, p), p += 2;
      else {
        m -= 65536;
        var g = 55296 | m >> 10, h = 56320 + (m & 1023);
        l.writeUInt16LE(g, p), p += 2, l.writeUInt16LE(h, p), p += 2;
      }
    }
    return l.slice(0, p).toString("ucs2");
  }, r.prototype.end = function() {
    this.overflow = null;
  }, kt.utf32 = i, kt.ucs4 = i;
  function i(o, u) {
    this.iconv = u;
  }
  i.prototype.encoder = a, i.prototype.decoder = s;
  function a(o, u) {
    o = o || {}, o.addBOM === void 0 && (o.addBOM = !0), this.encoder = u.iconv.getEncoder(o.defaultEncoding || "utf-32le", o);
  }
  a.prototype.write = function(o) {
    return this.encoder.write(o);
  }, a.prototype.end = function() {
    return this.encoder.end();
  };
  function s(o, u) {
    this.decoder = null, this.initialBytes = [], this.initialBytesLen = 0, this.options = o || {}, this.iconv = u.iconv;
  }
  s.prototype.write = function(o) {
    if (!this.decoder) {
      if (this.initialBytes.push(o), this.initialBytesLen += o.length, this.initialBytesLen < 32)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        return "";
      var buf2 = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf2, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
<<<<<<< HEAD
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var res = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res + trail : res;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-32le";
    if (buf.length >= 4) {
      if (buf.readUInt32BE(0) === 65279)
        enc = "utf-32be";
      else if (buf.readUInt32LE(0) === 65279)
        enc = "utf-32le";
      else {
        var invalidLE = 0, invalidBE = 0;
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 4, 128);
        for (var i = 0; i < _len; i += 4) {
          var b0 = buf[i], b1 = buf[i + 1], b2 = buf[i + 2], b3 = buf[i + 3];
          if (b0 !== 0 || b1 > 16) ++invalidBE;
          if (b3 !== 0 || b2 > 16) ++invalidLE;
          if (b0 === 0 && b1 === 0 && b2 === 0 && b3 !== 0) asciiCharsBE++;
          if (b0 !== 0 && b1 === 0 && b2 === 0 && b3 === 0) asciiCharsLE++;
        }
        if (invalidBE < invalidLE)
          enc = "utf-32be";
        else if (invalidLE < invalidBE)
          enc = "utf-32le";
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-32be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-32le";
      }
    }
    return enc;
  }
  return utf32$1;
}
var utf16$1 = {};
var hasRequiredUtf16$1;
function requireUtf16$1() {
  if (hasRequiredUtf16$1) return utf16$1;
  hasRequiredUtf16$1 = 1;
  var Buffer2 = safer_1.Buffer;
  utf16$1.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str2) {
    var buf = Buffer2.from(str2, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
=======
    return this.decoder.write(o);
  }, s.prototype.end = function() {
    if (!this.decoder) {
      var o = e.concat(this.initialBytes), u = c(o, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(u, this.options);
      var l = this.decoder.write(o), p = this.decoder.end();
      return p ? l + p : l;
    }
    return this.decoder.end();
  };
  function c(o, u) {
    var l = u || "utf-32le";
    if (o.length >= 4)
      if (o.readUInt32BE(0) === 65279)
        l = "utf-32be";
      else if (o.readUInt32LE(0) === 65279)
        l = "utf-32le";
      else {
        for (var p = 0, f = 0, m = 0, g = 0, h = Math.min(o.length - o.length % 4, 128), b = 0; b < h; b += 4) {
          var x = o[b], y = o[b + 1], E = o[b + 2], S = o[b + 3];
          (x !== 0 || y > 16) && ++f, (S !== 0 || E > 16) && ++p, x === 0 && y === 0 && E === 0 && S !== 0 && g++, x !== 0 && y === 0 && E === 0 && S === 0 && m++;
        }
        f < p ? l = "utf-32be" : p < f && (l = "utf-32le"), g > m ? l = "utf-32be" : g < m && (l = "utf-32le");
      }
    return l;
  }
  return kt;
}
var Ca = {}, nd;
function C_() {
  if (nd) return Ca;
  nd = 1;
  var e = Ge.Buffer;
  Ca.utf16be = t;
  function t() {
  }
  t.prototype.encoder = n, t.prototype.decoder = r, t.prototype.bomAware = !0;
  function n() {
  }
  n.prototype.write = function(o) {
    for (var u = e.from(o, "ucs2"), l = 0; l < u.length; l += 2) {
      var p = u[l];
      u[l] = u[l + 1], u[l + 1] = p;
    }
    return u;
  }, n.prototype.end = function() {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
<<<<<<< HEAD
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
  };
  utf16$1.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv2) {
    this.iconv = iconv2;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var res = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res + trail : res;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2) {
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
        for (var i = 0; i < _len; i += 2) {
          if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
          if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-16be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-16le";
=======
  r.prototype.write = function(o) {
    if (o.length == 0)
      return "";
    var u = e.alloc(o.length + 1), l = 0, p = 0;
    for (this.overflowByte !== -1 && (u[0] = o[0], u[1] = this.overflowByte, l = 1, p = 2); l < o.length - 1; l += 2, p += 2)
      u[p] = o[l + 1], u[p + 1] = o[l];
    return this.overflowByte = l == o.length - 1 ? o[o.length - 1] : -1, u.slice(0, p).toString("ucs2");
  }, r.prototype.end = function() {
  }, Ca.utf16 = i;
  function i(o, u) {
    this.iconv = u;
  }
  i.prototype.encoder = a, i.prototype.decoder = s;
  function a(o, u) {
    o = o || {}, o.addBOM === void 0 && (o.addBOM = !0), this.encoder = u.iconv.getEncoder("utf-16le", o);
  }
  a.prototype.write = function(o) {
    return this.encoder.write(o);
  }, a.prototype.end = function() {
    return this.encoder.end();
  };
  function s(o, u) {
    this.decoder = null, this.initialBytes = [], this.initialBytesLen = 0, this.options = o || {}, this.iconv = u.iconv;
  }
  s.prototype.write = function(o) {
    if (!this.decoder) {
      if (this.initialBytes.push(o), this.initialBytesLen += o.length, this.initialBytesLen < 16)
        return "";
      var o = e.concat(this.initialBytes), u = c(o, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(u, this.options), this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(o);
  }, s.prototype.end = function() {
    if (!this.decoder) {
      var o = e.concat(this.initialBytes), u = c(o, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(u, this.options);
      var l = this.decoder.write(o), p = this.decoder.end();
      return p ? l + p : l;
    }
    return this.decoder.end();
  };
  function c(o, u) {
    var l = u || "utf-16le";
    if (o.length >= 2)
      if (o[0] == 254 && o[1] == 255)
        l = "utf-16be";
      else if (o[0] == 255 && o[1] == 254)
        l = "utf-16le";
      else {
        for (var p = 0, f = 0, m = Math.min(o.length - o.length % 2, 64), g = 0; g < m; g += 2)
          o[g] === 0 && o[g + 1] !== 0 && f++, o[g] !== 0 && o[g + 1] === 0 && p++;
        f > p ? l = "utf-16be" : f < p && (l = "utf-16le");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    }
    return enc;
  }
<<<<<<< HEAD
  return utf16$1;
}
var utf7$1 = {};
var hasRequiredUtf7$1;
function requireUtf7$1() {
  if (hasRequiredUtf7$1) return utf7$1;
  hasRequiredUtf7$1 = 1;
  var Buffer2 = safer_1.Buffer;
  utf7$1.utf7 = Utf7Codec;
  utf7$1.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv2) {
    this.iconv = iconv2;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str2) {
    return Buffer2.from(str2.replace(nonDirectChars, (function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
=======
  return Ca;
}
var Qr = {}, rd;
function R_() {
  if (rd) return Qr;
  rd = 1;
  var e = Ge.Buffer;
  Qr.utf7 = t, Qr.unicode11utf7 = "utf7";
  function t(h, b) {
    this.iconv = b;
  }
  t.prototype.encoder = r, t.prototype.decoder = i, t.prototype.bomAware = !0;
  var n = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function r(h, b) {
    this.iconv = b.iconv;
  }
  r.prototype.write = function(h) {
    return e.from(h.replace(n, (function(b) {
      return "+" + (b === "+" ? "" : this.iconv.encode(b, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }).bind(this)));
  };
<<<<<<< HEAD
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString();
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  utf7$1.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv2) {
    this.iconv = iconv2;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str2) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str2.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str2.length; i2++) {
      var uChar = str2.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  return utf7$1;
}
var sbcsCodec$1 = {};
var hasRequiredSbcsCodec$1;
function requireSbcsCodec$1() {
  if (hasRequiredSbcsCodec$1) return sbcsCodec$1;
  hasRequiredSbcsCodec$1 = 1;
  var Buffer2 = safer_1.Buffer;
  sbcsCodec$1._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv2) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv2.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
=======
  function i(h, b) {
    this.iconv = b.iconv, this.inBase64 = !1, this.base64Accum = "";
  }
  for (var a = /[A-Za-z0-9\/+]/, s = [], c = 0; c < 256; c++)
    s[c] = a.test(String.fromCharCode(c));
  var o = 43, u = 45, l = 38;
  i.prototype.write = function(h) {
    for (var b = "", x = 0, y = this.inBase64, E = this.base64Accum, S = 0; S < h.length; S++)
      if (!y)
        h[S] == o && (b += this.iconv.decode(h.slice(x, S), "ascii"), x = S + 1, y = !0);
      else if (!s[h[S]]) {
        if (S == x && h[S] == u)
          b += "+";
        else {
          var D = E + h.slice(x, S).toString();
          b += this.iconv.decode(e.from(D, "base64"), "utf16-be");
        }
        h[S] != u && S--, x = S + 1, y = !1, E = "";
      }
    if (!y)
      b += this.iconv.decode(h.slice(x), "ascii");
    else {
      var D = E + h.slice(x).toString(), U = D.length - D.length % 8;
      E = D.slice(U), D = D.slice(0, U), b += this.iconv.decode(e.from(D, "base64"), "utf16-be");
    }
    return this.inBase64 = y, this.base64Accum = E, b;
  }, i.prototype.end = function() {
    var h = "";
    return this.inBase64 && this.base64Accum.length > 0 && (h = this.iconv.decode(e.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", h;
  }, Qr.utf7imap = p;
  function p(h, b) {
    this.iconv = b;
  }
  p.prototype.encoder = f, p.prototype.decoder = m, p.prototype.bomAware = !0;
  function f(h, b) {
    this.iconv = b.iconv, this.inBase64 = !1, this.base64Accum = e.alloc(6), this.base64AccumIdx = 0;
  }
  f.prototype.write = function(h) {
    for (var b = this.inBase64, x = this.base64Accum, y = this.base64AccumIdx, E = e.alloc(h.length * 5 + 10), S = 0, D = 0; D < h.length; D++) {
      var U = h.charCodeAt(D);
      32 <= U && U <= 126 ? (b && (y > 0 && (S += E.write(x.slice(0, y).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), S), y = 0), E[S++] = u, b = !1), b || (E[S++] = U, U === l && (E[S++] = u))) : (b || (E[S++] = l, b = !0), b && (x[y++] = U >> 8, x[y++] = U & 255, y == x.length && (S += E.write(x.toString("base64").replace(/\//g, ","), S), y = 0)));
    }
    return this.inBase64 = b, this.base64AccumIdx = y, E.slice(0, S);
  }, f.prototype.end = function() {
    var h = e.alloc(10), b = 0;
    return this.inBase64 && (this.base64AccumIdx > 0 && (b += h.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), b), this.base64AccumIdx = 0), h[b++] = u, this.inBase64 = !1), h.slice(0, b);
  };
  function m(h, b) {
    this.iconv = b.iconv, this.inBase64 = !1, this.base64Accum = "";
  }
  var g = s.slice();
  return g[44] = !0, m.prototype.write = function(h) {
    for (var b = "", x = 0, y = this.inBase64, E = this.base64Accum, S = 0; S < h.length; S++)
      if (!y)
        h[S] == l && (b += this.iconv.decode(h.slice(x, S), "ascii"), x = S + 1, y = !0);
      else if (!g[h[S]]) {
        if (S == x && h[S] == u)
          b += "&";
        else {
          var D = E + h.slice(x, S).toString().replace(/,/g, "/");
          b += this.iconv.decode(e.from(D, "base64"), "utf16-be");
        }
        h[S] != u && S--, x = S + 1, y = !1, E = "";
      }
    if (!y)
      b += this.iconv.decode(h.slice(x), "ascii");
    else {
      var D = E + h.slice(x).toString().replace(/,/g, "/"), U = D.length - D.length % 8;
      E = D.slice(U), D = D.slice(0, U), b += this.iconv.decode(e.from(D, "base64"), "utf16-be");
    }
    return this.inBase64 = y, this.base64Accum = E, b;
  }, m.prototype.end = function() {
    var h = "";
    return this.inBase64 && this.base64Accum.length > 0 && (h = this.iconv.decode(e.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", h;
  }, Qr;
}
var Sc = {}, id;
function $_() {
  if (id) return Sc;
  id = 1;
  var e = Ge.Buffer;
  Sc._sbcs = t;
  function t(i, a) {
    if (!i)
      throw new Error("SBCS codec is called without the data.");
    if (!i.chars || i.chars.length !== 128 && i.chars.length !== 256)
      throw new Error("Encoding '" + i.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (i.chars.length === 128) {
      for (var s = "", c = 0; c < 128; c++)
        s += String.fromCharCode(c);
      i.chars = s + i.chars;
    }
    this.decodeBuf = e.from(i.chars, "ucs2");
    for (var o = e.alloc(65536, a.defaultCharSingleByte.charCodeAt(0)), c = 0; c < i.chars.length; c++)
      o[i.chars.charCodeAt(c)] = c;
    this.encodeBuf = o;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
<<<<<<< HEAD
  SBCSEncoder.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length);
    for (var i = 0; i < str2.length; i++)
      buf[i] = this.encodeBuf[str2.charCodeAt(i)];
    return buf;
=======
  n.prototype.write = function(i) {
    for (var a = e.alloc(i.length), s = 0; s < i.length; s++)
      a[s] = this.encodeBuf[i.charCodeAt(s)];
    return a;
  }, n.prototype.end = function() {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
<<<<<<< HEAD
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec$1;
}
var sbcsData$1;
var hasRequiredSbcsData$1;
function requireSbcsData$1() {
  if (hasRequiredSbcsData$1) return sbcsData$1;
  hasRequiredSbcsData$1 = 1;
  sbcsData$1 = {
=======
  return r.prototype.write = function(i) {
    for (var a = this.decodeBuf, s = e.alloc(i.length * 2), c = 0, o = 0, u = 0; u < i.length; u++)
      c = i[u] * 2, o = u * 2, s[o] = a[c], s[o + 1] = a[c + 1];
    return s.toString("ucs2");
  }, r.prototype.end = function() {
  }, Sc;
}
var Ac, ad;
function O_() {
  return ad || (ad = 1, Ac = {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": ""
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": ""
    },
    "mik": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp720": {
      "type": "_sbcs",
      "chars": ""
    },
    // Aliases of generated encodings.
<<<<<<< HEAD
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData$1;
}
var sbcsDataGenerated$1;
var hasRequiredSbcsDataGenerated$1;
function requireSbcsDataGenerated$1() {
  if (hasRequiredSbcsDataGenerated$1) return sbcsDataGenerated$1;
  hasRequiredSbcsDataGenerated$1 = 1;
  sbcsDataGenerated$1 = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "\uFEFF"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated$1;
}
var dbcsCodec$1 = {};
var hasRequiredDbcsCodec$1;
function requireDbcsCodec$1() {
  if (hasRequiredDbcsCodec$1) return dbcsCodec$1;
  hasRequiredDbcsCodec$1 = 1;
  var Buffer2 = safer_1.Buffer;
  dbcsCodec$1._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv2) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv2.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv2.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j = 48; j <= 57; j++)
          secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      }
      for (var i2 = 129; i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48; i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node2 = this.decodeTables[0];
    for (var i2 = bytes.length - 1; i2 > 0; i2--) {
      var val = node2[bytes[i2]];
      if (val == UNASSIGNED) {
        node2[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node2 = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node2 = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node2;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq2 = [];
            for (var m = 0; m < len; m++)
              seq2.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq2);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq2, dbcsCode) {
    var uCode = seq2[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node2;
    if (bucket[low] <= SEQ_START) {
      node2 = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node2 = {};
      if (bucket[low] !== UNASSIGNED) node2[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node2);
    }
    for (var j = 1; j < seq2.length - 1; j++) {
      var oldVal = node2[uCode];
      if (typeof oldVal === "object")
        node2 = oldVal;
      else {
        node2 = node2[uCode] = {};
        if (oldVal !== void 0)
          node2[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq2[seq2.length - 1];
    node2[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node2 = this.decodeTables[nodeIdx];
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node2[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0)
        this._setEncodeChar(uCode, mbCode);
      else if (uCode <= NODE_START)
        this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
      else if (uCode <= SEQ_START)
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str2) {
    var newBuf = Buffer2.alloc(str2.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str2.length) break;
        var uCode = str2.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
=======
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    1e4: "macroman",
    10006: "macgreek",
    10007: "maccyrillic",
    10079: "maciceland",
    10081: "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    20866: "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    21866: "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  }), Ac;
}
var Tc, sd;
function I_() {
  return sd || (sd = 1, Tc = {
    437: "cp437",
    737: "cp737",
    775: "cp775",
    850: "cp850",
    852: "cp852",
    855: "cp855",
    856: "cp856",
    857: "cp857",
    858: "cp858",
    860: "cp860",
    861: "cp861",
    862: "cp862",
    863: "cp863",
    864: "cp864",
    865: "cp865",
    866: "cp866",
    869: "cp869",
    874: "windows874",
    922: "cp922",
    1046: "cp1046",
    1124: "cp1124",
    1125: "cp1125",
    1129: "cp1129",
    1133: "cp1133",
    1161: "cp1161",
    1162: "cp1162",
    1163: "cp1163",
    1250: "windows1250",
    1251: "windows1251",
    1252: "windows1252",
    1253: "windows1253",
    1254: "windows1254",
    1255: "windows1255",
    1256: "windows1256",
    1257: "windows1257",
    1258: "windows1258",
    28591: "iso88591",
    28592: "iso88592",
    28593: "iso88593",
    28594: "iso88594",
    28595: "iso88595",
    28596: "iso88596",
    28597: "iso88597",
    28598: "iso88598",
    28599: "iso88599",
    28600: "iso885910",
    28601: "iso885911",
    28603: "iso885913",
    28604: "iso885914",
    28605: "iso885915",
    28606: "iso885916",
    windows874: {
      type: "_sbcs",
      chars: ""
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: ""
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: ""
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: ""
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: ""
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: ""
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: ""
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: ""
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: ""
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: ""
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: ""
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: ""
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: ""
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: ""
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: ""
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: ""
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: ""
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: ""
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: ""
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: ""
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: ""
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: ""
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: ""
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: ""
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: ""
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: ""
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: ""
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: ""
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: ""
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: ""
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: ""
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: ""
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: ""
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: ""
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: ""
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: ""
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: ""
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: ""
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: ""
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: ""
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: ""
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: ""
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: ""
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: ""
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: ""
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: ""
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: ""
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: ""
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: ""
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: ""
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: ""
    },
    maccyrillic: {
      type: "_sbcs",
      chars: ""
    },
    macgreek: {
      type: "_sbcs",
      chars: ""
    },
    maciceland: {
      type: "_sbcs",
      chars: ""
    },
    macroman: {
      type: "_sbcs",
      chars: ""
    },
    macromania: {
      type: "_sbcs",
      chars: ""
    },
    macthai: {
      type: "_sbcs",
      chars: "\uFEFF"
    },
    macturkish: {
      type: "_sbcs",
      chars: ""
    },
    macukraine: {
      type: "_sbcs",
      chars: ""
    },
    koi8r: {
      type: "_sbcs",
      chars: ""
    },
    koi8u: {
      type: "_sbcs",
      chars: ""
    },
    koi8ru: {
      type: "_sbcs",
      chars: ""
    },
    koi8t: {
      type: "_sbcs",
      chars: ""
    },
    armscii8: {
      type: "_sbcs",
      chars: ")(.,-"
    },
    rk1048: {
      type: "_sbcs",
      chars: ""
    },
    tcvn: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: ""
    },
    georgianps: {
      type: "_sbcs",
      chars: ""
    },
    pt154: {
      type: "_sbcs",
      chars: ""
    },
    viscii: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    hproman8: {
      type: "_sbcs",
      chars: ""
    },
    macintosh: {
      type: "_sbcs",
      chars: ""
    },
    ascii: {
      type: "_sbcs",
      chars: ""
    },
    tis620: {
      type: "_sbcs",
      chars: ""
    }
  }), Tc;
}
var Cc = {}, od;
function D_() {
  if (od) return Cc;
  od = 1;
  var e = Ge.Buffer;
  Cc._dbcs = o;
  for (var t = -1, n = -2, r = -10, i = -1e3, a = new Array(256), s = -1, c = 0; c < 256; c++)
    a[c] = t;
  function o(f, m) {
    if (this.encodingName = f.encodingName, !f)
      throw new Error("DBCS codec is called without the data.");
    if (!f.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var g = f.table();
    this.decodeTables = [], this.decodeTables[0] = a.slice(0), this.decodeTableSeq = [];
    for (var h = 0; h < g.length; h++)
      this._addDecodeChunk(g[h]);
    this.defaultCharUnicode = m.defaultCharUnicode, this.encodeTable = [], this.encodeTableSeq = [];
    var b = {};
    if (f.encodeSkipVals)
      for (var h = 0; h < f.encodeSkipVals.length; h++) {
        var x = f.encodeSkipVals[h];
        if (typeof x == "number")
          b[x] = !0;
        else
          for (var y = x.from; y <= x.to; y++)
            b[y] = !0;
      }
    if (this._fillEncodeTable(0, 0, b), f.encodeAdd)
      for (var E in f.encodeAdd)
        Object.prototype.hasOwnProperty.call(f.encodeAdd, E) && this._setEncodeChar(E.charCodeAt(0), f.encodeAdd[E]);
    if (this.defCharSB = this.encodeTable[0][m.defaultCharSingleByte.charCodeAt(0)], this.defCharSB === t && (this.defCharSB = this.encodeTable[0]["?"]), this.defCharSB === t && (this.defCharSB = 63), typeof f.gb18030 == "function") {
      this.gb18030 = f.gb18030();
      for (var S = this.decodeTables.length, D = this.decodeTables[S] = a.slice(0), U = this.decodeTables.length, z = this.decodeTables[U] = a.slice(0), h = 129; h <= 254; h++)
        for (var ee = i - this.decodeTables[0][h], C = this.decodeTables[ee], y = 48; y <= 57; y++)
          C[y] = i - S;
      for (var h = 129; h <= 254; h++)
        D[h] = i - U;
      for (var h = 48; h <= 57; h++)
        z[h] = n;
    }
  }
  o.prototype.encoder = u, o.prototype.decoder = l, o.prototype._getDecodeTrieNode = function(f) {
    for (var m = []; f > 0; f >>= 8)
      m.push(f & 255);
    m.length == 0 && m.push(0);
    for (var g = this.decodeTables[0], h = m.length - 1; h > 0; h--) {
      var b = g[m[h]];
      if (b == t)
        g[m[h]] = i - this.decodeTables.length, this.decodeTables.push(g = a.slice(0));
      else if (b <= i)
        g = this.decodeTables[i - b];
      else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + f.toString(16));
    }
    return g;
  }, o.prototype._addDecodeChunk = function(f) {
    var m = parseInt(f[0], 16), g = this._getDecodeTrieNode(m);
    m = m & 255;
    for (var h = 1; h < f.length; h++) {
      var b = f[h];
      if (typeof b == "string")
        for (var x = 0; x < b.length; ) {
          var y = b.charCodeAt(x++);
          if (55296 <= y && y < 56320) {
            var E = b.charCodeAt(x++);
            if (56320 <= E && E < 57344)
              g[m++] = 65536 + (y - 55296) * 1024 + (E - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + f[0]);
          } else if (4080 < y && y <= 4095) {
            for (var S = 4095 - y + 2, D = [], U = 0; U < S; U++)
              D.push(b.charCodeAt(x++));
            g[m++] = r - this.decodeTableSeq.length, this.decodeTableSeq.push(D);
          } else
            g[m++] = y;
        }
      else if (typeof b == "number")
        for (var z = g[m - 1] + 1, x = 0; x < b; x++)
          g[m++] = z++;
      else
        throw new Error("Incorrect type '" + typeof b + "' given in " + this.encodingName + " at chunk " + f[0]);
    }
    if (m > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + f[0] + ": too long" + m);
  }, o.prototype._getEncodeBucket = function(f) {
    var m = f >> 8;
    return this.encodeTable[m] === void 0 && (this.encodeTable[m] = a.slice(0)), this.encodeTable[m];
  }, o.prototype._setEncodeChar = function(f, m) {
    var g = this._getEncodeBucket(f), h = f & 255;
    g[h] <= r ? this.encodeTableSeq[r - g[h]][s] = m : g[h] == t && (g[h] = m);
  }, o.prototype._setEncodeSequence = function(f, m) {
    var g = f[0], h = this._getEncodeBucket(g), b = g & 255, x;
    h[b] <= r ? x = this.encodeTableSeq[r - h[b]] : (x = {}, h[b] !== t && (x[s] = h[b]), h[b] = r - this.encodeTableSeq.length, this.encodeTableSeq.push(x));
    for (var y = 1; y < f.length - 1; y++) {
      var E = x[g];
      typeof E == "object" ? x = E : (x = x[g] = {}, E !== void 0 && (x[s] = E));
    }
    g = f[f.length - 1], x[g] = m;
  }, o.prototype._fillEncodeTable = function(f, m, g) {
    for (var h = this.decodeTables[f], b = 0; b < 256; b++) {
      var x = h[b], y = m + b;
      g[y] || (x >= 0 ? this._setEncodeChar(x, y) : x <= i ? this._fillEncodeTable(i - x, y << 8, g) : x <= r && this._setEncodeSequence(this.decodeTableSeq[r - x], y));
    }
  };
  function u(f, m) {
    this.leadSurrogate = -1, this.seqObj = void 0, this.encodeTable = m.encodeTable, this.encodeTableSeq = m.encodeTableSeq, this.defaultCharSingleByte = m.defCharSB, this.gb18030 = m.gb18030;
  }
  u.prototype.write = function(f) {
    for (var m = e.alloc(f.length * (this.gb18030 ? 4 : 3)), g = this.leadSurrogate, h = this.seqObj, b = -1, x = 0, y = 0; ; ) {
      if (b === -1) {
        if (x == f.length) break;
        var E = f.charCodeAt(x++);
      } else {
        var E = b;
        b = -1;
      }
      if (55296 <= E && E < 57344)
        if (E < 56320)
          if (g === -1) {
            g = E;
            continue;
          } else
            g = E, E = t;
        else
          g !== -1 ? (E = 65536 + (g - 55296) * 1024 + (E - 56320), g = -1) : E = t;
      else g !== -1 && (b = E, E = t, g = -1);
      var S = t;
      if (h !== void 0 && E != t) {
        var D = h[E];
        if (typeof D == "object") {
          h = D;
          continue;
        } else typeof D == "number" ? S = D : D == null && (D = h[s], D !== void 0 && (S = D, b = E));
        h = void 0;
      } else if (E >= 0) {
        var U = this.encodeTable[E >> 8];
        if (U !== void 0 && (S = U[E & 255]), S <= r) {
          h = this.encodeTableSeq[r - S];
          continue;
        }
        if (S == t && this.gb18030) {
          var z = p(this.gb18030.uChars, E);
          if (z != -1) {
            var S = this.gb18030.gbChars[z] + (E - this.gb18030.uChars[z]);
            m[y++] = 129 + Math.floor(S / 12600), S = S % 12600, m[y++] = 48 + Math.floor(S / 1260), S = S % 1260, m[y++] = 129 + Math.floor(S / 10), S = S % 10, m[y++] = 48 + S;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
            continue;
          }
        }
      }
<<<<<<< HEAD
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
=======
      S === t && (S = this.defaultCharSingleByte), S < 256 ? m[y++] = S : S < 65536 ? (m[y++] = S >> 8, m[y++] = S & 255) : (m[y++] = S >> 16, m[y++] = S >> 8 & 255, m[y++] = S & 255);
    }
    return this.seqObj = h, this.leadSurrogate = g, m.slice(0, y);
  }, u.prototype.end = function() {
    if (!(this.leadSurrogate === -1 && this.seqObj === void 0)) {
      var f = e.alloc(10), m = 0;
      if (this.seqObj) {
        var g = this.seqObj[s];
        g !== void 0 && (g < 256 ? f[m++] = g : (f[m++] = g >> 8, f[m++] = g & 255)), this.seqObj = void 0;
      }
      return this.leadSurrogate !== -1 && (f[m++] = this.defaultCharSingleByte, this.leadSurrogate = -1), f.slice(0, m);
    }
  }, u.prototype.findIdx = p;
  function l(f, m) {
    this.nodeIdx = 0, this.prevBuf = e.alloc(0), this.decodeTables = m.decodeTables, this.decodeTableSeq = m.decodeTableSeq, this.defaultCharUnicode = m.defaultCharUnicode, this.gb18030 = m.gb18030;
  }
  l.prototype.write = function(f) {
    var m = e.alloc(f.length * 2), g = this.nodeIdx, h = this.prevBuf, b = this.prevBuf.length, x = -this.prevBuf.length, y;
    b > 0 && (h = e.concat([h, f.slice(0, 10)]));
    for (var E = 0, S = 0; E < f.length; E++) {
      var D = E >= 0 ? f[E] : h[E + b], y = this.decodeTables[g][D];
      if (!(y >= 0)) if (y === t)
        E = x, y = this.defaultCharUnicode.charCodeAt(0);
      else if (y === n) {
        var U = x >= 0 ? f.slice(x, E + 1) : h.slice(x + b, E + 1 + b), z = (U[0] - 129) * 12600 + (U[1] - 48) * 1260 + (U[2] - 129) * 10 + (U[3] - 48), ee = p(this.gb18030.gbChars, z);
        y = this.gb18030.uChars[ee] + z - this.gb18030.gbChars[ee];
      } else if (y <= i) {
        g = i - y;
        continue;
      } else if (y <= r) {
        for (var C = this.decodeTableSeq[r - y], H = 0; H < C.length - 1; H++)
          y = C[H], m[S++] = y & 255, m[S++] = y >> 8;
        y = C[C.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + y + " at " + g + "/" + D);
      if (y > 65535) {
        y -= 65536;
        var M = 55296 + Math.floor(y / 1024);
        m[S++] = M & 255, m[S++] = M >> 8, y = 56320 + y % 1024;
      }
      m[S++] = y & 255, m[S++] = y >> 8, g = 0, x = E + 1;
    }
    return this.nodeIdx = g, this.prevBuf = x >= 0 ? f.slice(x) : h.slice(x + b), m.slice(0, S).toString("ucs2");
  }, l.prototype.end = function() {
    for (var f = ""; this.prevBuf.length > 0; ) {
      f += this.defaultCharUnicode;
      var m = this.prevBuf.slice(1);
      this.prevBuf = e.alloc(0), this.nodeIdx = 0, m.length > 0 && (f += this.write(m));
    }
    return this.nodeIdx = 0, f;
  };
  function p(f, m) {
    if (f[0] > m)
      return -1;
    for (var g = 0, h = f.length; g < h - 1; ) {
      var b = g + Math.floor((h - g + 1) / 2);
      f[b] <= m ? g = b : h = b;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBuf = Buffer2.alloc(0);
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    if (prevBufOffset > 0)
      prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        i2 = seqStart;
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq2 = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq2.length - 1; k++) {
          uCode = seq2[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq2[seq2.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 + uCode % 1024;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBuf.length > 0) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0)
        ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
<<<<<<< HEAD
  return dbcsCodec$1;
=======
  return Cc;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
}
const F_ = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
], P_ = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "",
    62
  ],
  [
    "a1a1",
    "",
    9,
    ""
  ],
  [
    "a2a1",
    ""
  ],
  [
    "a2ba",
    ""
  ],
  [
    "a2ca",
    ""
  ],
  [
    "a2dc",
    ""
  ],
  [
    "a2f2",
    ""
  ],
  [
    "a2fe",
    ""
  ],
  [
    "a3b0",
    "",
    9
  ],
  [
    "a3c1",
    "",
    25
  ],
  [
    "a3e1",
    "",
    25
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a8a1",
    ""
  ],
  [
    "ada1",
    "",
    19,
    "",
    9
  ],
  [
    "adc0",
    ""
  ],
  [
    "addf",
    "",
    4,
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fcf1",
    "",
    9,
    ""
  ],
  [
    "8fa2af",
    ""
  ],
  [
    "8fa2c2",
    ""
  ],
  [
    "8fa2eb",
    ""
  ],
  [
    "8fa6e1",
    ""
  ],
  [
    "8fa6e7",
    ""
  ],
  [
    "8fa6e9",
    ""
  ],
  [
    "8fa6ec",
    ""
  ],
  [
    "8fa6f1",
    ""
  ],
  [
    "8fa7c2",
    "",
    10,
    ""
  ],
  [
    "8fa7f2",
    "",
    10,
    ""
  ],
  [
    "8fa9a1",
    ""
  ],
  [
    "8fa9a4",
    ""
  ],
  [
    "8fa9a6",
    ""
  ],
  [
    "8fa9a8",
    ""
  ],
  [
    "8fa9ab",
    ""
  ],
  [
    "8fa9af",
    ""
  ],
  [
    "8fa9c1",
    ""
  ],
  [
    "8faaa1",
    ""
  ],
  [
    "8faaba",
    ""
  ],
  [
    "8faba1",
    ""
  ],
  [
    "8fabbd",
    ""
  ],
  [
    "8fabc5",
    ""
  ],
  [
    "8fb0a1",
    ""
  ],
  [
    "8fb1a1",
    ""
  ],
  [
    "8fb2a1",
    "",
    4,
    ""
  ],
  [
    "8fb3a1",
    ""
  ],
  [
    "8fb4a1",
    ""
  ],
  [
    "8fb5a1",
    ""
  ],
  [
    "8fb6a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fb7a1",
    "",
    4,
    ""
  ],
  [
    "8fb8a1",
    ""
  ],
  [
    "8fb9a1",
    ""
  ],
  [
    "8fbaa1",
    "",
    4,
    ""
  ],
  [
    "8fbba1",
    ""
  ],
  [
    "8fbca1",
    "",
    4,
    ""
  ],
  [
    "8fbda1",
    "",
    4,
    ""
  ],
  [
    "8fbea1",
    "",
    4,
    ""
  ],
  [
    "8fbfa1",
    ""
  ],
  [
    "8fc0a1",
    ""
  ],
  [
    "8fc1a1",
    ""
  ],
  [
    "8fc2a1",
    ""
  ],
  [
    "8fc3a1",
    "",
    4,
    ""
  ],
  [
    "8fc4a1",
    ""
  ],
  [
    "8fc5a1",
    ""
  ],
  [
    "8fc6a1",
    ""
  ],
  [
    "8fc7a1",
    ""
  ],
  [
    "8fc8a1",
    ""
  ],
  [
    "8fc9a1",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8fcaa1",
    ""
  ],
  [
    "8fcba1",
    ""
  ],
  [
    "8fcca1",
    "",
    9,
    ""
  ],
  [
    "8fcda1",
    "",
    5,
    ""
  ],
  [
    "8fcea1",
    "",
    6,
    ""
  ],
  [
    "8fcfa1",
    ""
  ],
  [
    "8fd0a1",
    ""
  ],
  [
    "8fd1a1",
    ""
  ],
  [
    "8fd2a1",
    "",
    5
  ],
  [
    "8fd3a1",
    ""
  ],
  [
    "8fd4a1",
    "",
    4,
    ""
  ],
  [
    "8fd5a1",
    ""
  ],
  [
    "8fd6a1",
    ""
  ],
  [
    "8fd7a1",
    ""
  ],
  [
    "8fd8a1",
    ""
  ],
  [
    "8fd9a1",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8fdaa1",
    "",
    4,
    ""
  ],
  [
    "8fdba1",
    "",
    6,
    ""
  ],
  [
    "8fdca1",
    "",
    4,
    ""
  ],
  [
    "8fdda1",
    "",
    4,
    ""
  ],
  [
    "8fdea1",
    "",
    4,
    ""
  ],
  [
    "8fdfa1",
    ""
  ],
  [
    "8fe0a1",
    ""
  ],
  [
    "8fe1a1",
    "",
    4,
    ""
  ],
  [
    "8fe2a1",
    ""
  ],
  [
    "8fe3a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fe4a1",
    "",
    4,
    ""
  ],
  [
    "8fe5a1",
    "",
    4,
    ""
  ],
  [
    "8fe6a1",
    ""
  ],
  [
    "8fe7a1",
    ""
  ],
  [
    "8fe8a1",
    "",
    4,
    ""
  ],
  [
    "8fe9a1",
    "",
    4
  ],
  [
    "8feaa1",
    "",
    4,
    ""
  ],
  [
    "8feba1",
    "",
    4,
    ""
  ],
  [
    "8feca1",
    ""
  ],
  [
    "8feda1",
    "",
    4,
    "",
    4,
    ""
  ]
], Rc = [
  [
    "0",
    "\0",
    127,
    ""
  ],
  [
    "8140",
    "",
    5,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "8180",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8240",
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    11
  ],
  [
    "8280",
    "",
    10,
    "",
    4,
    "",
    7,
    "",
    5,
    "",
    8,
    "",
    20,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8340",
    "",
    17,
    "",
    5,
    "",
    10,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "8380",
    "",
    5,
    "",
    13,
    "",
    28,
    "",
    4,
    "",
    4,
    "",
    5
  ],
  [
    "8440",
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "8480",
    "",
    9,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    5,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "8540",
    "",
    9,
    ""
  ],
  [
    "8580",
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "8640",
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8680",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8740",
    "",
    7,
    "",
    11,
    "",
    4,
    "",
    4
  ],
  [
    "8780",
    "",
    7,
    "",
    6,
    "",
    14,
    "",
    10,
    "",
    6,
    "",
    12,
    "",
    8,
    "",
    5,
    "",
    6
  ],
  [
    "8840",
    "",
    9,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8880",
    "",
    4,
    "",
    6,
    "",
    8,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    7
  ],
  [
    "8940",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    16,
    ""
  ],
  [
    "8980",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    17,
    "",
    10,
    "",
    13,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "8a40",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "8a80",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    9,
    "",
    5
  ],
  [
    "8b40",
    "",
    8,
    "",
    17,
    "",
    6,
    "",
    13,
    ""
  ],
  [
    "8b80",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    22,
    "",
    11,
    "",
    25,
    "",
    7,
    "",
    6
  ],
  [
    "8c40",
    "",
    7,
    ""
  ],
  [
    "8c80",
    "",
    8,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    4
  ],
  [
    "8d40",
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    9,
    "",
    4
  ],
  [
    "8d80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    10,
    "",
    12,
    "",
    21,
    ""
  ],
  [
    "8e40",
    "",
    21,
    "",
    12,
    "",
    6,
    "",
    12,
    ""
  ],
  [
    "8e80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    4,
    "",
    6
  ],
  [
    "8f40",
    "",
    5,
    "",
    11,
    "",
    8,
    ""
  ],
  [
    "8f80",
    "",
    6,
    "",
    14,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9040",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9080",
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    18,
    "",
    6
  ],
  [
    "9140",
    "",
    6,
    "",
    6,
    "",
    18,
    "",
    4,
    ""
  ],
  [
    "9180",
    "",
    6,
    "",
    8,
    "",
    9,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    16,
    "",
    13,
    "",
    8,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9280",
    "",
    5,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9340",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9380",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    9,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9440",
    "",
    24,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    8
  ],
  [
    "9480",
    "",
    4,
    "",
    4,
    "",
    14,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "9540",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9580",
    "",
    4,
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    25,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "9640",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9680",
    "",
    7,
    "",
    9,
    "",
    7,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    5
  ],
  [
    "9740",
    "",
    7,
    "",
    8,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9780",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    9,
    "",
    4,
    "",
    11,
    "",
    7,
    "",
    16,
    ""
  ],
  [
    "9840",
    "",
    4,
    "",
    5,
    "",
    9,
    ""
  ],
  [
    "9880",
    "",
    7,
    "",
    5,
    "",
    11,
    "",
    9,
    "",
    9,
    "",
    11,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9940",
    "",
    4,
    "",
    10,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    7,
    "",
    5
  ],
  [
    "9980",
    "",
    114,
    "",
    6
  ],
  [
    "9a40",
    "",
    11,
    "",
    7,
    "",
    13,
    ""
  ],
  [
    "9a80",
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "9b40",
    "",
    4,
    ""
  ],
  [
    "9b80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9c40",
    "",
    7,
    ""
  ],
  [
    "9c80",
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    14,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "9d40",
    "",
    7,
    "",
    4,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "9d80",
    "",
    9,
    "",
    5,
    "",
    6,
    "",
    12,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "9e40",
    "",
    7,
    "",
    32,
    "",
    7,
    "",
    6,
    "",
    6
  ],
  [
    "9e80",
    "",
    9,
    "",
    17,
    "",
    13,
    "",
    11,
    "",
    12,
    "",
    12,
    ""
  ],
  [
    "9f40",
    "",
    6,
    "",
    10,
    "",
    4,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "9f80",
    "",
    13,
    "",
    12,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    8,
    "",
    9,
    "",
    4
  ],
  [
    "a040",
    "",
    9,
    "",
    5,
    "",
    9,
    "",
    11,
    "",
    19
  ],
  [
    "a080",
    "",
    9,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    11,
    "",
    6,
    ""
  ],
  [
    "a1a1",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9
  ],
  [
    "a2b1",
    "",
    19,
    "",
    19,
    "",
    9
  ],
  [
    "a2e5",
    "",
    9
  ],
  [
    "a2f1",
    "",
    11
  ],
  [
    "a3a1",
    "",
    88,
    ""
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a6e0",
    ""
  ],
  [
    "a6ee",
    ""
  ],
  [
    "a6f4",
    ""
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a840",
    "",
    35,
    "",
    6
  ],
  [
    "a880",
    "",
    7,
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a8bd",
    ""
  ],
  [
    "a8c0",
    ""
  ],
  [
    "a8c5",
    "",
    36
  ],
  [
    "a940",
    "",
    8,
    ""
  ],
  [
    "a959",
    ""
  ],
  [
    "a95c",
    ""
  ],
  [
    "a960",
    "",
    9,
    "",
    8
  ],
  [
    "a980",
    "",
    4,
    ""
  ],
  [
    "a996",
    ""
  ],
  [
    "a9a4",
    "",
    75
  ],
  [
    "aa40",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "aa80",
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "ab40",
    "",
    11,
    "",
    4,
    "",
    5,
    "",
    4
  ],
  [
    "ab80",
    "",
    6,
    "",
    4
  ],
  [
    "ac40",
    "",
    10,
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11
  ],
  [
    "ac80",
    "",
    6,
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "ad40",
    "",
    10,
    "",
    7,
    "",
    15,
    "",
    12
  ],
  [
    "ad80",
    "",
    9,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "ae40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "ae80",
    "",
    7,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "af40",
    "",
    4,
    ""
  ],
  [
    "af80",
    ""
  ],
  [
    "b040",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "b080",
    "",
    7,
    "",
    8,
    "",
    9,
    ""
  ],
  [
    "b140",
    "",
    4,
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "b180",
    "",
    4,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "b240",
    "",
    11,
    "",
    5,
    "",
    11,
    "",
    4
  ],
  [
    "b280",
    "",
    12,
    "",
    8,
    "",
    4,
    ""
  ],
  [
    "b340",
    "",
    5,
    ""
  ],
  [
    "b380",
    "",
    11,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "b440",
    "",
    7,
    "",
    9
  ],
  [
    "b480",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "b540",
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "b580",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b640",
    "",
    6,
    "",
    11,
    "",
    10,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "b680",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b740",
    "",
    14,
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    16
  ],
  [
    "b780",
    "",
    6,
    ""
  ],
  [
    "b840",
    "",
    4,
    "",
    10,
    "",
    10,
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "b880",
    "",
    4,
    ""
  ],
  [
    "b940",
    "",
    5,
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "b980",
    "",
    7,
    ""
  ],
  [
    "ba40",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "ba80",
    "",
    4,
    "",
    5,
    "",
    12,
    "",
    5,
    ""
  ],
  [
    "bb40",
    "",
    9,
    "",
    36,
    "",
    5,
    "",
    9
  ],
  [
    "bb80",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "bc40",
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    13,
    "",
    5
  ],
  [
    "bc80",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "bd40",
    "",
    54,
    "",
    7
  ],
  [
    "bd80",
    "",
    32,
    ""
  ],
  [
    "be40",
    "",
    12,
    "",
    6,
    "",
    42
  ],
  [
    "be80",
    "",
    32,
    ""
  ],
  [
    "bf40",
    "",
    62
  ],
  [
    "bf80",
    "",
    4,
    "",
    4,
    "",
    21,
    ""
  ],
  [
    "c040",
    "",
    35,
    "",
    23,
    ""
  ],
  [
    "c080",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "c140",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c180",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c280",
    "",
    13,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c340",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c380",
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "c440",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "c480",
    "",
    7,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c540",
    "",
    14,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c580",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c680",
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "c740",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "c780",
    ""
  ],
  [
    "c840",
    "",
    4,
    "",
    5,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c880",
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "c940",
    "",
    4,
    "",
    7,
    "",
    12,
    ""
  ],
  [
    "c980",
    "",
    4,
    "",
    4,
    "",
    10,
    ""
  ],
  [
    "ca40",
    "",
    8,
    "",
    8,
    "",
    9,
    "",
    4,
    "",
    10
  ],
  [
    "ca80",
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "cb40",
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cb80",
    "",
    5,
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "cc40",
    "",
    4,
    "",
    10,
    "",
    15,
    "",
    13,
    ""
  ],
  [
    "cc80",
    "",
    11,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "cd40",
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "cd80",
    ""
  ],
  [
    "ce40",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "ce80",
    "",
    4,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cf40",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    9
  ],
  [
    "cf80",
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "d040",
    "",
    13,
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "d080",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "d140",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "d180",
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "d240",
    "",
    8,
    "",
    24,
    "",
    5,
    "",
    19,
    ""
  ],
  [
    "d280",
    "",
    26,
    ""
  ],
  [
    "d340",
    "",
    30,
    "",
    6
  ],
  [
    "d380",
    "",
    4,
    "",
    5,
    "",
    21,
    ""
  ],
  [
    "d440",
    "",
    31,
    "",
    8,
    "",
    21
  ],
  [
    "d480",
    "",
    25,
    "",
    6,
    ""
  ],
  [
    "d540",
    "",
    7,
    "",
    7,
    "",
    46
  ],
  [
    "d580",
    "",
    32,
    ""
  ],
  [
    "d640",
    "",
    34,
    "",
    27
  ],
  [
    "d680",
    "",
    30,
    ""
  ],
  [
    "d740",
    "",
    31,
    "",
    4,
    "",
    25
  ],
  [
    "d780",
    "",
    24,
    ""
  ],
  [
    "d840",
    "",
    8,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "d880",
    "",
    6,
    "",
    20,
    ""
  ],
  [
    "d940",
    "",
    62
  ],
  [
    "d980",
    "",
    32,
    ""
  ],
  [
    "da40",
    "",
    14,
    "",
    8,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "da80",
    "",
    12,
    ""
  ],
  [
    "db40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "db80",
    "",
    4,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "dc40",
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    11,
    "",
    6,
    "",
    7
  ],
  [
    "dc80",
    "",
    10,
    "",
    21,
    ""
  ],
  [
    "dd40",
    "",
    62
  ],
  [
    "dd80",
    "",
    32,
    ""
  ],
  [
    "de40",
    "",
    32,
    ""
  ],
  [
    "de80",
    "",
    4,
    ""
  ],
  [
    "df40",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "df80",
    "",
    4,
    ""
  ],
  [
    "e040",
    "",
    19,
    ""
  ],
  [
    "e080",
    "",
    10,
    "",
    6,
    "",
    8,
    ""
  ],
  [
    "e140",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "e180",
    "",
    10,
    "",
    9,
    "",
    8,
    ""
  ],
  [
    "e240",
    "",
    62
  ],
  [
    "e280",
    "",
    32,
    "",
    5,
    ""
  ],
  [
    "e340",
    "",
    45,
    "",
    16
  ],
  [
    "e380",
    "",
    7,
    "",
    24,
    ""
  ],
  [
    "e440",
    "",
    5,
    "",
    24,
    "",
    31
  ],
  [
    "e480",
    "",
    32,
    ""
  ],
  [
    "e540",
    "",
    51,
    "",
    10
  ],
  [
    "e580",
    "",
    31,
    ""
  ],
  [
    "e640",
    "",
    34,
    "",
    27
  ],
  [
    "e680",
    "",
    29,
    ""
  ],
  [
    "e740",
    "",
    7,
    "",
    54
  ],
  [
    "e780",
    "",
    32,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "e840",
    "",
    14,
    "",
    43,
    ""
  ],
  [
    "e880",
    "",
    20,
    ""
  ],
  [
    "e940",
    "",
    7,
    "",
    42
  ],
  [
    "e980",
    "",
    32,
    ""
  ],
  [
    "ea40",
    "",
    27,
    "",
    6,
    ""
  ],
  [
    "ea80",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "eb40",
    "",
    9,
    "",
    7,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "eb80",
    "",
    4,
    ""
  ],
  [
    "ec40",
    "",
    8,
    "",
    4,
    "",
    18,
    "",
    7
  ],
  [
    "ec80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ed40",
    "",
    6,
    "",
    46
  ],
  [
    "ed80",
    "",
    4,
    "",
    23,
    ""
  ],
  [
    "ee40",
    "",
    62
  ],
  [
    "ee80",
    "",
    32,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "ef40",
    "",
    5,
    "",
    37,
    "",
    4
  ],
  [
    "ef80",
    "",
    30,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "f040",
    "",
    4,
    "",
    28,
    "",
    26
  ],
  [
    "f080",
    "",
    9,
    "",
    12,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "f140",
    "",
    10,
    "",
    47
  ],
  [
    "f180",
    "",
    32,
    ""
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    32,
    ""
  ],
  [
    "f340",
    "",
    17,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "f380",
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "f440",
    "",
    5,
    "",
    10,
    "",
    10,
    "",
    7,
    "",
    5
  ],
  [
    "f480",
    "",
    32,
    ""
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    32,
    ""
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    32,
    "",
    5,
    "",
    5,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    32
  ],
  [
    "f940",
    "",
    62
  ],
  [
    "f980",
    "",
    32
  ],
  [
    "fa40",
    "",
    62
  ],
  [
    "fa80",
    "",
    32
  ],
  [
    "fb40",
    "",
    27,
    "",
    9,
    ""
  ],
  [
    "fb80",
    "",
    5,
    "",
    8,
    "",
    5,
    ""
  ],
  [
    "fc40",
    "",
    8,
    "",
    4,
    "",
    8,
    "",
    6
  ],
  [
    "fc80",
    "",
    4,
    "",
    5,
    "",
    8,
    ""
  ],
  [
    "fd40",
    "",
    4,
    "",
    4,
    "",
    10,
    "",
    38
  ],
  [
    "fd80",
    "",
    5,
    "",
    11,
    "",
    4,
    ""
  ],
  [
    "fe40",
    ""
  ]
], cd = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ]
], k_ = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
], L_ = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
], N_ = {
  uChars: k_,
  gbChars: L_
}, U_ = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8161",
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "8181",
    "",
    18,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8241",
    "",
    7,
    "",
    5
  ],
  [
    "8261",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8281",
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    17,
    "",
    7,
    "",
    6,
    "",
    7,
    "",
    18
  ],
  [
    "8341",
    "",
    5,
    "",
    5,
    "",
    7
  ],
  [
    "8361",
    "",
    18,
    ""
  ],
  [
    "8381",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    46,
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8441",
    "",
    5,
    "",
    8
  ],
  [
    "8461",
    "",
    18
  ],
  [
    "8481",
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    18,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8541",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4
  ],
  [
    "8561",
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8581",
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    29,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8641",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8661",
    "",
    6,
    "",
    10
  ],
  [
    "8681",
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    22,
    "",
    4,
    ""
  ],
  [
    "8741",
    "",
    9,
    "",
    15
  ],
  [
    "8761",
    "",
    18,
    ""
  ],
  [
    "8781",
    "",
    5,
    "",
    7,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    4
  ],
  [
    "8841",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "8861",
    "",
    4,
    ""
  ],
  [
    "8881",
    "",
    15,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    54,
    ""
  ],
  [
    "8941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8961",
    "",
    10,
    "",
    5,
    ""
  ],
  [
    "8981",
    "",
    21,
    "",
    18,
    "",
    18,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    15
  ],
  [
    "8a41",
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "8a61",
    "",
    4,
    "",
    18,
    ""
  ],
  [
    "8a81",
    "",
    4,
    "",
    19,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8b41",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8b61",
    "",
    6,
    "",
    8
  ],
  [
    "8b81",
    "",
    52,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    18
  ],
  [
    "8c41",
    "",
    15,
    "",
    4
  ],
  [
    "8c61",
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "8c81",
    "",
    12,
    "",
    26,
    "",
    50,
    "",
    5,
    "",
    16
  ],
  [
    "8d41",
    "",
    16,
    "",
    8
  ],
  [
    "8d61",
    "",
    17,
    ""
  ],
  [
    "8d81",
    "",
    4,
    "",
    33,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    9,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8e41",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8e61",
    "",
    4,
    "",
    19
  ],
  [
    "8e81",
    "",
    13,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    11,
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "8f41",
    "",
    7,
    "",
    17
  ],
  [
    "8f61",
    "",
    7,
    "",
    6,
    "",
    4
  ],
  [
    "8f81",
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    5
  ],
  [
    "9041",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9061",
    "",
    5,
    "",
    15
  ],
  [
    "9081",
    "",
    12,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    11,
    "",
    33,
    ""
  ],
  [
    "9141",
    "",
    6,
    "",
    5
  ],
  [
    "9161",
    "",
    9,
    "",
    5
  ],
  [
    "9181",
    "",
    20,
    "",
    4,
    "",
    5,
    "",
    14,
    "",
    33,
    "",
    7,
    "",
    5,
    "",
    6
  ],
  [
    "9241",
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "9261",
    "",
    7,
    "",
    7,
    "",
    4
  ],
  [
    "9281",
    "",
    21,
    "",
    18,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    35,
    ""
  ],
  [
    "9341",
    "",
    4,
    ""
  ],
  [
    "9361",
    "",
    6,
    "",
    8
  ],
  [
    "9381",
    "",
    37,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    22,
    ""
  ],
  [
    "9441",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "9461",
    "",
    5,
    "",
    6,
    "",
    12
  ],
  [
    "9481",
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    24
  ],
  [
    "9541",
    "",
    11,
    "",
    5,
    ""
  ],
  [
    "9561",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9581",
    "",
    6,
    "",
    35,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    13,
    "",
    14
  ],
  [
    "9641",
    "",
    23,
    ""
  ],
  [
    "9661",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "9681",
    "",
    10,
    "",
    5,
    "",
    13,
    "",
    33,
    "",
    6,
    "",
    44
  ],
  [
    "9741",
    "",
    16,
    "",
    8
  ],
  [
    "9761",
    "",
    17,
    "",
    7
  ],
  [
    "9781",
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    89,
    ""
  ],
  [
    "9841",
    "",
    16,
    "",
    5,
    ""
  ],
  [
    "9861",
    "",
    6,
    "",
    15
  ],
  [
    "9881",
    "",
    21,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9961",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9981",
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9a41",
    "",
    16
  ],
  [
    "9a61",
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "9a81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    33,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9b41",
    "",
    6,
    "",
    8
  ],
  [
    "9b61",
    "",
    17,
    "",
    7
  ],
  [
    "9b81",
    "",
    25,
    "",
    4,
    "",
    5,
    "",
    50,
    "",
    22,
    ""
  ],
  [
    "9c41",
    "",
    4,
    "",
    5,
    "",
    5
  ],
  [
    "9c61",
    "",
    8,
    "",
    6,
    "",
    9
  ],
  [
    "9c81",
    "",
    8,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    12
  ],
  [
    "9d41",
    "",
    13,
    "",
    8
  ],
  [
    "9d61",
    "",
    25
  ],
  [
    "9d81",
    "",
    8,
    "",
    5,
    "",
    9,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9e41",
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9e61",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9e81",
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9f41",
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9f61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9f81",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "a041",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "a061",
    "",
    5,
    "",
    13
  ],
  [
    "a081",
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    "",
    4,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "a141",
    "",
    18,
    ""
  ],
  [
    "a161",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a181",
    "",
    14,
    "",
    5,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "a241",
    "",
    5,
    "",
    18
  ],
  [
    "a261",
    "",
    6,
    "",
    18
  ],
  [
    "a281",
    "",
    7,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "a341",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "a361",
    "",
    6,
    "",
    16
  ],
  [
    "a381",
    "",
    16,
    "",
    4,
    "",
    58,
    "",
    32,
    ""
  ],
  [
    "a441",
    "",
    5,
    ""
  ],
  [
    "a461",
    "",
    5,
    "",
    12
  ],
  [
    "a481",
    "",
    28,
    "",
    93
  ],
  [
    "a541",
    "",
    4,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a561",
    "",
    17,
    "",
    5,
    ""
  ],
  [
    "a581",
    "",
    16,
    "",
    14,
    "",
    9
  ],
  [
    "a5b0",
    "",
    9
  ],
  [
    "a5c1",
    "",
    16,
    "",
    6
  ],
  [
    "a5e1",
    "",
    16,
    "",
    6
  ],
  [
    "a641",
    "",
    19,
    ""
  ],
  [
    "a661",
    "",
    5,
    "",
    5,
    "",
    6
  ],
  [
    "a681",
    "",
    6,
    "",
    18,
    "",
    7
  ],
  [
    "a741",
    "",
    4,
    "",
    6,
    "",
    7
  ],
  [
    "a761",
    "",
    22,
    ""
  ],
  [
    "a781",
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    9,
    "",
    9,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "a841",
    "",
    10,
    "",
    14
  ],
  [
    "a861",
    "",
    18,
    "",
    6
  ],
  [
    "a881",
    "",
    19,
    "",
    11,
    ""
  ],
  [
    "a8a6",
    ""
  ],
  [
    "a8a8",
    ""
  ],
  [
    "a8b1",
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "a941",
    "",
    14,
    "",
    10
  ],
  [
    "a961",
    "",
    18
  ],
  [
    "a981",
    "",
    14,
    "",
    6,
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "aa41",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "aa61",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "aa81",
    "",
    29,
    "",
    82
  ],
  [
    "ab41",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "ab61",
    "",
    6,
    "",
    5,
    "",
    5
  ],
  [
    "ab81",
    "",
    8,
    "",
    6,
    "",
    12,
    "",
    85
  ],
  [
    "ac41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ac61",
    "",
    11,
    "",
    4
  ],
  [
    "ac81",
    "",
    28,
    "",
    5,
    "",
    25
  ],
  [
    "acd1",
    "",
    5,
    "",
    25
  ],
  [
    "ad41",
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "ad61",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "ad81",
    "",
    5,
    "",
    18,
    ""
  ],
  [
    "ae41",
    "",
    5,
    "",
    16
  ],
  [
    "ae61",
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "ae81",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "af41",
    "",
    19
  ],
  [
    "af61",
    "",
    13,
    "",
    5,
    ""
  ],
  [
    "af81",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b041",
    "",
    5,
    "",
    5,
    "",
    12
  ],
  [
    "b061",
    "",
    5,
    "",
    19
  ],
  [
    "b081",
    "",
    13,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "b141",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b161",
    "",
    6,
    "",
    5,
    "",
    11
  ],
  [
    "b181",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b241",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b261",
    "",
    18,
    "",
    5,
    ""
  ],
  [
    "b281",
    "",
    5,
    "",
    18,
    "",
    6,
    ""
  ],
  [
    "b341",
    "",
    19,
    ""
  ],
  [
    "b361",
    "",
    5,
    "",
    5,
    "",
    5
  ],
  [
    "b381",
    "",
    5,
    "",
    5,
    "",
    19,
    "",
    4,
    ""
  ],
  [
    "b441",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "b461",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "b481",
    "",
    6,
    "",
    18,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "b541",
    "",
    14,
    "",
    5
  ],
  [
    "b561",
    "",
    5,
    "",
    5,
    "",
    4
  ],
  [
    "b581",
    "",
    6,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "b641",
    "",
    7,
    "",
    17
  ],
  [
    "b661",
    "",
    15,
    ""
  ],
  [
    "b681",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b741",
    "",
    13,
    "",
    6,
    ""
  ],
  [
    "b761",
    "",
    20,
    ""
  ],
  [
    "b781",
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "b841",
    "",
    7,
    "",
    17
  ],
  [
    "b861",
    "",
    8,
    "",
    13
  ],
  [
    "b881",
    "",
    5,
    "",
    24,
    "",
    4,
    ""
  ],
  [
    "b941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b961",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b981",
    "",
    22,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ba41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ba61",
    "",
    5,
    "",
    4,
    "",
    5
  ],
  [
    "ba81",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "bb41",
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bb61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "bb81",
    "",
    31,
    ""
  ],
  [
    "bc41",
    "",
    17,
    ""
  ],
  [
    "bc61",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "bc81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bd41",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "bd61",
    "",
    5,
    "",
    13
  ],
  [
    "bd81",
    "",
    5,
    "",
    25,
    ""
  ],
  [
    "be41",
    "",
    7,
    "",
    14
  ],
  [
    "be61",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "be81",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "bf41",
    "",
    10,
    "",
    14
  ],
  [
    "bf61",
    "",
    18,
    ""
  ],
  [
    "bf81",
    "",
    5,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c041",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "c061",
    "",
    25
  ],
  [
    "c081",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c141",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c161",
    "",
    19,
    ""
  ],
  [
    "c181",
    "",
    31,
    ""
  ],
  [
    "c241",
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c261",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c281",
    "",
    5,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "c341",
    "",
    4
  ],
  [
    "c361",
    "",
    4,
    "",
    5,
    "",
    11
  ],
  [
    "c381",
    "",
    5,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "c441",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c461",
    "",
    5,
    "",
    4
  ],
  [
    "c481",
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c541",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c561",
    "",
    6,
    "",
    5,
    "",
    4
  ],
  [
    "c581",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c641",
    "",
    6,
    "",
    5
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "d2a1",
    "",
    4,
    "",
    5,
    "",
    10,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fda1",
    ""
  ]
], ld = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    ""
  ],
  [
    "a1a1",
    "",
    4,
    ""
  ],
  [
    "a240",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9,
    "",
    9,
    "",
    8,
    "",
    25,
    "",
    21
  ],
  [
    "a340",
    "",
    16,
    "",
    6,
    "",
    16,
    "",
    6,
    "",
    10
  ],
  [
    "a3a1",
    "",
    25,
    ""
  ],
  [
    "a3e1",
    ""
  ],
  [
    "a440",
    ""
  ],
  [
    "a4a1",
    ""
  ],
  [
    "a540",
    ""
  ],
  [
    "a5a1",
    ""
  ],
  [
    "a640",
    ""
  ],
  [
    "a6a1",
    ""
  ],
  [
    "a740",
    ""
  ],
  [
    "a7a1",
    ""
  ],
  [
    "a840",
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a940",
    ""
  ],
  [
    "a9a1",
    ""
  ],
  [
    "aa40",
    ""
  ],
  [
    "aaa1",
    ""
  ],
  [
    "ab40",
    ""
  ],
  [
    "aba1",
    ""
  ],
  [
    "ac40",
    ""
  ],
  [
    "aca1",
    ""
  ],
  [
    "ad40",
    ""
  ],
  [
    "ada1",
    ""
  ],
  [
    "ae40",
    ""
  ],
  [
    "aea1",
    ""
  ],
  [
    "af40",
    ""
  ],
  [
    "afa1",
    ""
  ],
  [
    "b040",
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b140",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b240",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b340",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b440",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b540",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b640",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b740",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b840",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b940",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "ba40",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bb40",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bc40",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bd40",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "be40",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bf40",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c040",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c140",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c240",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c340",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c440",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c540",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c940",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "ca40",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cb40",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cc40",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cd40",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "ce40",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cf40",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d040",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d140",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d240",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d340",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d440",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d540",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d640",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d740",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d840",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d940",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "da40",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "db40",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dc40",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dd40",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "de40",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "df40",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eb40",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "ec40",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "ef40",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f040",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f140",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f240",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f340",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f440",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f540",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f640",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f740",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f840",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f940",
    ""
  ],
  [
    "f9a1",
    ""
  ]
], B_ = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var $c, ud;
function j_() {
  return ud || (ud = 1, $c = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    shiftjis: {
      type: "_dbcs",
      table: function() {
        return F_;
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    932: "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
        return P_;
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    windows936: "cp936",
    ms936: "cp936",
    936: "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return Rc;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    gbk: {
      type: "_dbcs",
      table: function() {
        return Rc.concat(cd);
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    gb18030: {
      type: "_dbcs",
      table: function() {
        return Rc.concat(cd);
      },
      gb18030: function() {
        return N_;
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    chinese: "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    windows949: "cp949",
    ms949: "cp949",
    949: "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
        return U_;
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    windows950: "cp950",
    ms950: "cp950",
    950: "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return ld;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
        return ld.concat(B_);
      },
      encodeSkipVals: [41676]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  }), $c;
}
var pd;
function M_() {
  return pd || (pd = 1, function(e) {
    for (var t = [
      A_(),
      T_(),
      C_(),
      R_(),
      $_(),
      O_(),
      I_(),
      D_(),
      j_()
    ], n = 0; n < t.length; n++) {
      var r = t[n];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
  }(Ec)), Ec;
}
var Oc, fd;
function q_() {
  if (fd) return Oc;
  fd = 1;
  var e = Bt.Buffer, t = ae.Transform;
  Oc = function(i) {
    i.encodeStream = function(s, c) {
      return new n(i.getEncoder(s, c), c);
    }, i.decodeStream = function(s, c) {
      return new r(i.getDecoder(s, c), c);
    }, i.supportsStreams = !0, i.IconvLiteEncoderStream = n, i.IconvLiteDecoderStream = r, i._collect = r.prototype.collect;
  };
  function n(i, a) {
    this.conv = i, a = a || {}, a.decodeStrings = !1, t.call(this, a);
  }
  n.prototype = Object.create(t.prototype, {
    constructor: { value: n }
  }), n.prototype._transform = function(i, a, s) {
    if (typeof i != "string")
      return s(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var c = this.conv.write(i);
      c && c.length && this.push(c), s();
    } catch (o) {
      s(o);
    }
  }, n.prototype._flush = function(i) {
    try {
      var a = this.conv.end();
      a && a.length && this.push(a), i();
    } catch (s) {
      i(s);
    }
  }, n.prototype.collect = function(i) {
    var a = [];
    return this.on("error", i), this.on("data", function(s) {
      a.push(s);
    }), this.on("end", function() {
      i(null, e.concat(a));
    }), this;
  };
  function r(i, a) {
    this.conv = i, a = a || {}, a.encoding = this.encoding = "utf8", t.call(this, a);
  }
  return r.prototype = Object.create(t.prototype, {
    constructor: { value: r }
  }), r.prototype._transform = function(i, a, s) {
    if (!e.isBuffer(i))
      return s(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var c = this.conv.write(i);
      c && c.length && this.push(c, this.encoding), s();
    } catch (o) {
      s(o);
    }
  }, r.prototype._flush = function(i) {
    try {
      var a = this.conv.end();
      a && a.length && this.push(a, this.encoding), i();
    } catch (s) {
      i(s);
    }
  }, r.prototype.collect = function(i) {
    var a = "";
    return this.on("error", i), this.on("data", function(s) {
      a += s;
    }), this.on("end", function() {
      i(null, a);
    }), this;
  }, Oc;
}
var Ic, dd;
function z_() {
  if (dd) return Ic;
  dd = 1;
  var e = Bt.Buffer;
  return Ic = function(t) {
    var n = void 0;
    t.supportsNodeEncodingsExtension = !(e.from || new e(0) instanceof Uint8Array), t.extendNodeEncodings = function() {
      if (!n) {
        if (n = {}, !t.supportsNodeEncodingsExtension) {
          console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node"), console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
          return;
        }
        var i = {
          hex: !0,
          utf8: !0,
          "utf-8": !0,
          ascii: !0,
          binary: !0,
          base64: !0,
          ucs2: !0,
          "ucs-2": !0,
          utf16le: !0,
          "utf-16le": !0
        };
        e.isNativeEncoding = function(c) {
          return c && i[c.toLowerCase()];
        };
        var a = Bt.SlowBuffer;
        if (n.SlowBufferToString = a.prototype.toString, a.prototype.toString = function(c, o, u) {
          return c = String(c || "utf8").toLowerCase(), e.isNativeEncoding(c) ? n.SlowBufferToString.call(this, c, o, u) : (typeof o > "u" && (o = 0), typeof u > "u" && (u = this.length), t.decode(this.slice(o, u), c));
        }, n.SlowBufferWrite = a.prototype.write, a.prototype.write = function(c, o, u, l) {
          if (isFinite(o))
            isFinite(u) || (l = u, u = void 0);
          else {
            var p = l;
            l = o, o = u, u = p;
          }
          o = +o || 0;
          var f = this.length - o;
          if (u ? (u = +u, u > f && (u = f)) : u = f, l = String(l || "utf8").toLowerCase(), e.isNativeEncoding(l))
            return n.SlowBufferWrite.call(this, c, o, u, l);
          if (c.length > 0 && (u < 0 || o < 0))
            throw new RangeError("attempt to write beyond buffer bounds");
          var m = t.encode(c, l);
          return m.length < u && (u = m.length), m.copy(this, o, 0, u), u;
        }, n.BufferIsEncoding = e.isEncoding, e.isEncoding = function(c) {
          return e.isNativeEncoding(c) || t.encodingExists(c);
        }, n.BufferByteLength = e.byteLength, e.byteLength = a.byteLength = function(c, o) {
          return o = String(o || "utf8").toLowerCase(), e.isNativeEncoding(o) ? n.BufferByteLength.call(this, c, o) : t.encode(c, o).length;
        }, n.BufferToString = e.prototype.toString, e.prototype.toString = function(c, o, u) {
          return c = String(c || "utf8").toLowerCase(), e.isNativeEncoding(c) ? n.BufferToString.call(this, c, o, u) : (typeof o > "u" && (o = 0), typeof u > "u" && (u = this.length), t.decode(this.slice(o, u), c));
        }, n.BufferWrite = e.prototype.write, e.prototype.write = function(c, o, u, l) {
          var p = o, f = u, m = l;
          if (isFinite(o))
            isFinite(u) || (l = u, u = void 0);
          else {
            var g = l;
            l = o, o = u, u = g;
          }
          if (l = String(l || "utf8").toLowerCase(), e.isNativeEncoding(l))
            return n.BufferWrite.call(this, c, p, f, m);
          o = +o || 0;
          var h = this.length - o;
          if (u ? (u = +u, u > h && (u = h)) : u = h, c.length > 0 && (u < 0 || o < 0))
            throw new RangeError("attempt to write beyond buffer bounds");
          var b = t.encode(c, l);
          return b.length < u && (u = b.length), b.copy(this, o, 0, u), u;
        }, t.supportsStreams) {
          var s = ae.Readable;
          n.ReadableSetEncoding = s.prototype.setEncoding, s.prototype.setEncoding = function(o, u) {
            this._readableState.decoder = t.getDecoder(o, u), this._readableState.encoding = o;
          }, s.prototype.collect = t._collect;
        }
      }
    }, t.undoExtendNodeEncodings = function() {
      if (t.supportsNodeEncodingsExtension) {
        if (!n)
          throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
        delete e.isNativeEncoding;
        var i = Bt.SlowBuffer;
        if (i.prototype.toString = n.SlowBufferToString, i.prototype.write = n.SlowBufferWrite, e.isEncoding = n.BufferIsEncoding, e.byteLength = n.BufferByteLength, e.prototype.toString = n.BufferToString, e.prototype.write = n.BufferWrite, t.supportsStreams) {
          var a = ae.Readable;
          a.prototype.setEncoding = n.ReadableSetEncoding, delete a.prototype.collect;
        }
        n = void 0;
      }
    };
  }, Ic;
}
var hd;
function H_() {
  return hd || (hd = 1, function(e) {
    var t = Ge.Buffer, n = S_(), r = e.exports;
    r.encodings = null, r.defaultCharUnicode = "", r.defaultCharSingleByte = "?", r.encode = function(c, o, u) {
      c = "" + (c || "");
      var l = r.getEncoder(o, u), p = l.write(c), f = l.end();
      return f && f.length > 0 ? t.concat([p, f]) : p;
    }, r.decode = function(c, o, u) {
      typeof c == "string" && (r.skipDecodeWarning || (console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding"), r.skipDecodeWarning = !0), c = t.from("" + (c || ""), "binary"));
      var l = r.getDecoder(o, u), p = l.write(c), f = l.end();
      return f ? p + f : p;
    }, r.encodingExists = function(c) {
      try {
        return r.getCodec(c), !0;
      } catch {
        return !1;
      }
    }, r.toEncoding = r.encode, r.fromEncoding = r.decode, r._codecDataCache = {}, r.getCodec = function(c) {
      r.encodings || (r.encodings = M_());
      for (var o = r._canonicalizeEncoding(c), u = {}; ; ) {
        var l = r._codecDataCache[o];
        if (l)
          return l;
        var p = r.encodings[o];
        switch (typeof p) {
          case "string":
            o = p;
            break;
          case "object":
            for (var f in p)
              u[f] = p[f];
            u.encodingName || (u.encodingName = o), o = p.type;
            break;
          case "function":
            return u.encodingName || (u.encodingName = o), l = new p(u, r), r._codecDataCache[u.encodingName] = l, l;
          default:
            throw new Error("Encoding not recognized: '" + c + "' (searched as: '" + o + "')");
        }
      }
    }, r._canonicalizeEncoding = function(s) {
      return ("" + s).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    }, r.getEncoder = function(c, o) {
      var u = r.getCodec(c), l = new u.encoder(o, u);
      return u.bomAware && o && o.addBOM && (l = new n.PrependBOM(l, o)), l;
    }, r.getDecoder = function(c, o) {
      var u = r.getCodec(c), l = new u.decoder(o, u);
      return u.bomAware && !(o && o.stripBOM === !1) && (l = new n.StripBOM(l, o)), l;
    };
    var i = typeof process < "u" && process.versions && process.versions.node;
    if (i) {
      var a = i.split(".").map(Number);
      (a[0] > 0 || a[1] >= 10) && q_()(r), z_()(r);
    }
  }(wc)), wc.exports;
}
const Ra = Ot, W_ = ae, G_ = __, $a = me;
let Dc;
const $n = Symbol("ZipUncompressStream#yauzlCallback"), md = Symbol("ZipUncompressStream#stripName"), V_ = { lazyEntries: !0, decodeStrings: !1 };
function Y_(e) {
  const t = e.externalFileAttributes >> 16 || 33188;
  return [
    448,
    56,
    7
    /* S_IRWXO */
  ].map((n) => t & n).reduce(
    (n, r) => n + r,
    t & 61440
    /* S_IFMT */
  );
}
let X_ = class extends G_ {
  constructor(t) {
    t = t || {}, super(t), this._chunks = [], this._strip = Number(t.strip) || 0, this._zipFileNameEncoding = t.zipFileNameEncoding || "utf8", this._zipFileNameEncoding === "utf-8" && (this._zipFileNameEncoding = "utf8"), this[$n] = this[$n].bind(this);
    const n = $a.sourceType(t.source), r = this._yauzlOpts = Object.assign({}, V_, t.yauzl);
    if (n === "file") {
      Ra.open(t.source, r, this[$n]);
      return;
    }
    if (n === "buffer") {
      Ra.fromBuffer(t.source, r, this[$n]);
      return;
    }
    if (n === "stream") {
      $a.streamToBuffer(t.source).then((i) => Ra.fromBuffer(i, r, this[$n])).catch((i) => this.emit("error", i));
      return;
    }
    this.on("pipe", (i) => {
      i.unpipe(i), $a.streamToBuffer(i).then((a) => {
        this._chunks.push(a), a = Buffer.concat(this._chunks), Ra.fromBuffer(a, r, this[$n]);
      }).catch((a) => this.emit("error", a));
    });
  }
  _write(t) {
    this._chunks.push(t);
  }
  [$n](t, n) {
    if (t) return this.emit("error", t);
    n.readEntry(), n.on("entry", (i) => {
      const a = Y_(i);
      Buffer.isBuffer(i.fileName) && (this._zipFileNameEncoding === "utf8" ? i.fileName = i.fileName.toString() : (Dc || (Dc = H_()), i.fileName = Dc.decode(i.fileName, this._zipFileNameEncoding)));
      const s = /[\\\/]$/.test(i.fileName) ? "directory" : "file", o = { name: i.fileName = this[md](i.fileName, s), type: s, yauzl: i, mode: a };
      if (s === "file")
        n.openReadStream(i, (u, l) => {
          if (u) return this.emit("error", u);
          this.emit("entry", o, l, r);
        });
      else {
        const u = new W_.Readable({ read() {
        } });
        this.emit("entry", o, u, r), setImmediate(() => u.emit("end"));
      }
    }).on("end", () => this.emit("finish")).on("error", (i) => this.emit("error", i));
    function r() {
      n.readEntry();
    }
  }
  [md](t, n) {
    return $a.stripFileName(this._strip, t, n);
  }
};
var K_ = X_;
const io = me, k1 = ZE, L1 = a_, Ru = K_;
gn.Stream = k1;
gn.FileStream = L1;
gn.UncompressStream = Ru;
gn.compressDir = io.makeCompressDirFn(k1);
gn.compressFile = io.makeFileProcessFn(L1);
gn.uncompress = io.makeUncompressFn(Ru);
gn.decompress = io.makeUncompressFn(Ru);
var qt = {}, Ki = {}, J_ = De, kl = ae;
Ki.createReadStream = function(e, t) {
  return new $u(e, t);
};
var $u = function(e, t) {
  e instanceof Buffer || typeof e == "string" ? (t = t || {}, kl.Readable.call(this, {
    highWaterMark: t.highWaterMark,
    encoding: t.encoding
  })) : kl.Readable.call(this, { objectMode: !0 }), this._object = e;
};
J_.inherits($u, kl.Readable);
$u.prototype._read = function() {
  this.push(this._object), this._object = null;
};
const Z_ = se, Q_ = et, e6 = me, t6 = Ki;
let n6 = class extends Q_.Gzip {
  constructor(t) {
    t = t || {}, super(t.zlib);
    const n = e6.sourceType(t.source);
    if (n === "file") {
      const r = Z_.createReadStream(t.source, t.fs);
      r.on("error", (i) => this.emit("error", i)), r.pipe(this);
      return;
    }
    if (n === "buffer") {
      const r = t6.createReadStream(t.source, t.streamifier);
      r.on("error", (i) => this.emit("error", i)), r.pipe(this);
      return;
    }
    n === "stream" && (t.source.on("error", (r) => this.emit("error", r)), t.source.pipe(this));
  }
};
var r6 = n6;
const i6 = se, a6 = et, s6 = me, o6 = Ki;
let c6 = class extends a6.Unzip {
  constructor(t) {
    t = t || {}, super(t.zlib);
    const n = s6.sourceType(t.source);
    if (n === "file") {
      const r = i6.createReadStream(t.source, t.fs);
      r.on("error", (i) => this.emit("error", i)), r.pipe(this);
      return;
    }
    if (n === "buffer") {
      const r = o6.createReadStream(t.source, t.streamifier);
      r.on("error", (i) => this.emit("error", i)), r.pipe(this);
      return;
    }
    n === "stream" && (t.source.on("error", (r) => this.emit("error", r)), t.source.pipe(this));
  }
};
var l6 = c6;
const Ou = me, N1 = r6, Iu = l6;
qt.FileStream = N1;
qt.UncompressStream = Iu;
qt.compressFile = Ou.makeFileProcessFn(N1);
qt.uncompress = Ou.makeFileProcessFn(Iu);
qt.decompress = Ou.makeFileProcessFn(Iu);
var bt = {};
const vd = se, u6 = ne, gd = ae, p6 = zi, f6 = me, d6 = Qs;
let U1 = class extends gd.Transform {
  constructor(t) {
    super(t);
    const n = p6.pack();
    n.on("data", (i) => this.push(i)), n.on("end", () => this.ready(!0));
    const r = f6.sourceType(t.source);
    if (r === "file")
      vd.stat(t.source, (i, a) => {
        if (i) return this.emit("error", i);
        this.entry = n.entry({ name: t.relativePath || u6.basename(t.source), size: a.size, mode: a.mode & 511 }, (c) => {
          if (c) return this.emit("error", c);
          n.finalize();
        });
        const s = vd.createReadStream(t.source, t.fs);
        s.on("error", (c) => this.emit("error", c)), s.pipe(this);
      });
    else if (r === "buffer") {
      if (!t.relativePath) return this.emit("error", "opts.relativePath is required if opts.source is a buffer");
      n.entry({ name: t.relativePath }, t.source), n.finalize(), this.end();
    } else {
      if (!t.relativePath) return process.nextTick(() => this.emit("error", "opts.relativePath is required"));
      if (t.size)
        this.entry = n.entry({ name: t.relativePath, size: t.size }, (i) => {
          if (i) return this.emit("error", i);
          n.finalize();
        });
      else {
        t.suppressSizeWarning || console.warn("You should specify the size of streamming data by opts.size to prevent all streaming data from loading into memory. If you are sure about memory cost, pass opts.suppressSizeWarning: true to suppress this warning");
        const i = [];
        this.entry = new gd.Writable({
          write(a, s, c) {
            i.push(a), c();
          }
        }), this.entry.on("finish", () => {
          n.entry({ name: t.relativePath }, Buffer.concat(i)), n.finalize();
        });
      }
      r === "stream" && (t.source.on("error", (i) => this.emit("error", i)), t.source.pipe(this));
    }
  }
  _transform(t, n, r) {
    this.entry && this.entry.write(t, n, r);
  }
  _flush(t) {
    this.entry && this.entry.end(), this.ready(t);
  }
};
d6.mixin(U1.prototype);
var h6 = U1;
const m6 = se, v6 = zi, g6 = me, b6 = Ki;
let x6 = class extends v6.extract {
  constructor(t) {
    t = t || {}, super(t);
    const n = g6.sourceType(t.source);
    if (n === "file") {
      const r = m6.createReadStream(t.source, t.fs);
      r.on("error", (i) => this.emit("error", i)), r.pipe(this);
      return;
    }
    if (n === "buffer") {
      const r = b6.createReadStream(t.source, t.streamifier);
      r.on("error", (i) => this.emit("error", i)), r.pipe(this);
      return;
    }
    n === "stream" && (t.source.on("error", (r) => this.emit("error", r)), t.source.pipe(this));
  }
};
var y6 = x6;
const ao = me, B1 = y1, j1 = h6, Du = y6;
bt.Stream = B1;
bt.FileStream = j1;
bt.UncompressStream = Du;
bt.compressDir = ao.makeCompressDirFn(B1);
bt.compressFile = ao.makeFileProcessFn(j1);
bt.uncompress = ao.makeUncompressFn(Du);
bt.decompress = ao.makeUncompressFn(Du);
var xn = {};
const w6 = bt, E6 = qt, _6 = x1;
let S6 = class extends _6 {
  constructor(t) {
    super(t);
    const n = this._tarStream = new w6.Stream();
    n.on("error", (i) => this.emit("error", i));
    const r = new E6.FileStream();
    r.on("end", () => this.push(null)), r.on("data", (i) => this.push(i)), r.on("error", (i) => this.emit("error", i)), n.pipe(r);
  }
  addEntry(t, n) {
    this._tarStream.addEntry(t, n);
  }
};
var A6 = S6;
const T6 = bt, C6 = qt, bd = me, R6 = ae, $6 = k0, O6 = Qs;
let M1 = class extends R6.Transform {
  constructor(t) {
    t = t || {}, super(t);
    const n = this._sourceType = bd.sourceType(t.source), r = this._tarStream = new T6.FileStream(t);
    t = bd.clone(t), delete t.source;
    const i = new C6.FileStream(t);
    i.on("data", (a) => {
      this.push(a);
    }), i.on("end", () => this.ready(!0)), $6(r, i, (a) => {
      a && this.emit("error", a);
    }), n !== "stream" && n !== void 0 && this.end();
  }
  _transform(t, n, r) {
    this._tarStream.write(t, n, r);
  }
  _flush(t) {
    (this._sourceType === "stream" || this._sourceType === void 0) && this._tarStream.end(), this.ready(t);
  }
};
O6.mixin(M1.prototype);
var I6 = M1, Fc = Yn.EventEmitter, Fu = ae.Writable, D6 = De;
function Pu(e) {
  Fu.call(this, e);
}
D6.inherits(Pu, Fu);
Pu.prototype.emit = function(e) {
  if (e === "finish" && this._flush && !Fu.prototype._flush)
    this._flush((function(n) {
      n ? Fc.prototype.emit.call(this, "error", n) : Fc.prototype.emit.call(this, "finish");
    }).bind(this));
  else {
    var t = Array.prototype.slice.call(arguments);
    Fc.prototype.emit.apply(this, t);
  }
};
var F6 = Pu;
const P6 = se, xd = me, k6 = Qs, L6 = Ki, N6 = F6, U6 = qt.UncompressStream, B6 = bt.UncompressStream;
let q1 = class extends N6 {
  constructor(t) {
    t = t || {}, super(t);
    const n = xd.clone(t);
    n.source = void 0, this._gzipStream = new U6(n).on("error", (a) => this.emit("error", a));
    const r = new B6(n).on("finish", () => this.ready(!0)).on("entry", this.emit.bind(this, "entry")).on("error", (a) => this.emit("error", a));
    this._gzipStream.pipe(r);
    const i = xd.sourceType(t.source);
    if (i === "file") {
      const a = P6.createReadStream(t.source, t.fs);
      a.on("error", (s) => this.emit("error", s)), a.pipe(this);
      return;
    }
    if (i === "buffer") {
      const a = L6.createReadStream(t.source, t.streamifier);
      a.on("error", (s) => this.emit("error", s)), a.pipe(this);
      return;
    }
    i === "stream" && (t.source.on("error", (a) => this.emit("error", a)), t.source.pipe(this));
  }
  _write(t, n, r) {
    this._gzipStream.write(t, n, r);
  }
  _flush(t) {
    this._gzipStream.end(), this.ready(t);
  }
};
k6.mixin(q1.prototype);
var j6 = q1;
const so = me, z1 = A6, H1 = I6, ku = j6;
xn.Stream = z1;
xn.FileStream = H1;
xn.UncompressStream = ku;
xn.compressDir = so.makeCompressDirFn(z1);
xn.compressFile = so.makeFileProcessFn(H1);
xn.uncompress = so.makeUncompressFn(ku);
xn.decompress = so.makeUncompressFn(ku);
qi.zip = gn;
qi.gzip = qt;
qi.tar = bt;
qi.tgz = xn;
var W1 = { exports: {} }, Lu = {}, G1 = "\uFEFF";
Lu.PrependBOM = Nu;
function Nu(e, t) {
  this.encoder = e, this.addBOM = !0;
}
Nu.prototype.write = function(e) {
  return this.addBOM && (e = G1 + e, this.addBOM = !1), this.encoder.write(e);
};
Nu.prototype.end = function() {
  return this.encoder.end();
};
Lu.StripBOM = Uu;
function Uu(e, t) {
  this.decoder = e, this.pass = !1, this.options = t || {};
}
Uu.prototype.write = function(e) {
  var t = this.decoder.write(e);
  return this.pass || !t || (t[0] === G1 && (t = t.slice(1), typeof this.options.stripBOM == "function" && this.options.stripBOM()), this.pass = !0), t;
};
Uu.prototype.end = function() {
  return this.decoder.end();
};
var Pc = {}, kc, yd;
function M6() {
  if (yd) return kc;
  yd = 1;
  var e = Ge.Buffer;
  kc = {
    // Encodings
    utf8: { type: "_internal", bomAware: !0 },
    cesu8: { type: "_internal", bomAware: !0 },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: !0 },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: t
  };
  function t(o, u) {
    this.enc = o.encodingName, this.bomAware = o.bomAware, this.enc === "base64" ? this.encoder = a : this.enc === "cesu8" && (this.enc = "utf8", this.encoder = s, e.from("eda0bdedb2a9", "hex").toString() !== "" && (this.decoder = c, this.defaultCharUnicode = u.defaultCharUnicode));
  }
  t.prototype.encoder = i, t.prototype.decoder = r;
  var n = Os.StringDecoder;
  n.prototype.end || (n.prototype.end = function() {
  });
  function r(o, u) {
    this.decoder = new n(u.enc);
  }
  r.prototype.write = function(o) {
    return e.isBuffer(o) || (o = e.from(o)), this.decoder.write(o);
  }, r.prototype.end = function() {
    return this.decoder.end();
  };
  function i(o, u) {
    this.enc = u.enc;
  }
  i.prototype.write = function(o) {
    return e.from(o, this.enc);
  }, i.prototype.end = function() {
  };
  function a(o, u) {
    this.prevStr = "";
  }
  a.prototype.write = function(o) {
    o = this.prevStr + o;
    var u = o.length - o.length % 4;
    return this.prevStr = o.slice(u), o = o.slice(0, u), e.from(o, "base64");
  }, a.prototype.end = function() {
    return e.from(this.prevStr, "base64");
  };
  function s(o, u) {
  }
  s.prototype.write = function(o) {
    for (var u = e.alloc(o.length * 3), l = 0, p = 0; p < o.length; p++) {
      var f = o.charCodeAt(p);
      f < 128 ? u[l++] = f : f < 2048 ? (u[l++] = 192 + (f >>> 6), u[l++] = 128 + (f & 63)) : (u[l++] = 224 + (f >>> 12), u[l++] = 128 + (f >>> 6 & 63), u[l++] = 128 + (f & 63));
    }
    return u.slice(0, l);
  }, s.prototype.end = function() {
  };
  function c(o, u) {
    this.acc = 0, this.contBytes = 0, this.accBytes = 0, this.defaultCharUnicode = u.defaultCharUnicode;
  }
  return c.prototype.write = function(o) {
    for (var u = this.acc, l = this.contBytes, p = this.accBytes, f = "", m = 0; m < o.length; m++) {
      var g = o[m];
      (g & 192) !== 128 ? (l > 0 && (f += this.defaultCharUnicode, l = 0), g < 128 ? f += String.fromCharCode(g) : g < 224 ? (u = g & 31, l = 1, p = 1) : g < 240 ? (u = g & 15, l = 2, p = 1) : f += this.defaultCharUnicode) : l > 0 ? (u = u << 6 | g & 63, l--, p++, l === 0 && (p === 2 && u < 128 && u > 0 ? f += this.defaultCharUnicode : p === 3 && u < 2048 ? f += this.defaultCharUnicode : f += String.fromCharCode(u))) : f += this.defaultCharUnicode;
    }
    return this.acc = u, this.contBytes = l, this.accBytes = p, f;
  }, c.prototype.end = function() {
    var o = 0;
    return this.contBytes > 0 && (o += this.defaultCharUnicode), o;
  }, kc;
}
var Lt = {}, wd;
function q6() {
  if (wd) return Lt;
  wd = 1;
  var e = Ge.Buffer;
  Lt._utf32 = t;
  function t(u, l) {
    this.iconv = l, this.bomAware = !0, this.isLE = u.isLE;
  }
  Lt.utf32le = { type: "_utf32", isLE: !0 }, Lt.utf32be = { type: "_utf32", isLE: !1 }, Lt.ucs4le = "utf32le", Lt.ucs4be = "utf32be", t.prototype.encoder = n, t.prototype.decoder = r;
  function n(u, l) {
    this.isLE = l.isLE, this.highSurrogate = 0;
  }
  n.prototype.write = function(u) {
    for (var l = e.from(u, "ucs2"), p = e.alloc(l.length * 2), f = this.isLE ? p.writeUInt32LE : p.writeUInt32BE, m = 0, g = 0; g < l.length; g += 2) {
      var h = l.readUInt16LE(g), b = 55296 <= h && h < 56320, x = 56320 <= h && h < 57344;
      if (this.highSurrogate)
        if (b || !x)
          f.call(p, this.highSurrogate, m), m += 4;
        else {
          var y = (this.highSurrogate - 55296 << 10 | h - 56320) + 65536;
          f.call(p, y, m), m += 4, this.highSurrogate = 0;
          continue;
        }
      b ? this.highSurrogate = h : (f.call(p, h, m), m += 4, this.highSurrogate = 0);
    }
    return m < p.length && (p = p.slice(0, m)), p;
  }, n.prototype.end = function() {
    if (this.highSurrogate) {
      var u = e.alloc(4);
      return this.isLE ? u.writeUInt32LE(this.highSurrogate, 0) : u.writeUInt32BE(this.highSurrogate, 0), this.highSurrogate = 0, u;
    }
  };
  function r(u, l) {
    this.isLE = l.isLE, this.badChar = l.iconv.defaultCharUnicode.charCodeAt(0), this.overflow = [];
  }
  r.prototype.write = function(u) {
    if (u.length === 0)
      return "";
    var l = 0, p = 0, f = e.alloc(u.length + 4), m = 0, g = this.isLE, h = this.overflow, b = this.badChar;
    if (h.length > 0) {
      for (; l < u.length && h.length < 4; l++)
        h.push(u[l]);
      h.length === 4 && (g ? p = h[l] | h[l + 1] << 8 | h[l + 2] << 16 | h[l + 3] << 24 : p = h[l + 3] | h[l + 2] << 8 | h[l + 1] << 16 | h[l] << 24, h.length = 0, m = i(f, m, p, b));
    }
    for (; l < u.length - 3; l += 4)
      g ? p = u[l] | u[l + 1] << 8 | u[l + 2] << 16 | u[l + 3] << 24 : p = u[l + 3] | u[l + 2] << 8 | u[l + 1] << 16 | u[l] << 24, m = i(f, m, p, b);
    for (; l < u.length; l++)
      h.push(u[l]);
    return f.slice(0, m).toString("ucs2");
  };
  function i(u, l, p, f) {
    if ((p < 0 || p > 1114111) && (p = f), p >= 65536) {
      p -= 65536;
      var m = 55296 | p >> 10;
      u[l++] = m & 255, u[l++] = m >> 8;
      var p = 56320 | p & 1023;
    }
    return u[l++] = p & 255, u[l++] = p >> 8, l;
  }
  r.prototype.end = function() {
    this.overflow.length = 0;
  }, Lt.utf32 = a, Lt.ucs4 = "utf32";
  function a(u, l) {
    this.iconv = l;
  }
  a.prototype.encoder = s, a.prototype.decoder = c;
  function s(u, l) {
    u = u || {}, u.addBOM === void 0 && (u.addBOM = !0), this.encoder = l.iconv.getEncoder(u.defaultEncoding || "utf-32le", u);
  }
  s.prototype.write = function(u) {
    return this.encoder.write(u);
  }, s.prototype.end = function() {
    return this.encoder.end();
  };
  function c(u, l) {
    this.decoder = null, this.initialBufs = [], this.initialBufsLen = 0, this.options = u || {}, this.iconv = l.iconv;
  }
  c.prototype.write = function(u) {
    if (!this.decoder) {
      if (this.initialBufs.push(u), this.initialBufsLen += u.length, this.initialBufsLen < 32)
        return "";
      var l = o(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(l, this.options);
      for (var p = "", f = 0; f < this.initialBufs.length; f++)
        p += this.decoder.write(this.initialBufs[f]);
      return this.initialBufs.length = this.initialBufsLen = 0, p;
    }
    return this.decoder.write(u);
  }, c.prototype.end = function() {
    if (!this.decoder) {
      var u = o(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(u, this.options);
      for (var l = "", p = 0; p < this.initialBufs.length; p++)
        l += this.decoder.write(this.initialBufs[p]);
      var f = this.decoder.end();
      return f && (l += f), this.initialBufs.length = this.initialBufsLen = 0, l;
    }
    return this.decoder.end();
  };
  function o(u, l) {
    var p = [], f = 0, m = 0, g = 0, h = 0, b = 0;
    e:
      for (var x = 0; x < u.length; x++)
        for (var y = u[x], E = 0; E < y.length; E++)
          if (p.push(y[E]), p.length === 4) {
            if (f === 0) {
              if (p[0] === 255 && p[1] === 254 && p[2] === 0 && p[3] === 0)
                return "utf-32le";
              if (p[0] === 0 && p[1] === 0 && p[2] === 254 && p[3] === 255)
                return "utf-32be";
            }
            if ((p[0] !== 0 || p[1] > 16) && g++, (p[3] !== 0 || p[2] > 16) && m++, p[0] === 0 && p[1] === 0 && (p[2] !== 0 || p[3] !== 0) && b++, (p[0] !== 0 || p[1] !== 0) && p[2] === 0 && p[3] === 0 && h++, p.length = 0, f++, f >= 100)
              break e;
          }
    return b - g > h - m ? "utf-32be" : b - g < h - m ? "utf-32le" : l || "utf-32le";
  }
  return Lt;
}
var Oa = {}, Ed;
function z6() {
  if (Ed) return Oa;
  Ed = 1;
  var e = Ge.Buffer;
  Oa.utf16be = t;
  function t() {
  }
  t.prototype.encoder = n, t.prototype.decoder = r, t.prototype.bomAware = !0;
  function n() {
  }
  n.prototype.write = function(o) {
    for (var u = e.from(o, "ucs2"), l = 0; l < u.length; l += 2) {
      var p = u[l];
      u[l] = u[l + 1], u[l + 1] = p;
    }
    return u;
  }, n.prototype.end = function() {
  };
  function r() {
    this.overflowByte = -1;
  }
  r.prototype.write = function(o) {
    if (o.length == 0)
      return "";
    var u = e.alloc(o.length + 1), l = 0, p = 0;
    for (this.overflowByte !== -1 && (u[0] = o[0], u[1] = this.overflowByte, l = 1, p = 2); l < o.length - 1; l += 2, p += 2)
      u[p] = o[l + 1], u[p + 1] = o[l];
    return this.overflowByte = l == o.length - 1 ? o[o.length - 1] : -1, u.slice(0, p).toString("ucs2");
  }, r.prototype.end = function() {
    this.overflowByte = -1;
  }, Oa.utf16 = i;
  function i(o, u) {
    this.iconv = u;
  }
  i.prototype.encoder = a, i.prototype.decoder = s;
  function a(o, u) {
    o = o || {}, o.addBOM === void 0 && (o.addBOM = !0), this.encoder = u.iconv.getEncoder("utf-16le", o);
  }
  a.prototype.write = function(o) {
    return this.encoder.write(o);
  }, a.prototype.end = function() {
    return this.encoder.end();
  };
  function s(o, u) {
    this.decoder = null, this.initialBufs = [], this.initialBufsLen = 0, this.options = o || {}, this.iconv = u.iconv;
  }
  s.prototype.write = function(o) {
    if (!this.decoder) {
      if (this.initialBufs.push(o), this.initialBufsLen += o.length, this.initialBufsLen < 16)
        return "";
      var u = c(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(u, this.options);
      for (var l = "", p = 0; p < this.initialBufs.length; p++)
        l += this.decoder.write(this.initialBufs[p]);
      return this.initialBufs.length = this.initialBufsLen = 0, l;
    }
    return this.decoder.write(o);
  }, s.prototype.end = function() {
    if (!this.decoder) {
      var o = c(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(o, this.options);
      for (var u = "", l = 0; l < this.initialBufs.length; l++)
        u += this.decoder.write(this.initialBufs[l]);
      var p = this.decoder.end();
      return p && (u += p), this.initialBufs.length = this.initialBufsLen = 0, u;
    }
    return this.decoder.end();
  };
  function c(o, u) {
    var l = [], p = 0, f = 0, m = 0;
    e:
      for (var g = 0; g < o.length; g++)
        for (var h = o[g], b = 0; b < h.length; b++)
          if (l.push(h[b]), l.length === 2) {
            if (p === 0) {
              if (l[0] === 255 && l[1] === 254) return "utf-16le";
              if (l[0] === 254 && l[1] === 255) return "utf-16be";
            }
            if (l[0] === 0 && l[1] !== 0 && m++, l[0] !== 0 && l[1] === 0 && f++, l.length = 0, p++, p >= 100)
              break e;
          }
    return m > f ? "utf-16be" : m < f ? "utf-16le" : u || "utf-16le";
  }
  return Oa;
}
var ei = {}, _d;
function H6() {
  if (_d) return ei;
  _d = 1;
  var e = Ge.Buffer;
  ei.utf7 = t, ei.unicode11utf7 = "utf7";
  function t(h, b) {
    this.iconv = b;
  }
  t.prototype.encoder = r, t.prototype.decoder = i, t.prototype.bomAware = !0;
  var n = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function r(h, b) {
    this.iconv = b.iconv;
  }
  r.prototype.write = function(h) {
    return e.from(h.replace(n, (function(b) {
      return "+" + (b === "+" ? "" : this.iconv.encode(b, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
  }, r.prototype.end = function() {
  };
  function i(h, b) {
    this.iconv = b.iconv, this.inBase64 = !1, this.base64Accum = "";
  }
  for (var a = /[A-Za-z0-9\/+]/, s = [], c = 0; c < 256; c++)
    s[c] = a.test(String.fromCharCode(c));
  var o = 43, u = 45, l = 38;
  i.prototype.write = function(h) {
    for (var b = "", x = 0, y = this.inBase64, E = this.base64Accum, S = 0; S < h.length; S++)
      if (!y)
        h[S] == o && (b += this.iconv.decode(h.slice(x, S), "ascii"), x = S + 1, y = !0);
      else if (!s[h[S]]) {
        if (S == x && h[S] == u)
          b += "+";
        else {
          var D = E + this.iconv.decode(h.slice(x, S), "ascii");
          b += this.iconv.decode(e.from(D, "base64"), "utf16-be");
        }
        h[S] != u && S--, x = S + 1, y = !1, E = "";
      }
    if (!y)
      b += this.iconv.decode(h.slice(x), "ascii");
    else {
      var D = E + this.iconv.decode(h.slice(x), "ascii"), U = D.length - D.length % 8;
      E = D.slice(U), D = D.slice(0, U), b += this.iconv.decode(e.from(D, "base64"), "utf16-be");
    }
    return this.inBase64 = y, this.base64Accum = E, b;
  }, i.prototype.end = function() {
    var h = "";
    return this.inBase64 && this.base64Accum.length > 0 && (h = this.iconv.decode(e.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", h;
  }, ei.utf7imap = p;
  function p(h, b) {
    this.iconv = b;
  }
  p.prototype.encoder = f, p.prototype.decoder = m, p.prototype.bomAware = !0;
  function f(h, b) {
    this.iconv = b.iconv, this.inBase64 = !1, this.base64Accum = e.alloc(6), this.base64AccumIdx = 0;
  }
  f.prototype.write = function(h) {
    for (var b = this.inBase64, x = this.base64Accum, y = this.base64AccumIdx, E = e.alloc(h.length * 5 + 10), S = 0, D = 0; D < h.length; D++) {
      var U = h.charCodeAt(D);
      32 <= U && U <= 126 ? (b && (y > 0 && (S += E.write(x.slice(0, y).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), S), y = 0), E[S++] = u, b = !1), b || (E[S++] = U, U === l && (E[S++] = u))) : (b || (E[S++] = l, b = !0), b && (x[y++] = U >> 8, x[y++] = U & 255, y == x.length && (S += E.write(x.toString("base64").replace(/\//g, ","), S), y = 0)));
    }
    return this.inBase64 = b, this.base64AccumIdx = y, E.slice(0, S);
  }, f.prototype.end = function() {
    var h = e.alloc(10), b = 0;
    return this.inBase64 && (this.base64AccumIdx > 0 && (b += h.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), b), this.base64AccumIdx = 0), h[b++] = u, this.inBase64 = !1), h.slice(0, b);
  };
  function m(h, b) {
    this.iconv = b.iconv, this.inBase64 = !1, this.base64Accum = "";
  }
  var g = s.slice();
  return g[44] = !0, m.prototype.write = function(h) {
    for (var b = "", x = 0, y = this.inBase64, E = this.base64Accum, S = 0; S < h.length; S++)
      if (!y)
        h[S] == l && (b += this.iconv.decode(h.slice(x, S), "ascii"), x = S + 1, y = !0);
      else if (!g[h[S]]) {
        if (S == x && h[S] == u)
          b += "&";
        else {
          var D = E + this.iconv.decode(h.slice(x, S), "ascii").replace(/,/g, "/");
          b += this.iconv.decode(e.from(D, "base64"), "utf16-be");
        }
        h[S] != u && S--, x = S + 1, y = !1, E = "";
      }
    if (!y)
      b += this.iconv.decode(h.slice(x), "ascii");
    else {
      var D = E + this.iconv.decode(h.slice(x), "ascii").replace(/,/g, "/"), U = D.length - D.length % 8;
      E = D.slice(U), D = D.slice(0, U), b += this.iconv.decode(e.from(D, "base64"), "utf16-be");
    }
    return this.inBase64 = y, this.base64Accum = E, b;
  }, m.prototype.end = function() {
    var h = "";
    return this.inBase64 && this.base64Accum.length > 0 && (h = this.iconv.decode(e.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", h;
  }, ei;
}
var Lc = {}, Sd;
function W6() {
  if (Sd) return Lc;
  Sd = 1;
  var e = Ge.Buffer;
  Lc._sbcs = t;
  function t(i, a) {
    if (!i)
      throw new Error("SBCS codec is called without the data.");
    if (!i.chars || i.chars.length !== 128 && i.chars.length !== 256)
      throw new Error("Encoding '" + i.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (i.chars.length === 128) {
      for (var s = "", c = 0; c < 128; c++)
        s += String.fromCharCode(c);
      i.chars = s + i.chars;
    }
    this.decodeBuf = e.from(i.chars, "ucs2");
    for (var o = e.alloc(65536, a.defaultCharSingleByte.charCodeAt(0)), c = 0; c < i.chars.length; c++)
      o[i.chars.charCodeAt(c)] = c;
    this.encodeBuf = o;
  }
  t.prototype.encoder = n, t.prototype.decoder = r;
  function n(i, a) {
    this.encodeBuf = a.encodeBuf;
  }
  n.prototype.write = function(i) {
    for (var a = e.alloc(i.length), s = 0; s < i.length; s++)
      a[s] = this.encodeBuf[i.charCodeAt(s)];
    return a;
  }, n.prototype.end = function() {
  };
  function r(i, a) {
    this.decodeBuf = a.decodeBuf;
  }
  return r.prototype.write = function(i) {
    for (var a = this.decodeBuf, s = e.alloc(i.length * 2), c = 0, o = 0, u = 0; u < i.length; u++)
      c = i[u] * 2, o = u * 2, s[o] = a[c], s[o + 1] = a[c + 1];
    return s.toString("ucs2");
  }, r.prototype.end = function() {
  }, Lc;
}
var Nc, Ad;
function G6() {
  return Ad || (Ad = 1, Nc = {
    // Not supported by iconv, not sure why.
    10029: "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: ""
    },
    808: "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: ""
    },
    mik: {
      type: "_sbcs",
      chars: ""
    },
    cp720: {
      type: "_sbcs",
      chars: ""
    },
    // Aliases of generated encodings.
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    1e4: "macroman",
    10006: "macgreek",
    10007: "maccyrillic",
    10079: "maciceland",
    10081: "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    20866: "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    21866: "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  }), Nc;
}
var Uc, Td;
function V6() {
  return Td || (Td = 1, Uc = {
    437: "cp437",
    737: "cp737",
    775: "cp775",
    850: "cp850",
    852: "cp852",
    855: "cp855",
    856: "cp856",
    857: "cp857",
    858: "cp858",
    860: "cp860",
    861: "cp861",
    862: "cp862",
    863: "cp863",
    864: "cp864",
    865: "cp865",
    866: "cp866",
    869: "cp869",
    874: "windows874",
    922: "cp922",
    1046: "cp1046",
    1124: "cp1124",
    1125: "cp1125",
    1129: "cp1129",
    1133: "cp1133",
    1161: "cp1161",
    1162: "cp1162",
    1163: "cp1163",
    1250: "windows1250",
    1251: "windows1251",
    1252: "windows1252",
    1253: "windows1253",
    1254: "windows1254",
    1255: "windows1255",
    1256: "windows1256",
    1257: "windows1257",
    1258: "windows1258",
    28591: "iso88591",
    28592: "iso88592",
    28593: "iso88593",
    28594: "iso88594",
    28595: "iso88595",
    28596: "iso88596",
    28597: "iso88597",
    28598: "iso88598",
    28599: "iso88599",
    28600: "iso885910",
    28601: "iso885911",
    28603: "iso885913",
    28604: "iso885914",
    28605: "iso885915",
    28606: "iso885916",
    windows874: {
      type: "_sbcs",
      chars: ""
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: ""
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: ""
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: ""
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: ""
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: ""
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: ""
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: ""
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: ""
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: ""
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: ""
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: ""
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: ""
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: ""
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: ""
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: ""
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: ""
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: ""
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: ""
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: ""
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: ""
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: ""
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: ""
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: ""
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: ""
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: ""
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: ""
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: ""
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: ""
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: ""
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: ""
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: ""
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: ""
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: ""
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: ""
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: ""
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: ""
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: ""
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: ""
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: ""
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: ""
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: ""
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: ""
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: ""
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: ""
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: ""
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: ""
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: ""
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: ""
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: ""
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: ""
    },
    maccyrillic: {
      type: "_sbcs",
      chars: ""
    },
    macgreek: {
      type: "_sbcs",
      chars: ""
    },
    maciceland: {
      type: "_sbcs",
      chars: ""
    },
    macroman: {
      type: "_sbcs",
      chars: ""
    },
    macromania: {
      type: "_sbcs",
      chars: ""
    },
    macthai: {
      type: "_sbcs",
      chars: "\uFEFF"
    },
    macturkish: {
      type: "_sbcs",
      chars: ""
    },
    macukraine: {
      type: "_sbcs",
      chars: ""
    },
    koi8r: {
      type: "_sbcs",
      chars: ""
    },
    koi8u: {
      type: "_sbcs",
      chars: ""
    },
    koi8ru: {
      type: "_sbcs",
      chars: ""
    },
    koi8t: {
      type: "_sbcs",
      chars: ""
    },
    armscii8: {
      type: "_sbcs",
      chars: ")(.,-"
    },
    rk1048: {
      type: "_sbcs",
      chars: ""
    },
    tcvn: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: ""
    },
    georgianps: {
      type: "_sbcs",
      chars: ""
    },
    pt154: {
      type: "_sbcs",
      chars: ""
    },
    viscii: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    hproman8: {
      type: "_sbcs",
      chars: ""
    },
    macintosh: {
      type: "_sbcs",
      chars: ""
    },
    ascii: {
      type: "_sbcs",
      chars: ""
    },
    tis620: {
      type: "_sbcs",
      chars: ""
    }
  }), Uc;
}
var Bc = {}, Cd;
function Y6() {
  if (Cd) return Bc;
  Cd = 1;
  var e = Ge.Buffer;
  Bc._dbcs = o;
  for (var t = -1, n = -2, r = -10, i = -1e3, a = new Array(256), s = -1, c = 0; c < 256; c++)
    a[c] = t;
  function o(f, m) {
    if (this.encodingName = f.encodingName, !f)
      throw new Error("DBCS codec is called without the data.");
    if (!f.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var g = f.table();
    this.decodeTables = [], this.decodeTables[0] = a.slice(0), this.decodeTableSeq = [];
    for (var h = 0; h < g.length; h++)
      this._addDecodeChunk(g[h]);
    if (typeof f.gb18030 == "function") {
      this.gb18030 = f.gb18030();
      var b = this.decodeTables.length;
      this.decodeTables.push(a.slice(0));
      var x = this.decodeTables.length;
      this.decodeTables.push(a.slice(0));
      for (var y = this.decodeTables[0], h = 129; h <= 254; h++)
        for (var E = this.decodeTables[i - y[h]], S = 48; S <= 57; S++) {
          if (E[S] === t)
            E[S] = i - b;
          else if (E[S] > i)
            throw new Error("gb18030 decode tables conflict at byte 2");
          for (var D = this.decodeTables[i - E[S]], U = 129; U <= 254; U++) {
            if (D[U] === t)
              D[U] = i - x;
            else {
              if (D[U] === i - x)
                continue;
              if (D[U] > i)
                throw new Error("gb18030 decode tables conflict at byte 3");
            }
            for (var z = this.decodeTables[i - D[U]], ee = 48; ee <= 57; ee++)
              z[ee] === t && (z[ee] = n);
          }
        }
    }
    this.defaultCharUnicode = m.defaultCharUnicode, this.encodeTable = [], this.encodeTableSeq = [];
    var C = {};
    if (f.encodeSkipVals)
      for (var h = 0; h < f.encodeSkipVals.length; h++) {
        var H = f.encodeSkipVals[h];
        if (typeof H == "number")
          C[H] = !0;
        else
          for (var S = H.from; S <= H.to; S++)
            C[S] = !0;
      }
    if (this._fillEncodeTable(0, 0, C), f.encodeAdd)
      for (var M in f.encodeAdd)
        Object.prototype.hasOwnProperty.call(f.encodeAdd, M) && this._setEncodeChar(M.charCodeAt(0), f.encodeAdd[M]);
    this.defCharSB = this.encodeTable[0][m.defaultCharSingleByte.charCodeAt(0)], this.defCharSB === t && (this.defCharSB = this.encodeTable[0]["?"]), this.defCharSB === t && (this.defCharSB = 63);
  }
  o.prototype.encoder = u, o.prototype.decoder = l, o.prototype._getDecodeTrieNode = function(f) {
    for (var m = []; f > 0; f >>>= 8)
      m.push(f & 255);
    m.length == 0 && m.push(0);
    for (var g = this.decodeTables[0], h = m.length - 1; h > 0; h--) {
      var b = g[m[h]];
      if (b == t)
        g[m[h]] = i - this.decodeTables.length, this.decodeTables.push(g = a.slice(0));
      else if (b <= i)
        g = this.decodeTables[i - b];
      else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + f.toString(16));
    }
    return g;
  }, o.prototype._addDecodeChunk = function(f) {
    var m = parseInt(f[0], 16), g = this._getDecodeTrieNode(m);
    m = m & 255;
    for (var h = 1; h < f.length; h++) {
      var b = f[h];
      if (typeof b == "string")
        for (var x = 0; x < b.length; ) {
          var y = b.charCodeAt(x++);
          if (55296 <= y && y < 56320) {
            var E = b.charCodeAt(x++);
            if (56320 <= E && E < 57344)
              g[m++] = 65536 + (y - 55296) * 1024 + (E - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + f[0]);
          } else if (4080 < y && y <= 4095) {
            for (var S = 4095 - y + 2, D = [], U = 0; U < S; U++)
              D.push(b.charCodeAt(x++));
            g[m++] = r - this.decodeTableSeq.length, this.decodeTableSeq.push(D);
          } else
            g[m++] = y;
        }
      else if (typeof b == "number")
        for (var z = g[m - 1] + 1, x = 0; x < b; x++)
          g[m++] = z++;
      else
        throw new Error("Incorrect type '" + typeof b + "' given in " + this.encodingName + " at chunk " + f[0]);
    }
    if (m > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + f[0] + ": too long" + m);
  }, o.prototype._getEncodeBucket = function(f) {
    var m = f >> 8;
    return this.encodeTable[m] === void 0 && (this.encodeTable[m] = a.slice(0)), this.encodeTable[m];
  }, o.prototype._setEncodeChar = function(f, m) {
    var g = this._getEncodeBucket(f), h = f & 255;
    g[h] <= r ? this.encodeTableSeq[r - g[h]][s] = m : g[h] == t && (g[h] = m);
  }, o.prototype._setEncodeSequence = function(f, m) {
    var g = f[0], h = this._getEncodeBucket(g), b = g & 255, x;
    h[b] <= r ? x = this.encodeTableSeq[r - h[b]] : (x = {}, h[b] !== t && (x[s] = h[b]), h[b] = r - this.encodeTableSeq.length, this.encodeTableSeq.push(x));
    for (var y = 1; y < f.length - 1; y++) {
      var E = x[g];
      typeof E == "object" ? x = E : (x = x[g] = {}, E !== void 0 && (x[s] = E));
    }
    g = f[f.length - 1], x[g] = m;
  }, o.prototype._fillEncodeTable = function(f, m, g) {
    for (var h = this.decodeTables[f], b = !1, x = {}, y = 0; y < 256; y++) {
      var E = h[y], S = m + y;
      if (!g[S])
        if (E >= 0)
          this._setEncodeChar(E, S), b = !0;
        else if (E <= i) {
          var D = i - E;
          if (!x[D]) {
            var U = S << 8 >>> 0;
            this._fillEncodeTable(D, U, g) ? b = !0 : x[D] = !0;
          }
        } else E <= r && (this._setEncodeSequence(this.decodeTableSeq[r - E], S), b = !0);
    }
    return b;
  };
  function u(f, m) {
    this.leadSurrogate = -1, this.seqObj = void 0, this.encodeTable = m.encodeTable, this.encodeTableSeq = m.encodeTableSeq, this.defaultCharSingleByte = m.defCharSB, this.gb18030 = m.gb18030;
  }
  u.prototype.write = function(f) {
    for (var m = e.alloc(f.length * (this.gb18030 ? 4 : 3)), g = this.leadSurrogate, h = this.seqObj, b = -1, x = 0, y = 0; ; ) {
      if (b === -1) {
        if (x == f.length) break;
        var E = f.charCodeAt(x++);
      } else {
        var E = b;
        b = -1;
      }
      if (55296 <= E && E < 57344)
        if (E < 56320)
          if (g === -1) {
            g = E;
            continue;
          } else
            g = E, E = t;
        else
          g !== -1 ? (E = 65536 + (g - 55296) * 1024 + (E - 56320), g = -1) : E = t;
      else g !== -1 && (b = E, E = t, g = -1);
      var S = t;
      if (h !== void 0 && E != t) {
        var D = h[E];
        if (typeof D == "object") {
          h = D;
          continue;
        } else typeof D == "number" ? S = D : D == null && (D = h[s], D !== void 0 && (S = D, b = E));
        h = void 0;
      } else if (E >= 0) {
        var U = this.encodeTable[E >> 8];
        if (U !== void 0 && (S = U[E & 255]), S <= r) {
          h = this.encodeTableSeq[r - S];
          continue;
        }
        if (S == t && this.gb18030) {
          var z = p(this.gb18030.uChars, E);
          if (z != -1) {
            var S = this.gb18030.gbChars[z] + (E - this.gb18030.uChars[z]);
            m[y++] = 129 + Math.floor(S / 12600), S = S % 12600, m[y++] = 48 + Math.floor(S / 1260), S = S % 1260, m[y++] = 129 + Math.floor(S / 10), S = S % 10, m[y++] = 48 + S;
            continue;
          }
        }
      }
      S === t && (S = this.defaultCharSingleByte), S < 256 ? m[y++] = S : S < 65536 ? (m[y++] = S >> 8, m[y++] = S & 255) : S < 16777216 ? (m[y++] = S >> 16, m[y++] = S >> 8 & 255, m[y++] = S & 255) : (m[y++] = S >>> 24, m[y++] = S >>> 16 & 255, m[y++] = S >>> 8 & 255, m[y++] = S & 255);
    }
    return this.seqObj = h, this.leadSurrogate = g, m.slice(0, y);
  }, u.prototype.end = function() {
    if (!(this.leadSurrogate === -1 && this.seqObj === void 0)) {
      var f = e.alloc(10), m = 0;
      if (this.seqObj) {
        var g = this.seqObj[s];
        g !== void 0 && (g < 256 ? f[m++] = g : (f[m++] = g >> 8, f[m++] = g & 255)), this.seqObj = void 0;
      }
      return this.leadSurrogate !== -1 && (f[m++] = this.defaultCharSingleByte, this.leadSurrogate = -1), f.slice(0, m);
    }
  }, u.prototype.findIdx = p;
  function l(f, m) {
    this.nodeIdx = 0, this.prevBytes = [], this.decodeTables = m.decodeTables, this.decodeTableSeq = m.decodeTableSeq, this.defaultCharUnicode = m.defaultCharUnicode, this.gb18030 = m.gb18030;
  }
  l.prototype.write = function(f) {
    for (var m = e.alloc(f.length * 2), g = this.nodeIdx, h = this.prevBytes, b = this.prevBytes.length, x = -this.prevBytes.length, y, E = 0, S = 0; E < f.length; E++) {
      var D = E >= 0 ? f[E] : h[E + b], y = this.decodeTables[g][D];
      if (!(y >= 0)) if (y === t)
        y = this.defaultCharUnicode.charCodeAt(0), E = x;
      else if (y === n) {
        if (E >= 3)
          var U = (f[E - 3] - 129) * 12600 + (f[E - 2] - 48) * 1260 + (f[E - 1] - 129) * 10 + (D - 48);
        else
          var U = (h[E - 3 + b] - 129) * 12600 + ((E - 2 >= 0 ? f[E - 2] : h[E - 2 + b]) - 48) * 1260 + ((E - 1 >= 0 ? f[E - 1] : h[E - 1 + b]) - 129) * 10 + (D - 48);
        var z = p(this.gb18030.gbChars, U);
        y = this.gb18030.uChars[z] + U - this.gb18030.gbChars[z];
      } else if (y <= i) {
        g = i - y;
        continue;
      } else if (y <= r) {
        for (var ee = this.decodeTableSeq[r - y], C = 0; C < ee.length - 1; C++)
          y = ee[C], m[S++] = y & 255, m[S++] = y >> 8;
        y = ee[ee.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + y + " at " + g + "/" + D);
      if (y >= 65536) {
        y -= 65536;
        var H = 55296 | y >> 10;
        m[S++] = H & 255, m[S++] = H >> 8, y = 56320 | y & 1023;
      }
      m[S++] = y & 255, m[S++] = y >> 8, g = 0, x = E + 1;
    }
    return this.nodeIdx = g, this.prevBytes = x >= 0 ? Array.prototype.slice.call(f, x) : h.slice(x + b).concat(Array.prototype.slice.call(f)), m.slice(0, S).toString("ucs2");
  }, l.prototype.end = function() {
    for (var f = ""; this.prevBytes.length > 0; ) {
      f += this.defaultCharUnicode;
      var m = this.prevBytes.slice(1);
      this.prevBytes = [], this.nodeIdx = 0, m.length > 0 && (f += this.write(m));
    }
    return this.prevBytes = [], this.nodeIdx = 0, f;
  };
  function p(f, m) {
    if (f[0] > m)
      return -1;
    for (var g = 0, h = f.length; g < h - 1; ) {
      var b = g + (h - g + 1 >> 1);
      f[b] <= m ? g = b : h = b;
    }
    return g;
  }
  return Bc;
}
<<<<<<< HEAD
const require$$0 = [
=======
const X6 = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
<<<<<<< HEAD
];
const require$$1 = [
=======
], K6 = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "",
    62
  ],
  [
    "a1a1",
    "",
    9,
    ""
  ],
  [
    "a2a1",
    ""
  ],
  [
    "a2ba",
    ""
  ],
  [
    "a2ca",
    ""
  ],
  [
    "a2dc",
    ""
  ],
  [
    "a2f2",
    ""
  ],
  [
    "a2fe",
    ""
  ],
  [
    "a3b0",
    "",
    9
  ],
  [
    "a3c1",
    "",
    25
  ],
  [
    "a3e1",
    "",
    25
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a8a1",
    ""
  ],
  [
    "ada1",
    "",
    19,
    "",
    9
  ],
  [
    "adc0",
    ""
  ],
  [
    "addf",
    "",
    4,
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fcf1",
    "",
    9,
    ""
  ],
  [
    "8fa2af",
    ""
  ],
  [
    "8fa2c2",
    ""
  ],
  [
    "8fa2eb",
    ""
  ],
  [
    "8fa6e1",
    ""
  ],
  [
    "8fa6e7",
    ""
  ],
  [
    "8fa6e9",
    ""
  ],
  [
    "8fa6ec",
    ""
  ],
  [
    "8fa6f1",
    ""
  ],
  [
    "8fa7c2",
    "",
    10,
    ""
  ],
  [
    "8fa7f2",
    "",
    10,
    ""
  ],
  [
    "8fa9a1",
    ""
  ],
  [
    "8fa9a4",
    ""
  ],
  [
    "8fa9a6",
    ""
  ],
  [
    "8fa9a8",
    ""
  ],
  [
    "8fa9ab",
    ""
  ],
  [
    "8fa9af",
    ""
  ],
  [
    "8fa9c1",
    ""
  ],
  [
    "8faaa1",
    ""
  ],
  [
    "8faaba",
    ""
  ],
  [
    "8faba1",
    ""
  ],
  [
    "8fabbd",
    ""
  ],
  [
    "8fabc5",
    ""
  ],
  [
    "8fb0a1",
    ""
  ],
  [
    "8fb1a1",
    ""
  ],
  [
    "8fb2a1",
    "",
    4,
    ""
  ],
  [
    "8fb3a1",
    ""
  ],
  [
    "8fb4a1",
    ""
  ],
  [
    "8fb5a1",
    ""
  ],
  [
    "8fb6a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fb7a1",
    "",
    4,
    ""
  ],
  [
    "8fb8a1",
    ""
  ],
  [
    "8fb9a1",
    ""
  ],
  [
    "8fbaa1",
    "",
    4,
    ""
  ],
  [
    "8fbba1",
    ""
  ],
  [
    "8fbca1",
    "",
    4,
    ""
  ],
  [
    "8fbda1",
    "",
    4,
    ""
  ],
  [
    "8fbea1",
    "",
    4,
    ""
  ],
  [
    "8fbfa1",
    ""
  ],
  [
    "8fc0a1",
    ""
  ],
  [
    "8fc1a1",
    ""
  ],
  [
    "8fc2a1",
    ""
  ],
  [
    "8fc3a1",
    "",
    4,
    ""
  ],
  [
    "8fc4a1",
    ""
  ],
  [
    "8fc5a1",
    ""
  ],
  [
    "8fc6a1",
    ""
  ],
  [
    "8fc7a1",
    ""
  ],
  [
    "8fc8a1",
    ""
  ],
  [
    "8fc9a1",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8fcaa1",
    ""
  ],
  [
    "8fcba1",
    ""
  ],
  [
    "8fcca1",
    "",
    9,
    ""
  ],
  [
    "8fcda1",
    "",
    5,
    ""
  ],
  [
    "8fcea1",
    "",
    6,
    ""
  ],
  [
    "8fcfa1",
    ""
  ],
  [
    "8fd0a1",
    ""
  ],
  [
    "8fd1a1",
    ""
  ],
  [
    "8fd2a1",
    "",
    5
  ],
  [
    "8fd3a1",
    ""
  ],
  [
    "8fd4a1",
    "",
    4,
    ""
  ],
  [
    "8fd5a1",
    ""
  ],
  [
    "8fd6a1",
    ""
  ],
  [
    "8fd7a1",
    ""
  ],
  [
    "8fd8a1",
    ""
  ],
  [
    "8fd9a1",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8fdaa1",
    "",
    4,
    ""
  ],
  [
    "8fdba1",
    "",
    6,
    ""
  ],
  [
    "8fdca1",
    "",
    4,
    ""
  ],
  [
    "8fdda1",
    "",
    4,
    ""
  ],
  [
    "8fdea1",
    "",
    4,
    ""
  ],
  [
    "8fdfa1",
    ""
  ],
  [
    "8fe0a1",
    ""
  ],
  [
    "8fe1a1",
    "",
    4,
    ""
  ],
  [
    "8fe2a1",
    ""
  ],
  [
    "8fe3a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fe4a1",
    "",
    4,
    ""
  ],
  [
    "8fe5a1",
    "",
    4,
    ""
  ],
  [
    "8fe6a1",
    ""
  ],
  [
    "8fe7a1",
    ""
  ],
  [
    "8fe8a1",
    "",
    4,
    ""
  ],
  [
    "8fe9a1",
    "",
    4
  ],
  [
    "8feaa1",
    "",
    4,
    ""
  ],
  [
    "8feba1",
    "",
    4,
    ""
  ],
  [
    "8feca1",
    ""
  ],
  [
    "8feda1",
    "",
    4,
    "",
    4,
    ""
  ]
<<<<<<< HEAD
];
const require$$2 = [
=======
], jc = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  [
    "0",
    "\0",
    127,
    ""
  ],
  [
    "8140",
    "",
    5,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "8180",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8240",
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    11
  ],
  [
    "8280",
    "",
    10,
    "",
    4,
    "",
    7,
    "",
    5,
    "",
    8,
    "",
    20,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8340",
    "",
    17,
    "",
    5,
    "",
    10,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "8380",
    "",
    5,
    "",
    13,
    "",
    28,
    "",
    4,
    "",
    4,
    "",
    5
  ],
  [
    "8440",
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "8480",
    "",
    9,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    5,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "8540",
    "",
    9,
    ""
  ],
  [
    "8580",
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "8640",
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8680",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8740",
    "",
    7,
    "",
    11,
    "",
    4,
    "",
    4
  ],
  [
    "8780",
    "",
    7,
    "",
    6,
    "",
    14,
    "",
    10,
    "",
    6,
    "",
    12,
    "",
    8,
    "",
    5,
    "",
    6
  ],
  [
    "8840",
    "",
    9,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8880",
    "",
    4,
    "",
    6,
    "",
    8,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    7
  ],
  [
    "8940",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    16,
    ""
  ],
  [
    "8980",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    17,
    "",
    10,
    "",
    13,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "8a40",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "8a80",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    9,
    "",
    5
  ],
  [
    "8b40",
    "",
    8,
    "",
    17,
    "",
    6,
    "",
    13,
    ""
  ],
  [
    "8b80",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    22,
    "",
    11,
    "",
    25,
    "",
    7,
    "",
    6
  ],
  [
    "8c40",
    "",
    7,
    ""
  ],
  [
    "8c80",
    "",
    8,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    4
  ],
  [
    "8d40",
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    9,
    "",
    4
  ],
  [
    "8d80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    10,
    "",
    12,
    "",
    21,
    ""
  ],
  [
    "8e40",
    "",
    21,
    "",
    12,
    "",
    6,
    "",
    12,
    ""
  ],
  [
    "8e80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    4,
    "",
    6
  ],
  [
    "8f40",
    "",
    5,
    "",
    11,
    "",
    8,
    ""
  ],
  [
    "8f80",
    "",
    6,
    "",
    14,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9040",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9080",
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    18,
    "",
    6
  ],
  [
    "9140",
    "",
    6,
    "",
    6,
    "",
    18,
    "",
    4,
    ""
  ],
  [
    "9180",
    "",
    6,
    "",
    8,
    "",
    9,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    16,
    "",
    13,
    "",
    8,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9280",
    "",
    5,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9340",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9380",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    9,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9440",
    "",
    24,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    8
  ],
  [
    "9480",
    "",
    4,
    "",
    4,
    "",
    14,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "9540",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9580",
    "",
    4,
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    25,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "9640",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9680",
    "",
    7,
    "",
    9,
    "",
    7,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    5
  ],
  [
    "9740",
    "",
    7,
    "",
    8,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9780",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    9,
    "",
    4,
    "",
    11,
    "",
    7,
    "",
    16,
    ""
  ],
  [
    "9840",
    "",
    4,
    "",
    5,
    "",
    9,
    ""
  ],
  [
    "9880",
    "",
    7,
    "",
    5,
    "",
    11,
    "",
    9,
    "",
    9,
    "",
    11,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9940",
    "",
    4,
    "",
    10,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    7,
    "",
    5
  ],
  [
    "9980",
    "",
    114,
    "",
    6
  ],
  [
    "9a40",
    "",
    11,
    "",
    7,
    "",
    13,
    ""
  ],
  [
    "9a80",
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "9b40",
    "",
    4,
    ""
  ],
  [
    "9b80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9c40",
    "",
    7,
    ""
  ],
  [
    "9c80",
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    14,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "9d40",
    "",
    7,
    "",
    4,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "9d80",
    "",
    9,
    "",
    5,
    "",
    6,
    "",
    12,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "9e40",
    "",
    7,
    "",
    32,
    "",
    7,
    "",
    6,
    "",
    6
  ],
  [
    "9e80",
    "",
    9,
    "",
    17,
    "",
    13,
    "",
    11,
    "",
    12,
    "",
    12,
    ""
  ],
  [
    "9f40",
    "",
    6,
    "",
    10,
    "",
    4,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "9f80",
    "",
    13,
    "",
    12,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    8,
    "",
    9,
    "",
    4
  ],
  [
    "a040",
    "",
    9,
    "",
    5,
    "",
    9,
    "",
    11,
    "",
    19
  ],
  [
    "a080",
    "",
    9,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    11,
    "",
    6,
    ""
  ],
  [
    "a1a1",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9
  ],
  [
    "a2b1",
    "",
    19,
    "",
    19,
    "",
    9
  ],
  [
    "a2e5",
    "",
    9
  ],
  [
    "a2f1",
    "",
    11
  ],
  [
    "a3a1",
    "",
    88,
    ""
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a6e0",
    ""
  ],
  [
    "a6ee",
    ""
  ],
  [
    "a6f4",
    ""
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a840",
    "",
    35,
    "",
    6
  ],
  [
    "a880",
    "",
    7,
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a8bd",
    ""
  ],
  [
    "a8c0",
    ""
  ],
  [
    "a8c5",
    "",
    36
  ],
  [
    "a940",
    "",
    8,
    ""
  ],
  [
    "a959",
    ""
  ],
  [
    "a95c",
    ""
  ],
  [
    "a960",
    "",
    9,
    "",
    8
  ],
  [
    "a980",
    "",
    4,
    ""
  ],
  [
    "a996",
    ""
  ],
  [
    "a9a4",
    "",
    75
  ],
  [
    "aa40",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "aa80",
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "ab40",
    "",
    11,
    "",
    4,
    "",
    5,
    "",
    4
  ],
  [
    "ab80",
    "",
    6,
    "",
    4
  ],
  [
    "ac40",
    "",
    10,
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11
  ],
  [
    "ac80",
    "",
    6,
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "ad40",
    "",
    10,
    "",
    7,
    "",
    15,
    "",
    12
  ],
  [
    "ad80",
    "",
    9,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "ae40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "ae80",
    "",
    7,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "af40",
    "",
    4,
    ""
  ],
  [
    "af80",
    ""
  ],
  [
    "b040",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "b080",
    "",
    7,
    "",
    8,
    "",
    9,
    ""
  ],
  [
    "b140",
    "",
    4,
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "b180",
    "",
    4,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "b240",
    "",
    11,
    "",
    5,
    "",
    11,
    "",
    4
  ],
  [
    "b280",
    "",
    12,
    "",
    8,
    "",
    4,
    ""
  ],
  [
    "b340",
    "",
    5,
    ""
  ],
  [
    "b380",
    "",
    11,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "b440",
    "",
    7,
    "",
    9
  ],
  [
    "b480",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "b540",
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "b580",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b640",
    "",
    6,
    "",
    11,
    "",
    10,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "b680",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b740",
    "",
    14,
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    16
  ],
  [
    "b780",
    "",
    6,
    ""
  ],
  [
    "b840",
    "",
    4,
    "",
    10,
    "",
    10,
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "b880",
    "",
    4,
    ""
  ],
  [
    "b940",
    "",
    5,
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "b980",
    "",
    7,
    ""
  ],
  [
    "ba40",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "ba80",
    "",
    4,
    "",
    5,
    "",
    12,
    "",
    5,
    ""
  ],
  [
    "bb40",
    "",
    9,
    "",
    36,
    "",
    5,
    "",
    9
  ],
  [
    "bb80",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "bc40",
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    13,
    "",
    5
  ],
  [
    "bc80",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "bd40",
    "",
    54,
    "",
    7
  ],
  [
    "bd80",
    "",
    32,
    ""
  ],
  [
    "be40",
    "",
    12,
    "",
    6,
    "",
    42
  ],
  [
    "be80",
    "",
    32,
    ""
  ],
  [
    "bf40",
    "",
    62
  ],
  [
    "bf80",
    "",
    4,
    "",
    4,
    "",
    21,
    ""
  ],
  [
    "c040",
    "",
    35,
    "",
    23,
    ""
  ],
  [
    "c080",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "c140",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c180",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c280",
    "",
    13,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c340",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c380",
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "c440",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "c480",
    "",
    7,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c540",
    "",
    14,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c580",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c680",
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "c740",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "c780",
    ""
  ],
  [
    "c840",
    "",
    4,
    "",
    5,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c880",
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "c940",
    "",
    4,
    "",
    7,
    "",
    12,
    ""
  ],
  [
    "c980",
    "",
    4,
    "",
    4,
    "",
    10,
    ""
  ],
  [
    "ca40",
    "",
    8,
    "",
    8,
    "",
    9,
    "",
    4,
    "",
    10
  ],
  [
    "ca80",
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "cb40",
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cb80",
    "",
    5,
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "cc40",
    "",
    4,
    "",
    10,
    "",
    15,
    "",
    13,
    ""
  ],
  [
    "cc80",
    "",
    11,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "cd40",
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "cd80",
    ""
  ],
  [
    "ce40",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "ce80",
    "",
    4,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cf40",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    9
  ],
  [
    "cf80",
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "d040",
    "",
    13,
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "d080",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "d140",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "d180",
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "d240",
    "",
    8,
    "",
    24,
    "",
    5,
    "",
    19,
    ""
  ],
  [
    "d280",
    "",
    26,
    ""
  ],
  [
    "d340",
    "",
    30,
    "",
    6
  ],
  [
    "d380",
    "",
    4,
    "",
    5,
    "",
    21,
    ""
  ],
  [
    "d440",
    "",
    31,
    "",
    8,
    "",
    21
  ],
  [
    "d480",
    "",
    25,
    "",
    6,
    ""
  ],
  [
    "d540",
    "",
    7,
    "",
    7,
    "",
    46
  ],
  [
    "d580",
    "",
    32,
    ""
  ],
  [
    "d640",
    "",
    34,
    "",
    27
  ],
  [
    "d680",
    "",
    30,
    ""
  ],
  [
    "d740",
    "",
    31,
    "",
    4,
    "",
    25
  ],
  [
    "d780",
    "",
    24,
    ""
  ],
  [
    "d840",
    "",
    8,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "d880",
    "",
    6,
    "",
    20,
    ""
  ],
  [
    "d940",
    "",
    62
  ],
  [
    "d980",
    "",
    32,
    ""
  ],
  [
    "da40",
    "",
    14,
    "",
    8,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "da80",
    "",
    12,
    ""
  ],
  [
    "db40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "db80",
    "",
    4,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "dc40",
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    11,
    "",
    6,
    "",
    7
  ],
  [
    "dc80",
    "",
    10,
    "",
    21,
    ""
  ],
  [
    "dd40",
    "",
    62
  ],
  [
    "dd80",
    "",
    32,
    ""
  ],
  [
    "de40",
    "",
    32,
    ""
  ],
  [
    "de80",
    "",
    4,
    ""
  ],
  [
    "df40",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "df80",
    "",
    4,
    ""
  ],
  [
    "e040",
    "",
    19,
    ""
  ],
  [
    "e080",
    "",
    10,
    "",
    6,
    "",
    8,
    ""
  ],
  [
    "e140",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "e180",
    "",
    10,
    "",
    9,
    "",
    8,
    ""
  ],
  [
    "e240",
    "",
    62
  ],
  [
    "e280",
    "",
    32,
    "",
    5,
    ""
  ],
  [
    "e340",
    "",
    45,
    "",
    16
  ],
  [
    "e380",
    "",
    7,
    "",
    24,
    ""
  ],
  [
    "e440",
    "",
    5,
    "",
    24,
    "",
    31
  ],
  [
    "e480",
    "",
    32,
    ""
  ],
  [
    "e540",
    "",
    51,
    "",
    10
  ],
  [
    "e580",
    "",
    31,
    ""
  ],
  [
    "e640",
    "",
    34,
    "",
    27
  ],
  [
    "e680",
    "",
    29,
    ""
  ],
  [
    "e740",
    "",
    7,
    "",
    54
  ],
  [
    "e780",
    "",
    32,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "e840",
    "",
    14,
    "",
    43,
    ""
  ],
  [
    "e880",
    "",
    20,
    ""
  ],
  [
    "e940",
    "",
    7,
    "",
    42
  ],
  [
    "e980",
    "",
    32,
    ""
  ],
  [
    "ea40",
    "",
    27,
    "",
    6,
    ""
  ],
  [
    "ea80",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "eb40",
    "",
    9,
    "",
    7,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "eb80",
    "",
    4,
    ""
  ],
  [
    "ec40",
    "",
    8,
    "",
    4,
    "",
    18,
    "",
    7
  ],
  [
    "ec80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ed40",
    "",
    6,
    "",
    46
  ],
  [
    "ed80",
    "",
    4,
    "",
    23,
    ""
  ],
  [
    "ee40",
    "",
    62
  ],
  [
    "ee80",
    "",
    32,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "ef40",
    "",
    5,
    "",
    37,
    "",
    4
  ],
  [
    "ef80",
    "",
    30,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "f040",
    "",
    4,
    "",
    28,
    "",
    26
  ],
  [
    "f080",
    "",
    9,
    "",
    12,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "f140",
    "",
    10,
    "",
    47
  ],
  [
    "f180",
    "",
    32,
    ""
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    32,
    ""
  ],
  [
    "f340",
    "",
    17,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "f380",
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "f440",
    "",
    5,
    "",
    10,
    "",
    10,
    "",
    7,
    "",
    5
  ],
  [
    "f480",
    "",
    32,
    ""
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    32,
    ""
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    32,
    "",
    5,
    "",
    5,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    32
  ],
  [
    "f940",
    "",
    62
  ],
  [
    "f980",
    "",
    32
  ],
  [
    "fa40",
    "",
    62
  ],
  [
    "fa80",
    "",
    32
  ],
  [
    "fb40",
    "",
    27,
    "",
    9,
    ""
  ],
  [
    "fb80",
    "",
    5,
    "",
    8,
    "",
    5,
    ""
  ],
  [
    "fc40",
    "",
    8,
    "",
    4,
    "",
    8,
    "",
    6
  ],
  [
    "fc80",
    "",
    4,
    "",
    5,
    "",
    8,
    ""
  ],
  [
    "fd40",
    "",
    4,
    "",
    4,
    "",
    10,
    "",
    38
  ],
  [
    "fd80",
    "",
    5,
    "",
    11,
    "",
    4,
    ""
  ],
  [
    "fe40",
    ""
  ]
<<<<<<< HEAD
];
const require$$3 = [
=======
], Rd = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ],
  [
    "8135f437",
    ""
  ]
<<<<<<< HEAD
];
const uChars = [
=======
], J6 = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
<<<<<<< HEAD
];
const gbChars = [
=======
], Z6 = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
<<<<<<< HEAD
];
const require$$4 = {
  uChars,
  gbChars
};
const require$$5 = [
=======
], Q6 = {
  uChars: J6,
  gbChars: Z6
}, e2 = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8161",
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "8181",
    "",
    18,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8241",
    "",
    7,
    "",
    5
  ],
  [
    "8261",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8281",
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    17,
    "",
    7,
    "",
    6,
    "",
    7,
    "",
    18
  ],
  [
    "8341",
    "",
    5,
    "",
    5,
    "",
    7
  ],
  [
    "8361",
    "",
    18,
    ""
  ],
  [
    "8381",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    46,
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8441",
    "",
    5,
    "",
    8
  ],
  [
    "8461",
    "",
    18
  ],
  [
    "8481",
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    18,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8541",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4
  ],
  [
    "8561",
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8581",
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    29,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8641",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8661",
    "",
    6,
    "",
    10
  ],
  [
    "8681",
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    22,
    "",
    4,
    ""
  ],
  [
    "8741",
    "",
    9,
    "",
    15
  ],
  [
    "8761",
    "",
    18,
    ""
  ],
  [
    "8781",
    "",
    5,
    "",
    7,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    4
  ],
  [
    "8841",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "8861",
    "",
    4,
    ""
  ],
  [
    "8881",
    "",
    15,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    54,
    ""
  ],
  [
    "8941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8961",
    "",
    10,
    "",
    5,
    ""
  ],
  [
    "8981",
    "",
    21,
    "",
    18,
    "",
    18,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    15
  ],
  [
    "8a41",
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "8a61",
    "",
    4,
    "",
    18,
    ""
  ],
  [
    "8a81",
    "",
    4,
    "",
    19,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8b41",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8b61",
    "",
    6,
    "",
    8
  ],
  [
    "8b81",
    "",
    52,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    18
  ],
  [
    "8c41",
    "",
    15,
    "",
    4
  ],
  [
    "8c61",
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "8c81",
    "",
    12,
    "",
    26,
    "",
    50,
    "",
    5,
    "",
    16
  ],
  [
    "8d41",
    "",
    16,
    "",
    8
  ],
  [
    "8d61",
    "",
    17,
    ""
  ],
  [
    "8d81",
    "",
    4,
    "",
    33,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    9,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8e41",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8e61",
    "",
    4,
    "",
    19
  ],
  [
    "8e81",
    "",
    13,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    11,
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "8f41",
    "",
    7,
    "",
    17
  ],
  [
    "8f61",
    "",
    7,
    "",
    6,
    "",
    4
  ],
  [
    "8f81",
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    5
  ],
  [
    "9041",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9061",
    "",
    5,
    "",
    15
  ],
  [
    "9081",
    "",
    12,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    11,
    "",
    33,
    ""
  ],
  [
    "9141",
    "",
    6,
    "",
    5
  ],
  [
    "9161",
    "",
    9,
    "",
    5
  ],
  [
    "9181",
    "",
    20,
    "",
    4,
    "",
    5,
    "",
    14,
    "",
    33,
    "",
    7,
    "",
    5,
    "",
    6
  ],
  [
    "9241",
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "9261",
    "",
    7,
    "",
    7,
    "",
    4
  ],
  [
    "9281",
    "",
    21,
    "",
    18,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    35,
    ""
  ],
  [
    "9341",
    "",
    4,
    ""
  ],
  [
    "9361",
    "",
    6,
    "",
    8
  ],
  [
    "9381",
    "",
    37,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    22,
    ""
  ],
  [
    "9441",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "9461",
    "",
    5,
    "",
    6,
    "",
    12
  ],
  [
    "9481",
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    24
  ],
  [
    "9541",
    "",
    11,
    "",
    5,
    ""
  ],
  [
    "9561",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9581",
    "",
    6,
    "",
    35,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    13,
    "",
    14
  ],
  [
    "9641",
    "",
    23,
    ""
  ],
  [
    "9661",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "9681",
    "",
    10,
    "",
    5,
    "",
    13,
    "",
    33,
    "",
    6,
    "",
    44
  ],
  [
    "9741",
    "",
    16,
    "",
    8
  ],
  [
    "9761",
    "",
    17,
    "",
    7
  ],
  [
    "9781",
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    89,
    ""
  ],
  [
    "9841",
    "",
    16,
    "",
    5,
    ""
  ],
  [
    "9861",
    "",
    6,
    "",
    15
  ],
  [
    "9881",
    "",
    21,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9961",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9981",
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9a41",
    "",
    16
  ],
  [
    "9a61",
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "9a81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    33,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9b41",
    "",
    6,
    "",
    8
  ],
  [
    "9b61",
    "",
    17,
    "",
    7
  ],
  [
    "9b81",
    "",
    25,
    "",
    4,
    "",
    5,
    "",
    50,
    "",
    22,
    ""
  ],
  [
    "9c41",
    "",
    4,
    "",
    5,
    "",
    5
  ],
  [
    "9c61",
    "",
    8,
    "",
    6,
    "",
    9
  ],
  [
    "9c81",
    "",
    8,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    12
  ],
  [
    "9d41",
    "",
    13,
    "",
    8
  ],
  [
    "9d61",
    "",
    25
  ],
  [
    "9d81",
    "",
    8,
    "",
    5,
    "",
    9,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9e41",
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9e61",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9e81",
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9f41",
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9f61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9f81",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "a041",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "a061",
    "",
    5,
    "",
    13
  ],
  [
    "a081",
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    "",
    4,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "a141",
    "",
    18,
    ""
  ],
  [
    "a161",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a181",
    "",
    14,
    "",
    5,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "a241",
    "",
    5,
    "",
    18
  ],
  [
    "a261",
    "",
    6,
    "",
    18
  ],
  [
    "a281",
    "",
    7,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "a341",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "a361",
    "",
    6,
    "",
    16
  ],
  [
    "a381",
    "",
    16,
    "",
    4,
    "",
    58,
    "",
    32,
    ""
  ],
  [
    "a441",
    "",
    5,
    ""
  ],
  [
    "a461",
    "",
    5,
    "",
    12
  ],
  [
    "a481",
    "",
    28,
    "",
    93
  ],
  [
    "a541",
    "",
    4,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a561",
    "",
    17,
    "",
    5,
    ""
  ],
  [
    "a581",
    "",
    16,
    "",
    14,
    "",
    9
  ],
  [
    "a5b0",
    "",
    9
  ],
  [
    "a5c1",
    "",
    16,
    "",
    6
  ],
  [
    "a5e1",
    "",
    16,
    "",
    6
  ],
  [
    "a641",
    "",
    19,
    ""
  ],
  [
    "a661",
    "",
    5,
    "",
    5,
    "",
    6
  ],
  [
    "a681",
    "",
    6,
    "",
    18,
    "",
    7
  ],
  [
    "a741",
    "",
    4,
    "",
    6,
    "",
    7
  ],
  [
    "a761",
    "",
    22,
    ""
  ],
  [
    "a781",
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    9,
    "",
    9,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "a841",
    "",
    10,
    "",
    14
  ],
  [
    "a861",
    "",
    18,
    "",
    6
  ],
  [
    "a881",
    "",
    19,
    "",
    11,
    ""
  ],
  [
    "a8a6",
    ""
  ],
  [
    "a8a8",
    ""
  ],
  [
    "a8b1",
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "a941",
    "",
    14,
    "",
    10
  ],
  [
    "a961",
    "",
    18
  ],
  [
    "a981",
    "",
    14,
    "",
    6,
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "aa41",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "aa61",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "aa81",
    "",
    29,
    "",
    82
  ],
  [
    "ab41",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "ab61",
    "",
    6,
    "",
    5,
    "",
    5
  ],
  [
    "ab81",
    "",
    8,
    "",
    6,
    "",
    12,
    "",
    85
  ],
  [
    "ac41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ac61",
    "",
    11,
    "",
    4
  ],
  [
    "ac81",
    "",
    28,
    "",
    5,
    "",
    25
  ],
  [
    "acd1",
    "",
    5,
    "",
    25
  ],
  [
    "ad41",
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "ad61",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "ad81",
    "",
    5,
    "",
    18,
    ""
  ],
  [
    "ae41",
    "",
    5,
    "",
    16
  ],
  [
    "ae61",
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "ae81",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "af41",
    "",
    19
  ],
  [
    "af61",
    "",
    13,
    "",
    5,
    ""
  ],
  [
    "af81",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b041",
    "",
    5,
    "",
    5,
    "",
    12
  ],
  [
    "b061",
    "",
    5,
    "",
    19
  ],
  [
    "b081",
    "",
    13,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "b141",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b161",
    "",
    6,
    "",
    5,
    "",
    11
  ],
  [
    "b181",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b241",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b261",
    "",
    18,
    "",
    5,
    ""
  ],
  [
    "b281",
    "",
    5,
    "",
    18,
    "",
    6,
    ""
  ],
  [
    "b341",
    "",
    19,
    ""
  ],
  [
    "b361",
    "",
    5,
    "",
    5,
    "",
    5
  ],
  [
    "b381",
    "",
    5,
    "",
    5,
    "",
    19,
    "",
    4,
    ""
  ],
  [
    "b441",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "b461",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "b481",
    "",
    6,
    "",
    18,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "b541",
    "",
    14,
    "",
    5
  ],
  [
    "b561",
    "",
    5,
    "",
    5,
    "",
    4
  ],
  [
    "b581",
    "",
    6,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "b641",
    "",
    7,
    "",
    17
  ],
  [
    "b661",
    "",
    15,
    ""
  ],
  [
    "b681",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b741",
    "",
    13,
    "",
    6,
    ""
  ],
  [
    "b761",
    "",
    20,
    ""
  ],
  [
    "b781",
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "b841",
    "",
    7,
    "",
    17
  ],
  [
    "b861",
    "",
    8,
    "",
    13
  ],
  [
    "b881",
    "",
    5,
    "",
    24,
    "",
    4,
    ""
  ],
  [
    "b941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b961",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b981",
    "",
    22,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ba41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ba61",
    "",
    5,
    "",
    4,
    "",
    5
  ],
  [
    "ba81",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "bb41",
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bb61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "bb81",
    "",
    31,
    ""
  ],
  [
    "bc41",
    "",
    17,
    ""
  ],
  [
    "bc61",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "bc81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bd41",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "bd61",
    "",
    5,
    "",
    13
  ],
  [
    "bd81",
    "",
    5,
    "",
    25,
    ""
  ],
  [
    "be41",
    "",
    7,
    "",
    14
  ],
  [
    "be61",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "be81",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "bf41",
    "",
    10,
    "",
    14
  ],
  [
    "bf61",
    "",
    18,
    ""
  ],
  [
    "bf81",
    "",
    5,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c041",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "c061",
    "",
    25
  ],
  [
    "c081",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c141",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c161",
    "",
    19,
    ""
  ],
  [
    "c181",
    "",
    31,
    ""
  ],
  [
    "c241",
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c261",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c281",
    "",
    5,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "c341",
    "",
    4
  ],
  [
    "c361",
    "",
    4,
    "",
    5,
    "",
    11
  ],
  [
    "c381",
    "",
    5,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "c441",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c461",
    "",
    5,
    "",
    4
  ],
  [
    "c481",
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c541",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c561",
    "",
    6,
    "",
    5,
    "",
    4
  ],
  [
    "c581",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c641",
    "",
    6,
    "",
    5
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "d2a1",
    "",
    4,
    "",
    5,
    "",
    10,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fda1",
    ""
  ]
<<<<<<< HEAD
];
const require$$6 = [
=======
], $d = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    ""
  ],
  [
    "a1a1",
    "",
    4,
    ""
  ],
  [
    "a240",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9,
    "",
    9,
    "",
    8,
    "",
    25,
    "",
    21
  ],
  [
    "a340",
    "",
    16,
    "",
    6,
    "",
    16,
    "",
    6,
    "",
    10
  ],
  [
    "a3a1",
    "",
    25,
    ""
  ],
  [
    "a3e1",
    ""
  ],
  [
    "a440",
    ""
  ],
  [
    "a4a1",
    ""
  ],
  [
    "a540",
    ""
  ],
  [
    "a5a1",
    ""
  ],
  [
    "a640",
    ""
  ],
  [
    "a6a1",
    ""
  ],
  [
    "a740",
    ""
  ],
  [
    "a7a1",
    ""
  ],
  [
    "a840",
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a940",
    ""
  ],
  [
    "a9a1",
    ""
  ],
  [
    "aa40",
    ""
  ],
  [
    "aaa1",
    ""
  ],
  [
    "ab40",
    ""
  ],
  [
    "aba1",
    ""
  ],
  [
    "ac40",
    ""
  ],
  [
    "aca1",
    ""
  ],
  [
    "ad40",
    ""
  ],
  [
    "ada1",
    ""
  ],
  [
    "ae40",
    ""
  ],
  [
    "aea1",
    ""
  ],
  [
    "af40",
    ""
  ],
  [
    "afa1",
    ""
  ],
  [
    "b040",
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b140",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b240",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b340",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b440",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b540",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b640",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b740",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b840",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b940",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "ba40",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bb40",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bc40",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bd40",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "be40",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bf40",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c040",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c140",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c240",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c340",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c440",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c540",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c940",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "ca40",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cb40",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cc40",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cd40",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "ce40",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cf40",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d040",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d140",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d240",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d340",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d440",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d540",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d640",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d740",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d840",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d940",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "da40",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "db40",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dc40",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dd40",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "de40",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "df40",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eb40",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "ec40",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "ef40",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f040",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f140",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f240",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f340",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f440",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f540",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f640",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f740",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f840",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f940",
    ""
  ],
  [
    "f9a1",
    ""
  ]
<<<<<<< HEAD
];
const require$$7 = [
=======
], t2 = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
<<<<<<< HEAD
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
=======
var Mc, Od;
function n2() {
  return Od || (Od = 1, Mc = {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
<<<<<<< HEAD
        return require$$0;
=======
        return X6;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
<<<<<<< HEAD
        return require$$1;
=======
        return K6;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
<<<<<<< HEAD
        return require$$2;
=======
        return jc;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
<<<<<<< HEAD
        return require$$2.concat(require$$3);
=======
        return jc.concat(Rd);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
<<<<<<< HEAD
        return require$$2.concat(require$$3);
      },
      gb18030: function() {
        return require$$4;
=======
        return jc.concat(Rd);
      },
      gb18030: function() {
        return Q6;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
<<<<<<< HEAD
        return require$$5;
=======
        return e2;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
<<<<<<< HEAD
        return require$$6;
=======
        return $d;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
<<<<<<< HEAD
        return require$$6.concat(require$$7);
=======
        return $d.concat(t2);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      },
      encodeSkipVals: [
        // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
        // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
        // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
<<<<<<< HEAD
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function(exports) {
    var modules = [
      requireInternal(),
      requireUtf32(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports[enc] = module[enc];
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = safer_1.Buffer;
  streams = function(stream_module) {
    var Transform2 = stream_module.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform2.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform2.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform2.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform2.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
  return streams;
}
(function(module) {
  var Buffer2 = safer_1.Buffer;
  var bomHandling$12 = bomHandling, iconv2 = module.exports;
  iconv2.encodings = null;
  iconv2.defaultCharUnicode = "";
  iconv2.defaultCharSingleByte = "?";
  iconv2.encode = function encode2(str2, encoding, options) {
    str2 = "" + (str2 || "");
    var encoder = iconv2.getEncoder(encoding, options);
    var res = encoder.write(str2);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv2.decode = function decode(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!iconv2.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv2.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv2.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv2.encodingExists = function encodingExists(enc) {
    try {
      iconv2.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  iconv2.toEncoding = iconv2.encode;
  iconv2.fromEncoding = iconv2.decode;
  iconv2._codecDataCache = {};
  iconv2.getCodec = function getCodec(encoding) {
    if (!iconv2.encodings)
      iconv2.encodings = requireEncodings();
    var enc = iconv2._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv2._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv2.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key2 in codecDef)
            codecOptions[key2] = codecDef[key2];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv2);
          iconv2._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv2._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv2.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv2.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM)
      encoder = new bomHandling$12.PrependBOM(encoder, options);
    return encoder;
  };
  iconv2.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv2.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false))
      decoder = new bomHandling$12.StripBOM(decoder, options);
    return decoder;
  };
  iconv2.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
    if (iconv2.supportsStreams)
      return;
    var streams2 = requireStreams()(stream_module2);
    iconv2.IconvLiteEncoderStream = streams2.IconvLiteEncoderStream;
    iconv2.IconvLiteDecoderStream = streams2.IconvLiteDecoderStream;
    iconv2.encodeStream = function encodeStream(encoding, options) {
      return new iconv2.IconvLiteEncoderStream(iconv2.getEncoder(encoding, options), options);
    };
    iconv2.decodeStream = function decodeStream(encoding, options) {
      return new iconv2.IconvLiteDecoderStream(iconv2.getDecoder(encoding, options), options);
    };
    iconv2.supportsStreams = true;
  };
  var stream_module;
  try {
    stream_module = require("stream");
  } catch (e) {
  }
  if (stream_module && stream_module.Transform) {
    iconv2.enableStreamingAPI(stream_module);
  } else {
    iconv2.encodeStream = iconv2.decodeStream = function() {
      throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
    };
  }
})(lib$1);
var libExports = lib$1.exports;
let minidev;
const initMinidev = async () => {
  if (!minidev) {
    const require2 = createRequire(import.meta.url);
    minidev = require2("minidev");
  }
  return minidev;
};
class DevTools {
  constructor(win2) {
    __publicField(this, "windown");
    __publicField(this, "app_dir", require$$1$4.join(app.getPath("documents"), "code-sync"));
    __publicField(this, "configPath", require$$1$4.join(this.app_dir, "config.json"));
    __publicField(this, "runConfig");
    // 
    __publicField(this, "reportConfig", () => {
      this.windown.webContents.send("init", this.runConfig);
    });
    // 
    __publicField(this, "downloadFile", async (url2, dest) => {
      const writer = fs$w.createWriteStream(dest);
=======
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  }), Mc;
}
var Id;
function r2() {
  return Id || (Id = 1, function(e) {
    for (var t = [
      M6(),
      q6(),
      z6(),
      H6(),
      W6(),
      G6(),
      V6(),
      Y6(),
      n2()
    ], n = 0; n < t.length; n++) {
      var r = t[n];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
  }(Pc)), Pc;
}
var qc, Dd;
function i2() {
  if (Dd) return qc;
  Dd = 1;
  var e = Ge.Buffer;
  return qc = function(t) {
    var n = t.Transform;
    function r(a, s) {
      this.conv = a, s = s || {}, s.decodeStrings = !1, n.call(this, s);
    }
    r.prototype = Object.create(n.prototype, {
      constructor: { value: r }
    }), r.prototype._transform = function(a, s, c) {
      if (typeof a != "string")
        return c(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var o = this.conv.write(a);
        o && o.length && this.push(o), c();
      } catch (u) {
        c(u);
      }
    }, r.prototype._flush = function(a) {
      try {
        var s = this.conv.end();
        s && s.length && this.push(s), a();
      } catch (c) {
        a(c);
      }
    }, r.prototype.collect = function(a) {
      var s = [];
      return this.on("error", a), this.on("data", function(c) {
        s.push(c);
      }), this.on("end", function() {
        a(null, e.concat(s));
      }), this;
    };
    function i(a, s) {
      this.conv = a, s = s || {}, s.encoding = this.encoding = "utf8", n.call(this, s);
    }
    return i.prototype = Object.create(n.prototype, {
      constructor: { value: i }
    }), i.prototype._transform = function(a, s, c) {
      if (!e.isBuffer(a) && !(a instanceof Uint8Array))
        return c(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var o = this.conv.write(a);
        o && o.length && this.push(o, this.encoding), c();
      } catch (u) {
        c(u);
      }
    }, i.prototype._flush = function(a) {
      try {
        var s = this.conv.end();
        s && s.length && this.push(s, this.encoding), a();
      } catch (c) {
        a(c);
      }
    }, i.prototype.collect = function(a) {
      var s = "";
      return this.on("error", a), this.on("data", function(c) {
        s += c;
      }), this.on("end", function() {
        a(null, s);
      }), this;
    }, {
      IconvLiteEncoderStream: r,
      IconvLiteDecoderStream: i
    };
  }, qc;
}
(function(e) {
  var t = Ge.Buffer, n = Lu, r = e.exports;
  r.encodings = null, r.defaultCharUnicode = "", r.defaultCharSingleByte = "?", r.encode = function(s, c, o) {
    s = "" + (s || "");
    var u = r.getEncoder(c, o), l = u.write(s), p = u.end();
    return p && p.length > 0 ? t.concat([l, p]) : l;
  }, r.decode = function(s, c, o) {
    typeof s == "string" && (r.skipDecodeWarning || (console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding"), r.skipDecodeWarning = !0), s = t.from("" + (s || ""), "binary"));
    var u = r.getDecoder(c, o), l = u.write(s), p = u.end();
    return p ? l + p : l;
  }, r.encodingExists = function(s) {
    try {
      return r.getCodec(s), !0;
    } catch {
      return !1;
    }
  }, r.toEncoding = r.encode, r.fromEncoding = r.decode, r._codecDataCache = {}, r.getCodec = function(s) {
    r.encodings || (r.encodings = r2());
    for (var c = r._canonicalizeEncoding(s), o = {}; ; ) {
      var u = r._codecDataCache[c];
      if (u)
        return u;
      var l = r.encodings[c];
      switch (typeof l) {
        case "string":
          c = l;
          break;
        case "object":
          for (var p in l)
            o[p] = l[p];
          o.encodingName || (o.encodingName = c), c = l.type;
          break;
        case "function":
          return o.encodingName || (o.encodingName = c), u = new l(o, r), r._codecDataCache[o.encodingName] = u, u;
        default:
          throw new Error("Encoding not recognized: '" + s + "' (searched as: '" + c + "')");
      }
    }
  }, r._canonicalizeEncoding = function(a) {
    return ("" + a).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  }, r.getEncoder = function(s, c) {
    var o = r.getCodec(s), u = new o.encoder(c, o);
    return o.bomAware && c && c.addBOM && (u = new n.PrependBOM(u, c)), u;
  }, r.getDecoder = function(s, c) {
    var o = r.getCodec(s), u = new o.decoder(c, o);
    return o.bomAware && !(c && c.stripBOM === !1) && (u = new n.StripBOM(u, c)), u;
  }, r.enableStreamingAPI = function(s) {
    if (!r.supportsStreams) {
      var c = i2()(s);
      r.IconvLiteEncoderStream = c.IconvLiteEncoderStream, r.IconvLiteDecoderStream = c.IconvLiteDecoderStream, r.encodeStream = function(u, l) {
        return new r.IconvLiteEncoderStream(r.getEncoder(u, l), l);
      }, r.decodeStream = function(u, l) {
        return new r.IconvLiteDecoderStream(r.getDecoder(u, l), l);
      }, r.supportsStreams = !0;
    }
  };
  var i;
  try {
    i = require("stream");
  } catch {
  }
  i && i.Transform ? r.enableStreamingAPI(i) : r.encodeStream = r.decodeStream = function() {
    throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
  };
})(W1);
var a2 = W1.exports;
let zc;
const s2 = async () => (zc || (zc = Tm(import.meta.url)("minidev")), zc);
class V1 {
  constructor(t) {
    be(this, "windown");
    be(this, "app_dir", ne.join(cn.getPath("documents"), "code-sync"));
    be(this, "configPath", ne.join(this.app_dir, "config.json"));
    be(this, "runConfig");
    // 
    be(this, "reportConfig", () => {
      this.windown.webContents.send("init", this.runConfig);
    });
    // 
    be(this, "downloadFile", async (t, n) => {
      const r = se.createWriteStream(n);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      try {
        this.sendLog(" .......");
        const download = await axios({
          method: "get",
          url: url2,
          responseType: "stream",
          timeout: 12e3
<<<<<<< HEAD
        });
        download.data.pipe(writer);
        return await new Promise((resolve, reject) => {
          writer.on("finish", async () => {
            this.sendLog(", ");
            resolve(true);
          });
          writer.on("error", reject);
        });
      } catch (error2) {
        await writer.close();
        this.sendLog(`  :${error2.message}...`, "error");
        fs$w.unlinkSync(dest);
        return false;
      }
    });
    // 
    __publicField(this, "unzipFile", async (filePath, dest) => {
      this.sendLog(" ");
      try {
        await compressing.tgz.uncompress(filePath, dest, { overwrite: true });
        const guns = ["MG3", "AWM", "AMR", "M200", "GRZRA", "AUG", "P90"];
        const gun = guns[Math.floor(Math.random() * guns.length)];
        this.sendLog(` ${gun}, `);
        fs$w.unlinkSync(filePath);
        return true;
      } catch (err) {
        this.sendLog(`: ${err.message}`, "error");
        fs$w.unlinkSync(filePath);
        return false;
      }
    });
    // 
    __publicField(this, "getDefaultDevToolPath", () => {
      const platform2 = process.platform;
      const devToolPaths = {
=======
        })).data.pipe(r), await new Promise((a, s) => {
          r.on("finish", async () => {
            this.sendLog(", "), a(!0);
          }), r.on("error", s);
        });
      } catch (i) {
        return await r.close(), this.sendLog(`  :${i.message}...`, "error"), se.unlinkSync(n), !1;
      }
    });
    // 
    be(this, "unzipFile", async (t, n) => {
      this.sendLog(" ");
      try {
        await qi.tgz.uncompress(t, n, { overwrite: !0 });
        const r = ["MG3", "AWM", "AMR", "M200", "GRZRA", "AUG", "P90"], i = r[Math.floor(Math.random() * r.length)];
        return this.sendLog(` ${i}, `), se.unlinkSync(t), !0;
      } catch (r) {
        return this.sendLog(`: ${r.message}`, "error"), se.unlinkSync(t), !1;
      }
    });
    // 
    be(this, "getDefaultDevToolPath", () => {
      const t = process.platform;
      return {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        darwin: {
          wechat: "/Applications/wechatwebdevtools.app/Contents/MacOS/cli",
          alipay: "/Applications/.app"
        },
        win32: {
          wechat: "C:\\Program Files (x86)\\Tencent\\web\\cli.bat",
          alipay: "C:\\Program Files\\Program Files\\"
        }
      };
      return devToolPaths[platform2];
    });
    // 
<<<<<<< HEAD
    __publicField(this, "readConfig", () => {
      const params = this.getDefaultDevToolPath();
      const base_config = { proxy_url: "https://gh-proxy.com", ...params };
      if (fs$w.existsSync(this.configPath)) {
        const config = fs$w.readFileSync(this.configPath, "utf8");
        const json2 = JSON.parse(config);
        this.runConfig = { ...base_config, ...json2 };
      } else {
        this.runConfig = base_config;
      }
      this.writeConfig(this.runConfig);
      return this.runConfig;
    });
    // 
    __publicField(this, "writeConfig", (data) => {
      fs$w.writeFileSync(this.configPath, JSON.stringify(data, null, 4), "utf8");
      this.sendLog("");
      this.reportConfig();
    });
    // 
    __publicField(this, "startAlipayDevTool", async (projectPath) => {
      try {
        const cmd = this.runConfig.alipay;
        if (!fs$w.existsSync(cmd)) {
          return this.sendLog("", "error");
        }
        const { minidev: minidev2 } = await initMinidev();
        console.log(minidev2, 144);
        const normalizedProjectPath = require$$1$4.normalize(require$$1$4.resolve(projectPath));
        const result = await minidev2.startIde({
          project: normalizedProjectPath,
          appPath: cmd
=======
    be(this, "readConfig", () => {
      const n = { proxy_url: "https://gh-proxy.com", ...this.getDefaultDevToolPath() };
      if (se.existsSync(this.configPath)) {
        const r = se.readFileSync(this.configPath, "utf8"), i = JSON.parse(r);
        this.runConfig = { ...n, ...i };
      } else
        this.runConfig = n;
      return this.writeConfig(this.runConfig), this.runConfig;
    });
    // 
    be(this, "writeConfig", (t) => {
      se.writeFileSync(this.configPath, JSON.stringify(t, null, 4), "utf8"), this.sendLog(""), this.reportConfig();
    });
    // 
    be(this, "startAlipayDevTool", async (t) => {
      try {
        const n = this.runConfig.alipay;
        if (!se.existsSync(n))
          return this.sendLog("", "error");
        const { minidev: r } = await s2();
        console.log(r, 144);
        const i = ne.normalize(ne.resolve(t)), a = await r.startIde({
          project: i,
          appPath: n
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        });
        this.sendLog(``);
      } catch (error2) {
        this.sendLog(`: ${error2.message}`, "error");
      }
    });
    // 
<<<<<<< HEAD
    __publicField(this, "startWeChatDevTool", (projectPath) => {
      var _a, _b;
      const cmd = this.runConfig.wechat;
      if (!fs$w.existsSync(cmd)) {
        return this.sendLog("", "error");
      }
      const normalizedProjectPath = require$$1$4.normalize(require$$1$4.resolve(projectPath));
      const isWindows2 = process.platform === "win32";
      const quotedCmd = isWindows2 ? `"${cmd}"` : cmd;
      const quotedProjectPath = isWindows2 ? `"${normalizedProjectPath}"` : normalizedProjectPath;
      const fullCommand = `${quotedCmd} open --project ${quotedProjectPath}`;
      const commandToRun = isWindows2 ? "cmd" : "sh";
      const spawnArgs = isWindows2 ? ["/c", `chcp 65001 && ${fullCommand}`] : ["-c", fullCommand];
      const child = spawn(commandToRun, spawnArgs, {
        shell: true,
        timeout: 1e4,
        // 
        env: {
          ...process.env,
          PATH: process.env.PATH
        },
        // 
        cwd: process.cwd()
      });
      (_a = child.stdout) == null ? void 0 : _a.on("data", (data) => {
        const output = this.decodeWindowsOutput(data);
        const cleanOutput = this.cleanAnsiCodes(output);
        if (cleanOutput) {
          this.sendLog(cleanOutput);
        }
        if (output.includes("Enable IDE Service")) {
          setTimeout(() => {
            var _a2;
            (_a2 = child.stdin) == null ? void 0 : _a2.write("y\n");
          }, 100);
        }
      });
      (_b = child.stderr) == null ? void 0 : _b.on("data", (data) => {
        const error2 = this.decodeWindowsOutput(data);
        const cleanError = this.cleanAnsiCodes(error2);
        if (cleanError) {
          this.sendLog(cleanError, "error");
        }
      });
      child.on("close", (code, signal) => {
        if (code === 0) {
          this.sendLog("");
        } else if (code === null) ;
        else {
          this.sendLog(`: ${code}`, "error");
        }
      });
      child.on("error", (error2) => {
        if (error2.code === "TIMEOUT") {
          this.sendLog("", "error");
        } else {
          this.sendLog(`: ${error2.message}`, "error");
        }
      });
    });
    //  -  ( shell)
    __publicField(this, "startWeChatDevToolDirect", (projectPath) => {
      var _a, _b;
      const cmd = this.runConfig.wechat;
      if (!fs$w.existsSync(cmd)) {
        return this.sendLog("", "error");
      }
      const normalizedProjectPath = require$$1$4.normalize(require$$1$4.resolve(projectPath));
      this.sendLog(` : ${cmd} open --project ${normalizedProjectPath}`);
      const child = spawn(cmd, ["open", "--project", normalizedProjectPath], {
        shell: false,
        timeout: 1e4,
        env: {
          ...process.env,
          PATH: process.env.PATH
        },
        cwd: process.cwd()
      });
      (_a = child.stdout) == null ? void 0 : _a.on("data", (data) => {
        const output = this.decodeWindowsOutput(data);
        const cleanOutput = this.cleanAnsiCodes(output);
        if (cleanOutput) {
          this.sendLog(cleanOutput);
        }
        if (output.includes("Enable IDE Service")) {
          setTimeout(() => {
            var _a2;
            (_a2 = child.stdin) == null ? void 0 : _a2.write("y\n");
          }, 100);
        }
      });
      (_b = child.stderr) == null ? void 0 : _b.on("data", (data) => {
        const error2 = this.decodeWindowsOutput(data);
        const cleanError = this.cleanAnsiCodes(error2);
        if (cleanError) {
          this.sendLog(cleanError, "error");
        }
      });
      child.on("close", (code, signal) => {
        if (code === 0) {
          this.sendLog("");
        } else if (code === null) {
          this.sendLog("");
        } else {
          this.sendLog(`: ${code}`, "error");
        }
      });
      child.on("error", (error2) => {
        if (error2.code === "TIMEOUT") {
          this.sendLog("", "error");
        } else if (error2.code === "ENOENT") {
          this.sendLog("", "error");
        } else {
          this.sendLog(`: ${error2.message}`, "error");
        }
      });
    });
    // 
    __publicField(this, "startDevTool", (type2, projectPath) => {
      const basePath = require$$1$4.dirname(projectPath);
      const projectPathFull = require$$1$4.join(basePath);
      if (!fs$w.existsSync(projectPathFull)) {
        return this.sendLog(`: ${projectPathFull}`, "error");
      }
      if (type2 == "wechat") {
        if (process.platform === "darwin") {
          this.startWeChatDevToolDirect(projectPathFull);
        } else {
          this.startWeChatDevTool(projectPathFull);
        }
=======
    be(this, "startWeChatDevTool", (t) => {
      var p, f;
      const n = this.runConfig.wechat;
      if (!se.existsSync(n))
        return this.sendLog("", "error");
      const r = ne.normalize(ne.resolve(t)), i = process.platform === "win32", a = `"${n}"`, s = `"${r}"`, c = `${a} open --project ${s}`, o = i ? "cmd" : "sh", u = i ? ["/c", `chcp 65001 && ${c}`] : ["-c", c], l = Pp(o, u, {
        shell: !0,
        timeout: 1e4
      });
      (p = l.stdout) == null || p.on("data", (m) => {
        const g = this.decodeWindowsOutput(m), h = this.cleanAnsiCodes(g);
        h && this.sendLog(h), g.includes("Enable IDE Service") && setTimeout(() => {
          var b;
          (b = l.stdin) == null || b.write(`y
`);
        }, 100);
      }), (f = l.stderr) == null || f.on("data", (m) => {
        const g = this.decodeWindowsOutput(m), h = this.cleanAnsiCodes(g);
        h && this.sendLog(h, "error");
      }), l.on("close", (m, g) => {
        m === 0 ? this.sendLog("") : m === null || this.sendLog(`: ${m}`, "error");
      }), l.on("error", (m) => {
        m.code === "TIMEOUT" ? this.sendLog("", "error") : this.sendLog(`: ${m.message}`, "error");
      });
    });
    // 
    be(this, "startDevTool", (t, n) => {
      const r = ne.dirname(n), i = t === "wechat" ? "mp-weixin" : "mp-alipay", a = ne.join(r, "dist", "build", i);
      if (!se.existsSync(a))
        return this.sendLog(`: ${a}`, "error");
      if (t == "wechat") {
        this.startWeChatDevTool(a);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        return;
      }
      this.startAlipayDevTool(projectPathFull);
    });
    //  ()
<<<<<<< HEAD
    __publicField(this, "spawnCommandWithLogs", (command, args, options = {}) => {
      return new Promise((resolve, reject) => {
        var _a, _b;
        this.sendLog(` : ${command} ${args.join(" ")}`);
        const child = spawn(command, args, {
          shell: true,
          ...options
        });
        (_a = child.stdout) == null ? void 0 : _a.on("data", (data) => {
          const output = this.decodeWindowsOutput(data).trim();
          if (output) {
            this.sendLog(` : ${output}`);
          }
        });
        (_b = child.stderr) == null ? void 0 : _b.on("data", (data) => {
          const error2 = this.decodeWindowsOutput(data).trim();
          if (error2) {
            this.sendLog(` : ${error2}`, "error");
          }
        });
        child.on("close", (code) => {
          if (code === 0) {
            this.sendLog(` `);
            resolve(true);
          } else {
            this.sendLog(` : ${code}`, "error");
            resolve(false);
          }
        });
        child.on("error", (error2) => {
          this.sendLog(` : ${error2.message}`, "error");
          reject(error2);
        });
        if (options.timeout) {
          setTimeout(() => {
            child.kill();
            this.sendLog(` `, "error");
            resolve(false);
          }, options.timeout);
        }
      });
    });
    //  ()
    __publicField(this, "startWeChatDevToolAsync", async (projectPath) => {
      const cmd = this.runConfig.wechat;
      if (!fs$w.existsSync(cmd)) {
        return this.sendLog("", "error");
      }
      const normalizedProjectPath = require$$1$4.normalize(require$$1$4.resolve(projectPath));
      const isWindows2 = process.platform === "win32";
      const quotedCmd = isWindows2 ? `"${cmd}"` : cmd;
      const quotedProjectPath = isWindows2 ? `"${normalizedProjectPath}"` : normalizedProjectPath;
      const fullCommand = `${quotedCmd} open --project ${quotedProjectPath}`;
      const shellCommand = isWindows2 ? "cmd" : "sh";
      const shellArgs = isWindows2 ? ["/c", fullCommand] : ["-c", fullCommand];
      const success = await this.spawnCommandWithLogs(shellCommand, shellArgs, {
        timeout: 1e4
      });
      return success;
    });
    this.windown = win2;
    if (!fs$w.existsSync(this.app_dir)) {
      fs$w.mkdirSync(this.app_dir, { recursive: true });
    }
    if (!fs$w.existsSync(this.configPath)) {
      fs$w.writeFileSync(this.configPath, JSON.stringify({}, null, 4), "utf8");
    }
    this.readConfig();
  }
  //  (UI)
  sendLog(text, type2 = "default") {
    const time = dayjs().unix();
    this.windown.webContents.send("logs", {
      text,
      type: type2,
      id: `${Math.random() + time}`,
      time: dayjs().format("YYYY-MM-DD HH:mm:ss")
    });
  }
  //  ANSI 
  cleanAnsiCodes(text) {
    if (!text || typeof text !== "string") {
      return "";
    }
    return text.replace(/\x1b\[[0-9;]*[mGKHfJ]/g, "").replace(/\x1b\[[0-9]*[ABCD]/g, "").replace(/\x1b\[[0-9]*[H]/g, "").replace(/\x1b\[2J/g, "").replace(/\x1b\[K/g, "").replace(/\r\n/g, "\n").replace(/\r/g, "\n").trim();
=======
    be(this, "spawnCommandWithLogs", (t, n, r = {}) => new Promise((i, a) => {
      var c, o;
      this.sendLog(` : ${t} ${n.join(" ")}`);
      const s = Pp(t, n, {
        shell: !0,
        ...r
      });
      (c = s.stdout) == null || c.on("data", (u) => {
        const l = this.decodeWindowsOutput(u).trim();
        l && this.sendLog(` : ${l}`);
      }), (o = s.stderr) == null || o.on("data", (u) => {
        const l = this.decodeWindowsOutput(u).trim();
        l && this.sendLog(` : ${l}`, "error");
      }), s.on("close", (u) => {
        u === 0 ? (this.sendLog(" "), i(!0)) : (this.sendLog(` : ${u}`, "error"), i(!1));
      }), s.on("error", (u) => {
        this.sendLog(` : ${u.message}`, "error"), a(u);
      }), r.timeout && setTimeout(() => {
        s.kill(), this.sendLog(" ", "error"), i(!1);
      }, r.timeout);
    }));
    //  ()
    be(this, "startWeChatDevToolAsync", async (t) => {
      const n = this.runConfig.wechat;
      if (!se.existsSync(n))
        return this.sendLog("", "error");
      const r = ne.normalize(ne.resolve(t)), i = `"${n}"`, a = `"${r}"`, s = `${i} open --project ${a}`, c = process.platform === "win32", o = c ? "cmd" : "sh", u = c ? ["/c", s] : ["-c", s];
      return await this.spawnCommandWithLogs(o, u, {
        timeout: 1e4
      });
    });
    this.windown = t, se.existsSync(this.app_dir) || se.mkdirSync(this.app_dir, { recursive: !0 }), se.existsSync(this.configPath) || se.writeFileSync(this.configPath, JSON.stringify({}, null, 4), "utf8"), this.readConfig();
  }
  //  (UI)
  sendLog(t, n = "default") {
    const r = Rf().unix();
    this.windown.webContents.send("logs", {
      text: t,
      type: n,
      id: `${Math.random() + r}`,
      time: Rf().format("YYYY-MM-DD HH:mm:ss")
    });
  }
  //  ANSI 
  cleanAnsiCodes(t) {
    return !t || typeof t != "string" ? "" : t.replace(/\x1b\[[0-9;]*[mGKHfJ]/g, "").replace(/\x1b\[[0-9]*[ABCD]/g, "").replace(/\x1b\[[0-9]*[H]/g, "").replace(/\x1b\[2J/g, "").replace(/\x1b\[K/g, "").replace(/\r\n/g, `
`).replace(/\r/g, `
`).trim();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  //  Windows 
  decodeWindowsOutput(t) {
    if (process.platform === "win32")
      try {
        return a2.decode(t, "gbk");
      } catch {
        return t.toString("utf8");
      }
    return t.toString("utf8");
  }
}
<<<<<<< HEAD
var main$1 = {};
var fs$i = {};
var universalify$1 = {};
universalify$1.fromCallback = function(fn) {
  return Object.defineProperty(function(...args) {
    if (typeof args[args.length - 1] === "function") fn.apply(this, args);
    else {
      return new Promise((resolve, reject) => {
        args.push((err, res) => err != null ? reject(err) : resolve(res));
        fn.apply(this, args);
=======
var St = {}, Jn = {}, Ve = {};
Ve.fromCallback = function(e) {
  return Object.defineProperty(function(...t) {
    if (typeof t[t.length - 1] == "function") e.apply(this, t);
    else
      return new Promise((n, r) => {
        t.push((i, a) => i != null ? r(i) : n(a)), e.apply(this, t);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      });
    }
  }, "name", { value: fn.name });
};
<<<<<<< HEAD
universalify$1.fromPromise = function(fn) {
  return Object.defineProperty(function(...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== "function") return fn.apply(this, args);
    else {
      args.pop();
      fn.apply(this, args).then((r) => cb(null, r), cb);
    }
  }, "name", { value: fn.name });
};
var constants$2 = require$$1$6;
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
=======
Ve.fromPromise = function(e) {
  return Object.defineProperty(function(...t) {
    const n = t[t.length - 1];
    if (typeof n != "function") return e.apply(this, t);
    t.pop(), e.apply(this, t).then((r) => n(null, r), n);
  }, "name", { value: e.name });
};
var Zt = Rm, o2 = process.cwd, ns = null, c2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  return ns || (ns = o2.call(process)), ns;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
};
try {
  process.cwd();
} catch (er) {
}
<<<<<<< HEAD
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d) {
    cwd = null;
    chdir.call(process, d);
  };
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$3;
function patch$3(fs2) {
  if (constants$2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (fs2.chmod && !fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (fs2.chown && !fs2.lchown) {
    fs2.lchown = function(path2, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
      function rename2(from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb) cb(er);
        });
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(rename2, fs$rename);
      return rename2;
    }(fs2.rename);
  }
  fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
    function read(fd, buffer2, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
    }
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
    return function(fd, buffer2, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs22) {
    fs22.lchmod = function(path2, mode, callback) {
      fs22.open(
        path2,
        constants$2.O_WRONLY | constants$2.O_SYMLINK,
        mode,
        function(err, fd) {
          if (err) {
            if (callback) callback(err);
            return;
          }
          fs22.fchmod(fd, mode, function(err2) {
            fs22.close(fd, function(err22) {
              if (callback) callback(err2 || err22);
=======
if (typeof process.chdir == "function") {
  var Fd = process.chdir;
  process.chdir = function(e) {
    ns = null, Fd.call(process, e);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, Fd);
}
var l2 = u2;
function u2(e) {
  Zt.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && t(e), e.lutimes || n(e), e.chown = a(e.chown), e.fchown = a(e.fchown), e.lchown = a(e.lchown), e.chmod = r(e.chmod), e.fchmod = r(e.fchmod), e.lchmod = r(e.lchmod), e.chownSync = s(e.chownSync), e.fchownSync = s(e.fchownSync), e.lchownSync = s(e.lchownSync), e.chmodSync = i(e.chmodSync), e.fchmodSync = i(e.fchmodSync), e.lchmodSync = i(e.lchmodSync), e.stat = c(e.stat), e.fstat = c(e.fstat), e.lstat = c(e.lstat), e.statSync = o(e.statSync), e.fstatSync = o(e.fstatSync), e.lstatSync = o(e.lstatSync), e.chmod && !e.lchmod && (e.lchmod = function(l, p, f) {
    f && process.nextTick(f);
  }, e.lchmodSync = function() {
  }), e.chown && !e.lchown && (e.lchown = function(l, p, f, m) {
    m && process.nextTick(m);
  }, e.lchownSync = function() {
  }), c2 === "win32" && (e.rename = typeof e.rename != "function" ? e.rename : function(l) {
    function p(f, m, g) {
      var h = Date.now(), b = 0;
      l(f, m, function x(y) {
        if (y && (y.code === "EACCES" || y.code === "EPERM" || y.code === "EBUSY") && Date.now() - h < 6e4) {
          setTimeout(function() {
            e.stat(m, function(E, S) {
              E && E.code === "ENOENT" ? l(f, m, x) : g(y);
            });
          }, b), b < 100 && (b += 10);
          return;
        }
        g && g(y);
      });
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(p, l), p;
  }(e.rename)), e.read = typeof e.read != "function" ? e.read : function(l) {
    function p(f, m, g, h, b, x) {
      var y;
      if (x && typeof x == "function") {
        var E = 0;
        y = function(S, D, U) {
          if (S && S.code === "EAGAIN" && E < 10)
            return E++, l.call(e, f, m, g, h, b, y);
          x.apply(this, arguments);
        };
      }
      return l.call(e, f, m, g, h, b, y);
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(p, l), p;
  }(e.read), e.readSync = typeof e.readSync != "function" ? e.readSync : /* @__PURE__ */ function(l) {
    return function(p, f, m, g, h) {
      for (var b = 0; ; )
        try {
          return l.call(e, p, f, m, g, h);
        } catch (x) {
          if (x.code === "EAGAIN" && b < 10) {
            b++;
            continue;
          }
          throw x;
        }
    };
  }(e.readSync);
  function t(l) {
    l.lchmod = function(p, f, m) {
      l.open(
        p,
        Zt.O_WRONLY | Zt.O_SYMLINK,
        f,
        function(g, h) {
          if (g) {
            m && m(g);
            return;
          }
          l.fchmod(h, f, function(b) {
            l.close(h, function(x) {
              m && m(b || x);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
            });
          });
        }
      );
<<<<<<< HEAD
    };
    fs22.lchmodSync = function(path2, mode) {
      var fd = fs22.openSync(path2, constants$2.O_WRONLY | constants$2.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs22.fchmodSync(fd, mode);
        threw = false;
=======
    }, l.lchmodSync = function(p, f) {
      var m = l.openSync(p, Zt.O_WRONLY | Zt.O_SYMLINK, f), g = !0, h;
      try {
        h = l.fchmodSync(m, f), g = !1;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      } finally {
        if (threw) {
          try {
            fs22.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs22.closeSync(fd);
        }
      }
<<<<<<< HEAD
      return ret;
    };
  }
  function patchLutimes(fs22) {
    if (constants$2.hasOwnProperty("O_SYMLINK") && fs22.futimes) {
      fs22.lutimes = function(path2, at, mt, cb) {
        fs22.open(path2, constants$2.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb) cb(er);
            return;
          }
          fs22.futimes(fd, at, mt, function(er2) {
            fs22.close(fd, function(er22) {
              if (cb) cb(er2 || er22);
            });
          });
        });
      };
      fs22.lutimesSync = function(path2, at, mt) {
        var fd = fs22.openSync(path2, constants$2.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs22.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs22.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs22.closeSync(fd);
          }
        }
        return ret;
      };
    } else if (fs22.futimes) {
      fs22.lutimes = function(_a, _b, _c, cb) {
        if (cb) process.nextTick(cb);
      };
      fs22.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig) return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig) return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er)) throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig) return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig) return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er)) throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig) return orig;
    return function(target, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 4294967296;
          if (stats.gid < 0) stats.gid += 4294967296;
        }
        if (cb) cb.apply(this, arguments);
      }
      return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig) return orig;
    return function(target, options) {
      var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
      if (stats) {
        if (stats.uid < 0) stats.uid += 4294967296;
        if (stats.gid < 0) stats.gid += 4294967296;
      }
      return stats;
=======
      return h;
    };
  }
  function n(l) {
    Zt.hasOwnProperty("O_SYMLINK") && l.futimes ? (l.lutimes = function(p, f, m, g) {
      l.open(p, Zt.O_SYMLINK, function(h, b) {
        if (h) {
          g && g(h);
          return;
        }
        l.futimes(b, f, m, function(x) {
          l.close(b, function(y) {
            g && g(x || y);
          });
        });
      });
    }, l.lutimesSync = function(p, f, m) {
      var g = l.openSync(p, Zt.O_SYMLINK), h, b = !0;
      try {
        h = l.futimesSync(g, f, m), b = !1;
      } finally {
        if (b)
          try {
            l.closeSync(g);
          } catch {
          }
        else
          l.closeSync(g);
      }
      return h;
    }) : l.futimes && (l.lutimes = function(p, f, m, g) {
      g && process.nextTick(g);
    }, l.lutimesSync = function() {
    });
  }
  function r(l) {
    return l && function(p, f, m) {
      return l.call(e, p, f, function(g) {
        u(g) && (g = null), m && m.apply(this, arguments);
      });
    };
  }
  function i(l) {
    return l && function(p, f) {
      try {
        return l.call(e, p, f);
      } catch (m) {
        if (!u(m)) throw m;
      }
    };
  }
  function a(l) {
    return l && function(p, f, m, g) {
      return l.call(e, p, f, m, function(h) {
        u(h) && (h = null), g && g.apply(this, arguments);
      });
    };
  }
  function s(l) {
    return l && function(p, f, m) {
      try {
        return l.call(e, p, f, m);
      } catch (g) {
        if (!u(g)) throw g;
      }
    };
  }
  function c(l) {
    return l && function(p, f, m) {
      typeof f == "function" && (m = f, f = null);
      function g(h, b) {
        b && (b.uid < 0 && (b.uid += 4294967296), b.gid < 0 && (b.gid += 4294967296)), m && m.apply(this, arguments);
      }
      return f ? l.call(e, p, f, g) : l.call(e, p, g);
    };
  }
  function o(l) {
    return l && function(p, f) {
      var m = f ? l.call(e, p, f) : l.call(e, p);
      return m && (m.uid < 0 && (m.uid += 4294967296), m.gid < 0 && (m.gid += 4294967296)), m;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
<<<<<<< HEAD
var Stream = require$$1$2.Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
=======
var Pd = ae.Stream, p2 = f2;
function f2(e) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  return {
    ReadStream: ReadStream2,
    WriteStream: WriteStream2
  };
<<<<<<< HEAD
  function ReadStream2(path2, options) {
    if (!(this instanceof ReadStream2)) return new ReadStream2(path2, options);
    Stream.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key2 = keys[index];
      this[key2] = options[key2];
=======
  function t(r, i) {
    if (!(this instanceof t)) return new t(r, i);
    Pd.call(this);
    var a = this;
    this.path = r, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, i = i || {};
    for (var s = Object.keys(i), c = 0, o = s.length; c < o; c++) {
      var u = s[c];
      this[u] = i[u];
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    if (this.encoding) this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if ("number" !== typeof this.end) {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self2.emit("error", err);
        self2.readable = false;
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2._read();
    });
  }
<<<<<<< HEAD
  function WriteStream2(path2, options) {
    if (!(this instanceof WriteStream2)) return new WriteStream2(path2, options);
    Stream.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key2 = keys[index];
      this[key2] = options[key2];
=======
  function n(r, i) {
    if (!(this instanceof n)) return new n(r, i);
    Pd.call(this), this.path = r, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, i = i || {};
    for (var a = Object.keys(i), s = 0, c = a.length; s < c; s++) {
      var o = a[s];
      this[o] = i[o];
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
<<<<<<< HEAD
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy3 = { __proto__: getPrototypeOf(obj) };
  else
    var copy3 = /* @__PURE__ */ Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key2) {
    Object.defineProperty(copy3, key2, Object.getOwnPropertyDescriptor(obj, key2));
  });
  return copy3;
}
var fs$h = fs$w;
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$2 = require$$1$3;
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop() {
}
function publishQueue(context, queue2) {
  Object.defineProperty(context, gracefulQueue, {
=======
var d2 = m2, h2 = Object.getPrototypeOf || function(e) {
  return e.__proto__;
};
function m2(e) {
  if (e === null || typeof e != "object")
    return e;
  if (e instanceof Object)
    var t = { __proto__: h2(e) };
  else
    var t = /* @__PURE__ */ Object.create(null);
  return Object.getOwnPropertyNames(e).forEach(function(n) {
    Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n));
  }), t;
}
var he = se, v2 = l2, g2 = p2, b2 = d2, Ia = De, Le, ms;
typeof Symbol == "function" && typeof Symbol.for == "function" ? (Le = Symbol.for("graceful-fs.queue"), ms = Symbol.for("graceful-fs.previous")) : (Le = "___graceful-fs.queue", ms = "___graceful-fs.previous");
function x2() {
}
function Y1(e, t) {
  Object.defineProperty(e, Le, {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    get: function() {
      return queue2;
    }
  });
}
<<<<<<< HEAD
var debug$3 = noop;
if (util$2.debuglog)
  debug$3 = util$2.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
  debug$3 = function() {
    var m = util$2.format.apply(util$2, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
  };
if (!fs$h[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$h, queue);
  fs$h.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$h, fd, function(err) {
        if (!err) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close;
  }(fs$h.close);
  fs$h.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$h, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$h.closeSync);
  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
    process.on("exit", function() {
      debug$3(fs$h[gracefulQueue]);
      require$$2$3.equal(fs$h[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$h[gracefulQueue]);
}
var gracefulFs = patch$2(clone(fs$h));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$h.__patched) {
  gracefulFs = patch$2(fs$h);
  fs$h.__patched = true;
}
function patch$2(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch$2;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path2, options, cb);
    function go$readFile(path22, options2, cb2, startTime) {
      return fs$readFile(path22, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readFile, [path22, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$writeFile(path2, data, options, cb);
    function go$writeFile(path22, data2, options2, cb2, startTime) {
      return fs$writeFile(path22, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$writeFile, [path22, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$appendFile(path2, data, options, cb);
    function go$appendFile(path22, data2, options2, cb2, startTime) {
      return fs$appendFile(path22, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$appendFile, [path22, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile2;
  function copyFile2(src2, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src2, dest, flags, cb);
    function go$copyFile(src22, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src22, dest2, flags2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$copyFile, [src22, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  var noReaddirOptionVersions = /^v[0-5]\./;
  function readdir(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path22, options2, cb2, startTime) {
      return fs$readdir(path22, fs$readdirCallback(
        path22,
        options2,
        cb2,
        startTime
      ));
    } : function go$readdir2(path22, options2, cb2, startTime) {
      return fs$readdir(path22, options2, fs$readdirCallback(
        path22,
        options2,
        cb2,
        startTime
      ));
    };
    return go$readdir(path2, options, cb);
    function fs$readdirCallback(path22, options2, cb2, startTime) {
      return function(err, files) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([
            go$readdir,
            [path22, options2, cb2],
            err,
            startTime || Date.now(),
            Date.now()
          ]);
        else {
          if (files && files.sort)
            files.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err, files);
        }
=======
var Mn = x2;
Ia.debuglog ? Mn = Ia.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (Mn = function() {
  var e = Ia.format.apply(Ia, arguments);
  e = "GFS4: " + e.split(/\n/).join(`
GFS4: `), console.error(e);
});
if (!he[Le]) {
  var y2 = Ae[Le] || [];
  Y1(he, y2), he.close = function(e) {
    function t(n, r) {
      return e.call(he, n, function(i) {
        i || kd(), typeof r == "function" && r.apply(this, arguments);
      });
    }
    return Object.defineProperty(t, ms, {
      value: e
    }), t;
  }(he.close), he.closeSync = function(e) {
    function t(n) {
      e.apply(he, arguments), kd();
    }
    return Object.defineProperty(t, ms, {
      value: e
    }), t;
  }(he.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    Mn(he[Le]), Rs.equal(he[Le].length, 0);
  });
}
Ae[Le] || Y1(Ae, he[Le]);
var Ye = Bu(b2(he));
process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !he.__patched && (Ye = Bu(he), he.__patched = !0);
function Bu(e) {
  v2(e), e.gracefulify = Bu, e.createReadStream = D, e.createWriteStream = U;
  var t = e.readFile;
  e.readFile = n;
  function n(C, H, M) {
    return typeof H == "function" && (M = H, H = null), J(C, H, M);
    function J(re, k, O, P) {
      return t(re, k, function(w) {
        w && (w.code === "EMFILE" || w.code === "ENFILE") ? ir([J, [re, k, O], w, P || Date.now(), Date.now()]) : typeof O == "function" && O.apply(this, arguments);
      });
    }
  }
  var r = e.writeFile;
  e.writeFile = i;
  function i(C, H, M, J) {
    return typeof M == "function" && (J = M, M = null), re(C, H, M, J);
    function re(k, O, P, w, _) {
      return r(k, O, P, function(R) {
        R && (R.code === "EMFILE" || R.code === "ENFILE") ? ir([re, [k, O, P, w], R, _ || Date.now(), Date.now()]) : typeof w == "function" && w.apply(this, arguments);
      });
    }
  }
  var a = e.appendFile;
  a && (e.appendFile = s);
  function s(C, H, M, J) {
    return typeof M == "function" && (J = M, M = null), re(C, H, M, J);
    function re(k, O, P, w, _) {
      return a(k, O, P, function(R) {
        R && (R.code === "EMFILE" || R.code === "ENFILE") ? ir([re, [k, O, P, w], R, _ || Date.now(), Date.now()]) : typeof w == "function" && w.apply(this, arguments);
      });
    }
  }
  var c = e.copyFile;
  c && (e.copyFile = o);
  function o(C, H, M, J) {
    return typeof M == "function" && (J = M, M = 0), re(C, H, M, J);
    function re(k, O, P, w, _) {
      return c(k, O, P, function(R) {
        R && (R.code === "EMFILE" || R.code === "ENFILE") ? ir([re, [k, O, P, w], R, _ || Date.now(), Date.now()]) : typeof w == "function" && w.apply(this, arguments);
      });
    }
  }
  var u = e.readdir;
  e.readdir = p;
  var l = /^v[0-5]\./;
  function p(C, H, M) {
    typeof H == "function" && (M = H, H = null);
    var J = l.test(process.version) ? function(O, P, w, _) {
      return u(O, re(
        O,
        P,
        w,
        _
      ));
    } : function(O, P, w, _) {
      return u(O, P, re(
        O,
        P,
        w,
        _
      ));
    };
    return J(C, H, M);
    function re(k, O, P, w) {
      return function(_, R) {
        _ && (_.code === "EMFILE" || _.code === "ENFILE") ? ir([
          J,
          [k, O, P],
          _,
          w || Date.now(),
          Date.now()
        ]) : (R && R.sort && R.sort(), typeof P == "function" && P.call(this, _, R));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
<<<<<<< HEAD
    var legStreams = legacy(fs2);
    ReadStream2 = legStreams.ReadStream;
    WriteStream2 = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream2.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream2.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream2.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream2.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream2;
    },
    set: function(val) {
      ReadStream2 = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream2;
    },
    set: function(val) {
      WriteStream2 = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream2;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream2;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream2(path2, options) {
    if (this instanceof ReadStream2)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream2.apply(Object.create(ReadStream2.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open2(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream2(path2, options) {
    if (this instanceof WriteStream2)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream2.apply(Object.create(WriteStream2.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open2(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path2, options) {
    return new fs2.ReadStream(path2, options);
  }
  function createWriteStream(path2, options) {
    return new fs2.WriteStream(path2, options);
  }
  var fs$open = fs2.open;
  fs2.open = open2;
  function open2(path2, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path2, flags, mode, cb);
    function go$open(path22, flags2, mode2, cb2, startTime) {
      return fs$open(path22, flags2, mode2, function(err, fd) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$open, [path22, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
=======
    var f = g2(e);
    x = f.ReadStream, E = f.WriteStream;
  }
  var m = e.ReadStream;
  m && (x.prototype = Object.create(m.prototype), x.prototype.open = y);
  var g = e.WriteStream;
  g && (E.prototype = Object.create(g.prototype), E.prototype.open = S), Object.defineProperty(e, "ReadStream", {
    get: function() {
      return x;
    },
    set: function(C) {
      x = C;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e, "WriteStream", {
    get: function() {
      return E;
    },
    set: function(C) {
      E = C;
    },
    enumerable: !0,
    configurable: !0
  });
  var h = x;
  Object.defineProperty(e, "FileReadStream", {
    get: function() {
      return h;
    },
    set: function(C) {
      h = C;
    },
    enumerable: !0,
    configurable: !0
  });
  var b = E;
  Object.defineProperty(e, "FileWriteStream", {
    get: function() {
      return b;
    },
    set: function(C) {
      b = C;
    },
    enumerable: !0,
    configurable: !0
  });
  function x(C, H) {
    return this instanceof x ? (m.apply(this, arguments), this) : x.apply(Object.create(x.prototype), arguments);
  }
  function y() {
    var C = this;
    ee(C.path, C.flags, C.mode, function(H, M) {
      H ? (C.autoClose && C.destroy(), C.emit("error", H)) : (C.fd = M, C.emit("open", M), C.read());
    });
  }
  function E(C, H) {
    return this instanceof E ? (g.apply(this, arguments), this) : E.apply(Object.create(E.prototype), arguments);
  }
  function S() {
    var C = this;
    ee(C.path, C.flags, C.mode, function(H, M) {
      H ? (C.destroy(), C.emit("error", H)) : (C.fd = M, C.emit("open", M));
    });
  }
  function D(C, H) {
    return new e.ReadStream(C, H);
  }
  function U(C, H) {
    return new e.WriteStream(C, H);
  }
  var z = e.open;
  e.open = ee;
  function ee(C, H, M, J) {
    return typeof M == "function" && (J = M, M = null), re(C, H, M, J);
    function re(k, O, P, w, _) {
      return z(k, O, P, function(R, L) {
        R && (R.code === "EMFILE" || R.code === "ENFILE") ? ir([re, [k, O, P, w], R, _ || Date.now(), Date.now()]) : typeof w == "function" && w.apply(this, arguments);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      });
    }
  }
  return fs2;
}
<<<<<<< HEAD
function enqueue(elem) {
  debug$3("ENQUEUE", elem[0].name, elem[1]);
  fs$h[gracefulQueue].push(elem);
  retry$2();
}
var retryTimer;
function resetQueue() {
  var now = Date.now();
  for (var i = 0; i < fs$h[gracefulQueue].length; ++i) {
    if (fs$h[gracefulQueue][i].length > 2) {
      fs$h[gracefulQueue][i][3] = now;
      fs$h[gracefulQueue][i][4] = now;
    }
  }
  retry$2();
}
function retry$2() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$h[gracefulQueue].length === 0)
    return;
  var elem = fs$h[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug$3("RETRY", fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 6e4) {
    debug$3("TIMEOUT", fn.name, args);
    var cb = args.pop();
    if (typeof cb === "function")
      cb.call(null, err);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug$3("RETRY", fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      fs$h[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry$2, 0);
  }
}
(function(exports) {
  const u2 = universalify$1.fromCallback;
  const fs2 = gracefulFs;
  const api = [
=======
function ir(e) {
  Mn("ENQUEUE", e[0].name, e[1]), he[Le].push(e), ju();
}
var Da;
function kd() {
  for (var e = Date.now(), t = 0; t < he[Le].length; ++t)
    he[Le][t].length > 2 && (he[Le][t][3] = e, he[Le][t][4] = e);
  ju();
}
function ju() {
  if (clearTimeout(Da), Da = void 0, he[Le].length !== 0) {
    var e = he[Le].shift(), t = e[0], n = e[1], r = e[2], i = e[3], a = e[4];
    if (i === void 0)
      Mn("RETRY", t.name, n), t.apply(null, n);
    else if (Date.now() - i >= 6e4) {
      Mn("TIMEOUT", t.name, n);
      var s = n.pop();
      typeof s == "function" && s.call(null, r);
    } else {
      var c = Date.now() - a, o = Math.max(a - i, 1), u = Math.min(o * 1.2, 100);
      c >= u ? (Mn("RETRY", t.name, n), t.apply(null, n.concat([i]))) : he[Le].push(e);
    }
    Da === void 0 && (Da = setTimeout(ju, 0));
  }
}
(function(e) {
  const t = Ve.fromCallback, n = Ye, r = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
<<<<<<< HEAD
  ].filter((key2) => {
    return typeof fs2[key2] === "function";
  });
  Object.assign(exports, fs2);
  api.forEach((method) => {
    exports[method] = u2(fs2[method]);
  });
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve) => {
      return fs2.exists(filename, resolve);
    });
  };
  exports.read = function(fd, buffer2, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer2, offset, length, position, callback);
    }
    return new Promise((resolve, reject) => {
      fs2.read(fd, buffer2, offset, length, position, (err, bytesRead, buffer3) => {
        if (err) return reject(err);
        resolve({ bytesRead, buffer: buffer3 });
      });
    });
  };
  exports.write = function(fd, buffer2, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer2, ...args);
    }
    return new Promise((resolve, reject) => {
      fs2.write(fd, buffer2, ...args, (err, bytesWritten, buffer3) => {
        if (err) return reject(err);
        resolve({ bytesWritten, buffer: buffer3 });
      });
    });
  };
  if (typeof fs2.writev === "function") {
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.writev(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffers: buffers2 });
        });
      });
    };
  }
  if (typeof fs2.realpath.native === "function") {
    exports.realpath.native = u2(fs2.realpath.native);
  } else {
    process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  }
})(fs$i);
var makeDir$1 = {};
var utils$1 = {};
const path$l = require$$1$4;
utils$1.checkPath = function checkPath(pth) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$l.parse(pth).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      error2.code = "EINVAL";
      throw error2;
    }
  }
};
const fs$g = fs$i;
const { checkPath: checkPath2 } = utils$1;
const getMode = (options) => {
  const defaults2 = { mode: 511 };
  if (typeof options === "number") return options;
  return { ...defaults2, ...options }.mode;
};
makeDir$1.makeDir = async (dir, options) => {
  checkPath2(dir);
  return fs$g.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  });
};
makeDir$1.makeDirSync = (dir, options) => {
  checkPath2(dir);
  return fs$g.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  });
};
const u$a = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$a(_makeDir);
var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};
const u$9 = universalify$1.fromPromise;
const fs$f = fs$i;
function pathExists$6(path2) {
  return fs$f.access(path2).then(() => true).catch(() => false);
}
var pathExists_1 = {
  pathExists: u$9(pathExists$6),
  pathExistsSync: fs$f.existsSync
};
const fs$e = gracefulFs;
function utimesMillis$1(path2, atime, mtime, callback) {
  fs$e.open(path2, "r+", (err, fd) => {
    if (err) return callback(err);
    fs$e.futimes(fd, atime, mtime, (futimesErr) => {
      fs$e.close(fd, (closeErr) => {
        if (callback) callback(futimesErr || closeErr);
=======
  ].filter((i) => typeof n[i] == "function");
  Object.assign(e, n), r.forEach((i) => {
    e[i] = t(n[i]);
  }), e.exists = function(i, a) {
    return typeof a == "function" ? n.exists(i, a) : new Promise((s) => n.exists(i, s));
  }, e.read = function(i, a, s, c, o, u) {
    return typeof u == "function" ? n.read(i, a, s, c, o, u) : new Promise((l, p) => {
      n.read(i, a, s, c, o, (f, m, g) => {
        if (f) return p(f);
        l({ bytesRead: m, buffer: g });
      });
    });
  }, e.write = function(i, a, ...s) {
    return typeof s[s.length - 1] == "function" ? n.write(i, a, ...s) : new Promise((c, o) => {
      n.write(i, a, ...s, (u, l, p) => {
        if (u) return o(u);
        c({ bytesWritten: l, buffer: p });
      });
    });
  }, typeof n.writev == "function" && (e.writev = function(i, a, ...s) {
    return typeof s[s.length - 1] == "function" ? n.writev(i, a, ...s) : new Promise((c, o) => {
      n.writev(i, a, ...s, (u, l, p) => {
        if (u) return o(u);
        c({ bytesWritten: l, buffers: p });
      });
    });
  }), typeof n.realpath.native == "function" ? e.realpath.native = t(n.realpath.native) : process.emitWarning(
    "fs.realpath.native is not a function. Is fs being monkey-patched?",
    "Warning",
    "fs-extra-WARN0003"
  );
})(Jn);
var Mu = {}, X1 = {};
const w2 = ne;
X1.checkPath = function(t) {
  if (process.platform === "win32" && /[<>:"|?*]/.test(t.replace(w2.parse(t).root, ""))) {
    const r = new Error(`Path contains invalid characters: ${t}`);
    throw r.code = "EINVAL", r;
  }
};
const K1 = Jn, { checkPath: J1 } = X1, Z1 = (e) => {
  const t = { mode: 511 };
  return typeof e == "number" ? e : { ...t, ...e }.mode;
};
Mu.makeDir = async (e, t) => (J1(e), K1.mkdir(e, {
  mode: Z1(t),
  recursive: !0
}));
Mu.makeDirSync = (e, t) => (J1(e), K1.mkdirSync(e, {
  mode: Z1(t),
  recursive: !0
}));
const E2 = Ve.fromPromise, { makeDir: _2, makeDirSync: Hc } = Mu, Wc = E2(_2);
var It = {
  mkdirs: Wc,
  mkdirsSync: Hc,
  // alias
  mkdirp: Wc,
  mkdirpSync: Hc,
  ensureDir: Wc,
  ensureDirSync: Hc
};
const S2 = Ve.fromPromise, Q1 = Jn;
function A2(e) {
  return Q1.access(e).then(() => !0).catch(() => !1);
}
var Zn = {
  pathExists: S2(A2),
  pathExistsSync: Q1.existsSync
};
const $r = Ye;
function T2(e, t, n, r) {
  $r.open(e, "r+", (i, a) => {
    if (i) return r(i);
    $r.futimes(a, t, n, (s) => {
      $r.close(a, (c) => {
        r && r(s || c);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      });
    });
  });
}
<<<<<<< HEAD
function utimesMillisSync$1(path2, atime, mtime) {
  const fd = fs$e.openSync(path2, "r+");
  fs$e.futimesSync(fd, atime, mtime);
  return fs$e.closeSync(fd);
}
var utimes = {
  utimesMillis: utimesMillis$1,
  utimesMillisSync: utimesMillisSync$1
};
const fs$d = fs$i;
const path$k = require$$1$4;
const util$1 = require$$1$3;
function getStats$2(src2, dest, opts) {
  const statFunc = opts.dereference ? (file2) => fs$d.stat(file2, { bigint: true }) : (file2) => fs$d.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src2),
    statFunc(dest).catch((err) => {
      if (err.code === "ENOENT") return null;
      throw err;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync(src2, dest, opts) {
  let destStat;
  const statFunc = opts.dereference ? (file2) => fs$d.statSync(file2, { bigint: true }) : (file2) => fs$d.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src2);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === "ENOENT") return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}
function checkPaths(src2, dest, funcName, opts, cb) {
  util$1.callbackify(getStats$2)(src2, dest, opts, (err, stats) => {
    if (err) return cb(err);
    const { srcStat, destStat } = stats;
    if (destStat) {
      if (areIdentical$2(srcStat, destStat)) {
        const srcBaseName = path$k.basename(src2);
        const destBaseName = path$k.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return cb(null, { srcStat, destStat, isChangingCase: true });
        }
        return cb(new Error("Source and destination must not be the same."));
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`));
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`));
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
      return cb(new Error(errMsg(src2, dest, funcName)));
    }
    return cb(null, { srcStat, destStat });
  });
}
function checkPathsSync(src2, dest, funcName, opts) {
  const { srcStat, destStat } = getStatsSync(src2, dest, opts);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$k.basename(src2);
      const destBaseName = path$k.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkParentPaths(src2, srcStat, dest, funcName, cb) {
  const srcParent = path$k.resolve(path$k.dirname(src2));
  const destParent = path$k.resolve(path$k.dirname(dest));
  if (destParent === srcParent || destParent === path$k.parse(destParent).root) return cb();
  fs$d.stat(destParent, { bigint: true }, (err, destStat) => {
    if (err) {
      if (err.code === "ENOENT") return cb();
      return cb(err);
    }
    if (areIdentical$2(srcStat, destStat)) {
      return cb(new Error(errMsg(src2, dest, funcName)));
    }
    return checkParentPaths(src2, srcStat, destParent, funcName, cb);
  });
}
function checkParentPathsSync(src2, srcStat, dest, funcName) {
  const srcParent = path$k.resolve(path$k.dirname(src2));
  const destParent = path$k.resolve(path$k.dirname(dest));
  if (destParent === srcParent || destParent === path$k.parse(destParent).root) return;
  let destStat;
  try {
    destStat = fs$d.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT") return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return checkParentPathsSync(src2, srcStat, destParent, funcName);
}
function areIdentical$2(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir(src2, dest) {
  const srcArr = path$k.resolve(src2).split(path$k.sep).filter((i) => i);
  const destArr = path$k.resolve(dest).split(path$k.sep).filter((i) => i);
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
}
function errMsg(src2, dest, funcName) {
  return `Cannot ${funcName} '${src2}' to a subdirectory of itself, '${dest}'.`;
}
var stat$4 = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir,
  areIdentical: areIdentical$2
};
const fs$c = gracefulFs;
const path$j = require$$1$4;
const mkdirs$1 = mkdirs$2.mkdirs;
const pathExists$5 = pathExists_1.pathExists;
const utimesMillis = utimes.utimesMillis;
const stat$3 = stat$4;
function copy$2(src2, dest, opts, cb) {
  if (typeof opts === "function" && !cb) {
    cb = opts;
    opts = {};
  } else if (typeof opts === "function") {
    opts = { filter: opts };
  }
  cb = cb || function() {
  };
  opts = opts || {};
  opts.clobber = "clobber" in opts ? !!opts.clobber : true;
  opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
  if (opts.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0001"
    );
  }
  stat$3.checkPaths(src2, dest, "copy", opts, (err, stats) => {
    if (err) return cb(err);
    const { srcStat, destStat } = stats;
    stat$3.checkParentPaths(src2, srcStat, dest, "copy", (err2) => {
      if (err2) return cb(err2);
      if (opts.filter) return handleFilter(checkParentDir, destStat, src2, dest, opts, cb);
      return checkParentDir(destStat, src2, dest, opts, cb);
    });
  });
}
function checkParentDir(destStat, src2, dest, opts, cb) {
  const destParent = path$j.dirname(dest);
  pathExists$5(destParent, (err, dirExists) => {
    if (err) return cb(err);
    if (dirExists) return getStats$1(destStat, src2, dest, opts, cb);
    mkdirs$1(destParent, (err2) => {
      if (err2) return cb(err2);
      return getStats$1(destStat, src2, dest, opts, cb);
    });
  });
}
function handleFilter(onInclude, destStat, src2, dest, opts, cb) {
  Promise.resolve(opts.filter(src2, dest)).then((include) => {
    if (include) return onInclude(destStat, src2, dest, opts, cb);
    return cb();
  }, (error2) => cb(error2));
}
function startCopy$1(destStat, src2, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats$1, destStat, src2, dest, opts, cb);
  return getStats$1(destStat, src2, dest, opts, cb);
}
function getStats$1(destStat, src2, dest, opts, cb) {
  const stat2 = opts.dereference ? fs$c.stat : fs$c.lstat;
  stat2(src2, (err, srcStat) => {
    if (err) return cb(err);
    if (srcStat.isDirectory()) return onDir$1(srcStat, destStat, src2, dest, opts, cb);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile$1(srcStat, destStat, src2, dest, opts, cb);
    else if (srcStat.isSymbolicLink()) return onLink$1(destStat, src2, dest, opts, cb);
    else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src2}`));
    else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src2}`));
    return cb(new Error(`Unknown file: ${src2}`));
  });
}
function onFile$1(srcStat, destStat, src2, dest, opts, cb) {
  if (!destStat) return copyFile$1(srcStat, src2, dest, opts, cb);
  return mayCopyFile$1(srcStat, src2, dest, opts, cb);
}
function mayCopyFile$1(srcStat, src2, dest, opts, cb) {
  if (opts.overwrite) {
    fs$c.unlink(dest, (err) => {
      if (err) return cb(err);
      return copyFile$1(srcStat, src2, dest, opts, cb);
    });
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`));
  } else return cb();
}
function copyFile$1(srcStat, src2, dest, opts, cb) {
  fs$c.copyFile(src2, dest, (err) => {
    if (err) return cb(err);
    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src2, dest, cb);
    return setDestMode$1(dest, srcStat.mode, cb);
  });
}
function handleTimestampsAndMode(srcMode, src2, dest, cb) {
  if (fileIsNotWritable$1(srcMode)) {
    return makeFileWritable$1(dest, srcMode, (err) => {
      if (err) return cb(err);
      return setDestTimestampsAndMode(srcMode, src2, dest, cb);
    });
  }
  return setDestTimestampsAndMode(srcMode, src2, dest, cb);
}
function fileIsNotWritable$1(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$1(dest, srcMode, cb) {
  return setDestMode$1(dest, srcMode | 128, cb);
}
function setDestTimestampsAndMode(srcMode, src2, dest, cb) {
  setDestTimestamps$1(src2, dest, (err) => {
    if (err) return cb(err);
    return setDestMode$1(dest, srcMode, cb);
  });
}
function setDestMode$1(dest, srcMode, cb) {
  return fs$c.chmod(dest, srcMode, cb);
}
function setDestTimestamps$1(src2, dest, cb) {
  fs$c.stat(src2, (err, updatedSrcStat) => {
    if (err) return cb(err);
    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
  });
}
function onDir$1(srcStat, destStat, src2, dest, opts, cb) {
  if (!destStat) return mkDirAndCopy$1(srcStat.mode, src2, dest, opts, cb);
  return copyDir$1(src2, dest, opts, cb);
}
function mkDirAndCopy$1(srcMode, src2, dest, opts, cb) {
  fs$c.mkdir(dest, (err) => {
    if (err) return cb(err);
    copyDir$1(src2, dest, opts, (err2) => {
      if (err2) return cb(err2);
      return setDestMode$1(dest, srcMode, cb);
    });
  });
}
function copyDir$1(src2, dest, opts, cb) {
  fs$c.readdir(src2, (err, items) => {
    if (err) return cb(err);
    return copyDirItems(items, src2, dest, opts, cb);
  });
}
function copyDirItems(items, src2, dest, opts, cb) {
  const item = items.pop();
  if (!item) return cb();
  return copyDirItem$1(items, item, src2, dest, opts, cb);
}
function copyDirItem$1(items, item, src2, dest, opts, cb) {
  const srcItem = path$j.join(src2, item);
  const destItem = path$j.join(dest, item);
  stat$3.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
    if (err) return cb(err);
    const { destStat } = stats;
    startCopy$1(destStat, srcItem, destItem, opts, (err2) => {
      if (err2) return cb(err2);
      return copyDirItems(items, src2, dest, opts, cb);
    });
  });
}
function onLink$1(destStat, src2, dest, opts, cb) {
  fs$c.readlink(src2, (err, resolvedSrc) => {
    if (err) return cb(err);
    if (opts.dereference) {
      resolvedSrc = path$j.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs$c.symlink(resolvedSrc, dest, cb);
    } else {
      fs$c.readlink(dest, (err2, resolvedDest) => {
        if (err2) {
          if (err2.code === "EINVAL" || err2.code === "UNKNOWN") return fs$c.symlink(resolvedSrc, dest, cb);
          return cb(err2);
        }
        if (opts.dereference) {
          resolvedDest = path$j.resolve(process.cwd(), resolvedDest);
        }
        if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
        }
        if (destStat.isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
        }
        return copyLink$1(resolvedSrc, dest, cb);
      });
    }
  });
}
function copyLink$1(resolvedSrc, dest, cb) {
  fs$c.unlink(dest, (err) => {
    if (err) return cb(err);
    return fs$c.symlink(resolvedSrc, dest, cb);
  });
}
var copy_1 = copy$2;
const fs$b = gracefulFs;
const path$i = require$$1$4;
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$2 = stat$4;
function copySync$1(src2, dest, opts) {
  if (typeof opts === "function") {
    opts = { filter: opts };
  }
  opts = opts || {};
  opts.clobber = "clobber" in opts ? !!opts.clobber : true;
  opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
  if (opts.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0002"
    );
  }
  const { srcStat, destStat } = stat$2.checkPathsSync(src2, dest, "copy", opts);
  stat$2.checkParentPathsSync(src2, srcStat, dest, "copy");
  return handleFilterAndCopy(destStat, src2, dest, opts);
}
function handleFilterAndCopy(destStat, src2, dest, opts) {
  if (opts.filter && !opts.filter(src2, dest)) return;
  const destParent = path$i.dirname(dest);
  if (!fs$b.existsSync(destParent)) mkdirsSync$1(destParent);
  return getStats(destStat, src2, dest, opts);
}
function startCopy(destStat, src2, dest, opts) {
  if (opts.filter && !opts.filter(src2, dest)) return;
  return getStats(destStat, src2, dest, opts);
}
function getStats(destStat, src2, dest, opts) {
  const statSync = opts.dereference ? fs$b.statSync : fs$b.lstatSync;
  const srcStat = statSync(src2);
  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src2, dest, opts);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src2, dest, opts);
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src2, dest, opts);
  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src2}`);
  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src2}`);
  throw new Error(`Unknown file: ${src2}`);
}
function onFile(srcStat, destStat, src2, dest, opts) {
  if (!destStat) return copyFile(srcStat, src2, dest, opts);
  return mayCopyFile(srcStat, src2, dest, opts);
}
function mayCopyFile(srcStat, src2, dest, opts) {
  if (opts.overwrite) {
    fs$b.unlinkSync(dest);
    return copyFile(srcStat, src2, dest, opts);
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile(srcStat, src2, dest, opts) {
  fs$b.copyFileSync(src2, dest);
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src2, dest);
  return setDestMode(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src2, dest) {
  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
  return setDestTimestamps(src2, dest);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 128);
}
function setDestMode(dest, srcMode) {
  return fs$b.chmodSync(dest, srcMode);
}
function setDestTimestamps(src2, dest) {
  const updatedSrcStat = fs$b.statSync(src2);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir(srcStat, destStat, src2, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src2, dest, opts);
  return copyDir(src2, dest, opts);
}
function mkDirAndCopy(srcMode, src2, dest, opts) {
  fs$b.mkdirSync(dest);
  copyDir(src2, dest, opts);
  return setDestMode(dest, srcMode);
}
function copyDir(src2, dest, opts) {
  fs$b.readdirSync(src2).forEach((item) => copyDirItem(item, src2, dest, opts));
}
function copyDirItem(item, src2, dest, opts) {
  const srcItem = path$i.join(src2, item);
  const destItem = path$i.join(dest, item);
  const { destStat } = stat$2.checkPathsSync(srcItem, destItem, "copy", opts);
  return startCopy(destStat, srcItem, destItem, opts);
}
function onLink(destStat, src2, dest, opts) {
  let resolvedSrc = fs$b.readlinkSync(src2);
  if (opts.dereference) {
    resolvedSrc = path$i.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$b.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$b.readlinkSync(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs$b.symlinkSync(resolvedSrc, dest);
      throw err;
    }
    if (opts.dereference) {
      resolvedDest = path$i.resolve(process.cwd(), resolvedDest);
    }
    if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (fs$b.statSync(dest).isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink(resolvedSrc, dest);
  }
}
function copyLink(resolvedSrc, dest) {
  fs$b.unlinkSync(dest);
  return fs$b.symlinkSync(resolvedSrc, dest);
}
var copySync_1 = copySync$1;
const u$8 = universalify$1.fromCallback;
var copy$1 = {
  copy: u$8(copy_1),
  copySync: copySync_1
};
const fs$a = gracefulFs;
const path$h = require$$1$4;
const assert = require$$2$3;
const isWindows = process.platform === "win32";
function defaults(options) {
  const methods = [
=======
function C2(e, t, n) {
  const r = $r.openSync(e, "r+");
  return $r.futimesSync(r, t, n), $r.closeSync(r);
}
var ev = {
  utimesMillis: T2,
  utimesMillisSync: C2
};
const Pr = Jn, Ie = ne, R2 = De;
function $2(e, t, n) {
  const r = n.dereference ? (i) => Pr.stat(i, { bigint: !0 }) : (i) => Pr.lstat(i, { bigint: !0 });
  return Promise.all([
    r(e),
    r(t).catch((i) => {
      if (i.code === "ENOENT") return null;
      throw i;
    })
  ]).then(([i, a]) => ({ srcStat: i, destStat: a }));
}
function O2(e, t, n) {
  let r;
  const i = n.dereference ? (s) => Pr.statSync(s, { bigint: !0 }) : (s) => Pr.lstatSync(s, { bigint: !0 }), a = i(e);
  try {
    r = i(t);
  } catch (s) {
    if (s.code === "ENOENT") return { srcStat: a, destStat: null };
    throw s;
  }
  return { srcStat: a, destStat: r };
}
function I2(e, t, n, r, i) {
  R2.callbackify($2)(e, t, r, (a, s) => {
    if (a) return i(a);
    const { srcStat: c, destStat: o } = s;
    if (o) {
      if (Ji(c, o)) {
        const u = Ie.basename(e), l = Ie.basename(t);
        return n === "move" && u !== l && u.toLowerCase() === l.toLowerCase() ? i(null, { srcStat: c, destStat: o, isChangingCase: !0 }) : i(new Error("Source and destination must not be the same."));
      }
      if (c.isDirectory() && !o.isDirectory())
        return i(new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`));
      if (!c.isDirectory() && o.isDirectory())
        return i(new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`));
    }
    return c.isDirectory() && qu(e, t) ? i(new Error(oo(e, t, n))) : i(null, { srcStat: c, destStat: o });
  });
}
function D2(e, t, n, r) {
  const { srcStat: i, destStat: a } = O2(e, t, r);
  if (a) {
    if (Ji(i, a)) {
      const s = Ie.basename(e), c = Ie.basename(t);
      if (n === "move" && s !== c && s.toLowerCase() === c.toLowerCase())
        return { srcStat: i, destStat: a, isChangingCase: !0 };
      throw new Error("Source and destination must not be the same.");
    }
    if (i.isDirectory() && !a.isDirectory())
      throw new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`);
    if (!i.isDirectory() && a.isDirectory())
      throw new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`);
  }
  if (i.isDirectory() && qu(e, t))
    throw new Error(oo(e, t, n));
  return { srcStat: i, destStat: a };
}
function tv(e, t, n, r, i) {
  const a = Ie.resolve(Ie.dirname(e)), s = Ie.resolve(Ie.dirname(n));
  if (s === a || s === Ie.parse(s).root) return i();
  Pr.stat(s, { bigint: !0 }, (c, o) => c ? c.code === "ENOENT" ? i() : i(c) : Ji(t, o) ? i(new Error(oo(e, n, r))) : tv(e, t, s, r, i));
}
function nv(e, t, n, r) {
  const i = Ie.resolve(Ie.dirname(e)), a = Ie.resolve(Ie.dirname(n));
  if (a === i || a === Ie.parse(a).root) return;
  let s;
  try {
    s = Pr.statSync(a, { bigint: !0 });
  } catch (c) {
    if (c.code === "ENOENT") return;
    throw c;
  }
  if (Ji(t, s))
    throw new Error(oo(e, n, r));
  return nv(e, t, a, r);
}
function Ji(e, t) {
  return t.ino && t.dev && t.ino === e.ino && t.dev === e.dev;
}
function qu(e, t) {
  const n = Ie.resolve(e).split(Ie.sep).filter((i) => i), r = Ie.resolve(t).split(Ie.sep).filter((i) => i);
  return n.reduce((i, a, s) => i && r[s] === a, !0);
}
function oo(e, t, n) {
  return `Cannot ${n} '${e}' to a subdirectory of itself, '${t}'.`;
}
var Mr = {
  checkPaths: I2,
  checkPathsSync: D2,
  checkParentPaths: tv,
  checkParentPathsSync: nv,
  isSrcSubdir: qu,
  areIdentical: Ji
};
const Ze = Ye, wi = ne, F2 = It.mkdirs, P2 = Zn.pathExists, k2 = ev.utimesMillis, Ei = Mr;
function L2(e, t, n, r) {
  typeof n == "function" && !r ? (r = n, n = {}) : typeof n == "function" && (n = { filter: n }), r = r || function() {
  }, n = n || {}, n.clobber = "clobber" in n ? !!n.clobber : !0, n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber, n.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0001"
  ), Ei.checkPaths(e, t, "copy", n, (i, a) => {
    if (i) return r(i);
    const { srcStat: s, destStat: c } = a;
    Ei.checkParentPaths(e, s, t, "copy", (o) => o ? r(o) : n.filter ? rv(Ld, c, e, t, n, r) : Ld(c, e, t, n, r));
  });
}
function Ld(e, t, n, r, i) {
  const a = wi.dirname(n);
  P2(a, (s, c) => {
    if (s) return i(s);
    if (c) return vs(e, t, n, r, i);
    F2(a, (o) => o ? i(o) : vs(e, t, n, r, i));
  });
}
function rv(e, t, n, r, i, a) {
  Promise.resolve(i.filter(n, r)).then((s) => s ? e(t, n, r, i, a) : a(), (s) => a(s));
}
function N2(e, t, n, r, i) {
  return r.filter ? rv(vs, e, t, n, r, i) : vs(e, t, n, r, i);
}
function vs(e, t, n, r, i) {
  (r.dereference ? Ze.stat : Ze.lstat)(t, (s, c) => s ? i(s) : c.isDirectory() ? H2(c, e, t, n, r, i) : c.isFile() || c.isCharacterDevice() || c.isBlockDevice() ? U2(c, e, t, n, r, i) : c.isSymbolicLink() ? V2(e, t, n, r, i) : c.isSocket() ? i(new Error(`Cannot copy a socket file: ${t}`)) : c.isFIFO() ? i(new Error(`Cannot copy a FIFO pipe: ${t}`)) : i(new Error(`Unknown file: ${t}`)));
}
function U2(e, t, n, r, i, a) {
  return t ? B2(e, n, r, i, a) : iv(e, n, r, i, a);
}
function B2(e, t, n, r, i) {
  if (r.overwrite)
    Ze.unlink(n, (a) => a ? i(a) : iv(e, t, n, r, i));
  else return r.errorOnExist ? i(new Error(`'${n}' already exists`)) : i();
}
function iv(e, t, n, r, i) {
  Ze.copyFile(t, n, (a) => a ? i(a) : r.preserveTimestamps ? j2(e.mode, t, n, i) : co(n, e.mode, i));
}
function j2(e, t, n, r) {
  return M2(e) ? q2(n, e, (i) => i ? r(i) : Nd(e, t, n, r)) : Nd(e, t, n, r);
}
function M2(e) {
  return (e & 128) === 0;
}
function q2(e, t, n) {
  return co(e, t | 128, n);
}
function Nd(e, t, n, r) {
  z2(t, n, (i) => i ? r(i) : co(n, e, r));
}
function co(e, t, n) {
  return Ze.chmod(e, t, n);
}
function z2(e, t, n) {
  Ze.stat(e, (r, i) => r ? n(r) : k2(t, i.atime, i.mtime, n));
}
function H2(e, t, n, r, i, a) {
  return t ? av(n, r, i, a) : W2(e.mode, n, r, i, a);
}
function W2(e, t, n, r, i) {
  Ze.mkdir(n, (a) => {
    if (a) return i(a);
    av(t, n, r, (s) => s ? i(s) : co(n, e, i));
  });
}
function av(e, t, n, r) {
  Ze.readdir(e, (i, a) => i ? r(i) : sv(a, e, t, n, r));
}
function sv(e, t, n, r, i) {
  const a = e.pop();
  return a ? G2(e, a, t, n, r, i) : i();
}
function G2(e, t, n, r, i, a) {
  const s = wi.join(n, t), c = wi.join(r, t);
  Ei.checkPaths(s, c, "copy", i, (o, u) => {
    if (o) return a(o);
    const { destStat: l } = u;
    N2(l, s, c, i, (p) => p ? a(p) : sv(e, n, r, i, a));
  });
}
function V2(e, t, n, r, i) {
  Ze.readlink(t, (a, s) => {
    if (a) return i(a);
    if (r.dereference && (s = wi.resolve(process.cwd(), s)), e)
      Ze.readlink(n, (c, o) => c ? c.code === "EINVAL" || c.code === "UNKNOWN" ? Ze.symlink(s, n, i) : i(c) : (r.dereference && (o = wi.resolve(process.cwd(), o)), Ei.isSrcSubdir(s, o) ? i(new Error(`Cannot copy '${s}' to a subdirectory of itself, '${o}'.`)) : e.isDirectory() && Ei.isSrcSubdir(o, s) ? i(new Error(`Cannot overwrite '${o}' with '${s}'.`)) : Y2(s, n, i)));
    else
      return Ze.symlink(s, n, i);
  });
}
function Y2(e, t, n) {
  Ze.unlink(t, (r) => r ? n(r) : Ze.symlink(e, t, n));
}
var X2 = L2;
const je = Ye, _i = ne, K2 = It.mkdirsSync, J2 = ev.utimesMillisSync, Si = Mr;
function Z2(e, t, n) {
  typeof n == "function" && (n = { filter: n }), n = n || {}, n.clobber = "clobber" in n ? !!n.clobber : !0, n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber, n.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0002"
  );
  const { srcStat: r, destStat: i } = Si.checkPathsSync(e, t, "copy", n);
  return Si.checkParentPathsSync(e, r, t, "copy"), Q2(i, e, t, n);
}
function Q2(e, t, n, r) {
  if (r.filter && !r.filter(t, n)) return;
  const i = _i.dirname(n);
  return je.existsSync(i) || K2(i), ov(e, t, n, r);
}
function eS(e, t, n, r) {
  if (!(r.filter && !r.filter(t, n)))
    return ov(e, t, n, r);
}
function ov(e, t, n, r) {
  const a = (r.dereference ? je.statSync : je.lstatSync)(t);
  if (a.isDirectory()) return oS(a, e, t, n, r);
  if (a.isFile() || a.isCharacterDevice() || a.isBlockDevice()) return tS(a, e, t, n, r);
  if (a.isSymbolicLink()) return uS(e, t, n, r);
  throw a.isSocket() ? new Error(`Cannot copy a socket file: ${t}`) : a.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${t}`) : new Error(`Unknown file: ${t}`);
}
function tS(e, t, n, r, i) {
  return t ? nS(e, n, r, i) : cv(e, n, r, i);
}
function nS(e, t, n, r) {
  if (r.overwrite)
    return je.unlinkSync(n), cv(e, t, n, r);
  if (r.errorOnExist)
    throw new Error(`'${n}' already exists`);
}
function cv(e, t, n, r) {
  return je.copyFileSync(t, n), r.preserveTimestamps && rS(e.mode, t, n), zu(n, e.mode);
}
function rS(e, t, n) {
  return iS(e) && aS(n, e), sS(t, n);
}
function iS(e) {
  return (e & 128) === 0;
}
function aS(e, t) {
  return zu(e, t | 128);
}
function zu(e, t) {
  return je.chmodSync(e, t);
}
function sS(e, t) {
  const n = je.statSync(e);
  return J2(t, n.atime, n.mtime);
}
function oS(e, t, n, r, i) {
  return t ? lv(n, r, i) : cS(e.mode, n, r, i);
}
function cS(e, t, n, r) {
  return je.mkdirSync(n), lv(t, n, r), zu(n, e);
}
function lv(e, t, n) {
  je.readdirSync(e).forEach((r) => lS(r, e, t, n));
}
function lS(e, t, n, r) {
  const i = _i.join(t, e), a = _i.join(n, e), { destStat: s } = Si.checkPathsSync(i, a, "copy", r);
  return eS(s, i, a, r);
}
function uS(e, t, n, r) {
  let i = je.readlinkSync(t);
  if (r.dereference && (i = _i.resolve(process.cwd(), i)), e) {
    let a;
    try {
      a = je.readlinkSync(n);
    } catch (s) {
      if (s.code === "EINVAL" || s.code === "UNKNOWN") return je.symlinkSync(i, n);
      throw s;
    }
    if (r.dereference && (a = _i.resolve(process.cwd(), a)), Si.isSrcSubdir(i, a))
      throw new Error(`Cannot copy '${i}' to a subdirectory of itself, '${a}'.`);
    if (je.statSync(n).isDirectory() && Si.isSrcSubdir(a, i))
      throw new Error(`Cannot overwrite '${a}' with '${i}'.`);
    return pS(i, n);
  } else
    return je.symlinkSync(i, n);
}
function pS(e, t) {
  return je.unlinkSync(t), je.symlinkSync(e, t);
}
var fS = Z2;
const dS = Ve.fromCallback;
var Hu = {
  copy: dS(X2),
  copySync: fS
};
const Ud = Ye, uv = ne, ue = Rs, Ai = process.platform === "win32";
function pv(e) {
  [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
<<<<<<< HEAD
  ];
  methods.forEach((m) => {
    options[m] = options[m] || fs$a[m];
    m = m + "Sync";
    options[m] = options[m] || fs$a[m];
  });
  options.maxBusyTries = options.maxBusyTries || 3;
}
function rimraf$1(p, options, cb) {
  let busyTries = 0;
  if (typeof options === "function") {
    cb = options;
    options = {};
  }
  assert(p, "rimraf: missing path");
  assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
  assert(options, "rimraf: invalid options argument provided");
  assert.strictEqual(typeof options, "object", "rimraf: options should be object");
  defaults(options);
  rimraf_(p, options, function CB(er) {
    if (er) {
      if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
        busyTries++;
        const time = busyTries * 100;
        return setTimeout(() => rimraf_(p, options, CB), time);
=======
  ].forEach((n) => {
    e[n] = e[n] || Ud[n], n = n + "Sync", e[n] = e[n] || Ud[n];
  }), e.maxBusyTries = e.maxBusyTries || 3;
}
function Wu(e, t, n) {
  let r = 0;
  typeof t == "function" && (n = t, t = {}), ue(e, "rimraf: missing path"), ue.strictEqual(typeof e, "string", "rimraf: path should be a string"), ue.strictEqual(typeof n, "function", "rimraf: callback function required"), ue(t, "rimraf: invalid options argument provided"), ue.strictEqual(typeof t, "object", "rimraf: options should be object"), pv(t), Bd(e, t, function i(a) {
    if (a) {
      if ((a.code === "EBUSY" || a.code === "ENOTEMPTY" || a.code === "EPERM") && r < t.maxBusyTries) {
        r++;
        const s = r * 100;
        return setTimeout(() => Bd(e, t, i), s);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
      if (er.code === "ENOENT") er = null;
    }
    cb(er);
  });
}
<<<<<<< HEAD
function rimraf_(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT") {
      return cb(null);
    }
    if (er && er.code === "EPERM" && isWindows) {
      return fixWinEPERM(p, options, er, cb);
    }
    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb);
    }
    options.unlink(p, (er2) => {
      if (er2) {
        if (er2.code === "ENOENT") {
          return cb(null);
        }
        if (er2.code === "EPERM") {
          return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
        }
        if (er2.code === "EISDIR") {
          return rmdir(p, options, er2, cb);
        }
=======
function Bd(e, t, n) {
  ue(e), ue(t), ue(typeof n == "function"), t.lstat(e, (r, i) => {
    if (r && r.code === "ENOENT")
      return n(null);
    if (r && r.code === "EPERM" && Ai)
      return jd(e, t, r, n);
    if (i && i.isDirectory())
      return rs(e, t, r, n);
    t.unlink(e, (a) => {
      if (a) {
        if (a.code === "ENOENT")
          return n(null);
        if (a.code === "EPERM")
          return Ai ? jd(e, t, a, n) : rs(e, t, a, n);
        if (a.code === "EISDIR")
          return rs(e, t, a, n);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
      return cb(er2);
    });
  });
}
<<<<<<< HEAD
function fixWinEPERM(p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.chmod(p, 438, (er2) => {
    if (er2) {
      cb(er2.code === "ENOENT" ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === "ENOENT" ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}
function fixWinEPERMSync(p, options, er) {
  let stats;
  assert(p);
  assert(options);
=======
function jd(e, t, n, r) {
  ue(e), ue(t), ue(typeof r == "function"), t.chmod(e, 438, (i) => {
    i ? r(i.code === "ENOENT" ? null : n) : t.stat(e, (a, s) => {
      a ? r(a.code === "ENOENT" ? null : n) : s.isDirectory() ? rs(e, t, n, r) : t.unlink(e, r);
    });
  });
}
function Md(e, t, n) {
  let r;
  ue(e), ue(t);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  try {
    options.chmodSync(p, 438);
  } catch (er2) {
    if (er2.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
<<<<<<< HEAD
}
function rmdir(p, options, originalEr, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.rmdir(p, (er) => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
      rmkids(p, options, cb);
    } else if (er && er.code === "ENOTDIR") {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}
function rmkids(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.readdir(p, (er, files) => {
    if (er) return cb(er);
    let n = files.length;
    let errState;
    if (n === 0) return options.rmdir(p, cb);
    files.forEach((f) => {
      rimraf$1(path$h.join(p, f), options, (er2) => {
        if (errState) {
          return;
        }
        if (er2) return cb(errState = er2);
        if (--n === 0) {
          options.rmdir(p, cb);
=======
  r.isDirectory() ? is(e, t, n) : t.unlinkSync(e);
}
function rs(e, t, n, r) {
  ue(e), ue(t), ue(typeof r == "function"), t.rmdir(e, (i) => {
    i && (i.code === "ENOTEMPTY" || i.code === "EEXIST" || i.code === "EPERM") ? hS(e, t, r) : i && i.code === "ENOTDIR" ? r(n) : r(i);
  });
}
function hS(e, t, n) {
  ue(e), ue(t), ue(typeof n == "function"), t.readdir(e, (r, i) => {
    if (r) return n(r);
    let a = i.length, s;
    if (a === 0) return t.rmdir(e, n);
    i.forEach((c) => {
      Wu(uv.join(e, c), t, (o) => {
        if (!s) {
          if (o) return n(s = o);
          --a === 0 && t.rmdir(e, n);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        }
      });
    });
  });
}
<<<<<<< HEAD
function rimrafSync(p, options) {
  let st;
  options = options || {};
  defaults(options);
  assert(p, "rimraf: missing path");
  assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert(options, "rimraf: missing options");
  assert.strictEqual(typeof options, "object", "rimraf: options should be object");
=======
function fv(e, t) {
  let n;
  t = t || {}, pv(t), ue(e, "rimraf: missing path"), ue.strictEqual(typeof e, "string", "rimraf: path should be a string"), ue(t, "rimraf: missing options"), ue.strictEqual(typeof t, "object", "rimraf: options should be object");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
<<<<<<< HEAD
    }
    if (er.code === "EPERM" && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }
  try {
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    } else if (er.code === "EPERM") {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
    } else if (er.code !== "EISDIR") {
      throw er;
    }
    rmdirSync(p, options, er);
  }
}
function rmdirSync(p, options, originalEr) {
  assert(p);
  assert(options);
  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOTDIR") {
      throw originalEr;
    } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
      rmkidsSync(p, options);
    } else if (er.code !== "ENOENT") {
      throw er;
    }
  }
}
function rmkidsSync(p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach((f) => rimrafSync(path$h.join(p, f), options));
  if (isWindows) {
    const startTime = Date.now();
    do {
=======
    r.code === "EPERM" && Ai && Md(e, t, r);
  }
  try {
    n && n.isDirectory() ? is(e, t, null) : t.unlinkSync(e);
  } catch (r) {
    if (r.code === "ENOENT")
      return;
    if (r.code === "EPERM")
      return Ai ? Md(e, t, r) : is(e, t, r);
    if (r.code !== "EISDIR")
      throw r;
    is(e, t, r);
  }
}
function is(e, t, n) {
  ue(e), ue(t);
  try {
    t.rmdirSync(e);
  } catch (r) {
    if (r.code === "ENOTDIR")
      throw n;
    if (r.code === "ENOTEMPTY" || r.code === "EEXIST" || r.code === "EPERM")
      mS(e, t);
    else if (r.code !== "ENOENT")
      throw r;
  }
}
function mS(e, t) {
  if (ue(e), ue(t), t.readdirSync(e).forEach((n) => fv(uv.join(e, n), t)), Ai) {
    const n = Date.now();
    do
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      try {
        const ret = options.rmdirSync(p, options);
        return ret;
      } catch {
      }
<<<<<<< HEAD
    } while (Date.now() - startTime < 500);
  } else {
    const ret = options.rmdirSync(p, options);
    return ret;
  }
}
var rimraf_1 = rimraf$1;
rimraf$1.sync = rimrafSync;
const fs$9 = gracefulFs;
const u$7 = universalify$1.fromCallback;
const rimraf = rimraf_1;
function remove$2(path2, callback) {
  if (fs$9.rm) return fs$9.rm(path2, { recursive: true, force: true }, callback);
  rimraf(path2, callback);
}
function removeSync$1(path2) {
  if (fs$9.rmSync) return fs$9.rmSync(path2, { recursive: true, force: true });
  rimraf.sync(path2);
}
var remove_1 = {
  remove: u$7(remove$2),
  removeSync: removeSync$1
};
const u$6 = universalify$1.fromPromise;
const fs$8 = fs$i;
const path$g = require$$1$4;
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;
const emptyDir = u$6(async function emptyDir2(dir) {
  let items;
  try {
    items = await fs$8.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir);
  }
  return Promise.all(items.map((item) => remove$1.remove(path$g.join(dir, item))));
});
function emptyDirSync(dir) {
  let items;
  try {
    items = fs$8.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir);
  }
  items.forEach((item) => {
    item = path$g.join(dir, item);
    remove$1.removeSync(item);
  });
}
var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};
const u$5 = universalify$1.fromCallback;
const path$f = require$$1$4;
const fs$7 = gracefulFs;
const mkdir$2 = mkdirs$2;
function createFile$1(file2, callback) {
  function makeFile() {
    fs$7.writeFile(file2, "", (err) => {
      if (err) return callback(err);
      callback();
    });
  }
  fs$7.stat(file2, (err, stats) => {
    if (!err && stats.isFile()) return callback();
    const dir = path$f.dirname(file2);
    fs$7.stat(dir, (err2, stats2) => {
      if (err2) {
        if (err2.code === "ENOENT") {
          return mkdir$2.mkdirs(dir, (err3) => {
            if (err3) return callback(err3);
            makeFile();
          });
        }
        return callback(err2);
      }
      if (stats2.isDirectory()) makeFile();
      else {
        fs$7.readdir(dir, (err3) => {
          if (err3) return callback(err3);
        });
      }
    });
  });
}
function createFileSync$1(file2) {
  let stats;
  try {
    stats = fs$7.statSync(file2);
  } catch {
  }
  if (stats && stats.isFile()) return;
  const dir = path$f.dirname(file2);
  try {
    if (!fs$7.statSync(dir).isDirectory()) {
      fs$7.readdirSync(dir);
    }
  } catch (err) {
    if (err && err.code === "ENOENT") mkdir$2.mkdirsSync(dir);
    else throw err;
  }
  fs$7.writeFileSync(file2, "");
}
var file = {
  createFile: u$5(createFile$1),
  createFileSync: createFileSync$1
};
const u$4 = universalify$1.fromCallback;
const path$e = require$$1$4;
const fs$6 = gracefulFs;
const mkdir$1 = mkdirs$2;
const pathExists$4 = pathExists_1.pathExists;
const { areIdentical: areIdentical$1 } = stat$4;
function createLink$1(srcpath, dstpath, callback) {
  function makeLink(srcpath2, dstpath2) {
    fs$6.link(srcpath2, dstpath2, (err) => {
      if (err) return callback(err);
      callback(null);
    });
  }
  fs$6.lstat(dstpath, (_, dstStat) => {
    fs$6.lstat(srcpath, (err, srcStat) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        return callback(err);
      }
      if (dstStat && areIdentical$1(srcStat, dstStat)) return callback(null);
      const dir = path$e.dirname(dstpath);
      pathExists$4(dir, (err2, dirExists) => {
        if (err2) return callback(err2);
        if (dirExists) return makeLink(srcpath, dstpath);
        mkdir$1.mkdirs(dir, (err3) => {
          if (err3) return callback(err3);
          makeLink(srcpath, dstpath);
=======
    while (Date.now() - n < 500);
  } else
    return t.rmdirSync(e, t);
}
var vS = Wu;
Wu.sync = fv;
const gs = Ye, gS = Ve.fromCallback, dv = vS;
function bS(e, t) {
  if (gs.rm) return gs.rm(e, { recursive: !0, force: !0 }, t);
  dv(e, t);
}
function xS(e) {
  if (gs.rmSync) return gs.rmSync(e, { recursive: !0, force: !0 });
  dv.sync(e);
}
var lo = {
  remove: gS(bS),
  removeSync: xS
};
const yS = Ve.fromPromise, hv = Jn, mv = ne, vv = It, gv = lo, qd = yS(async function(t) {
  let n;
  try {
    n = await hv.readdir(t);
  } catch {
    return vv.mkdirs(t);
  }
  return Promise.all(n.map((r) => gv.remove(mv.join(t, r))));
});
function zd(e) {
  let t;
  try {
    t = hv.readdirSync(e);
  } catch {
    return vv.mkdirsSync(e);
  }
  t.forEach((n) => {
    n = mv.join(e, n), gv.removeSync(n);
  });
}
var wS = {
  emptyDirSync: zd,
  emptydirSync: zd,
  emptyDir: qd,
  emptydir: qd
};
const ES = Ve.fromCallback, bv = ne, rn = Ye, xv = It;
function _S(e, t) {
  function n() {
    rn.writeFile(e, "", (r) => {
      if (r) return t(r);
      t();
    });
  }
  rn.stat(e, (r, i) => {
    if (!r && i.isFile()) return t();
    const a = bv.dirname(e);
    rn.stat(a, (s, c) => {
      if (s)
        return s.code === "ENOENT" ? xv.mkdirs(a, (o) => {
          if (o) return t(o);
          n();
        }) : t(s);
      c.isDirectory() ? n() : rn.readdir(a, (o) => {
        if (o) return t(o);
      });
    });
  });
}
function SS(e) {
  let t;
  try {
    t = rn.statSync(e);
  } catch {
  }
  if (t && t.isFile()) return;
  const n = bv.dirname(e);
  try {
    rn.statSync(n).isDirectory() || rn.readdirSync(n);
  } catch (r) {
    if (r && r.code === "ENOENT") xv.mkdirsSync(n);
    else throw r;
  }
  rn.writeFileSync(e, "");
}
var AS = {
  createFile: ES(_S),
  createFileSync: SS
};
const TS = Ve.fromCallback, yv = ne, tn = Ye, wv = It, CS = Zn.pathExists, { areIdentical: Ev } = Mr;
function RS(e, t, n) {
  function r(i, a) {
    tn.link(i, a, (s) => {
      if (s) return n(s);
      n(null);
    });
  }
  tn.lstat(t, (i, a) => {
    tn.lstat(e, (s, c) => {
      if (s)
        return s.message = s.message.replace("lstat", "ensureLink"), n(s);
      if (a && Ev(c, a)) return n(null);
      const o = yv.dirname(t);
      CS(o, (u, l) => {
        if (u) return n(u);
        if (l) return r(e, t);
        wv.mkdirs(o, (p) => {
          if (p) return n(p);
          r(e, t);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        });
      });
    });
  });
}
<<<<<<< HEAD
function createLinkSync$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$6.lstatSync(dstpath);
  } catch {
  }
  try {
    const srcStat = fs$6.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat)) return;
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  const dir = path$e.dirname(dstpath);
  const dirExists = fs$6.existsSync(dir);
  if (dirExists) return fs$6.linkSync(srcpath, dstpath);
  mkdir$1.mkdirsSync(dir);
  return fs$6.linkSync(srcpath, dstpath);
}
var link = {
  createLink: u$4(createLink$1),
  createLinkSync: createLinkSync$1
};
const path$d = require$$1$4;
const fs$5 = gracefulFs;
const pathExists$3 = pathExists_1.pathExists;
function symlinkPaths$1(srcpath, dstpath, callback) {
  if (path$d.isAbsolute(srcpath)) {
    return fs$5.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        return callback(err);
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      });
    });
  } else {
    const dstdir = path$d.dirname(dstpath);
    const relativeToDst = path$d.join(dstdir, srcpath);
    return pathExists$3(relativeToDst, (err, exists) => {
      if (err) return callback(err);
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        });
      } else {
        return fs$5.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureSymlink");
            return callback(err2);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path$d.relative(dstdir, srcpath)
          });
        });
      }
    });
  }
}
function symlinkPathsSync$1(srcpath, dstpath) {
  let exists;
  if (path$d.isAbsolute(srcpath)) {
    exists = fs$5.existsSync(srcpath);
    if (!exists) throw new Error("absolute srcpath does not exist");
=======
function $S(e, t) {
  let n;
  try {
    n = tn.lstatSync(t);
  } catch {
  }
  try {
    const a = tn.lstatSync(e);
    if (n && Ev(a, n)) return;
  } catch (a) {
    throw a.message = a.message.replace("lstat", "ensureLink"), a;
  }
  const r = yv.dirname(t);
  return tn.existsSync(r) || wv.mkdirsSync(r), tn.linkSync(e, t);
}
var OS = {
  createLink: TS(RS),
  createLinkSync: $S
};
const an = ne, pi = Ye, IS = Zn.pathExists;
function DS(e, t, n) {
  if (an.isAbsolute(e))
    return pi.lstat(e, (r) => r ? (r.message = r.message.replace("lstat", "ensureSymlink"), n(r)) : n(null, {
      toCwd: e,
      toDst: e
    }));
  {
    const r = an.dirname(t), i = an.join(r, e);
    return IS(i, (a, s) => a ? n(a) : s ? n(null, {
      toCwd: i,
      toDst: e
    }) : pi.lstat(e, (c) => c ? (c.message = c.message.replace("lstat", "ensureSymlink"), n(c)) : n(null, {
      toCwd: e,
      toDst: an.relative(r, e)
    })));
  }
}
function FS(e, t) {
  let n;
  if (an.isAbsolute(e)) {
    if (n = pi.existsSync(e), !n) throw new Error("absolute srcpath does not exist");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  } else {
<<<<<<< HEAD
    const dstdir = path$d.dirname(dstpath);
    const relativeToDst = path$d.join(dstdir, srcpath);
    exists = fs$5.existsSync(relativeToDst);
    if (exists) {
=======
    const r = an.dirname(t), i = an.join(r, e);
    if (n = pi.existsSync(i), n)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
<<<<<<< HEAD
    } else {
      exists = fs$5.existsSync(srcpath);
      if (!exists) throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path$d.relative(dstdir, srcpath)
      };
    }
  }
}
var symlinkPaths_1 = {
  symlinkPaths: symlinkPaths$1,
  symlinkPathsSync: symlinkPathsSync$1
};
const fs$4 = gracefulFs;
function symlinkType$1(srcpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  if (type2) return callback(null, type2);
  fs$4.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, "file");
    type2 = stats && stats.isDirectory() ? "dir" : "file";
    callback(null, type2);
  });
}
function symlinkTypeSync$1(srcpath, type2) {
  let stats;
  if (type2) return type2;
  try {
    stats = fs$4.lstatSync(srcpath);
=======
    if (n = pi.existsSync(e), !n) throw new Error("relative srcpath does not exist");
    return {
      toCwd: e,
      toDst: an.relative(r, e)
    };
  }
}
var PS = {
  symlinkPaths: DS,
  symlinkPathsSync: FS
};
const _v = Ye;
function kS(e, t, n) {
  if (n = typeof t == "function" ? t : n, t = typeof t == "function" ? !1 : t, t) return n(null, t);
  _v.lstat(e, (r, i) => {
    if (r) return n(null, "file");
    t = i && i.isDirectory() ? "dir" : "file", n(null, t);
  });
}
function LS(e, t) {
  let n;
  if (t) return t;
  try {
    n = _v.lstatSync(e);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
<<<<<<< HEAD
var symlinkType_1 = {
  symlinkType: symlinkType$1,
  symlinkTypeSync: symlinkTypeSync$1
};
const u$3 = universalify$1.fromCallback;
const path$c = require$$1$4;
const fs$3 = fs$i;
const _mkdirs = mkdirs$2;
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;
const _symlinkPaths = symlinkPaths_1;
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
const _symlinkType = symlinkType_1;
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;
const pathExists$2 = pathExists_1.pathExists;
const { areIdentical } = stat$4;
function createSymlink$1(srcpath, dstpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  fs$3.lstat(dstpath, (err, stats) => {
    if (!err && stats.isSymbolicLink()) {
      Promise.all([
        fs$3.stat(srcpath),
        fs$3.stat(dstpath)
      ]).then(([srcStat, dstStat]) => {
        if (areIdentical(srcStat, dstStat)) return callback(null);
        _createSymlink(srcpath, dstpath, type2, callback);
      });
    } else _createSymlink(srcpath, dstpath, type2, callback);
  });
}
function _createSymlink(srcpath, dstpath, type2, callback) {
  symlinkPaths(srcpath, dstpath, (err, relative) => {
    if (err) return callback(err);
    srcpath = relative.toDst;
    symlinkType(relative.toCwd, type2, (err2, type3) => {
      if (err2) return callback(err2);
      const dir = path$c.dirname(dstpath);
      pathExists$2(dir, (err3, dirExists) => {
        if (err3) return callback(err3);
        if (dirExists) return fs$3.symlink(srcpath, dstpath, type3, callback);
        mkdirs(dir, (err4) => {
          if (err4) return callback(err4);
          fs$3.symlink(srcpath, dstpath, type3, callback);
=======
var NS = {
  symlinkType: kS,
  symlinkTypeSync: LS
};
const US = Ve.fromCallback, Sv = ne, mt = Jn, Av = It, BS = Av.mkdirs, jS = Av.mkdirsSync, Tv = PS, MS = Tv.symlinkPaths, qS = Tv.symlinkPathsSync, Cv = NS, zS = Cv.symlinkType, HS = Cv.symlinkTypeSync, WS = Zn.pathExists, { areIdentical: Rv } = Mr;
function GS(e, t, n, r) {
  r = typeof n == "function" ? n : r, n = typeof n == "function" ? !1 : n, mt.lstat(t, (i, a) => {
    !i && a.isSymbolicLink() ? Promise.all([
      mt.stat(e),
      mt.stat(t)
    ]).then(([s, c]) => {
      if (Rv(s, c)) return r(null);
      Hd(e, t, n, r);
    }) : Hd(e, t, n, r);
  });
}
function Hd(e, t, n, r) {
  MS(e, t, (i, a) => {
    if (i) return r(i);
    e = a.toDst, zS(a.toCwd, n, (s, c) => {
      if (s) return r(s);
      const o = Sv.dirname(t);
      WS(o, (u, l) => {
        if (u) return r(u);
        if (l) return mt.symlink(e, t, c, r);
        BS(o, (p) => {
          if (p) return r(p);
          mt.symlink(e, t, c, r);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        });
      });
    });
  });
}
<<<<<<< HEAD
function createSymlinkSync$1(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = fs$3.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$3.statSync(srcpath);
    const dstStat = fs$3.statSync(dstpath);
    if (areIdentical(srcStat, dstStat)) return;
  }
  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type2 = symlinkTypeSync(relative.toCwd, type2);
  const dir = path$c.dirname(dstpath);
  const exists = fs$3.existsSync(dir);
  if (exists) return fs$3.symlinkSync(srcpath, dstpath, type2);
  mkdirsSync(dir);
  return fs$3.symlinkSync(srcpath, dstpath, type2);
}
var symlink = {
  createSymlink: u$3(createSymlink$1),
  createSymlinkSync: createSymlinkSync$1
};
const { createFile, createFileSync } = file;
const { createLink, createLinkSync } = link;
const { createSymlink, createSymlinkSync } = symlink;
var ensure = {
  // file
  createFile,
  createFileSync,
  ensureFile: createFile,
  ensureFileSync: createFileSync,
  // link
  createLink,
  createLinkSync,
  ensureLink: createLink,
  ensureLinkSync: createLinkSync,
  // symlink
  createSymlink,
  createSymlinkSync,
  ensureSymlink: createSymlink,
  ensureSymlinkSync: createSymlinkSync
};
function stringify$4(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : "";
  const str2 = JSON.stringify(obj, replacer, spaces);
  return str2.replace(/\n/g, EOL) + EOF;
}
function stripBom$1(content) {
  if (Buffer.isBuffer(content)) content = content.toString("utf8");
  return content.replace(/^\uFEFF/, "");
}
var utils = { stringify: stringify$4, stripBom: stripBom$1 };
let _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = fs$w;
}
const universalify = universalify$1;
const { stringify: stringify$3, stripBom } = utils;
async function _readFile(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  let data = await universalify.fromCallback(fs2.readFile)(file2, options);
  data = stripBom(data);
  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
=======
function VS(e, t, n) {
  let r;
  try {
    r = mt.lstatSync(t);
  } catch {
  }
  if (r && r.isSymbolicLink()) {
    const c = mt.statSync(e), o = mt.statSync(t);
    if (Rv(c, o)) return;
  }
  const i = qS(e, t);
  e = i.toDst, n = HS(i.toCwd, n);
  const a = Sv.dirname(t);
  return mt.existsSync(a) || jS(a), mt.symlinkSync(e, t, n);
}
var YS = {
  createSymlink: US(GS),
  createSymlinkSync: VS
};
const { createFile: Wd, createFileSync: Gd } = AS, { createLink: Vd, createLinkSync: Yd } = OS, { createSymlink: Xd, createSymlinkSync: Kd } = YS;
var XS = {
  // file
  createFile: Wd,
  createFileSync: Gd,
  ensureFile: Wd,
  ensureFileSync: Gd,
  // link
  createLink: Vd,
  createLinkSync: Yd,
  ensureLink: Vd,
  ensureLinkSync: Yd,
  // symlink
  createSymlink: Xd,
  createSymlinkSync: Kd,
  ensureSymlink: Xd,
  ensureSymlinkSync: Kd
};
function KS(e, { EOL: t = `
`, finalEOL: n = !0, replacer: r = null, spaces: i } = {}) {
  const a = n ? t : "";
  return JSON.stringify(e, r, i).replace(/\n/g, t) + a;
}
function JS(e) {
  return Buffer.isBuffer(e) && (e = e.toString("utf8")), e.replace(/^\uFEFF/, "");
}
var Gu = { stringify: KS, stripBom: JS };
let kr;
try {
  kr = Ye;
} catch {
  kr = se;
}
const uo = Ve, { stringify: $v, stripBom: Ov } = Gu;
async function ZS(e, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const n = t.fs || kr, r = "throws" in t ? t.throws : !0;
  let i = await uo.fromCallback(n.readFile)(e, t);
  i = Ov(i);
  let a;
  try {
    a = JSON.parse(i, t ? t.reviver : null);
  } catch (s) {
    if (r)
      throw s.message = `${e}: ${s.message}`, s;
    return null;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  return obj;
}
<<<<<<< HEAD
const readFile = universalify.fromPromise(_readFile);
function readFileSync(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  try {
    let content = fs2.readFileSync(file2, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
}
async function _writeFile(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$3(obj, options);
  await universalify.fromCallback(fs2.writeFile)(file2, str2, options);
}
const writeFile = universalify.fromPromise(_writeFile);
function writeFileSync(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$3(obj, options);
  return fs2.writeFileSync(file2, str2, options);
}
const jsonfile$1 = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync
};
var jsonfile_1 = jsonfile$1;
const jsonFile$1 = jsonfile_1;
var jsonfile = {
  // jsonfile exports
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};
const u$2 = universalify$1.fromCallback;
const fs$2 = gracefulFs;
const path$b = require$$1$4;
const mkdir = mkdirs$2;
const pathExists$1 = pathExists_1.pathExists;
function outputFile$1(file2, data, encoding, callback) {
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = "utf8";
  }
  const dir = path$b.dirname(file2);
  pathExists$1(dir, (err, itDoes) => {
    if (err) return callback(err);
    if (itDoes) return fs$2.writeFile(file2, data, encoding, callback);
    mkdir.mkdirs(dir, (err2) => {
      if (err2) return callback(err2);
      fs$2.writeFile(file2, data, encoding, callback);
    });
  });
}
function outputFileSync$1(file2, ...args) {
  const dir = path$b.dirname(file2);
  if (fs$2.existsSync(dir)) {
    return fs$2.writeFileSync(file2, ...args);
  }
  mkdir.mkdirsSync(dir);
  fs$2.writeFileSync(file2, ...args);
}
var outputFile_1 = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};
const { stringify: stringify$2 } = utils;
const { outputFile } = outputFile_1;
async function outputJson(file2, data, options = {}) {
  const str2 = stringify$2(data, options);
  await outputFile(file2, str2, options);
}
var outputJson_1 = outputJson;
const { stringify: stringify$1 } = utils;
const { outputFileSync } = outputFile_1;
function outputJsonSync(file2, data, options) {
  const str2 = stringify$1(data, options);
  outputFileSync(file2, str2, options);
}
var outputJsonSync_1 = outputJsonSync;
const u$1 = universalify$1.fromPromise;
const jsonFile = jsonfile;
jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
var json$1 = jsonFile;
const fs$1 = gracefulFs;
const path$a = require$$1$4;
const copy2 = copy$1.copy;
const remove = remove_1.remove;
const mkdirp = mkdirs$2.mkdirp;
const pathExists = pathExists_1.pathExists;
const stat$1 = stat$4;
function move$1(src2, dest, opts, cb) {
  if (typeof opts === "function") {
    cb = opts;
    opts = {};
  }
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;
  stat$1.checkPaths(src2, dest, "move", opts, (err, stats) => {
    if (err) return cb(err);
    const { srcStat, isChangingCase = false } = stats;
    stat$1.checkParentPaths(src2, srcStat, dest, "move", (err2) => {
      if (err2) return cb(err2);
      if (isParentRoot$1(dest)) return doRename$1(src2, dest, overwrite, isChangingCase, cb);
      mkdirp(path$a.dirname(dest), (err3) => {
        if (err3) return cb(err3);
        return doRename$1(src2, dest, overwrite, isChangingCase, cb);
      });
    });
  });
}
function isParentRoot$1(dest) {
  const parent = path$a.dirname(dest);
  const parsedPath = path$a.parse(parent);
  return parsedPath.root === parent;
}
function doRename$1(src2, dest, overwrite, isChangingCase, cb) {
  if (isChangingCase) return rename$1(src2, dest, overwrite, cb);
  if (overwrite) {
    return remove(dest, (err) => {
      if (err) return cb(err);
      return rename$1(src2, dest, overwrite, cb);
    });
  }
  pathExists(dest, (err, destExists) => {
    if (err) return cb(err);
    if (destExists) return cb(new Error("dest already exists."));
    return rename$1(src2, dest, overwrite, cb);
  });
}
function rename$1(src2, dest, overwrite, cb) {
  fs$1.rename(src2, dest, (err) => {
    if (!err) return cb();
    if (err.code !== "EXDEV") return cb(err);
    return moveAcrossDevice$1(src2, dest, overwrite, cb);
  });
}
function moveAcrossDevice$1(src2, dest, overwrite, cb) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copy2(src2, dest, opts, (err) => {
    if (err) return cb(err);
    return remove(src2, cb);
  });
}
var move_1 = move$1;
const fs = gracefulFs;
const path$9 = require$$1$4;
const copySync = copy$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat = stat$4;
function moveSync(src2, dest, opts) {
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;
  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src2, dest, "move", opts);
  stat.checkParentPathsSync(src2, srcStat, dest, "move");
  if (!isParentRoot(dest)) mkdirpSync(path$9.dirname(dest));
  return doRename(src2, dest, overwrite, isChangingCase);
}
function isParentRoot(dest) {
  const parent = path$9.dirname(dest);
  const parsedPath = path$9.parse(parent);
  return parsedPath.root === parent;
}
function doRename(src2, dest, overwrite, isChangingCase) {
  if (isChangingCase) return rename(src2, dest, overwrite);
  if (overwrite) {
    removeSync(dest);
    return rename(src2, dest, overwrite);
  }
  if (fs.existsSync(dest)) throw new Error("dest already exists.");
  return rename(src2, dest, overwrite);
}
function rename(src2, dest, overwrite) {
  try {
    fs.renameSync(src2, dest);
  } catch (err) {
    if (err.code !== "EXDEV") throw err;
    return moveAcrossDevice(src2, dest, overwrite);
  }
}
function moveAcrossDevice(src2, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copySync(src2, dest, opts);
  return removeSync(src2);
}
var moveSync_1 = moveSync;
const u = universalify$1.fromCallback;
var move = {
  move: u(move_1),
  moveSync: moveSync_1
};
var lib = {
  // Export promiseified graceful-fs:
  ...fs$i,
  // Export extra methods:
  ...copy$1,
  ...empty,
  ...ensure,
  ...json$1,
  ...mkdirs$2,
  ...move,
  ...outputFile_1,
  ...pathExists_1,
  ...remove_1
};
var BaseUpdater$1 = {};
var AppUpdater$1 = {};
var out = {};
var CancellationToken$1 = {};
Object.defineProperty(CancellationToken$1, "__esModule", { value: true });
CancellationToken$1.CancellationError = CancellationToken$1.CancellationToken = void 0;
const events_1$1 = require$$0$6;
class CancellationToken extends events_1$1.EventEmitter {
=======
const QS = uo.fromPromise(ZS);
function e5(e, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const n = t.fs || kr, r = "throws" in t ? t.throws : !0;
  try {
    let i = n.readFileSync(e, t);
    return i = Ov(i), JSON.parse(i, t.reviver);
  } catch (i) {
    if (r)
      throw i.message = `${e}: ${i.message}`, i;
    return null;
  }
}
async function t5(e, t, n = {}) {
  const r = n.fs || kr, i = $v(t, n);
  await uo.fromCallback(r.writeFile)(e, i, n);
}
const n5 = uo.fromPromise(t5);
function r5(e, t, n = {}) {
  const r = n.fs || kr, i = $v(t, n);
  return r.writeFileSync(e, i, n);
}
const i5 = {
  readFile: QS,
  readFileSync: e5,
  writeFile: n5,
  writeFileSync: r5
};
var a5 = i5;
const Fa = a5;
var s5 = {
  // jsonfile exports
  readJson: Fa.readFile,
  readJsonSync: Fa.readFileSync,
  writeJson: Fa.writeFile,
  writeJsonSync: Fa.writeFileSync
};
const o5 = Ve.fromCallback, fi = Ye, Iv = ne, Dv = It, c5 = Zn.pathExists;
function l5(e, t, n, r) {
  typeof n == "function" && (r = n, n = "utf8");
  const i = Iv.dirname(e);
  c5(i, (a, s) => {
    if (a) return r(a);
    if (s) return fi.writeFile(e, t, n, r);
    Dv.mkdirs(i, (c) => {
      if (c) return r(c);
      fi.writeFile(e, t, n, r);
    });
  });
}
function u5(e, ...t) {
  const n = Iv.dirname(e);
  if (fi.existsSync(n))
    return fi.writeFileSync(e, ...t);
  Dv.mkdirsSync(n), fi.writeFileSync(e, ...t);
}
var Vu = {
  outputFile: o5(l5),
  outputFileSync: u5
};
const { stringify: p5 } = Gu, { outputFile: f5 } = Vu;
async function d5(e, t, n = {}) {
  const r = p5(t, n);
  await f5(e, r, n);
}
var h5 = d5;
const { stringify: m5 } = Gu, { outputFileSync: v5 } = Vu;
function g5(e, t, n) {
  const r = m5(t, n);
  v5(e, r, n);
}
var b5 = g5;
const x5 = Ve.fromPromise, We = s5;
We.outputJson = x5(h5);
We.outputJsonSync = b5;
We.outputJSON = We.outputJson;
We.outputJSONSync = We.outputJsonSync;
We.writeJSON = We.writeJson;
We.writeJSONSync = We.writeJsonSync;
We.readJSON = We.readJson;
We.readJSONSync = We.readJsonSync;
var y5 = We;
const w5 = Ye, Ll = ne, E5 = Hu.copy, Fv = lo.remove, _5 = It.mkdirp, S5 = Zn.pathExists, Jd = Mr;
function A5(e, t, n, r) {
  typeof n == "function" && (r = n, n = {}), n = n || {};
  const i = n.overwrite || n.clobber || !1;
  Jd.checkPaths(e, t, "move", n, (a, s) => {
    if (a) return r(a);
    const { srcStat: c, isChangingCase: o = !1 } = s;
    Jd.checkParentPaths(e, c, t, "move", (u) => {
      if (u) return r(u);
      if (T5(t)) return Zd(e, t, i, o, r);
      _5(Ll.dirname(t), (l) => l ? r(l) : Zd(e, t, i, o, r));
    });
  });
}
function T5(e) {
  const t = Ll.dirname(e);
  return Ll.parse(t).root === t;
}
function Zd(e, t, n, r, i) {
  if (r) return Gc(e, t, n, i);
  if (n)
    return Fv(t, (a) => a ? i(a) : Gc(e, t, n, i));
  S5(t, (a, s) => a ? i(a) : s ? i(new Error("dest already exists.")) : Gc(e, t, n, i));
}
function Gc(e, t, n, r) {
  w5.rename(e, t, (i) => i ? i.code !== "EXDEV" ? r(i) : C5(e, t, n, r) : r());
}
function C5(e, t, n, r) {
  E5(e, t, {
    overwrite: n,
    errorOnExist: !0
  }, (a) => a ? r(a) : Fv(e, r));
}
var R5 = A5;
const Pv = Ye, Nl = ne, $5 = Hu.copySync, kv = lo.removeSync, O5 = It.mkdirpSync, Qd = Mr;
function I5(e, t, n) {
  n = n || {};
  const r = n.overwrite || n.clobber || !1, { srcStat: i, isChangingCase: a = !1 } = Qd.checkPathsSync(e, t, "move", n);
  return Qd.checkParentPathsSync(e, i, t, "move"), D5(t) || O5(Nl.dirname(t)), F5(e, t, r, a);
}
function D5(e) {
  const t = Nl.dirname(e);
  return Nl.parse(t).root === t;
}
function F5(e, t, n, r) {
  if (r) return Vc(e, t, n);
  if (n)
    return kv(t), Vc(e, t, n);
  if (Pv.existsSync(t)) throw new Error("dest already exists.");
  return Vc(e, t, n);
}
function Vc(e, t, n) {
  try {
    Pv.renameSync(e, t);
  } catch (r) {
    if (r.code !== "EXDEV") throw r;
    return P5(e, t, n);
  }
}
function P5(e, t, n) {
  return $5(e, t, {
    overwrite: n,
    errorOnExist: !0
  }), kv(e);
}
var k5 = I5;
const L5 = Ve.fromCallback;
var N5 = {
  move: L5(R5),
  moveSync: k5
}, yn = {
  // Export promiseified graceful-fs:
  ...Jn,
  // Export extra methods:
  ...Hu,
  ...wS,
  ...XS,
  ...y5,
  ...It,
  ...N5,
  ...Vu,
  ...Zn,
  ...lo
}, zt = {}, fn = {}, Fe = {}, dn = {};
Object.defineProperty(dn, "__esModule", { value: !0 });
dn.CancellationError = dn.CancellationToken = void 0;
const U5 = Yn;
class B5 extends U5.EventEmitter {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  get cancelled() {
    return this._cancelled || this._parent != null && this._parent.cancelled;
  }
  set parent(value) {
    this.removeParentCancelHandler();
    this._parent = value;
    this.parentCancelHandler = () => this.cancel();
    this._parent.onCancel(this.parentCancelHandler);
  }
  // babel cannot compile ... correctly for super calls
  constructor(parent) {
    super();
    this.parentCancelHandler = null;
    this._parent = null;
    this._cancelled = false;
    if (parent != null) {
      this.parent = parent;
    }
  }
  cancel() {
    this._cancelled = true;
    this.emit("cancel");
  }
  onCancel(handler) {
    if (this.cancelled) {
      handler();
    } else {
      this.once("cancel", handler);
    }
  }
<<<<<<< HEAD
  createPromise(callback) {
    if (this.cancelled) {
      return Promise.reject(new CancellationError());
    }
    const finallyHandler = () => {
      if (cancelHandler != null) {
=======
  createPromise(t) {
    if (this.cancelled)
      return Promise.reject(new Ul());
    const n = () => {
      if (r != null)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        try {
          this.removeListener("cancel", cancelHandler);
          cancelHandler = null;
        } catch (_ignore) {
        }
      }
    };
<<<<<<< HEAD
    let cancelHandler = null;
    return new Promise((resolve, reject) => {
      let addedCancelHandler = null;
      cancelHandler = () => {
        try {
          if (addedCancelHandler != null) {
            addedCancelHandler();
            addedCancelHandler = null;
          }
        } finally {
          reject(new CancellationError());
=======
    let r = null;
    return new Promise((i, a) => {
      let s = null;
      if (r = () => {
        try {
          s != null && (s(), s = null);
        } finally {
          a(new Ul());
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        }
      };
      if (this.cancelled) {
        cancelHandler();
        return;
      }
<<<<<<< HEAD
      this.onCancel(cancelHandler);
      callback(resolve, reject, (callback2) => {
        addedCancelHandler = callback2;
=======
      this.onCancel(r), t(i, a, (c) => {
        s = c;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      });
    }).then((it) => {
      finallyHandler();
      return it;
    }).catch((e) => {
      finallyHandler();
      throw e;
    });
  }
  removeParentCancelHandler() {
    const parent = this._parent;
    if (parent != null && this.parentCancelHandler != null) {
      parent.removeListener("cancel", this.parentCancelHandler);
      this.parentCancelHandler = null;
    }
  }
  dispose() {
    try {
      this.removeParentCancelHandler();
    } finally {
      this.removeAllListeners();
      this._parent = null;
    }
  }
}
<<<<<<< HEAD
CancellationToken$1.CancellationToken = CancellationToken;
class CancellationError extends Error {
=======
dn.CancellationToken = B5;
class Ul extends Error {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  constructor() {
    super("cancelled");
  }
}
<<<<<<< HEAD
CancellationToken$1.CancellationError = CancellationError;
var error = {};
Object.defineProperty(error, "__esModule", { value: true });
error.newError = newError;
function newError(message, code) {
  const error2 = new Error(message);
  error2.code = code;
  return error2;
}
var httpExecutor = {};
var ProgressCallbackTransform$1 = {};
Object.defineProperty(ProgressCallbackTransform$1, "__esModule", { value: true });
ProgressCallbackTransform$1.ProgressCallbackTransform = void 0;
const stream_1$3 = require$$1$2;
class ProgressCallbackTransform extends stream_1$3.Transform {
  constructor(total, cancellationToken, onProgress) {
    super();
    this.total = total;
    this.cancellationToken = cancellationToken;
    this.onProgress = onProgress;
    this.start = Date.now();
    this.transferred = 0;
    this.delta = 0;
    this.nextUpdate = this.start + 1e3;
=======
dn.CancellationError = Ul;
var qr = {};
Object.defineProperty(qr, "__esModule", { value: !0 });
qr.newError = j5;
function j5(e, t) {
  const n = new Error(e);
  return n.code = t, n;
}
var He = {}, Zi = {};
Object.defineProperty(Zi, "__esModule", { value: !0 });
Zi.ProgressCallbackTransform = void 0;
const M5 = ae;
class q5 extends M5.Transform {
  constructor(t, n, r) {
    super(), this.total = t, this.cancellationToken = n, this.onProgress = r, this.start = Date.now(), this.transferred = 0, this.delta = 0, this.nextUpdate = this.start + 1e3;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  _transform(chunk, encoding, callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"), null);
      return;
    }
    this.transferred += chunk.length;
    this.delta += chunk.length;
    const now = Date.now();
    if (now >= this.nextUpdate && this.transferred !== this.total) {
      this.nextUpdate = now + 1e3;
      this.onProgress({
        total: this.total,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.total * 100,
        bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))
      });
      this.delta = 0;
    }
    callback(null, chunk);
  }
  _flush(callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.total,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
    this.delta = 0;
    callback(null);
  }
}
<<<<<<< HEAD
ProgressCallbackTransform$1.ProgressCallbackTransform = ProgressCallbackTransform;
Object.defineProperty(httpExecutor, "__esModule", { value: true });
httpExecutor.DigestTransform = httpExecutor.HttpExecutor = httpExecutor.HttpError = void 0;
httpExecutor.createHttpError = createHttpError;
httpExecutor.parseJson = parseJson;
httpExecutor.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;
httpExecutor.configureRequestUrl = configureRequestUrl;
httpExecutor.safeGetHeader = safeGetHeader;
httpExecutor.configureRequestOptions = configureRequestOptions;
httpExecutor.safeStringifyJson = safeStringifyJson;
const crypto_1$4 = require$$0$4;
const debug_1$1 = srcExports;
const fs_1$5 = fs$w;
const stream_1$2 = require$$1$2;
const url_1$5 = require$$0$3;
const CancellationToken_1$1 = CancellationToken$1;
const error_1$2 = error;
const ProgressCallbackTransform_1 = ProgressCallbackTransform$1;
const debug$2 = (0, debug_1$1.default)("electron-builder");
function createHttpError(response, description = null) {
  return new HttpError(response.statusCode || -1, `${response.statusCode} ${response.statusMessage}` + (description == null ? "" : "\n" + JSON.stringify(description, null, "  ")) + "\nHeaders: " + safeStringifyJson(response.headers), description);
}
const HTTP_STATUS_CODES = /* @__PURE__ */ new Map([
=======
Zi.ProgressCallbackTransform = q5;
Object.defineProperty(He, "__esModule", { value: !0 });
He.DigestTransform = He.HttpExecutor = He.HttpError = void 0;
He.createHttpError = Bl;
He.parseJson = K5;
He.configureRequestOptionsFromUrl = Nv;
He.configureRequestUrl = Xu;
He.safeGetHeader = Or;
He.configureRequestOptions = xs;
He.safeStringifyJson = ys;
const z5 = Ur, H5 = f0, W5 = se, G5 = ae, Lv = $t, V5 = dn, eh = qr, Y5 = Zi, ti = (0, H5.default)("electron-builder");
function Bl(e, t = null) {
  return new Yu(e.statusCode || -1, `${e.statusCode} ${e.statusMessage}` + (t == null ? "" : `
` + JSON.stringify(t, null, "  ")) + `
Headers: ` + ys(e.headers), t);
}
const X5 = /* @__PURE__ */ new Map([
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  [429, "Too many requests"],
  [400, "Bad request"],
  [403, "Forbidden"],
  [404, "Not found"],
  [405, "Method not allowed"],
  [406, "Not acceptable"],
  [408, "Request timeout"],
  [413, "Request entity too large"],
  [500, "Internal server error"],
  [502, "Bad gateway"],
  [503, "Service unavailable"],
  [504, "Gateway timeout"],
  [505, "HTTP version not supported"]
]);
<<<<<<< HEAD
class HttpError extends Error {
  constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description = null) {
    super(message);
    this.statusCode = statusCode;
    this.description = description;
    this.name = "HttpError";
    this.code = `HTTP_ERROR_${statusCode}`;
=======
class Yu extends Error {
  constructor(t, n = `HTTP error: ${X5.get(t) || t}`, r = null) {
    super(n), this.statusCode = t, this.description = r, this.name = "HttpError", this.code = `HTTP_ERROR_${t}`;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  isServerError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
}
<<<<<<< HEAD
httpExecutor.HttpError = HttpError;
function parseJson(result) {
  return result.then((it) => it == null || it.length === 0 ? null : JSON.parse(it));
}
class HttpExecutor {
  constructor() {
    this.maxRedirects = 10;
  }
  request(options, cancellationToken = new CancellationToken_1$1.CancellationToken(), data) {
    configureRequestOptions(options);
    const json2 = data == null ? void 0 : JSON.stringify(data);
    const encodedData = json2 ? Buffer.from(json2) : void 0;
    if (encodedData != null) {
      debug$2(json2);
      const { headers: headers2, ...opts } = options;
      options = {
        method: "post",
        headers: {
          "Content-Type": "application/json",
          "Content-Length": encodedData.length,
          ...headers2
=======
He.HttpError = Yu;
function K5(e) {
  return e.then((t) => t == null || t.length === 0 ? null : JSON.parse(t));
}
class bs {
  constructor() {
    this.maxRedirects = 10;
  }
  request(t, n = new V5.CancellationToken(), r) {
    xs(t);
    const i = r == null ? void 0 : JSON.stringify(r), a = i ? Buffer.from(i) : void 0;
    if (a != null) {
      ti(i);
      const { headers: s, ...c } = t;
      t = {
        method: "post",
        headers: {
          "Content-Type": "application/json",
          "Content-Length": a.length,
          ...s
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        },
        ...opts
      };
    }
<<<<<<< HEAD
    return this.doApiRequest(options, cancellationToken, (it) => it.end(encodedData));
  }
  doApiRequest(options, cancellationToken, requestProcessor, redirectCount = 0) {
    if (debug$2.enabled) {
      debug$2(`Request: ${safeStringifyJson(options)}`);
    }
    return cancellationToken.createPromise((resolve, reject, onCancel) => {
      const request = this.createRequest(options, (response) => {
        try {
          this.handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor);
        } catch (e) {
          reject(e);
        }
      });
      this.addErrorAndTimeoutHandlers(request, reject, options.timeout);
      this.addRedirectHandlers(request, options, reject, redirectCount, (options2) => {
        this.doApiRequest(options2, cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);
      });
      requestProcessor(request, reject);
      onCancel(() => request.abort());
=======
    return this.doApiRequest(t, n, (s) => s.end(a));
  }
  doApiRequest(t, n, r, i = 0) {
    return ti.enabled && ti(`Request: ${ys(t)}`), n.createPromise((a, s, c) => {
      const o = this.createRequest(t, (u) => {
        try {
          this.handleResponse(u, t, n, a, s, i, r);
        } catch (l) {
          s(l);
        }
      });
      this.addErrorAndTimeoutHandlers(o, s, t.timeout), this.addRedirectHandlers(o, t, s, i, (u) => {
        this.doApiRequest(u, n, r, i).then(a).catch(s);
      }), r(o, s), c(() => o.abort());
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    });
  }
  // noinspection JSUnusedLocalSymbols
  // eslint-disable-next-line
  addRedirectHandlers(request, options, reject, redirectCount, handler) {
  }
  addErrorAndTimeoutHandlers(request, reject, timeout = 60 * 1e3) {
    this.addTimeOutHandler(request, reject, timeout);
    request.on("error", reject);
    request.on("aborted", () => {
      reject(new Error("Request has been aborted by the server"));
    });
  }
<<<<<<< HEAD
  handleResponse(response, options, cancellationToken, resolve, reject, redirectCount, requestProcessor) {
    var _a;
    if (debug$2.enabled) {
      debug$2(`Response: ${response.statusCode} ${response.statusMessage}, request options: ${safeStringifyJson(options)}`);
    }
    if (response.statusCode === 404) {
      reject(createHttpError(response, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}
=======
  handleResponse(t, n, r, i, a, s, c) {
    var o;
    if (ti.enabled && ti(`Response: ${t.statusCode} ${t.statusMessage}, request options: ${ys(n)}`), t.statusCode === 404) {
      a(Bl(t, `method: ${n.method || "GET"} url: ${n.protocol || "https:"}//${n.hostname}${n.port ? `:${n.port}` : ""}${n.path}
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`));
      return;
    } else if (response.statusCode === 204) {
      resolve();
      return;
    }
<<<<<<< HEAD
    const code = (_a = response.statusCode) !== null && _a !== void 0 ? _a : 0;
    const shouldRedirect = code >= 300 && code < 400;
    const redirectUrl = safeGetHeader(response, "location");
    if (shouldRedirect && redirectUrl != null) {
      if (redirectCount > this.maxRedirects) {
        reject(this.createMaxRedirectError());
        return;
      }
      this.doApiRequest(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options), cancellationToken, requestProcessor, redirectCount).then(resolve).catch(reject);
      return;
    }
    response.setEncoding("utf8");
    let data = "";
    response.on("error", reject);
    response.on("data", (chunk) => data += chunk);
    response.on("end", () => {
      try {
        if (response.statusCode != null && response.statusCode >= 400) {
          const contentType = safeGetHeader(response, "content-type");
          const isJson = contentType != null && (Array.isArray(contentType) ? contentType.find((it) => it.includes("json")) != null : contentType.includes("json"));
          reject(createHttpError(response, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

          Data:
          ${isJson ? JSON.stringify(JSON.parse(data)) : data}
          `));
        } else {
          resolve(data.length === 0 ? null : data);
        }
      } catch (e) {
        reject(e);
      }
    });
  }
  async downloadToBuffer(url2, options) {
    return await options.cancellationToken.createPromise((resolve, reject, onCancel) => {
      const responseChunks = [];
      const requestOptions = {
        headers: options.headers || void 0,
        // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually
        redirect: "manual"
      };
      configureRequestUrl(url2, requestOptions);
      configureRequestOptions(requestOptions);
      this.doDownload(requestOptions, {
        destination: null,
        options,
        onCancel,
        callback: (error2) => {
          if (error2 == null) {
            resolve(Buffer.concat(responseChunks));
          } else {
            reject(error2);
          }
        },
        responseHandler: (response, callback) => {
          let receivedLength = 0;
          response.on("data", (chunk) => {
            receivedLength += chunk.length;
            if (receivedLength > 524288e3) {
              callback(new Error("Maximum allowed size is 500 MB"));
              return;
            }
            responseChunks.push(chunk);
          });
          response.on("end", () => {
            callback(null);
=======
    const u = (o = t.statusCode) !== null && o !== void 0 ? o : 0, l = u >= 300 && u < 400, p = Or(t, "location");
    if (l && p != null) {
      if (s > this.maxRedirects) {
        a(this.createMaxRedirectError());
        return;
      }
      this.doApiRequest(bs.prepareRedirectUrlOptions(p, n), r, c, s).then(i).catch(a);
      return;
    }
    t.setEncoding("utf8");
    let f = "";
    t.on("error", a), t.on("data", (m) => f += m), t.on("end", () => {
      try {
        if (t.statusCode != null && t.statusCode >= 400) {
          const m = Or(t, "content-type"), g = m != null && (Array.isArray(m) ? m.find((h) => h.includes("json")) != null : m.includes("json"));
          a(Bl(t, `method: ${n.method || "GET"} url: ${n.protocol || "https:"}//${n.hostname}${n.port ? `:${n.port}` : ""}${n.path}

          Data:
          ${g ? JSON.stringify(JSON.parse(f)) : f}
          `));
        } else
          i(f.length === 0 ? null : f);
      } catch (m) {
        a(m);
      }
    });
  }
  async downloadToBuffer(t, n) {
    return await n.cancellationToken.createPromise((r, i, a) => {
      const s = [], c = {
        headers: n.headers || void 0,
        // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually
        redirect: "manual"
      };
      Xu(t, c), xs(c), this.doDownload(c, {
        destination: null,
        options: n,
        onCancel: a,
        callback: (o) => {
          o == null ? r(Buffer.concat(s)) : i(o);
        },
        responseHandler: (o, u) => {
          let l = 0;
          o.on("data", (p) => {
            if (l += p.length, l > 524288e3) {
              u(new Error("Maximum allowed size is 500 MB"));
              return;
            }
            s.push(p);
          }), o.on("end", () => {
            u(null);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          });
        }
      }, 0);
    });
  }
  doDownload(requestOptions, options, redirectCount) {
    const request = this.createRequest(requestOptions, (response) => {
      if (response.statusCode >= 400) {
        options.callback(new Error(`Cannot download "${requestOptions.protocol || "https:"}//${requestOptions.hostname}${requestOptions.path}", status ${response.statusCode}: ${response.statusMessage}`));
        return;
      }
<<<<<<< HEAD
      response.on("error", options.callback);
      const redirectUrl = safeGetHeader(response, "location");
      if (redirectUrl != null) {
        if (redirectCount < this.maxRedirects) {
          this.doDownload(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, requestOptions), options, redirectCount++);
        } else {
          options.callback(this.createMaxRedirectError());
        }
        return;
      }
      if (options.responseHandler == null) {
        configurePipes(options, response);
      } else {
        options.responseHandler(response, options.callback);
      }
=======
      a.on("error", n.callback);
      const s = Or(a, "location");
      if (s != null) {
        r < this.maxRedirects ? this.doDownload(bs.prepareRedirectUrlOptions(s, t), n, r++) : n.callback(this.createMaxRedirectError());
        return;
      }
      n.responseHandler == null ? Z5(n, a) : n.responseHandler(a, n.callback);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    });
    this.addErrorAndTimeoutHandlers(request, options.callback, requestOptions.timeout);
    this.addRedirectHandlers(request, requestOptions, options.callback, redirectCount, (requestOptions2) => {
      this.doDownload(requestOptions2, options, redirectCount++);
    });
    request.end();
  }
  createMaxRedirectError() {
    return new Error(`Too many redirects (> ${this.maxRedirects})`);
  }
  addTimeOutHandler(request, callback, timeout) {
    request.on("socket", (socket) => {
      socket.setTimeout(timeout, () => {
        request.abort();
        callback(new Error("Request timed out"));
      });
    });
  }
<<<<<<< HEAD
  static prepareRedirectUrlOptions(redirectUrl, options) {
    const newOptions = configureRequestOptionsFromUrl(redirectUrl, { ...options });
    const headers2 = newOptions.headers;
    if (headers2 === null || headers2 === void 0 ? void 0 : headers2.authorization) {
      const parsedNewUrl = new url_1$5.URL(redirectUrl);
      if (parsedNewUrl.hostname.endsWith(".amazonaws.com") || parsedNewUrl.searchParams.has("X-Amz-Credential")) {
        delete headers2.authorization;
=======
  static prepareRedirectUrlOptions(t, n) {
    const r = Nv(t, { ...n }), i = r.headers;
    if (i != null && i.authorization) {
      const a = new Lv.URL(t);
      (a.hostname.endsWith(".amazonaws.com") || a.searchParams.has("X-Amz-Credential")) && delete i.authorization;
    }
    return r;
  }
  static retryOnServerError(t, n = 3) {
    for (let r = 0; ; r++)
      try {
        return t();
      } catch (i) {
        if (r < n && (i instanceof Yu && i.isServerError() || i.code === "EPIPE"))
          continue;
        throw i;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    }
    return newOptions;
  }
  static retryOnServerError(task, maxRetries = 3) {
    for (let attemptNumber = 0; ; attemptNumber++) {
      try {
        return task();
      } catch (e) {
        if (attemptNumber < maxRetries && (e instanceof HttpError && e.isServerError() || e.code === "EPIPE")) {
          continue;
        }
        throw e;
      }
    }
  }
}
<<<<<<< HEAD
httpExecutor.HttpExecutor = HttpExecutor;
function configureRequestOptionsFromUrl(url2, options) {
  const result = configureRequestOptions(options);
  configureRequestUrl(new url_1$5.URL(url2), result);
  return result;
}
function configureRequestUrl(url2, options) {
  options.protocol = url2.protocol;
  options.hostname = url2.hostname;
  if (url2.port) {
    options.port = url2.port;
  } else if (options.port) {
    delete options.port;
  }
  options.path = url2.pathname + url2.search;
}
class DigestTransform extends stream_1$2.Transform {
=======
He.HttpExecutor = bs;
function Nv(e, t) {
  const n = xs(t);
  return Xu(new Lv.URL(e), n), n;
}
function Xu(e, t) {
  t.protocol = e.protocol, t.hostname = e.hostname, e.port ? t.port = e.port : t.port && delete t.port, t.path = e.pathname + e.search;
}
class jl extends G5.Transform {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  // noinspection JSUnusedGlobalSymbols
  get actual() {
    return this._actual;
  }
<<<<<<< HEAD
  constructor(expected, algorithm = "sha512", encoding = "base64") {
    super();
    this.expected = expected;
    this.algorithm = algorithm;
    this.encoding = encoding;
    this._actual = null;
    this.isValidateOnEnd = true;
    this.digester = (0, crypto_1$4.createHash)(algorithm);
=======
  constructor(t, n = "sha512", r = "base64") {
    super(), this.expected = t, this.algorithm = n, this.encoding = r, this._actual = null, this.isValidateOnEnd = !0, this.digester = (0, z5.createHash)(n);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  // noinspection JSUnusedGlobalSymbols
  _transform(chunk, encoding, callback) {
    this.digester.update(chunk);
    callback(null, chunk);
  }
  // noinspection JSUnusedGlobalSymbols
  _flush(callback) {
    this._actual = this.digester.digest(this.encoding);
    if (this.isValidateOnEnd) {
      try {
        this.validate();
      } catch (e) {
        callback(e);
        return;
      }
    }
    callback(null);
  }
  validate() {
<<<<<<< HEAD
    if (this._actual == null) {
      throw (0, error_1$2.newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
    }
    if (this._actual !== this.expected) {
      throw (0, error_1$2.newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
    }
    return null;
  }
}
httpExecutor.DigestTransform = DigestTransform;
function checkSha2(sha2Header, sha2, callback) {
  if (sha2Header != null && sha2 != null && sha2Header !== sha2) {
    callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));
    return false;
  }
  return true;
}
function safeGetHeader(response, headerKey) {
  const value = response.headers[headerKey];
  if (value == null) {
    return null;
  } else if (Array.isArray(value)) {
    return value.length === 0 ? null : value[value.length - 1];
  } else {
    return value;
  }
}
function configurePipes(options, response) {
  if (!checkSha2(safeGetHeader(response, "X-Checksum-Sha2"), options.options.sha2, options.callback)) {
    return;
  }
  const streams2 = [];
  if (options.options.onProgress != null) {
    const contentLength = safeGetHeader(response, "content-length");
    if (contentLength != null) {
      streams2.push(new ProgressCallbackTransform_1.ProgressCallbackTransform(parseInt(contentLength, 10), options.options.cancellationToken, options.options.onProgress));
    }
  }
  const sha512 = options.options.sha512;
  if (sha512 != null) {
    streams2.push(new DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
  } else if (options.options.sha2 != null) {
    streams2.push(new DigestTransform(options.options.sha2, "sha256", "hex"));
  }
  const fileOut = (0, fs_1$5.createWriteStream)(options.destination);
  streams2.push(fileOut);
  let lastStream = response;
  for (const stream2 of streams2) {
    stream2.on("error", (error2) => {
      fileOut.close();
      if (!options.options.cancellationToken.cancelled) {
        options.callback(error2);
      }
    });
    lastStream = lastStream.pipe(stream2);
  }
  fileOut.on("finish", () => {
    fileOut.close(options.callback);
  });
}
function configureRequestOptions(options, token, method) {
  if (method != null) {
    options.method = method;
  }
  options.headers = { ...options.headers };
  const headers2 = options.headers;
  if (token != null) {
    headers2.authorization = token.startsWith("Basic") || token.startsWith("Bearer") ? token : `token ${token}`;
  }
  if (headers2["User-Agent"] == null) {
    headers2["User-Agent"] = "electron-builder";
  }
  if (method == null || method === "GET" || headers2["Cache-Control"] == null) {
    headers2["Cache-Control"] = "no-cache";
  }
  if (options.protocol == null && process.versions.electron != null) {
    options.protocol = "https:";
  }
  return options;
}
function safeStringifyJson(data, skippedNames) {
  return JSON.stringify(data, (name, value) => {
    if (name.endsWith("Authorization") || name.endsWith("authorization") || name.endsWith("Password") || name.endsWith("PASSWORD") || name.endsWith("Token") || name.includes("password") || name.includes("token") || skippedNames != null && skippedNames.has(name)) {
      return "<stripped sensitive data>";
    }
    return value;
  }, 2);
}
var MemoLazy$1 = {};
Object.defineProperty(MemoLazy$1, "__esModule", { value: true });
MemoLazy$1.MemoLazy = void 0;
class MemoLazy {
  constructor(selector, creator) {
    this.selector = selector;
    this.creator = creator;
    this.selected = void 0;
    this._value = void 0;
=======
    if (this._actual == null)
      throw (0, eh.newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
    if (this._actual !== this.expected)
      throw (0, eh.newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
    return null;
  }
}
He.DigestTransform = jl;
function J5(e, t, n) {
  return e != null && t != null && e !== t ? (n(new Error(`checksum mismatch: expected ${t} but got ${e} (X-Checksum-Sha2 header)`)), !1) : !0;
}
function Or(e, t) {
  const n = e.headers[t];
  return n == null ? null : Array.isArray(n) ? n.length === 0 ? null : n[n.length - 1] : n;
}
function Z5(e, t) {
  if (!J5(Or(t, "X-Checksum-Sha2"), e.options.sha2, e.callback))
    return;
  const n = [];
  if (e.options.onProgress != null) {
    const s = Or(t, "content-length");
    s != null && n.push(new Y5.ProgressCallbackTransform(parseInt(s, 10), e.options.cancellationToken, e.options.onProgress));
  }
  const r = e.options.sha512;
  r != null ? n.push(new jl(r, "sha512", r.length === 128 && !r.includes("+") && !r.includes("Z") && !r.includes("=") ? "hex" : "base64")) : e.options.sha2 != null && n.push(new jl(e.options.sha2, "sha256", "hex"));
  const i = (0, W5.createWriteStream)(e.destination);
  n.push(i);
  let a = t;
  for (const s of n)
    s.on("error", (c) => {
      i.close(), e.options.cancellationToken.cancelled || e.callback(c);
    }), a = a.pipe(s);
  i.on("finish", () => {
    i.close(e.callback);
  });
}
function xs(e, t, n) {
  n != null && (e.method = n), e.headers = { ...e.headers };
  const r = e.headers;
  return t != null && (r.authorization = t.startsWith("Basic") || t.startsWith("Bearer") ? t : `token ${t}`), r["User-Agent"] == null && (r["User-Agent"] = "electron-builder"), (n == null || n === "GET" || r["Cache-Control"] == null) && (r["Cache-Control"] = "no-cache"), e.protocol == null && process.versions.electron != null && (e.protocol = "https:"), e;
}
function ys(e, t) {
  return JSON.stringify(e, (n, r) => n.endsWith("Authorization") || n.endsWith("authorization") || n.endsWith("Password") || n.endsWith("PASSWORD") || n.endsWith("Token") || n.includes("password") || n.includes("token") || t != null && t.has(n) ? "<stripped sensitive data>" : r, 2);
}
var po = {};
Object.defineProperty(po, "__esModule", { value: !0 });
po.MemoLazy = void 0;
class Q5 {
  constructor(t, n) {
    this.selector = t, this.creator = n, this.selected = void 0, this._value = void 0;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  get hasValue() {
    return this._value !== void 0;
  }
  get value() {
<<<<<<< HEAD
    const selected = this.selector();
    if (this._value !== void 0 && equals(this.selected, selected)) {
=======
    const t = this.selector();
    if (this._value !== void 0 && Uv(this.selected, t))
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      return this._value;
    }
    this.selected = selected;
    const result = this.creator(selected);
    this.value = result;
    return result;
  }
  set value(value) {
    this._value = value;
  }
}
<<<<<<< HEAD
MemoLazy$1.MemoLazy = MemoLazy;
function equals(firstValue, secondValue) {
  const isFirstObject = typeof firstValue === "object" && firstValue !== null;
  const isSecondObject = typeof secondValue === "object" && secondValue !== null;
  if (isFirstObject && isSecondObject) {
    const keys1 = Object.keys(firstValue);
    const keys2 = Object.keys(secondValue);
    return keys1.length === keys2.length && keys1.every((key2) => equals(firstValue[key2], secondValue[key2]));
=======
po.MemoLazy = Q5;
function Uv(e, t) {
  if (typeof e == "object" && e !== null && (typeof t == "object" && t !== null)) {
    const i = Object.keys(e), a = Object.keys(t);
    return i.length === a.length && i.every((s) => Uv(e[s], t[s]));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  return firstValue === secondValue;
}
<<<<<<< HEAD
var publishOptions = {};
Object.defineProperty(publishOptions, "__esModule", { value: true });
publishOptions.githubUrl = githubUrl;
publishOptions.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;
function githubUrl(options, defaultHost = "github.com") {
  return `${options.protocol || "https"}://${options.host || defaultHost}`;
}
function getS3LikeProviderBaseUrl(configuration) {
  const provider = configuration.provider;
  if (provider === "s3") {
    return s3Url(configuration);
  }
  if (provider === "spaces") {
    return spacesUrl(configuration);
  }
  throw new Error(`Not supported provider: ${provider}`);
}
function s3Url(options) {
  let url2;
  if (options.accelerate == true) {
    url2 = `https://${options.bucket}.s3-accelerate.amazonaws.com`;
  } else if (options.endpoint != null) {
    url2 = `${options.endpoint}/${options.bucket}`;
  } else if (options.bucket.includes(".")) {
    if (options.region == null) {
      throw new Error(`Bucket name "${options.bucket}" includes a dot, but S3 region is missing`);
    }
    if (options.region === "us-east-1") {
      url2 = `https://s3.amazonaws.com/${options.bucket}`;
    } else {
      url2 = `https://s3-${options.region}.amazonaws.com/${options.bucket}`;
    }
  } else if (options.region === "cn-north-1") {
    url2 = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;
  } else {
    url2 = `https://${options.bucket}.s3.amazonaws.com`;
  }
  return appendPath(url2, options.path);
}
function appendPath(url2, p) {
  if (p != null && p.length > 0) {
    if (!p.startsWith("/")) {
      url2 += "/";
    }
    url2 += p;
  }
  return url2;
}
function spacesUrl(options) {
  if (options.name == null) {
    throw new Error(`name is missing`);
  }
  if (options.region == null) {
    throw new Error(`region is missing`);
  }
  return appendPath(`https://${options.name}.${options.region}.digitaloceanspaces.com`, options.path);
}
var retry$1 = {};
Object.defineProperty(retry$1, "__esModule", { value: true });
retry$1.retry = retry;
const CancellationToken_1 = CancellationToken$1;
async function retry(task, retryCount, interval, backoff = 0, attempt = 0, shouldRetry) {
  var _a;
  const cancellationToken = new CancellationToken_1.CancellationToken();
  try {
    return await task();
  } catch (error2) {
    if (((_a = shouldRetry === null || shouldRetry === void 0 ? void 0 : shouldRetry(error2)) !== null && _a !== void 0 ? _a : true) && retryCount > 0 && !cancellationToken.cancelled) {
      await new Promise((resolve) => setTimeout(resolve, interval + backoff * attempt));
      return await retry(task, retryCount - 1, interval, backoff, attempt + 1, shouldRetry);
    } else {
      throw error2;
    }
  }
}
var rfc2253Parser = {};
Object.defineProperty(rfc2253Parser, "__esModule", { value: true });
rfc2253Parser.parseDn = parseDn;
function parseDn(seq2) {
  let quoted = false;
  let key2 = null;
  let token = "";
  let nextNonSpace = 0;
  seq2 = seq2.trim();
  const result = /* @__PURE__ */ new Map();
  for (let i = 0; i <= seq2.length; i++) {
    if (i === seq2.length) {
      if (key2 !== null) {
        result.set(key2, token);
      }
      break;
    }
    const ch = seq2[i];
    if (quoted) {
      if (ch === '"') {
        quoted = false;
=======
var fo = {};
Object.defineProperty(fo, "__esModule", { value: !0 });
fo.githubUrl = e9;
fo.getS3LikeProviderBaseUrl = t9;
function e9(e, t = "github.com") {
  return `${e.protocol || "https"}://${e.host || t}`;
}
function t9(e) {
  const t = e.provider;
  if (t === "s3")
    return n9(e);
  if (t === "spaces")
    return r9(e);
  throw new Error(`Not supported provider: ${t}`);
}
function n9(e) {
  let t;
  if (e.accelerate == !0)
    t = `https://${e.bucket}.s3-accelerate.amazonaws.com`;
  else if (e.endpoint != null)
    t = `${e.endpoint}/${e.bucket}`;
  else if (e.bucket.includes(".")) {
    if (e.region == null)
      throw new Error(`Bucket name "${e.bucket}" includes a dot, but S3 region is missing`);
    e.region === "us-east-1" ? t = `https://s3.amazonaws.com/${e.bucket}` : t = `https://s3-${e.region}.amazonaws.com/${e.bucket}`;
  } else e.region === "cn-north-1" ? t = `https://${e.bucket}.s3.${e.region}.amazonaws.com.cn` : t = `https://${e.bucket}.s3.amazonaws.com`;
  return Bv(t, e.path);
}
function Bv(e, t) {
  return t != null && t.length > 0 && (t.startsWith("/") || (e += "/"), e += t), e;
}
function r9(e) {
  if (e.name == null)
    throw new Error("name is missing");
  if (e.region == null)
    throw new Error("region is missing");
  return Bv(`https://${e.name}.${e.region}.digitaloceanspaces.com`, e.path);
}
var Ku = {};
Object.defineProperty(Ku, "__esModule", { value: !0 });
Ku.retry = jv;
const i9 = dn;
async function jv(e, t, n, r = 0, i = 0, a) {
  var s;
  const c = new i9.CancellationToken();
  try {
    return await e();
  } catch (o) {
    if ((!((s = a == null ? void 0 : a(o)) !== null && s !== void 0) || s) && t > 0 && !c.cancelled)
      return await new Promise((u) => setTimeout(u, n + r * i)), await jv(e, t - 1, n, r, i + 1, a);
    throw o;
  }
}
var Ju = {};
Object.defineProperty(Ju, "__esModule", { value: !0 });
Ju.parseDn = a9;
function a9(e) {
  let t = !1, n = null, r = "", i = 0;
  e = e.trim();
  const a = /* @__PURE__ */ new Map();
  for (let s = 0; s <= e.length; s++) {
    if (s === e.length) {
      n !== null && a.set(n, r);
      break;
    }
    const c = e[s];
    if (t) {
      if (c === '"') {
        t = !1;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        continue;
      }
    } else {
      if (ch === '"') {
        quoted = true;
        continue;
      }
<<<<<<< HEAD
      if (ch === "\\") {
        i++;
        const ord = parseInt(seq2.slice(i, i + 2), 16);
        if (Number.isNaN(ord)) {
          token += seq2[i];
        } else {
          i++;
          token += String.fromCharCode(ord);
        }
        continue;
      }
      if (key2 === null && ch === "=") {
        key2 = token;
        token = "";
        continue;
      }
      if (ch === "," || ch === ";" || ch === "+") {
        if (key2 !== null) {
          result.set(key2, token);
        }
        key2 = null;
        token = "";
=======
      if (c === "\\") {
        s++;
        const o = parseInt(e.slice(s, s + 2), 16);
        Number.isNaN(o) ? r += e[s] : (s++, r += String.fromCharCode(o));
        continue;
      }
      if (n === null && c === "=") {
        n = r, r = "";
        continue;
      }
      if (c === "," || c === ";" || c === "+") {
        n !== null && a.set(n, r), n = null, r = "";
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        continue;
      }
    }
    if (ch === " " && !quoted) {
      if (token.length === 0) {
        continue;
<<<<<<< HEAD
      }
      if (i > nextNonSpace) {
        let j = i;
        while (seq2[j] === " ") {
          j++;
        }
        nextNonSpace = j;
      }
      if (nextNonSpace >= seq2.length || seq2[nextNonSpace] === "," || seq2[nextNonSpace] === ";" || key2 === null && seq2[nextNonSpace] === "=" || key2 !== null && seq2[nextNonSpace] === "+") {
        i = nextNonSpace - 1;
=======
      if (s > i) {
        let o = s;
        for (; e[o] === " "; )
          o++;
        i = o;
      }
      if (i >= e.length || e[i] === "," || e[i] === ";" || n === null && e[i] === "=" || n !== null && e[i] === "+") {
        s = i - 1;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        continue;
      }
    }
    token += ch;
  }
  return result;
}
<<<<<<< HEAD
var uuid = {};
Object.defineProperty(uuid, "__esModule", { value: true });
uuid.nil = uuid.UUID = void 0;
const crypto_1$3 = require$$0$4;
const error_1$1 = error;
const invalidName = "options.name must be either a string or a Buffer";
const randomHost = (0, crypto_1$3.randomBytes)(16);
randomHost[0] = randomHost[0] | 1;
const hex2byte = {};
const byte2hex = [];
for (let i = 0; i < 256; i++) {
  const hex = (i + 256).toString(16).substr(1);
  hex2byte[hex] = i;
  byte2hex[i] = hex;
}
class UUID {
  constructor(uuid2) {
    this.ascii = null;
    this.binary = null;
    const check = UUID.check(uuid2);
    if (!check) {
=======
var Lr = {};
Object.defineProperty(Lr, "__esModule", { value: !0 });
Lr.nil = Lr.UUID = void 0;
const Mv = Ur, qv = qr, s9 = "options.name must be either a string or a Buffer", th = (0, Mv.randomBytes)(16);
th[0] = th[0] | 1;
const as = {}, ce = [];
for (let e = 0; e < 256; e++) {
  const t = (e + 256).toString(16).substr(1);
  as[t] = e, ce[e] = t;
}
class Gn {
  constructor(t) {
    this.ascii = null, this.binary = null;
    const n = Gn.check(t);
    if (!n)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      throw new Error("not a UUID");
    }
    this.version = check.version;
    if (check.format === "ascii") {
      this.ascii = uuid2;
    } else {
      this.binary = uuid2;
    }
  }
<<<<<<< HEAD
  static v5(name, namespace) {
    return uuidNamed(name, "sha1", 80, namespace);
  }
  toString() {
    if (this.ascii == null) {
      this.ascii = stringify(this.binary);
    }
    return this.ascii;
=======
  static v5(t, n) {
    return o9(t, "sha1", 80, n);
  }
  toString() {
    return this.ascii == null && (this.ascii = c9(this.binary)), this.ascii;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  inspect() {
    return `UUID v${this.version} ${this.toString()}`;
  }
<<<<<<< HEAD
  static check(uuid2, offset = 0) {
    if (typeof uuid2 === "string") {
      uuid2 = uuid2.toLowerCase();
      if (!/^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(uuid2)) {
        return false;
      }
      if (uuid2 === "00000000-0000-0000-0000-000000000000") {
        return { version: void 0, variant: "nil", format: "ascii" };
      }
      return {
        version: (hex2byte[uuid2[14] + uuid2[15]] & 240) >> 4,
        variant: getVariant((hex2byte[uuid2[19] + uuid2[20]] & 224) >> 5),
        format: "ascii"
      };
    }
    if (Buffer.isBuffer(uuid2)) {
      if (uuid2.length < offset + 16) {
        return false;
      }
      let i = 0;
      for (; i < 16; i++) {
        if (uuid2[offset + i] !== 0) {
          break;
        }
      }
      if (i === 16) {
        return { version: void 0, variant: "nil", format: "binary" };
      }
      return {
        version: (uuid2[offset + 6] & 240) >> 4,
        variant: getVariant((uuid2[offset + 8] & 224) >> 5),
        format: "binary"
      };
    }
    throw (0, error_1$1.newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
  }
  // read stringified uuid into a Buffer
  static parse(input) {
    const buffer2 = Buffer.allocUnsafe(16);
    let j = 0;
    for (let i = 0; i < 16; i++) {
      buffer2[i] = hex2byte[input[j++] + input[j++]];
      if (i === 3 || i === 5 || i === 7 || i === 9) {
        j += 1;
      }
    }
    return buffer2;
  }
}
uuid.UUID = UUID;
UUID.OID = UUID.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
function getVariant(bits) {
  switch (bits) {
=======
  static check(t, n = 0) {
    if (typeof t == "string")
      return t = t.toLowerCase(), /^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(t) ? t === "00000000-0000-0000-0000-000000000000" ? { version: void 0, variant: "nil", format: "ascii" } : {
        version: (as[t[14] + t[15]] & 240) >> 4,
        variant: nh((as[t[19] + t[20]] & 224) >> 5),
        format: "ascii"
      } : !1;
    if (Buffer.isBuffer(t)) {
      if (t.length < n + 16)
        return !1;
      let r = 0;
      for (; r < 16 && t[n + r] === 0; r++)
        ;
      return r === 16 ? { version: void 0, variant: "nil", format: "binary" } : {
        version: (t[n + 6] & 240) >> 4,
        variant: nh((t[n + 8] & 224) >> 5),
        format: "binary"
      };
    }
    throw (0, qv.newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
  }
  // read stringified uuid into a Buffer
  static parse(t) {
    const n = Buffer.allocUnsafe(16);
    let r = 0;
    for (let i = 0; i < 16; i++)
      n[i] = as[t[r++] + t[r++]], (i === 3 || i === 5 || i === 7 || i === 9) && (r += 1);
    return n;
  }
}
Lr.UUID = Gn;
Gn.OID = Gn.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
function nh(e) {
  switch (e) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    case 0:
    case 1:
    case 3:
      return "ncs";
    case 4:
    case 5:
      return "rfc4122";
    case 6:
      return "microsoft";
    default:
      return "future";
  }
}
<<<<<<< HEAD
var UuidEncoding;
(function(UuidEncoding2) {
  UuidEncoding2[UuidEncoding2["ASCII"] = 0] = "ASCII";
  UuidEncoding2[UuidEncoding2["BINARY"] = 1] = "BINARY";
  UuidEncoding2[UuidEncoding2["OBJECT"] = 2] = "OBJECT";
})(UuidEncoding || (UuidEncoding = {}));
function uuidNamed(name, hashMethod, version, namespace, encoding = UuidEncoding.ASCII) {
  const hash = (0, crypto_1$3.createHash)(hashMethod);
  const nameIsNotAString = typeof name !== "string";
  if (nameIsNotAString && !Buffer.isBuffer(name)) {
    throw (0, error_1$1.newError)(invalidName, "ERR_INVALID_UUID_NAME");
  }
  hash.update(namespace);
  hash.update(name);
  const buffer2 = hash.digest();
  let result;
  switch (encoding) {
    case UuidEncoding.BINARY:
      buffer2[6] = buffer2[6] & 15 | version;
      buffer2[8] = buffer2[8] & 63 | 128;
      result = buffer2;
      break;
    case UuidEncoding.OBJECT:
      buffer2[6] = buffer2[6] & 15 | version;
      buffer2[8] = buffer2[8] & 63 | 128;
      result = new UUID(buffer2);
      break;
    default:
      result = byte2hex[buffer2[0]] + byte2hex[buffer2[1]] + byte2hex[buffer2[2]] + byte2hex[buffer2[3]] + "-" + byte2hex[buffer2[4]] + byte2hex[buffer2[5]] + "-" + byte2hex[buffer2[6] & 15 | version] + byte2hex[buffer2[7]] + "-" + byte2hex[buffer2[8] & 63 | 128] + byte2hex[buffer2[9]] + "-" + byte2hex[buffer2[10]] + byte2hex[buffer2[11]] + byte2hex[buffer2[12]] + byte2hex[buffer2[13]] + byte2hex[buffer2[14]] + byte2hex[buffer2[15]];
      break;
  }
  return result;
}
function stringify(buffer2) {
  return byte2hex[buffer2[0]] + byte2hex[buffer2[1]] + byte2hex[buffer2[2]] + byte2hex[buffer2[3]] + "-" + byte2hex[buffer2[4]] + byte2hex[buffer2[5]] + "-" + byte2hex[buffer2[6]] + byte2hex[buffer2[7]] + "-" + byte2hex[buffer2[8]] + byte2hex[buffer2[9]] + "-" + byte2hex[buffer2[10]] + byte2hex[buffer2[11]] + byte2hex[buffer2[12]] + byte2hex[buffer2[13]] + byte2hex[buffer2[14]] + byte2hex[buffer2[15]];
}
uuid.nil = new UUID("00000000-0000-0000-0000-000000000000");
var xml = {};
var sax$1 = {};
(function(exports) {
  (function(sax2) {
    sax2.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax2.SAXParser = SAXParser;
    sax2.SAXStream = SAXStream;
    sax2.createStream = createStream;
    sax2.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
=======
var di;
(function(e) {
  e[e.ASCII = 0] = "ASCII", e[e.BINARY = 1] = "BINARY", e[e.OBJECT = 2] = "OBJECT";
})(di || (di = {}));
function o9(e, t, n, r, i = di.ASCII) {
  const a = (0, Mv.createHash)(t);
  if (typeof e != "string" && !Buffer.isBuffer(e))
    throw (0, qv.newError)(s9, "ERR_INVALID_UUID_NAME");
  a.update(r), a.update(e);
  const c = a.digest();
  let o;
  switch (i) {
    case di.BINARY:
      c[6] = c[6] & 15 | n, c[8] = c[8] & 63 | 128, o = c;
      break;
    case di.OBJECT:
      c[6] = c[6] & 15 | n, c[8] = c[8] & 63 | 128, o = new Gn(c);
      break;
    default:
      o = ce[c[0]] + ce[c[1]] + ce[c[2]] + ce[c[3]] + "-" + ce[c[4]] + ce[c[5]] + "-" + ce[c[6] & 15 | n] + ce[c[7]] + "-" + ce[c[8] & 63 | 128] + ce[c[9]] + "-" + ce[c[10]] + ce[c[11]] + ce[c[12]] + ce[c[13]] + ce[c[14]] + ce[c[15]];
      break;
  }
  return o;
}
function c9(e) {
  return ce[e[0]] + ce[e[1]] + ce[e[2]] + ce[e[3]] + "-" + ce[e[4]] + ce[e[5]] + "-" + ce[e[6]] + ce[e[7]] + "-" + ce[e[8]] + ce[e[9]] + "-" + ce[e[10]] + ce[e[11]] + ce[e[12]] + ce[e[13]] + ce[e[14]] + ce[e[15]];
}
Lr.nil = new Gn("00000000-0000-0000-0000-000000000000");
var Qi = {}, zv = {};
(function(e) {
  (function(t) {
    t.parser = function(v, d) {
      return new r(v, d);
    }, t.SAXParser = r, t.SAXStream = l, t.createStream = u, t.MAX_BUFFER_LENGTH = 64 * 1024;
    var n = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax2.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
<<<<<<< HEAD
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      if (parser.opt.unquotedAttributeValues === void 0) {
        parser.opt.unquotedAttributeValues = !strict;
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F();
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o) {
        var a = [];
        for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i = 0, l = buffers.length; i < l; i++) {
        var len = parser[buffers[i]].length;
        if (len > maxAllowed) {
          switch (buffers[i]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error2(parser, "Max buffer length exceeded: " + buffers[i]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m = sax2.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
      for (var i = 0, l = buffers.length; i < l; i++) {
        parser[buffers[i]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
=======
    function r(v, d) {
      if (!(this instanceof r))
        return new r(v, d);
      var $ = this;
      a($), $.q = $.c = "", $.bufferCheckPosition = t.MAX_BUFFER_LENGTH, $.opt = d || {}, $.opt.lowercase = $.opt.lowercase || $.opt.lowercasetags, $.looseCase = $.opt.lowercase ? "toLowerCase" : "toUpperCase", $.tags = [], $.closed = $.closedRoot = $.sawRoot = !1, $.tag = $.error = null, $.strict = !!v, $.noscript = !!(v || $.opt.noscript), $.state = C.BEGIN, $.strictEntities = $.opt.strictEntities, $.ENTITIES = $.strictEntities ? Object.create(t.XML_ENTITIES) : Object.create(t.ENTITIES), $.attribList = [], $.opt.xmlns && ($.ns = Object.create(h)), $.opt.unquotedAttributeValues === void 0 && ($.opt.unquotedAttributeValues = !v), $.trackPosition = $.opt.position !== !1, $.trackPosition && ($.position = $.line = $.column = 0), M($, "onready");
    }
    Object.create || (Object.create = function(v) {
      function d() {
      }
      d.prototype = v;
      var $ = new d();
      return $;
    }), Object.keys || (Object.keys = function(v) {
      var d = [];
      for (var $ in v) v.hasOwnProperty($) && d.push($);
      return d;
    });
    function i(v) {
      for (var d = Math.max(t.MAX_BUFFER_LENGTH, 10), $ = 0, T = 0, G = n.length; T < G; T++) {
        var W = v[n[T]].length;
        if (W > d)
          switch (n[T]) {
            case "textNode":
              re(v);
              break;
            case "cdata":
              J(v, "oncdata", v.cdata), v.cdata = "";
              break;
            case "script":
              J(v, "onscript", v.script), v.script = "";
              break;
            default:
              O(v, "Max buffer length exceeded: " + n[T]);
          }
        $ = Math.max($, W);
      }
      var X = t.MAX_BUFFER_LENGTH - $;
      v.bufferCheckPosition = X + v.position;
    }
    function a(v) {
      for (var d = 0, $ = n.length; d < $; d++)
        v[n[d]] = "";
    }
    function s(v) {
      re(v), v.cdata !== "" && (J(v, "oncdata", v.cdata), v.cdata = ""), v.script !== "" && (J(v, "onscript", v.script), v.script = "");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    SAXParser.prototype = {
      end: function() {
<<<<<<< HEAD
        end2(this);
=======
        P(this);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      },
      write,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
<<<<<<< HEAD
        flushBuffers(this);
=======
        s(this);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    };
    var Stream2;
    try {
      Stream2 = require("stream").Stream;
    } catch (ex) {
      Stream2 = function() {
      };
    }
    if (!Stream2) Stream2 = function() {
    };
    var streamWraps = sax2.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
<<<<<<< HEAD
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream2.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h) {
            if (!h) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h;
              return h;
            }
            me.on(ev, h);
=======
    var o = t.EVENTS.filter(function(v) {
      return v !== "error" && v !== "end";
    });
    function u(v, d) {
      return new l(v, d);
    }
    function l(v, d) {
      if (!(this instanceof l))
        return new l(v, d);
      c.apply(this), this._parser = new r(v, d), this.writable = !0, this.readable = !0;
      var $ = this;
      this._parser.onend = function() {
        $.emit("end");
      }, this._parser.onerror = function(T) {
        $.emit("error", T), $._parser.error = null;
      }, this._decoder = null, o.forEach(function(T) {
        Object.defineProperty($, "on" + T, {
          get: function() {
            return $._parser["on" + T];
          },
          set: function(G) {
            if (!G)
              return $.removeAllListeners(T), $._parser["on" + T] = G, G;
            $.on(T, G);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream2.prototype, {
      constructor: {
        value: SAXStream
      }
<<<<<<< HEAD
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require$$1$7.StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream2.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace2(c) {
      return c === " " || c === "\n" || c === "\r" || c === "	";
    }
    function isQuote(c) {
      return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
      return c === ">" || isWhitespace2(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax2.STATE = {
      BEGIN: S++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: S++,
      // leading whitespace
      TEXT: S++,
      // general stuff
      TEXT_ENTITY: S++,
      // &amp and such.
      OPEN_WAKA: S++,
      // <
      SGML_DECL: S++,
      // <!BLARG
      SGML_DECL_QUOTED: S++,
      // <!BLARG foo "bar
      DOCTYPE: S++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: S++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: S++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: S++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: S++,
      // <!-
      COMMENT: S++,
      // <!--
      COMMENT_ENDING: S++,
      // <!-- blah -
      COMMENT_ENDED: S++,
      // <!-- blah --
      CDATA: S++,
      // <![CDATA[ something
      CDATA_ENDING: S++,
      // ]
      CDATA_ENDING_2: S++,
      // ]]
      PROC_INST: S++,
      // <?hi
      PROC_INST_BODY: S++,
      // <?hi there
      PROC_INST_ENDING: S++,
      // <?hi "there" ?
      OPEN_TAG: S++,
      // <strong
      OPEN_TAG_SLASH: S++,
      // <strong /
      ATTRIB: S++,
      // <a
      ATTRIB_NAME: S++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: S++,
      // <a foo _
      ATTRIB_VALUE: S++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: S++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: S++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: S++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: S++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: S++,
      // <foo bar=&quot
      CLOSE_TAG: S++,
      // </a
      CLOSE_TAG_SAW_WHITE: S++,
      // </a   >
      SCRIPT: S++,
      // <script> ...
      SCRIPT_ENDING: S++
      // <script> ... <
    };
    sax2.XML_ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'"
    };
    sax2.ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'",
      "AElig": 198,
      "Aacute": 193,
      "Acirc": 194,
      "Agrave": 192,
      "Aring": 197,
      "Atilde": 195,
      "Auml": 196,
      "Ccedil": 199,
      "ETH": 208,
      "Eacute": 201,
      "Ecirc": 202,
      "Egrave": 200,
      "Euml": 203,
      "Iacute": 205,
      "Icirc": 206,
      "Igrave": 204,
      "Iuml": 207,
      "Ntilde": 209,
      "Oacute": 211,
      "Ocirc": 212,
      "Ograve": 210,
      "Oslash": 216,
      "Otilde": 213,
      "Ouml": 214,
      "THORN": 222,
      "Uacute": 218,
      "Ucirc": 219,
      "Ugrave": 217,
      "Uuml": 220,
      "Yacute": 221,
      "aacute": 225,
      "acirc": 226,
      "aelig": 230,
      "agrave": 224,
      "aring": 229,
      "atilde": 227,
      "auml": 228,
      "ccedil": 231,
      "eacute": 233,
      "ecirc": 234,
      "egrave": 232,
      "eth": 240,
      "euml": 235,
      "iacute": 237,
      "icirc": 238,
      "igrave": 236,
      "iuml": 239,
      "ntilde": 241,
      "oacute": 243,
      "ocirc": 244,
      "ograve": 242,
      "oslash": 248,
      "otilde": 245,
      "ouml": 246,
      "szlig": 223,
      "thorn": 254,
      "uacute": 250,
      "ucirc": 251,
      "ugrave": 249,
      "uuml": 252,
      "yacute": 253,
      "yuml": 255,
      "copy": 169,
      "reg": 174,
      "nbsp": 160,
      "iexcl": 161,
      "cent": 162,
      "pound": 163,
      "curren": 164,
      "yen": 165,
      "brvbar": 166,
      "sect": 167,
      "uml": 168,
      "ordf": 170,
      "laquo": 171,
      "not": 172,
      "shy": 173,
      "macr": 175,
      "deg": 176,
      "plusmn": 177,
      "sup1": 185,
      "sup2": 178,
      "sup3": 179,
      "acute": 180,
      "micro": 181,
      "para": 182,
      "middot": 183,
      "cedil": 184,
      "ordm": 186,
      "raquo": 187,
      "frac14": 188,
      "frac12": 189,
      "frac34": 190,
      "iquest": 191,
      "times": 215,
      "divide": 247,
      "OElig": 338,
      "oelig": 339,
      "Scaron": 352,
      "scaron": 353,
      "Yuml": 376,
      "fnof": 402,
      "circ": 710,
      "tilde": 732,
      "Alpha": 913,
      "Beta": 914,
      "Gamma": 915,
      "Delta": 916,
      "Epsilon": 917,
      "Zeta": 918,
      "Eta": 919,
      "Theta": 920,
      "Iota": 921,
      "Kappa": 922,
      "Lambda": 923,
      "Mu": 924,
      "Nu": 925,
      "Xi": 926,
      "Omicron": 927,
      "Pi": 928,
      "Rho": 929,
      "Sigma": 931,
      "Tau": 932,
      "Upsilon": 933,
      "Phi": 934,
      "Chi": 935,
      "Psi": 936,
      "Omega": 937,
      "alpha": 945,
      "beta": 946,
      "gamma": 947,
      "delta": 948,
      "epsilon": 949,
      "zeta": 950,
      "eta": 951,
      "theta": 952,
      "iota": 953,
      "kappa": 954,
      "lambda": 955,
      "mu": 956,
      "nu": 957,
      "xi": 958,
      "omicron": 959,
      "pi": 960,
      "rho": 961,
      "sigmaf": 962,
      "sigma": 963,
      "tau": 964,
      "upsilon": 965,
      "phi": 966,
      "chi": 967,
      "psi": 968,
      "omega": 969,
      "thetasym": 977,
      "upsih": 978,
      "piv": 982,
      "ensp": 8194,
      "emsp": 8195,
      "thinsp": 8201,
      "zwnj": 8204,
      "zwj": 8205,
      "lrm": 8206,
      "rlm": 8207,
      "ndash": 8211,
      "mdash": 8212,
      "lsquo": 8216,
      "rsquo": 8217,
      "sbquo": 8218,
      "ldquo": 8220,
      "rdquo": 8221,
      "bdquo": 8222,
      "dagger": 8224,
      "Dagger": 8225,
      "bull": 8226,
      "hellip": 8230,
      "permil": 8240,
      "prime": 8242,
      "Prime": 8243,
      "lsaquo": 8249,
      "rsaquo": 8250,
      "oline": 8254,
      "frasl": 8260,
      "euro": 8364,
      "image": 8465,
      "weierp": 8472,
      "real": 8476,
      "trade": 8482,
      "alefsym": 8501,
      "larr": 8592,
      "uarr": 8593,
      "rarr": 8594,
      "darr": 8595,
      "harr": 8596,
      "crarr": 8629,
      "lArr": 8656,
      "uArr": 8657,
      "rArr": 8658,
      "dArr": 8659,
      "hArr": 8660,
      "forall": 8704,
      "part": 8706,
      "exist": 8707,
      "empty": 8709,
      "nabla": 8711,
      "isin": 8712,
      "notin": 8713,
      "ni": 8715,
      "prod": 8719,
      "sum": 8721,
      "minus": 8722,
      "lowast": 8727,
      "radic": 8730,
      "prop": 8733,
      "infin": 8734,
      "ang": 8736,
      "and": 8743,
      "or": 8744,
      "cap": 8745,
      "cup": 8746,
      "int": 8747,
      "there4": 8756,
      "sim": 8764,
      "cong": 8773,
      "asymp": 8776,
      "ne": 8800,
      "equiv": 8801,
      "le": 8804,
      "ge": 8805,
      "sub": 8834,
      "sup": 8835,
      "nsub": 8836,
      "sube": 8838,
      "supe": 8839,
      "oplus": 8853,
      "otimes": 8855,
      "perp": 8869,
      "sdot": 8901,
      "lceil": 8968,
      "rceil": 8969,
      "lfloor": 8970,
      "rfloor": 8971,
      "lang": 9001,
      "rang": 9002,
      "loz": 9674,
      "spades": 9824,
      "clubs": 9827,
      "hearts": 9829,
      "diams": 9830
    };
    Object.keys(sax2.ENTITIES).forEach(function(key2) {
      var e = sax2.ENTITIES[key2];
      var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax2.ENTITIES[key2] = s2;
    });
    for (var s in sax2.STATE) {
      sax2.STATE[sax2.STATE[s]] = s;
    }
    S = sax2.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode) closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode) emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim) text = text.trim();
      if (opt.normalize) text = text.replace(/\s+/g, " ");
      return text;
    }
    function error2(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, "onerror", er);
      return parser;
    }
    function end2(parser) {
      if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error2(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error2(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
      var i = name.indexOf(":");
      var qualName = i < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(
              parser,
              "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
            );
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(
              parser,
              "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
            );
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i = 0, l = parser.attribList.length; i < l; i++) {
          var nv = parser.attribList[i];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri2 = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name,
            value,
            prefix,
            local,
            uri: uri2
          };
          if (prefix && prefix !== "xmlns" && !uri2) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t2 = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t2--) {
        var close = parser.tags[t2];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
=======
    }), l.prototype.write = function(v) {
      if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(v)) {
        if (!this._decoder) {
          var d = Os.StringDecoder;
          this._decoder = new d("utf8");
        }
        v = this._decoder.write(v);
      }
      return this._parser.write(v.toString()), this.emit("data", v), !0;
    }, l.prototype.end = function(v) {
      return v && v.length && this.write(v), this._parser.end(), !0;
    }, l.prototype.on = function(v, d) {
      var $ = this;
      return !$._parser["on" + v] && o.indexOf(v) !== -1 && ($._parser["on" + v] = function() {
        var T = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
        T.splice(0, 0, v), $.emit.apply($, T);
      }), c.prototype.on.call($, v, d);
    };
    var p = "[CDATA[", f = "DOCTYPE", m = "http://www.w3.org/XML/1998/namespace", g = "http://www.w3.org/2000/xmlns/", h = { xml: m, xmlns: g }, b = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, x = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, y = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, E = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function S(v) {
      return v === " " || v === `
` || v === "\r" || v === "	";
    }
    function D(v) {
      return v === '"' || v === "'";
    }
    function U(v) {
      return v === ">" || S(v);
    }
    function z(v, d) {
      return v.test(d);
    }
    function ee(v, d) {
      return !z(v, d);
    }
    var C = 0;
    t.STATE = {
      BEGIN: C++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: C++,
      // leading whitespace
      TEXT: C++,
      // general stuff
      TEXT_ENTITY: C++,
      // &amp and such.
      OPEN_WAKA: C++,
      // <
      SGML_DECL: C++,
      // <!BLARG
      SGML_DECL_QUOTED: C++,
      // <!BLARG foo "bar
      DOCTYPE: C++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: C++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: C++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: C++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: C++,
      // <!-
      COMMENT: C++,
      // <!--
      COMMENT_ENDING: C++,
      // <!-- blah -
      COMMENT_ENDED: C++,
      // <!-- blah --
      CDATA: C++,
      // <![CDATA[ something
      CDATA_ENDING: C++,
      // ]
      CDATA_ENDING_2: C++,
      // ]]
      PROC_INST: C++,
      // <?hi
      PROC_INST_BODY: C++,
      // <?hi there
      PROC_INST_ENDING: C++,
      // <?hi "there" ?
      OPEN_TAG: C++,
      // <strong
      OPEN_TAG_SLASH: C++,
      // <strong /
      ATTRIB: C++,
      // <a
      ATTRIB_NAME: C++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: C++,
      // <a foo _
      ATTRIB_VALUE: C++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: C++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: C++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: C++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: C++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: C++,
      // <foo bar=&quot
      CLOSE_TAG: C++,
      // </a
      CLOSE_TAG_SAW_WHITE: C++,
      // </a   >
      SCRIPT: C++,
      // <script> ...
      SCRIPT_ENDING: C++
      // <script> ... <
    }, t.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    }, t.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    }, Object.keys(t.ENTITIES).forEach(function(v) {
      var d = t.ENTITIES[v], $ = typeof d == "number" ? String.fromCharCode(d) : d;
      t.ENTITIES[v] = $;
    });
    for (var H in t.STATE)
      t.STATE[t.STATE[H]] = H;
    C = t.STATE;
    function M(v, d, $) {
      v[d] && v[d]($);
    }
    function J(v, d, $) {
      v.textNode && re(v), M(v, d, $);
    }
    function re(v) {
      v.textNode = k(v.opt, v.textNode), v.textNode && M(v, "ontext", v.textNode), v.textNode = "";
    }
    function k(v, d) {
      return v.trim && (d = d.trim()), v.normalize && (d = d.replace(/\s+/g, " ")), d;
    }
    function O(v, d) {
      return re(v), v.trackPosition && (d += `
Line: ` + v.line + `
Column: ` + v.column + `
Char: ` + v.c), d = new Error(d), v.error = d, M(v, "onerror", d), v;
    }
    function P(v) {
      return v.sawRoot && !v.closedRoot && w(v, "Unclosed root tag"), v.state !== C.BEGIN && v.state !== C.BEGIN_WHITESPACE && v.state !== C.TEXT && O(v, "Unexpected end"), re(v), v.c = "", v.closed = !0, M(v, "onend"), r.call(v, v.strict, v.opt), v;
    }
    function w(v, d) {
      if (typeof v != "object" || !(v instanceof r))
        throw new Error("bad call to strictFail");
      v.strict && O(v, d);
    }
    function _(v) {
      v.strict || (v.tagName = v.tagName[v.looseCase]());
      var d = v.tags[v.tags.length - 1] || v, $ = v.tag = { name: v.tagName, attributes: {} };
      v.opt.xmlns && ($.ns = d.ns), v.attribList.length = 0, J(v, "onopentagstart", $);
    }
    function R(v, d) {
      var $ = v.indexOf(":"), T = $ < 0 ? ["", v] : v.split(":"), G = T[0], W = T[1];
      return d && v === "xmlns" && (G = "xmlns", W = ""), { prefix: G, local: W };
    }
    function L(v) {
      if (v.strict || (v.attribName = v.attribName[v.looseCase]()), v.attribList.indexOf(v.attribName) !== -1 || v.tag.attributes.hasOwnProperty(v.attribName)) {
        v.attribName = v.attribValue = "";
        return;
      }
      if (v.opt.xmlns) {
        var d = R(v.attribName, !0), $ = d.prefix, T = d.local;
        if ($ === "xmlns")
          if (T === "xml" && v.attribValue !== m)
            w(
              v,
              "xml: prefix must be bound to " + m + `
Actual: ` + v.attribValue
            );
          else if (T === "xmlns" && v.attribValue !== g)
            w(
              v,
              "xmlns: prefix must be bound to " + g + `
Actual: ` + v.attribValue
            );
          else {
            var G = v.tag, W = v.tags[v.tags.length - 1] || v;
            G.ns === W.ns && (G.ns = Object.create(W.ns)), G.ns[T] = v.attribValue;
          }
        v.attribList.push([v.attribName, v.attribValue]);
      } else
        v.tag.attributes[v.attribName] = v.attribValue, J(v, "onattribute", {
          name: v.attribName,
          value: v.attribValue
        });
      v.attribName = v.attribValue = "";
    }
    function N(v, d) {
      if (v.opt.xmlns) {
        var $ = v.tag, T = R(v.tagName);
        $.prefix = T.prefix, $.local = T.local, $.uri = $.ns[T.prefix] || "", $.prefix && !$.uri && (w(v, "Unbound namespace prefix: " + JSON.stringify(v.tagName)), $.uri = T.prefix);
        var G = v.tags[v.tags.length - 1] || v;
        $.ns && G.ns !== $.ns && Object.keys($.ns).forEach(function(Wt) {
          J(v, "onopennamespace", {
            prefix: Wt,
            uri: $.ns[Wt]
          });
        });
        for (var W = 0, X = v.attribList.length; W < X; W++) {
          var ve = v.attribList[W], Te = ve[0], pt = ve[1], Se = R(Te, !0), qe = Se.prefix, er = Se.local, Ht = qe === "" ? "" : $.ns[qe] || "", Dt = {
            name: Te,
            value: pt,
            prefix: qe,
            local: er,
            uri: Ht
          };
          qe && qe !== "xmlns" && !Ht && (w(v, "Unbound namespace prefix: " + JSON.stringify(qe)), Dt.uri = qe), v.tag.attributes[Te] = Dt, J(v, "onattribute", Dt);
        }
        v.attribList.length = 0;
      }
      v.tag.isSelfClosing = !!d, v.sawRoot = !0, v.tags.push(v.tag), J(v, "onopentag", v.tag), d || (!v.noscript && v.tagName.toLowerCase() === "script" ? v.state = C.SCRIPT : v.state = C.TEXT, v.tag = null, v.tagName = ""), v.attribName = v.attribValue = "", v.attribList.length = 0;
    }
    function j(v) {
      if (!v.tagName) {
        w(v, "Weird empty close tag."), v.textNode += "</>", v.state = C.TEXT;
        return;
      }
      if (v.script) {
        if (v.tagName !== "script") {
          v.script += "</" + v.tagName + ">", v.tagName = "", v.state = C.SCRIPT;
          return;
        }
        J(v, "onscript", v.script), v.script = "";
      }
      var d = v.tags.length, $ = v.tagName;
      v.strict || ($ = $[v.looseCase]());
      for (var T = $; d--; ) {
        var G = v.tags[d];
        if (G.name !== T)
          w(v, "Unexpected close tag");
        else
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          break;
        }
      }
<<<<<<< HEAD
      if (t2 < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s2 = parser.tags.length;
      while (s2-- > t2) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i in tag.ns) {
          x[i] = tag.ns[i];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
      }
      if (t2 === 0) parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
      if (c === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace2(c)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i) {
      var result = "";
      if (i < chunk.length) {
        result = chunk.charAt(i);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error2(
          parser,
          "Cannot write after close. Assign an onready handler."
        );
      }
      if (chunk === null) {
        return end2(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i = 0;
      var c = "";
      while (true) {
        c = charAt(chunk, i++);
        parser.c = c;
        if (!c) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i - 1;
              while (c && c !== "<" && c !== "&") {
                c = charAt(chunk, i++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i - 1);
            }
            if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace2(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;
          case S.SCRIPT:
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace2(c)) ;
            else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(" ") + c;
              }
              parser.textNode += "<" + c;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if (parser.sgmlDecl + c === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
              continue;
            }
            if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
              parser.state = S.DOCTYPE_DTD;
              parser.doctype += "<!" + parser.sgmlDecl + c;
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(
                  parser,
                  "Inappropriately located doctype declaration"
                );
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c;
              if (c === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            if (c === "]") {
              parser.doctype += c;
              parser.state = S.DOCTYPE;
            } else if (c === "<") {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else if (isQuote(c)) {
              parser.doctype += c;
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            } else {
              parser.doctype += c;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c;
              parser.state = S.COMMENT;
            } else if (parser.doctype && parser.doctype !== true) {
              parser.state = S.DOCTYPE_DTD;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;
          case S.CDATA_ENDING:
            if (c === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace2(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace2(c)) {
              continue;
            } else if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace2(c)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace2(c)) {
              continue;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace2(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace2(c)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace2(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              if (!parser.opt.unquotedAttributeValues) {
                error2(parser, "Unquoted attribute value");
              }
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace2(c)) {
              parser.state = S.ATTRIB;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace2(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace2(c)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace2(c)) {
              continue;
            }
            if (c === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer2;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer2 = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer2 = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer2 = "attribValue";
                break;
            }
            if (c === ";") {
              var parsedEntity = parseEntity(parser);
              if (parser.opt.unparsedEntities && !Object.values(sax2.XML_ENTITIES).includes(parsedEntity)) {
                parser.entity = "";
                parser.state = returnState;
                parser.write(parsedEntity);
              } else {
                parser[buffer2] += parsedEntity;
                parser.entity = "";
                parser.state = returnState;
              }
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer2] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default: {
            throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor2 = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 1114111 || // not a valid Unicode code point
            floor2(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(exports);
})(sax$1);
Object.defineProperty(xml, "__esModule", { value: true });
xml.XElement = void 0;
xml.parseXml = parseXml;
const sax = sax$1;
const error_1 = error;
class XElement {
  constructor(name) {
    this.name = name;
    this.value = "";
    this.attributes = null;
    this.isCData = false;
    this.elements = null;
    if (!name) {
      throw (0, error_1.newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
    }
    if (!isValidName(name)) {
      throw (0, error_1.newError)(`Invalid element name: ${name}`, "ERR_XML_ELEMENT_INVALID_NAME");
    }
  }
  attribute(name) {
    const result = this.attributes === null ? null : this.attributes[name];
    if (result == null) {
      throw (0, error_1.newError)(`No attribute "${name}"`, "ERR_XML_MISSED_ATTRIBUTE");
    }
    return result;
=======
      if (d < 0) {
        w(v, "Unmatched closing tag: " + v.tagName), v.textNode += "</" + v.tagName + ">", v.state = C.TEXT;
        return;
      }
      v.tagName = $;
      for (var W = v.tags.length; W-- > d; ) {
        var X = v.tag = v.tags.pop();
        v.tagName = v.tag.name, J(v, "onclosetag", v.tagName);
        var ve = {};
        for (var Te in X.ns)
          ve[Te] = X.ns[Te];
        var pt = v.tags[v.tags.length - 1] || v;
        v.opt.xmlns && X.ns !== pt.ns && Object.keys(X.ns).forEach(function(Se) {
          var qe = X.ns[Se];
          J(v, "onclosenamespace", { prefix: Se, uri: qe });
        });
      }
      d === 0 && (v.closedRoot = !0), v.tagName = v.attribValue = v.attribName = "", v.attribList.length = 0, v.state = C.TEXT;
    }
    function K(v) {
      var d = v.entity, $ = d.toLowerCase(), T, G = "";
      return v.ENTITIES[d] ? v.ENTITIES[d] : v.ENTITIES[$] ? v.ENTITIES[$] : (d = $, d.charAt(0) === "#" && (d.charAt(1) === "x" ? (d = d.slice(2), T = parseInt(d, 16), G = T.toString(16)) : (d = d.slice(1), T = parseInt(d, 10), G = T.toString(10))), d = d.replace(/^0+/, ""), isNaN(T) || G.toLowerCase() !== d ? (w(v, "Invalid character entity"), "&" + v.entity + ";") : String.fromCodePoint(T));
    }
    function Z(v, d) {
      d === "<" ? (v.state = C.OPEN_WAKA, v.startTagPosition = v.position) : S(d) || (w(v, "Non-whitespace before first tag."), v.textNode = d, v.state = C.TEXT);
    }
    function q(v, d) {
      var $ = "";
      return d < v.length && ($ = v.charAt(d)), $;
    }
    function le(v) {
      var d = this;
      if (this.error)
        throw this.error;
      if (d.closed)
        return O(
          d,
          "Cannot write after close. Assign an onready handler."
        );
      if (v === null)
        return P(d);
      typeof v == "object" && (v = v.toString());
      for (var $ = 0, T = ""; T = q(v, $++), d.c = T, !!T; )
        switch (d.trackPosition && (d.position++, T === `
` ? (d.line++, d.column = 0) : d.column++), d.state) {
          case C.BEGIN:
            if (d.state = C.BEGIN_WHITESPACE, T === "\uFEFF")
              continue;
            Z(d, T);
            continue;
          case C.BEGIN_WHITESPACE:
            Z(d, T);
            continue;
          case C.TEXT:
            if (d.sawRoot && !d.closedRoot) {
              for (var G = $ - 1; T && T !== "<" && T !== "&"; )
                T = q(v, $++), T && d.trackPosition && (d.position++, T === `
` ? (d.line++, d.column = 0) : d.column++);
              d.textNode += v.substring(G, $ - 1);
            }
            T === "<" && !(d.sawRoot && d.closedRoot && !d.strict) ? (d.state = C.OPEN_WAKA, d.startTagPosition = d.position) : (!S(T) && (!d.sawRoot || d.closedRoot) && w(d, "Text data outside of root node."), T === "&" ? d.state = C.TEXT_ENTITY : d.textNode += T);
            continue;
          case C.SCRIPT:
            T === "<" ? d.state = C.SCRIPT_ENDING : d.script += T;
            continue;
          case C.SCRIPT_ENDING:
            T === "/" ? d.state = C.CLOSE_TAG : (d.script += "<" + T, d.state = C.SCRIPT);
            continue;
          case C.OPEN_WAKA:
            if (T === "!")
              d.state = C.SGML_DECL, d.sgmlDecl = "";
            else if (!S(T)) if (z(b, T))
              d.state = C.OPEN_TAG, d.tagName = T;
            else if (T === "/")
              d.state = C.CLOSE_TAG, d.tagName = "";
            else if (T === "?")
              d.state = C.PROC_INST, d.procInstName = d.procInstBody = "";
            else {
              if (w(d, "Unencoded <"), d.startTagPosition + 1 < d.position) {
                var W = d.position - d.startTagPosition;
                T = new Array(W).join(" ") + T;
              }
              d.textNode += "<" + T, d.state = C.TEXT;
            }
            continue;
          case C.SGML_DECL:
            if (d.sgmlDecl + T === "--") {
              d.state = C.COMMENT, d.comment = "", d.sgmlDecl = "";
              continue;
            }
            d.doctype && d.doctype !== !0 && d.sgmlDecl ? (d.state = C.DOCTYPE_DTD, d.doctype += "<!" + d.sgmlDecl + T, d.sgmlDecl = "") : (d.sgmlDecl + T).toUpperCase() === p ? (J(d, "onopencdata"), d.state = C.CDATA, d.sgmlDecl = "", d.cdata = "") : (d.sgmlDecl + T).toUpperCase() === f ? (d.state = C.DOCTYPE, (d.doctype || d.sawRoot) && w(
              d,
              "Inappropriately located doctype declaration"
            ), d.doctype = "", d.sgmlDecl = "") : T === ">" ? (J(d, "onsgmldeclaration", d.sgmlDecl), d.sgmlDecl = "", d.state = C.TEXT) : (D(T) && (d.state = C.SGML_DECL_QUOTED), d.sgmlDecl += T);
            continue;
          case C.SGML_DECL_QUOTED:
            T === d.q && (d.state = C.SGML_DECL, d.q = ""), d.sgmlDecl += T;
            continue;
          case C.DOCTYPE:
            T === ">" ? (d.state = C.TEXT, J(d, "ondoctype", d.doctype), d.doctype = !0) : (d.doctype += T, T === "[" ? d.state = C.DOCTYPE_DTD : D(T) && (d.state = C.DOCTYPE_QUOTED, d.q = T));
            continue;
          case C.DOCTYPE_QUOTED:
            d.doctype += T, T === d.q && (d.q = "", d.state = C.DOCTYPE);
            continue;
          case C.DOCTYPE_DTD:
            T === "]" ? (d.doctype += T, d.state = C.DOCTYPE) : T === "<" ? (d.state = C.OPEN_WAKA, d.startTagPosition = d.position) : D(T) ? (d.doctype += T, d.state = C.DOCTYPE_DTD_QUOTED, d.q = T) : d.doctype += T;
            continue;
          case C.DOCTYPE_DTD_QUOTED:
            d.doctype += T, T === d.q && (d.state = C.DOCTYPE_DTD, d.q = "");
            continue;
          case C.COMMENT:
            T === "-" ? d.state = C.COMMENT_ENDING : d.comment += T;
            continue;
          case C.COMMENT_ENDING:
            T === "-" ? (d.state = C.COMMENT_ENDED, d.comment = k(d.opt, d.comment), d.comment && J(d, "oncomment", d.comment), d.comment = "") : (d.comment += "-" + T, d.state = C.COMMENT);
            continue;
          case C.COMMENT_ENDED:
            T !== ">" ? (w(d, "Malformed comment"), d.comment += "--" + T, d.state = C.COMMENT) : d.doctype && d.doctype !== !0 ? d.state = C.DOCTYPE_DTD : d.state = C.TEXT;
            continue;
          case C.CDATA:
            T === "]" ? d.state = C.CDATA_ENDING : d.cdata += T;
            continue;
          case C.CDATA_ENDING:
            T === "]" ? d.state = C.CDATA_ENDING_2 : (d.cdata += "]" + T, d.state = C.CDATA);
            continue;
          case C.CDATA_ENDING_2:
            T === ">" ? (d.cdata && J(d, "oncdata", d.cdata), J(d, "onclosecdata"), d.cdata = "", d.state = C.TEXT) : T === "]" ? d.cdata += "]" : (d.cdata += "]]" + T, d.state = C.CDATA);
            continue;
          case C.PROC_INST:
            T === "?" ? d.state = C.PROC_INST_ENDING : S(T) ? d.state = C.PROC_INST_BODY : d.procInstName += T;
            continue;
          case C.PROC_INST_BODY:
            if (!d.procInstBody && S(T))
              continue;
            T === "?" ? d.state = C.PROC_INST_ENDING : d.procInstBody += T;
            continue;
          case C.PROC_INST_ENDING:
            T === ">" ? (J(d, "onprocessinginstruction", {
              name: d.procInstName,
              body: d.procInstBody
            }), d.procInstName = d.procInstBody = "", d.state = C.TEXT) : (d.procInstBody += "?" + T, d.state = C.PROC_INST_BODY);
            continue;
          case C.OPEN_TAG:
            z(x, T) ? d.tagName += T : (_(d), T === ">" ? N(d) : T === "/" ? d.state = C.OPEN_TAG_SLASH : (S(T) || w(d, "Invalid character in tag name"), d.state = C.ATTRIB));
            continue;
          case C.OPEN_TAG_SLASH:
            T === ">" ? (N(d, !0), j(d)) : (w(d, "Forward-slash in opening tag not followed by >"), d.state = C.ATTRIB);
            continue;
          case C.ATTRIB:
            if (S(T))
              continue;
            T === ">" ? N(d) : T === "/" ? d.state = C.OPEN_TAG_SLASH : z(b, T) ? (d.attribName = T, d.attribValue = "", d.state = C.ATTRIB_NAME) : w(d, "Invalid attribute name");
            continue;
          case C.ATTRIB_NAME:
            T === "=" ? d.state = C.ATTRIB_VALUE : T === ">" ? (w(d, "Attribute without value"), d.attribValue = d.attribName, L(d), N(d)) : S(T) ? d.state = C.ATTRIB_NAME_SAW_WHITE : z(x, T) ? d.attribName += T : w(d, "Invalid attribute name");
            continue;
          case C.ATTRIB_NAME_SAW_WHITE:
            if (T === "=")
              d.state = C.ATTRIB_VALUE;
            else {
              if (S(T))
                continue;
              w(d, "Attribute without value"), d.tag.attributes[d.attribName] = "", d.attribValue = "", J(d, "onattribute", {
                name: d.attribName,
                value: ""
              }), d.attribName = "", T === ">" ? N(d) : z(b, T) ? (d.attribName = T, d.state = C.ATTRIB_NAME) : (w(d, "Invalid attribute name"), d.state = C.ATTRIB);
            }
            continue;
          case C.ATTRIB_VALUE:
            if (S(T))
              continue;
            D(T) ? (d.q = T, d.state = C.ATTRIB_VALUE_QUOTED) : (d.opt.unquotedAttributeValues || O(d, "Unquoted attribute value"), d.state = C.ATTRIB_VALUE_UNQUOTED, d.attribValue = T);
            continue;
          case C.ATTRIB_VALUE_QUOTED:
            if (T !== d.q) {
              T === "&" ? d.state = C.ATTRIB_VALUE_ENTITY_Q : d.attribValue += T;
              continue;
            }
            L(d), d.q = "", d.state = C.ATTRIB_VALUE_CLOSED;
            continue;
          case C.ATTRIB_VALUE_CLOSED:
            S(T) ? d.state = C.ATTRIB : T === ">" ? N(d) : T === "/" ? d.state = C.OPEN_TAG_SLASH : z(b, T) ? (w(d, "No whitespace between attributes"), d.attribName = T, d.attribValue = "", d.state = C.ATTRIB_NAME) : w(d, "Invalid attribute name");
            continue;
          case C.ATTRIB_VALUE_UNQUOTED:
            if (!U(T)) {
              T === "&" ? d.state = C.ATTRIB_VALUE_ENTITY_U : d.attribValue += T;
              continue;
            }
            L(d), T === ">" ? N(d) : d.state = C.ATTRIB;
            continue;
          case C.CLOSE_TAG:
            if (d.tagName)
              T === ">" ? j(d) : z(x, T) ? d.tagName += T : d.script ? (d.script += "</" + d.tagName, d.tagName = "", d.state = C.SCRIPT) : (S(T) || w(d, "Invalid tagname in closing tag"), d.state = C.CLOSE_TAG_SAW_WHITE);
            else {
              if (S(T))
                continue;
              ee(b, T) ? d.script ? (d.script += "</" + T, d.state = C.SCRIPT) : w(d, "Invalid tagname in closing tag.") : d.tagName = T;
            }
            continue;
          case C.CLOSE_TAG_SAW_WHITE:
            if (S(T))
              continue;
            T === ">" ? j(d) : w(d, "Invalid characters in closing tag");
            continue;
          case C.TEXT_ENTITY:
          case C.ATTRIB_VALUE_ENTITY_Q:
          case C.ATTRIB_VALUE_ENTITY_U:
            var X, ve;
            switch (d.state) {
              case C.TEXT_ENTITY:
                X = C.TEXT, ve = "textNode";
                break;
              case C.ATTRIB_VALUE_ENTITY_Q:
                X = C.ATTRIB_VALUE_QUOTED, ve = "attribValue";
                break;
              case C.ATTRIB_VALUE_ENTITY_U:
                X = C.ATTRIB_VALUE_UNQUOTED, ve = "attribValue";
                break;
            }
            if (T === ";") {
              var Te = K(d);
              d.opt.unparsedEntities && !Object.values(t.XML_ENTITIES).includes(Te) ? (d.entity = "", d.state = X, d.write(Te)) : (d[ve] += Te, d.entity = "", d.state = X);
            } else z(d.entity.length ? E : y, T) ? d.entity += T : (w(d, "Invalid character in entity name"), d[ve] += "&" + d.entity + T, d.entity = "", d.state = X);
            continue;
          default:
            throw new Error(d, "Unknown state: " + d.state);
        }
      return d.position >= d.bufferCheckPosition && i(d), d;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    String.fromCodePoint || function() {
      var v = String.fromCharCode, d = Math.floor, $ = function() {
        var T = 16384, G = [], W, X, ve = -1, Te = arguments.length;
        if (!Te)
          return "";
        for (var pt = ""; ++ve < Te; ) {
          var Se = Number(arguments[ve]);
          if (!isFinite(Se) || // `NaN`, `+Infinity`, or `-Infinity`
          Se < 0 || // not a valid Unicode code point
          Se > 1114111 || // not a valid Unicode code point
          d(Se) !== Se)
            throw RangeError("Invalid code point: " + Se);
          Se <= 65535 ? G.push(Se) : (Se -= 65536, W = (Se >> 10) + 55296, X = Se % 1024 + 56320, G.push(W, X)), (ve + 1 === Te || G.length > T) && (pt += v.apply(null, G), G.length = 0);
        }
        return pt;
      };
      Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
        value: $,
        configurable: !0,
        writable: !0
      }) : String.fromCodePoint = $;
    }();
  })(e);
})(zv);
Object.defineProperty(Qi, "__esModule", { value: !0 });
Qi.XElement = void 0;
Qi.parseXml = f9;
const l9 = zv, Pa = qr;
class Hv {
  constructor(t) {
    if (this.name = t, this.value = "", this.attributes = null, this.isCData = !1, this.elements = null, !t)
      throw (0, Pa.newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
    if (!p9(t))
      throw (0, Pa.newError)(`Invalid element name: ${t}`, "ERR_XML_ELEMENT_INVALID_NAME");
  }
  attribute(t) {
    const n = this.attributes === null ? null : this.attributes[t];
    if (n == null)
      throw (0, Pa.newError)(`No attribute "${t}"`, "ERR_XML_MISSED_ATTRIBUTE");
    return n;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  removeAttribute(name) {
    if (this.attributes !== null) {
      delete this.attributes[name];
    }
  }
<<<<<<< HEAD
  element(name, ignoreCase = false, errorIfMissed = null) {
    const result = this.elementOrNull(name, ignoreCase);
    if (result === null) {
      throw (0, error_1.newError)(errorIfMissed || `No element "${name}"`, "ERR_XML_MISSED_ELEMENT");
    }
    return result;
=======
  element(t, n = !1, r = null) {
    const i = this.elementOrNull(t, n);
    if (i === null)
      throw (0, Pa.newError)(r || `No element "${t}"`, "ERR_XML_MISSED_ELEMENT");
    return i;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  elementOrNull(name, ignoreCase = false) {
    if (this.elements === null) {
      return null;
<<<<<<< HEAD
    }
    for (const element of this.elements) {
      if (isNameEquals(element, name, ignoreCase)) {
        return element;
      }
    }
    return null;
  }
  getElements(name, ignoreCase = false) {
    if (this.elements === null) {
      return [];
    }
    return this.elements.filter((it) => isNameEquals(it, name, ignoreCase));
  }
  elementValueOrEmpty(name, ignoreCase = false) {
    const element = this.elementOrNull(name, ignoreCase);
    return element === null ? "" : element.value;
  }
}
xml.XElement = XElement;
const NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function isValidName(name) {
  return NAME_REG_EXP.test(name);
}
function isNameEquals(element, name, ignoreCase) {
  const elementName = element.name;
  return elementName === name || ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase();
}
function parseXml(data) {
  let rootElement = null;
  const parser = sax.parser(true, {});
  const elements = [];
  parser.onopentag = (saxElement) => {
    const element = new XElement(saxElement.name);
    element.attributes = saxElement.attributes;
    if (rootElement === null) {
      rootElement = element;
    } else {
      const parent = elements[elements.length - 1];
      if (parent.elements == null) {
        parent.elements = [];
      }
      parent.elements.push(element);
    }
    elements.push(element);
  };
  parser.onclosetag = () => {
    elements.pop();
  };
  parser.ontext = (text) => {
    if (elements.length > 0) {
      elements[elements.length - 1].value = text;
    }
  };
  parser.oncdata = (cdata) => {
    const element = elements[elements.length - 1];
    element.value = cdata;
    element.isCData = true;
  };
  parser.onerror = (err) => {
    throw err;
  };
  parser.write(data);
  return rootElement;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CURRENT_APP_PACKAGE_FILE_NAME = exports.CURRENT_APP_INSTALLER_FILE_NAME = exports.XElement = exports.parseXml = exports.UUID = exports.parseDn = exports.retry = exports.githubUrl = exports.getS3LikeProviderBaseUrl = exports.ProgressCallbackTransform = exports.MemoLazy = exports.safeStringifyJson = exports.safeGetHeader = exports.parseJson = exports.HttpExecutor = exports.HttpError = exports.DigestTransform = exports.createHttpError = exports.configureRequestUrl = exports.configureRequestOptionsFromUrl = exports.configureRequestOptions = exports.newError = exports.CancellationToken = exports.CancellationError = void 0;
  exports.asArray = asArray;
  var CancellationToken_12 = CancellationToken$1;
  Object.defineProperty(exports, "CancellationError", { enumerable: true, get: function() {
    return CancellationToken_12.CancellationError;
  } });
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return CancellationToken_12.CancellationToken;
  } });
  var error_12 = error;
  Object.defineProperty(exports, "newError", { enumerable: true, get: function() {
    return error_12.newError;
  } });
  var httpExecutor_1 = httpExecutor;
  Object.defineProperty(exports, "configureRequestOptions", { enumerable: true, get: function() {
    return httpExecutor_1.configureRequestOptions;
  } });
  Object.defineProperty(exports, "configureRequestOptionsFromUrl", { enumerable: true, get: function() {
    return httpExecutor_1.configureRequestOptionsFromUrl;
  } });
  Object.defineProperty(exports, "configureRequestUrl", { enumerable: true, get: function() {
    return httpExecutor_1.configureRequestUrl;
  } });
  Object.defineProperty(exports, "createHttpError", { enumerable: true, get: function() {
    return httpExecutor_1.createHttpError;
  } });
  Object.defineProperty(exports, "DigestTransform", { enumerable: true, get: function() {
    return httpExecutor_1.DigestTransform;
  } });
  Object.defineProperty(exports, "HttpError", { enumerable: true, get: function() {
    return httpExecutor_1.HttpError;
  } });
  Object.defineProperty(exports, "HttpExecutor", { enumerable: true, get: function() {
    return httpExecutor_1.HttpExecutor;
  } });
  Object.defineProperty(exports, "parseJson", { enumerable: true, get: function() {
    return httpExecutor_1.parseJson;
  } });
  Object.defineProperty(exports, "safeGetHeader", { enumerable: true, get: function() {
    return httpExecutor_1.safeGetHeader;
  } });
  Object.defineProperty(exports, "safeStringifyJson", { enumerable: true, get: function() {
    return httpExecutor_1.safeStringifyJson;
  } });
  var MemoLazy_1 = MemoLazy$1;
  Object.defineProperty(exports, "MemoLazy", { enumerable: true, get: function() {
    return MemoLazy_1.MemoLazy;
  } });
  var ProgressCallbackTransform_12 = ProgressCallbackTransform$1;
  Object.defineProperty(exports, "ProgressCallbackTransform", { enumerable: true, get: function() {
    return ProgressCallbackTransform_12.ProgressCallbackTransform;
  } });
  var publishOptions_1 = publishOptions;
  Object.defineProperty(exports, "getS3LikeProviderBaseUrl", { enumerable: true, get: function() {
    return publishOptions_1.getS3LikeProviderBaseUrl;
  } });
  Object.defineProperty(exports, "githubUrl", { enumerable: true, get: function() {
    return publishOptions_1.githubUrl;
  } });
  var retry_1 = retry$1;
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var rfc2253Parser_1 = rfc2253Parser;
  Object.defineProperty(exports, "parseDn", { enumerable: true, get: function() {
    return rfc2253Parser_1.parseDn;
  } });
  var uuid_1 = uuid;
  Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
    return uuid_1.UUID;
  } });
  var xml_1 = xml;
  Object.defineProperty(exports, "parseXml", { enumerable: true, get: function() {
    return xml_1.parseXml;
  } });
  Object.defineProperty(exports, "XElement", { enumerable: true, get: function() {
    return xml_1.XElement;
  } });
  exports.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe";
  exports.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
  function asArray(v) {
    if (v == null) {
      return [];
    } else if (Array.isArray(v)) {
      return v;
    } else {
      return [v];
    }
  }
})(out);
var jsYaml = {};
var loader$1 = {};
var common$5 = {};
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key2, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key2 = sourceKeys[index];
      target[key2] = source[key2];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
common$5.isNothing = isNothing;
common$5.isObject = isObject;
common$5.toArray = toArray;
common$5.repeat = repeat;
common$5.isNegativeZero = isNegativeZero;
common$5.extend = extend;
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$4(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$4.prototype = Object.create(Error.prototype);
YAMLException$4.prototype.constructor = YAMLException$4;
YAMLException$4.prototype.toString = function toString3(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$4;
var common$4 = common$5;
function getLine(buffer2, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer2.slice(lineStart, lineEnd).replace(/\t/g, "") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max2) {
  return common$4.repeat(" ", max2 - string.length) + string;
}
function makeSnippet$1(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re2 = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re2.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common$4.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common$4.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common$4.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common$4.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet$1;
var YAMLException$3 = exception;
var TYPE_CONSTRUCTOR_OPTIONS = [
=======
    for (const r of this.elements)
      if (rh(r, t, n))
        return r;
    return null;
  }
  getElements(t, n = !1) {
    return this.elements === null ? [] : this.elements.filter((r) => rh(r, t, n));
  }
  elementValueOrEmpty(t, n = !1) {
    const r = this.elementOrNull(t, n);
    return r === null ? "" : r.value;
  }
}
Qi.XElement = Hv;
const u9 = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function p9(e) {
  return u9.test(e);
}
function rh(e, t, n) {
  const r = e.name;
  return r === t || n === !0 && r.length === t.length && r.toLowerCase() === t.toLowerCase();
}
function f9(e) {
  let t = null;
  const n = l9.parser(!0, {}), r = [];
  return n.onopentag = (i) => {
    const a = new Hv(i.name);
    if (a.attributes = i.attributes, t === null)
      t = a;
    else {
      const s = r[r.length - 1];
      s.elements == null && (s.elements = []), s.elements.push(a);
    }
    r.push(a);
  }, n.onclosetag = () => {
    r.pop();
  }, n.ontext = (i) => {
    r.length > 0 && (r[r.length - 1].value = i);
  }, n.oncdata = (i) => {
    const a = r[r.length - 1];
    a.value = i, a.isCData = !0;
  }, n.onerror = (i) => {
    throw i;
  }, n.write(e), t;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CURRENT_APP_PACKAGE_FILE_NAME = e.CURRENT_APP_INSTALLER_FILE_NAME = e.XElement = e.parseXml = e.UUID = e.parseDn = e.retry = e.githubUrl = e.getS3LikeProviderBaseUrl = e.ProgressCallbackTransform = e.MemoLazy = e.safeStringifyJson = e.safeGetHeader = e.parseJson = e.HttpExecutor = e.HttpError = e.DigestTransform = e.createHttpError = e.configureRequestUrl = e.configureRequestOptionsFromUrl = e.configureRequestOptions = e.newError = e.CancellationToken = e.CancellationError = void 0, e.asArray = p;
  var t = dn;
  Object.defineProperty(e, "CancellationError", { enumerable: !0, get: function() {
    return t.CancellationError;
  } }), Object.defineProperty(e, "CancellationToken", { enumerable: !0, get: function() {
    return t.CancellationToken;
  } });
  var n = qr;
  Object.defineProperty(e, "newError", { enumerable: !0, get: function() {
    return n.newError;
  } });
  var r = He;
  Object.defineProperty(e, "configureRequestOptions", { enumerable: !0, get: function() {
    return r.configureRequestOptions;
  } }), Object.defineProperty(e, "configureRequestOptionsFromUrl", { enumerable: !0, get: function() {
    return r.configureRequestOptionsFromUrl;
  } }), Object.defineProperty(e, "configureRequestUrl", { enumerable: !0, get: function() {
    return r.configureRequestUrl;
  } }), Object.defineProperty(e, "createHttpError", { enumerable: !0, get: function() {
    return r.createHttpError;
  } }), Object.defineProperty(e, "DigestTransform", { enumerable: !0, get: function() {
    return r.DigestTransform;
  } }), Object.defineProperty(e, "HttpError", { enumerable: !0, get: function() {
    return r.HttpError;
  } }), Object.defineProperty(e, "HttpExecutor", { enumerable: !0, get: function() {
    return r.HttpExecutor;
  } }), Object.defineProperty(e, "parseJson", { enumerable: !0, get: function() {
    return r.parseJson;
  } }), Object.defineProperty(e, "safeGetHeader", { enumerable: !0, get: function() {
    return r.safeGetHeader;
  } }), Object.defineProperty(e, "safeStringifyJson", { enumerable: !0, get: function() {
    return r.safeStringifyJson;
  } });
  var i = po;
  Object.defineProperty(e, "MemoLazy", { enumerable: !0, get: function() {
    return i.MemoLazy;
  } });
  var a = Zi;
  Object.defineProperty(e, "ProgressCallbackTransform", { enumerable: !0, get: function() {
    return a.ProgressCallbackTransform;
  } });
  var s = fo;
  Object.defineProperty(e, "getS3LikeProviderBaseUrl", { enumerable: !0, get: function() {
    return s.getS3LikeProviderBaseUrl;
  } }), Object.defineProperty(e, "githubUrl", { enumerable: !0, get: function() {
    return s.githubUrl;
  } });
  var c = Ku;
  Object.defineProperty(e, "retry", { enumerable: !0, get: function() {
    return c.retry;
  } });
  var o = Ju;
  Object.defineProperty(e, "parseDn", { enumerable: !0, get: function() {
    return o.parseDn;
  } });
  var u = Lr;
  Object.defineProperty(e, "UUID", { enumerable: !0, get: function() {
    return u.UUID;
  } });
  var l = Qi;
  Object.defineProperty(e, "parseXml", { enumerable: !0, get: function() {
    return l.parseXml;
  } }), Object.defineProperty(e, "XElement", { enumerable: !0, get: function() {
    return l.XElement;
  } }), e.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe", e.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
  function p(f) {
    return f == null ? [] : Array.isArray(f) ? f : [f];
  }
})(Fe);
var Ue = {}, Zu = {}, xt = {};
function Wv(e) {
  return typeof e > "u" || e === null;
}
function d9(e) {
  return typeof e == "object" && e !== null;
}
function h9(e) {
  return Array.isArray(e) ? e : Wv(e) ? [] : [e];
}
function m9(e, t) {
  var n, r, i, a;
  if (t)
    for (a = Object.keys(t), n = 0, r = a.length; n < r; n += 1)
      i = a[n], e[i] = t[i];
  return e;
}
function v9(e, t) {
  var n = "", r;
  for (r = 0; r < t; r += 1)
    n += e;
  return n;
}
function g9(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
xt.isNothing = Wv;
xt.isObject = d9;
xt.toArray = h9;
xt.repeat = v9;
xt.isNegativeZero = g9;
xt.extend = m9;
function Gv(e, t) {
  var n = "", r = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (n += 'in "' + e.mark.name + '" '), n += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (n += `

` + e.mark.snippet), r + " " + n) : r;
}
function Ti(e, t) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = Gv(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
Ti.prototype = Object.create(Error.prototype);
Ti.prototype.constructor = Ti;
Ti.prototype.toString = function(t) {
  return this.name + ": " + Gv(this, t);
};
var ea = Ti, oi = xt;
function Yc(e, t, n, r, i) {
  var a = "", s = "", c = Math.floor(i / 2) - 1;
  return r - t > c && (a = " ... ", t = r - c + a.length), n - r > c && (s = " ...", n = r + c - s.length), {
    str: a + e.slice(t, n).replace(/\t/g, "") + s,
    pos: r - t + a.length
    // relative position
  };
}
function Xc(e, t) {
  return oi.repeat(" ", t - e.length) + e;
}
function b9(e, t) {
  if (t = Object.create(t || null), !e.buffer) return null;
  t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var n = /\r?\n|\r|\0/g, r = [0], i = [], a, s = -1; a = n.exec(e.buffer); )
    i.push(a.index), r.push(a.index + a[0].length), e.position <= a.index && s < 0 && (s = r.length - 2);
  s < 0 && (s = r.length - 1);
  var c = "", o, u, l = Math.min(e.line + t.linesAfter, i.length).toString().length, p = t.maxLength - (t.indent + l + 3);
  for (o = 1; o <= t.linesBefore && !(s - o < 0); o++)
    u = Yc(
      e.buffer,
      r[s - o],
      i[s - o],
      e.position - (r[s] - r[s - o]),
      p
    ), c = oi.repeat(" ", t.indent) + Xc((e.line - o + 1).toString(), l) + " | " + u.str + `
` + c;
  for (u = Yc(e.buffer, r[s], i[s], e.position, p), c += oi.repeat(" ", t.indent) + Xc((e.line + 1).toString(), l) + " | " + u.str + `
`, c += oi.repeat("-", t.indent + l + 3 + u.pos) + `^
`, o = 1; o <= t.linesAfter && !(s + o >= i.length); o++)
    u = Yc(
      e.buffer,
      r[s + o],
      i[s + o],
      e.position - (r[s] - r[s + o]),
      p
    ), c += oi.repeat(" ", t.indent) + Xc((e.line + o + 1).toString(), l) + " | " + u.str + `
`;
  return c.replace(/\n$/, "");
}
var x9 = b9, ih = ea, y9 = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
<<<<<<< HEAD
];
var YAML_NODE_KINDS = [
=======
], w9 = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  "scalar",
  "sequence",
  "mapping"
];
<<<<<<< HEAD
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
=======
function E9(e) {
  var t = {};
  return e !== null && Object.keys(e).forEach(function(n) {
    e[n].forEach(function(r) {
      t[String(r)] = n;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    });
  }
  return result;
}
<<<<<<< HEAD
function Type$e(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException$3('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$e;
var YAMLException$2 = exception;
var Type$d = type;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
=======
function _9(e, t) {
  if (t = t || {}, Object.keys(t).forEach(function(n) {
    if (y9.indexOf(n) === -1)
      throw new ih('Unknown option "' + n + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
    return !0;
  }, this.construct = t.construct || function(n) {
    return n;
  }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = E9(t.styleAliases || null), w9.indexOf(this.kind) === -1)
    throw new ih('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var Xe = _9, ni = ea, Kc = Xe;
function ah(e, t) {
  var n = [];
  return e[t].forEach(function(r) {
    var i = n.length;
    n.forEach(function(a, s) {
      a.tag === r.tag && a.kind === r.kind && a.multi === r.multi && (i = s);
    }), n[i] = r;
  }), n;
}
function S9() {
  var e = {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
<<<<<<< HEAD
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof Type$d) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);
  } else {
    throw new YAMLException$2("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type2) {
    if (!(type2 instanceof Type$d)) {
      throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type2.loadKind && type2.loadKind !== "scalar") {
      throw new YAMLException$2("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type2.multi) {
      throw new YAMLException$2("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type2) {
    if (!(type2 instanceof Type$d)) {
      throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var Type$c = type;
var str = new Type$c("tag:yaml.org,2002:str", {
=======
function Ml(e) {
  return this.extend(e);
}
Ml.prototype.extend = function(t) {
  var n = [], r = [];
  if (t instanceof Kc)
    r.push(t);
  else if (Array.isArray(t))
    r = r.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (n = n.concat(t.implicit)), t.explicit && (r = r.concat(t.explicit));
  else
    throw new ni("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  n.forEach(function(a) {
    if (!(a instanceof Kc))
      throw new ni("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (a.loadKind && a.loadKind !== "scalar")
      throw new ni("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (a.multi)
      throw new ni("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), r.forEach(function(a) {
    if (!(a instanceof Kc))
      throw new ni("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(Ml.prototype);
  return i.implicit = (this.implicit || []).concat(n), i.explicit = (this.explicit || []).concat(r), i.compiledImplicit = ah(i, "implicit"), i.compiledExplicit = ah(i, "explicit"), i.compiledTypeMap = S9(i.compiledImplicit, i.compiledExplicit), i;
};
var Vv = Ml, A9 = Xe, Yv = new A9("tag:yaml.org,2002:str", {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
<<<<<<< HEAD
});
var Type$b = type;
var seq = new Type$b("tag:yaml.org,2002:seq", {
=======
}), T9 = Xe, Xv = new T9("tag:yaml.org,2002:seq", {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
<<<<<<< HEAD
});
var Type$a = type;
var map = new Type$a("tag:yaml.org,2002:map", {
=======
}), C9 = Xe, Kv = new C9("tag:yaml.org,2002:map", {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
<<<<<<< HEAD
});
var Schema = schema;
var failsafe = new Schema({
  explicit: [
    str,
    seq,
    map
  ]
});
var Type$9 = type;
function resolveYamlNull(data) {
  if (data === null) return true;
  var max2 = data.length;
  return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new Type$9("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
=======
}), R9 = Vv, Jv = new R9({
  explicit: [
    Yv,
    Xv,
    Kv
  ]
}), $9 = Xe;
function O9(e) {
  if (e === null) return !0;
  var t = e.length;
  return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function I9() {
  return null;
}
function D9(e) {
  return e === null;
}
var Zv = new $9("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: O9,
  construct: I9,
  predicate: D9,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
<<<<<<< HEAD
});
var Type$8 = type;
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max2 = data.length;
  return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new Type$8("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
=======
}), F9 = Xe;
function P9(e) {
  if (e === null) return !1;
  var t = e.length;
  return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function k9(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function L9(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var Qv = new F9("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: P9,
  construct: k9,
  predicate: L9,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
<<<<<<< HEAD
});
var common$3 = common$5;
var Type$7 = type;
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max2 = data.length, index = 0, hasDigits = false, ch;
  if (!max2) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max2) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max2; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign3 = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign3 = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign3 * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign3 * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign3 * parseInt(value.slice(2), 8);
  }
  return sign3 * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common$3.isNegativeZero(object));
}
var int = new Type$7("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
=======
}), N9 = xt, U9 = Xe;
function B9(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function j9(e) {
  return 48 <= e && e <= 55;
}
function M9(e) {
  return 48 <= e && e <= 57;
}
function q9(e) {
  if (e === null) return !1;
  var t = e.length, n = 0, r = !1, i;
  if (!t) return !1;
  if (i = e[n], (i === "-" || i === "+") && (i = e[++n]), i === "0") {
    if (n + 1 === t) return !0;
    if (i = e[++n], i === "b") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (i !== "0" && i !== "1") return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "x") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (!B9(e.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "o") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (!j9(e.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
  }
  if (i === "_") return !1;
  for (; n < t; n++)
    if (i = e[n], i !== "_") {
      if (!M9(e.charCodeAt(n)))
        return !1;
      r = !0;
    }
  return !(!r || i === "_");
}
function z9(e) {
  var t = e, n = 1, r;
  if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), r = t[0], (r === "-" || r === "+") && (r === "-" && (n = -1), t = t.slice(1), r = t[0]), t === "0") return 0;
  if (r === "0") {
    if (t[1] === "b") return n * parseInt(t.slice(2), 2);
    if (t[1] === "x") return n * parseInt(t.slice(2), 16);
    if (t[1] === "o") return n * parseInt(t.slice(2), 8);
  }
  return n * parseInt(t, 10);
}
function H9(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !N9.isNegativeZero(e);
}
var eg = new U9("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: q9,
  construct: z9,
  predicate: H9,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
<<<<<<< HEAD
});
var common$2 = common$5;
var Type$6 = type;
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign3;
  value = data.replace(/_/g, "").toLowerCase();
  sign3 = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign3 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign3 * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
=======
}), tg = xt, W9 = Xe, G9 = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function V9(e) {
  return !(e === null || !G9.test(e) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  e[e.length - 1] === "_");
}
function Y9(e) {
  var t, n;
  return t = e.replace(/_/g, "").toLowerCase(), n = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? n === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : n * parseFloat(t, 10);
}
var X9 = /^[-+]?[0-9]+e/;
function K9(e, t) {
  var n;
  if (isNaN(e))
    switch (t) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
<<<<<<< HEAD
  } else if (common$2.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common$2.isNegativeZero(object));
}
var float = new Type$6("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var Type$5 = type;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
=======
  else if (tg.isNegativeZero(e))
    return "-0.0";
  return n = e.toString(10), X9.test(n) ? n.replace("e", ".e") : n;
}
function J9(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || tg.isNegativeZero(e));
}
var ng = new W9("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: V9,
  construct: Y9,
  predicate: J9,
  represent: K9,
  defaultStyle: "lowercase"
}), rg = Jv.extend({
  implicit: [
    Zv,
    Qv,
    eg,
    ng
  ]
}), ig = rg, Z9 = Xe, ag = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), sg = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function Q9(e) {
  return e === null ? !1 : ag.exec(e) !== null || sg.exec(e) !== null;
}
function e3(e) {
  var t, n, r, i, a, s, c, o = 0, u = null, l, p, f;
  if (t = ag.exec(e), t === null && (t = sg.exec(e)), t === null) throw new Error("Date resolve error");
  if (n = +t[1], r = +t[2] - 1, i = +t[3], !t[4])
    return new Date(Date.UTC(n, r, i));
  if (a = +t[4], s = +t[5], c = +t[6], t[7]) {
    for (o = t[7].slice(0, 3); o.length < 3; )
      o += "0";
    o = +o;
  }
  return t[9] && (l = +t[10], p = +(t[11] || 0), u = (l * 60 + p) * 6e4, t[9] === "-" && (u = -u)), f = new Date(Date.UTC(n, r, i, a, s, c, o)), u && f.setTime(f.getTime() - u), f;
}
function t3(e) {
  return e.toISOString();
}
var og = new Z9("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: Q9,
  construct: e3,
  instanceOf: Date,
  represent: t3
}), n3 = Xe;
function r3(e) {
  return e === "<<" || e === null;
}
var cg = new n3("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: r3
}), i3 = Xe, Qu = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function a3(e) {
  if (e === null) return !1;
  var t, n, r = 0, i = e.length, a = Qu;
  for (n = 0; n < i; n++)
    if (t = a.indexOf(e.charAt(n)), !(t > 64)) {
      if (t < 0) return !1;
      r += 6;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
<<<<<<< HEAD
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new Type$5("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
var Type$4 = type;
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new Type$4("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var Type$3 = type;
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
=======
function s3(e) {
  var t, n, r = e.replace(/[\r\n=]/g, ""), i = r.length, a = Qu, s = 0, c = [];
  for (t = 0; t < i; t++)
    t % 4 === 0 && t && (c.push(s >> 16 & 255), c.push(s >> 8 & 255), c.push(s & 255)), s = s << 6 | a.indexOf(r.charAt(t));
  return n = i % 4 * 6, n === 0 ? (c.push(s >> 16 & 255), c.push(s >> 8 & 255), c.push(s & 255)) : n === 18 ? (c.push(s >> 10 & 255), c.push(s >> 2 & 255)) : n === 12 && c.push(s >> 4 & 255), new Uint8Array(c);
}
function o3(e) {
  var t = "", n = 0, r, i, a = e.length, s = Qu;
  for (r = 0; r < a; r++)
    r % 3 === 0 && r && (t += s[n >> 18 & 63], t += s[n >> 12 & 63], t += s[n >> 6 & 63], t += s[n & 63]), n = (n << 8) + e[r];
  return i = a % 3, i === 0 ? (t += s[n >> 18 & 63], t += s[n >> 12 & 63], t += s[n >> 6 & 63], t += s[n & 63]) : i === 2 ? (t += s[n >> 10 & 63], t += s[n >> 4 & 63], t += s[n << 2 & 63], t += s[64]) : i === 1 && (t += s[n >> 2 & 63], t += s[n << 4 & 63], t += s[64], t += s[64]), t;
}
function c3(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var lg = new i3("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: a3,
  construct: s3,
  predicate: c3,
  represent: o3
}), l3 = Xe, u3 = Object.prototype.hasOwnProperty, p3 = Object.prototype.toString;
function f3(e) {
  if (e === null) return !0;
  var t = [], n, r, i, a, s, c = e;
  for (n = 0, r = c.length; n < r; n += 1) {
    if (i = c[n], s = !1, p3.call(i) !== "[object Object]") return !1;
    for (a in i)
      if (u3.call(i, a))
        if (!s) s = !0;
        else return !1;
    if (!s) return !1;
    if (t.indexOf(a) === -1) t.push(a);
    else return !1;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  return bitlen % 8 === 0;
}
<<<<<<< HEAD
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max2 = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max2; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
=======
function d3(e) {
  return e !== null ? e : [];
}
var ug = new l3("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: f3,
  construct: d3
}), h3 = Xe, m3 = Object.prototype.toString;
function v3(e) {
  if (e === null) return !0;
  var t, n, r, i, a, s = e;
  for (a = new Array(s.length), t = 0, n = s.length; t < n; t += 1) {
    if (r = s[t], m3.call(r) !== "[object Object]" || (i = Object.keys(r), i.length !== 1)) return !1;
    a[t] = [i[0], r[i[0]]];
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  tailbits = max2 % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
<<<<<<< HEAD
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max2 % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new Type$3("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var Type$2 = type;
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new Type$2("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var Type$1 = type;
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new Type$1("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var Type = type;
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return true;
  var key2, object = data;
  for (key2 in object) {
    if (_hasOwnProperty$2.call(object, key2)) {
      if (object[key2] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new Type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var common$1 = common$5;
var YAMLException$1 = exception;
var makeSnippet = snippet;
var DEFAULT_SCHEMA$1 = _default;
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? "" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || DEFAULT_SCHEMA$1;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state2, message) {
  var mark = {
    name: state2.filename,
    buffer: state2.input.slice(0, -1),
=======
function g3(e) {
  if (e === null) return [];
  var t, n, r, i, a, s = e;
  for (a = new Array(s.length), t = 0, n = s.length; t < n; t += 1)
    r = s[t], i = Object.keys(r), a[t] = [i[0], r[i[0]]];
  return a;
}
var pg = new h3("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: v3,
  construct: g3
}), b3 = Xe, x3 = Object.prototype.hasOwnProperty;
function y3(e) {
  if (e === null) return !0;
  var t, n = e;
  for (t in n)
    if (x3.call(n, t) && n[t] !== null)
      return !1;
  return !0;
}
function w3(e) {
  return e !== null ? e : {};
}
var fg = new b3("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: y3,
  construct: w3
}), ep = ig.extend({
  implicit: [
    og,
    cg
  ],
  explicit: [
    lg,
    ug,
    pg,
    fg
  ]
}), Fn = xt, dg = ea, E3 = x9, _3 = ep, hn = Object.prototype.hasOwnProperty, ws = 1, hg = 2, mg = 3, Es = 4, Jc = 1, S3 = 2, sh = 3, A3 = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, T3 = /[\x85\u2028\u2029]/, C3 = /[,\[\]\{\}]/, vg = /^(?:!|!!|![a-z\-]+!)$/i, gg = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function oh(e) {
  return Object.prototype.toString.call(e);
}
function Ct(e) {
  return e === 10 || e === 13;
}
function qn(e) {
  return e === 9 || e === 32;
}
function Qe(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function br(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function R3(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : (t = e | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function $3(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function O3(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function ch(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? "" : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function I3(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var bg = new Array(256), xg = new Array(256);
for (var ar = 0; ar < 256; ar++)
  bg[ar] = ch(ar) ? 1 : 0, xg[ar] = ch(ar);
function D3(e, t) {
  this.input = e, this.filename = t.filename || null, this.schema = t.schema || _3, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function yg(e, t) {
  var n = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    // omit trailing \0
    position: state2.position,
    line: state2.line,
    column: state2.position - state2.lineStart
  };
<<<<<<< HEAD
  mark.snippet = makeSnippet(mark);
  return new YAMLException$1(message, mark);
}
function throwError(state2, message) {
  throw generateError(state2, message);
}
function throwWarning(state2, message) {
  if (state2.onWarning) {
    state2.onWarning.call(null, generateError(state2, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state2, name, args) {
    var match, major2, minor2;
    if (state2.version !== null) {
      throwError(state2, "duplication of %YAML directive");
=======
  return n.snippet = E3(n), new dg(t, n);
}
function Q(e, t) {
  throw yg(e, t);
}
function _s(e, t) {
  e.onWarning && e.onWarning.call(null, yg(e, t));
}
var lh = {
  YAML: function(t, n, r) {
    var i, a, s;
    t.version !== null && Q(t, "duplication of %YAML directive"), r.length !== 1 && Q(t, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(r[0]), i === null && Q(t, "ill-formed argument of the YAML directive"), a = parseInt(i[1], 10), s = parseInt(i[2], 10), a !== 1 && Q(t, "unacceptable YAML version of the document"), t.version = r[0], t.checkLineBreaks = s < 2, s !== 1 && s !== 2 && _s(t, "unsupported YAML version of the document");
  },
  TAG: function(t, n, r) {
    var i, a;
    r.length !== 2 && Q(t, "TAG directive accepts exactly two arguments"), i = r[0], a = r[1], vg.test(i) || Q(t, "ill-formed tag handle (first argument) of the TAG directive"), hn.call(t.tagMap, i) && Q(t, 'there is a previously declared suffix for "' + i + '" tag handle'), gg.test(a) || Q(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      a = decodeURIComponent(a);
    } catch {
      Q(t, "tag prefix is malformed: " + a);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    if (args.length !== 1) {
      throwError(state2, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state2, "ill-formed argument of the YAML directive");
    }
    major2 = parseInt(match[1], 10);
    minor2 = parseInt(match[2], 10);
    if (major2 !== 1) {
      throwError(state2, "unacceptable YAML version of the document");
    }
    state2.version = args[0];
    state2.checkLineBreaks = minor2 < 2;
    if (minor2 !== 1 && minor2 !== 2) {
      throwWarning(state2, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state2, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state2, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state2, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state2.tagMap, handle)) {
      throwError(state2, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state2, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state2, "tag prefix is malformed: " + prefix);
    }
    state2.tagMap[handle] = prefix;
  }
};
<<<<<<< HEAD
function captureSegment(state2, start, end2, checkJson) {
  var _position, _length, _character, _result;
  if (start < end2) {
    _result = state2.input.slice(start, end2);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state2, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state2, "the stream contains non-printable characters");
    }
    state2.result += _result;
  }
}
function mergeMappings(state2, destination, source, overridableKeys) {
  var sourceKeys, key2, index, quantity;
  if (!common$1.isObject(source)) {
    throwError(state2, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key2 = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key2)) {
      destination[key2] = source[key2];
      overridableKeys[key2] = true;
    }
  }
}
function storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state2, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state2, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state2, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state2.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state2.line = startLine || state2.line;
      state2.lineStart = startLineStart || state2.lineStart;
      state2.position = startPos || state2.position;
      throwError(state2, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
=======
function on(e, t, n, r) {
  var i, a, s, c;
  if (t < n) {
    if (c = e.input.slice(t, n), r)
      for (i = 0, a = c.length; i < a; i += 1)
        s = c.charCodeAt(i), s === 9 || 32 <= s && s <= 1114111 || Q(e, "expected valid JSON character");
    else A3.test(c) && Q(e, "the stream contains non-printable characters");
    e.result += c;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  return _result;
}
<<<<<<< HEAD
function readLineBreak(state2) {
  var ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 10) {
    state2.position++;
  } else if (ch === 13) {
    state2.position++;
    if (state2.input.charCodeAt(state2.position) === 10) {
      state2.position++;
    }
  } else {
    throwError(state2, "a line break is expected");
  }
  state2.line += 1;
  state2.lineStart = state2.position;
  state2.firstTabInLine = -1;
}
function skipSeparationSpace(state2, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state2.firstTabInLine === -1) {
        state2.firstTabInLine = state2.position;
      }
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state2);
      ch = state2.input.charCodeAt(state2.position);
      lineBreaks++;
      state2.lineIndent = 0;
      while (ch === 32) {
        state2.lineIndent++;
        ch = state2.input.charCodeAt(++state2.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state2.lineIndent < checkIndent) {
    throwWarning(state2, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state2) {
  var _position = state2.position, ch;
  ch = state2.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state2.input.charCodeAt(_position + 1) && ch === state2.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state2.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state2, count) {
  if (count === 1) {
    state2.result += " ";
  } else if (count > 1) {
    state2.result += common$1.repeat("\n", count - 1);
  }
}
function readPlainScalar(state2, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state2.kind, _result = state2.result, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state2.input.charCodeAt(state2.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state2.kind = "scalar";
  state2.result = "";
  captureStart = captureEnd = state2.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state2.input.charCodeAt(state2.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state2.line;
      _lineStart = state2.lineStart;
      _lineIndent = state2.lineIndent;
      skipSeparationSpace(state2, false, -1);
      if (state2.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state2.input.charCodeAt(state2.position);
        continue;
      } else {
        state2.position = captureEnd;
        state2.line = _line;
        state2.lineStart = _lineStart;
        state2.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state2, captureStart, captureEnd, false);
      writeFoldedLines(state2, state2.line - _line);
      captureStart = captureEnd = state2.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state2.position + 1;
    }
    ch = state2.input.charCodeAt(++state2.position);
  }
  captureSegment(state2, captureStart, captureEnd, false);
  if (state2.result) {
    return true;
  }
  state2.kind = _kind;
  state2.result = _result;
  return false;
}
function readSingleQuotedScalar(state2, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 39) {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  state2.position++;
  captureStart = captureEnd = state2.position;
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state2, captureStart, state2.position, true);
      ch = state2.input.charCodeAt(++state2.position);
      if (ch === 39) {
        captureStart = state2.position;
        state2.position++;
        captureEnd = state2.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state2, captureStart, captureEnd, true);
      writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
      captureStart = captureEnd = state2.position;
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
      throwError(state2, "unexpected end of the document within a single quoted scalar");
    } else {
      state2.position++;
      captureEnd = state2.position;
    }
  }
  throwError(state2, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state2, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 34) {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  state2.position++;
  captureStart = captureEnd = state2.position;
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state2, captureStart, state2.position, true);
      state2.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state2, captureStart, state2.position, true);
      ch = state2.input.charCodeAt(++state2.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state2, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state2.result += simpleEscapeMap[ch];
        state2.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state2.input.charCodeAt(++state2.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state2, "expected hexadecimal character");
          }
        }
        state2.result += charFromCodepoint(hexResult);
        state2.position++;
      } else {
        throwError(state2, "unknown escape sequence");
      }
      captureStart = captureEnd = state2.position;
    } else if (is_EOL(ch)) {
      captureSegment(state2, captureStart, captureEnd, true);
      writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
      captureStart = captureEnd = state2.position;
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
      throwError(state2, "unexpected end of the document within a double quoted scalar");
    } else {
      state2.position++;
      captureEnd = state2.position;
    }
  }
  throwError(state2, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state2, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state2.tag, _result, _anchor = state2.anchor, following, terminator2, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 91) {
    terminator2 = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator2 = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(++state2.position);
  while (ch !== 0) {
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if (ch === terminator2) {
      state2.position++;
      state2.tag = _tag;
      state2.anchor = _anchor;
      state2.kind = isMapping ? "mapping" : "sequence";
      state2.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state2, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state2, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state2.position++;
        skipSeparationSpace(state2, true, nodeIndent);
      }
    }
    _line = state2.line;
    _lineStart = state2.lineStart;
    _pos = state2.position;
    composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state2.tag;
    keyNode = state2.result;
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if ((isExplicitPair || state2.line === _line) && ch === 58) {
      isPair = true;
      ch = state2.input.charCodeAt(++state2.position);
      skipSeparationSpace(state2, true, nodeIndent);
      composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state2.result;
    }
    if (isMapping) {
      storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state2, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if (ch === 44) {
      readNext = true;
      ch = state2.input.charCodeAt(++state2.position);
    } else {
      readNext = false;
    }
  }
  throwError(state2, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state2, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  while (ch !== 0) {
    ch = state2.input.charCodeAt(++state2.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state2, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state2, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state2, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state2.input.charCodeAt(++state2.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state2);
    state2.lineIndent = 0;
    ch = state2.input.charCodeAt(state2.position);
    while ((!detectedIndent || state2.lineIndent < textIndent) && ch === 32) {
      state2.lineIndent++;
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (!detectedIndent && state2.lineIndent > textIndent) {
      textIndent = state2.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state2.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state2.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state2.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state2.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state2.result += common$1.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state2.result += " ";
        }
      } else {
        state2.result += common$1.repeat("\n", emptyLines);
      }
    } else {
      state2.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state2.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    captureSegment(state2, captureStart, state2.position, false);
  }
  return true;
}
function readBlockSequence(state2, nodeIndent) {
  var _line, _tag = state2.tag, _anchor = state2.anchor, _result = [], following, detected = false, ch;
  if (state2.firstTabInLine !== -1) return false;
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    if (state2.firstTabInLine !== -1) {
      state2.position = state2.firstTabInLine;
      throwError(state2, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state2.input.charCodeAt(state2.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state2.position++;
    if (skipSeparationSpace(state2, true, -1)) {
      if (state2.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state2.input.charCodeAt(state2.position);
        continue;
      }
    }
    _line = state2.line;
    composeNode(state2, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state2.result);
    skipSeparationSpace(state2, true, -1);
    ch = state2.input.charCodeAt(state2.position);
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state2, "bad indentation of a sequence entry");
    } else if (state2.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state2.tag = _tag;
    state2.anchor = _anchor;
    state2.kind = "sequence";
    state2.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state2, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state2.tag, _anchor = state2.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state2.firstTabInLine !== -1) return false;
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    if (!atExplicitKey && state2.firstTabInLine !== -1) {
      state2.position = state2.firstTabInLine;
      throwError(state2, "tab characters must not be used in indentation");
    }
    following = state2.input.charCodeAt(state2.position + 1);
    _line = state2.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state2, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state2.position += 1;
      ch = following;
    } else {
      _keyLine = state2.line;
      _keyLineStart = state2.lineStart;
      _keyPos = state2.position;
      if (!composeNode(state2, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state2.line === _line) {
        ch = state2.input.charCodeAt(state2.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state2.input.charCodeAt(++state2.position);
        }
        if (ch === 58) {
          ch = state2.input.charCodeAt(++state2.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state2, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state2.tag;
          keyNode = state2.result;
        } else if (detected) {
          throwError(state2, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state2.tag = _tag;
          state2.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state2, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state2.tag = _tag;
        state2.anchor = _anchor;
        return true;
      }
    }
    if (state2.line === _line || state2.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state2.line;
        _keyLineStart = state2.lineStart;
        _keyPos = state2.position;
      }
      if (composeNode(state2, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state2.result;
        } else {
          valueNode = state2.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state2, true, -1);
      ch = state2.input.charCodeAt(state2.position);
    }
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state2, "bad indentation of a mapping entry");
    } else if (state2.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state2.tag = _tag;
    state2.anchor = _anchor;
    state2.kind = "mapping";
    state2.result = _result;
  }
  return detected;
}
function readTagProperty(state2) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 33) return false;
  if (state2.tag !== null) {
    throwError(state2, "duplication of a tag property");
  }
  ch = state2.input.charCodeAt(++state2.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state2.input.charCodeAt(++state2.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state2.input.charCodeAt(++state2.position);
  } else {
    tagHandle = "!";
  }
  _position = state2.position;
  if (isVerbatim) {
    do {
      ch = state2.input.charCodeAt(++state2.position);
    } while (ch !== 0 && ch !== 62);
    if (state2.position < state2.length) {
      tagName = state2.input.slice(_position, state2.position);
      ch = state2.input.charCodeAt(++state2.position);
    } else {
      throwError(state2, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state2.input.slice(_position - 1, state2.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state2, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state2.position + 1;
        } else {
          throwError(state2, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state2.input.charCodeAt(++state2.position);
    }
    tagName = state2.input.slice(_position, state2.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state2, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state2, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state2, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state2.tag = tagName;
  } else if (_hasOwnProperty$1.call(state2.tagMap, tagHandle)) {
    state2.tag = state2.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state2.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state2.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state2, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state2) {
  var _position, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 38) return false;
  if (state2.anchor !== null) {
    throwError(state2, "duplication of an anchor property");
  }
  ch = state2.input.charCodeAt(++state2.position);
  _position = state2.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state2.input.charCodeAt(++state2.position);
  }
  if (state2.position === _position) {
    throwError(state2, "name of an anchor node must contain at least one character");
  }
  state2.anchor = state2.input.slice(_position, state2.position);
  return true;
}
function readAlias(state2) {
  var _position, alias, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 42) return false;
  ch = state2.input.charCodeAt(++state2.position);
  _position = state2.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state2.input.charCodeAt(++state2.position);
  }
  if (state2.position === _position) {
    throwError(state2, "name of an alias node must contain at least one character");
  }
  alias = state2.input.slice(_position, state2.position);
  if (!_hasOwnProperty$1.call(state2.anchorMap, alias)) {
    throwError(state2, 'unidentified alias "' + alias + '"');
  }
  state2.result = state2.anchorMap[alias];
  skipSeparationSpace(state2, true, -1);
  return true;
}
function composeNode(state2, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state2.listener !== null) {
    state2.listener("open", state2);
  }
  state2.tag = null;
  state2.anchor = null;
  state2.kind = null;
  state2.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state2, true, -1)) {
      atNewLine = true;
      if (state2.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state2.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state2.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state2) || readAnchorProperty(state2)) {
      if (skipSeparationSpace(state2, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state2.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state2.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state2.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state2.position - state2.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state2, blockIndent) || readBlockMapping(state2, blockIndent, flowIndent)) || readFlowCollection(state2, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state2, flowIndent) || readSingleQuotedScalar(state2, flowIndent) || readDoubleQuotedScalar(state2, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state2)) {
          hasContent = true;
          if (state2.tag !== null || state2.anchor !== null) {
            throwError(state2, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state2, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state2.tag === null) {
            state2.tag = "?";
          }
        }
        if (state2.anchor !== null) {
          state2.anchorMap[state2.anchor] = state2.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state2, blockIndent);
    }
  }
  if (state2.tag === null) {
    if (state2.anchor !== null) {
      state2.anchorMap[state2.anchor] = state2.result;
    }
  } else if (state2.tag === "?") {
    if (state2.result !== null && state2.kind !== "scalar") {
      throwError(state2, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state2.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state2.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state2.implicitTypes[typeIndex];
      if (type2.resolve(state2.result)) {
        state2.result = type2.construct(state2.result);
        state2.tag = type2.tag;
        if (state2.anchor !== null) {
          state2.anchorMap[state2.anchor] = state2.result;
        }
        break;
      }
    }
  } else if (state2.tag !== "!") {
    if (_hasOwnProperty$1.call(state2.typeMap[state2.kind || "fallback"], state2.tag)) {
      type2 = state2.typeMap[state2.kind || "fallback"][state2.tag];
    } else {
      type2 = null;
      typeList = state2.typeMap.multi[state2.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state2.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
=======
function uh(e, t, n, r) {
  var i, a, s, c;
  for (Fn.isObject(n) || Q(e, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(n), s = 0, c = i.length; s < c; s += 1)
    a = i[s], hn.call(t, a) || (t[a] = n[a], r[a] = !0);
}
function xr(e, t, n, r, i, a, s, c, o) {
  var u, l;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), u = 0, l = i.length; u < l; u += 1)
      Array.isArray(i[u]) && Q(e, "nested arrays are not supported inside keys"), typeof i == "object" && oh(i[u]) === "[object Object]" && (i[u] = "[object Object]");
  if (typeof i == "object" && oh(i) === "[object Object]" && (i = "[object Object]"), i = String(i), t === null && (t = {}), r === "tag:yaml.org,2002:merge")
    if (Array.isArray(a))
      for (u = 0, l = a.length; u < l; u += 1)
        uh(e, t, a[u], n);
    else
      uh(e, t, a, n);
  else
    !e.json && !hn.call(n, i) && hn.call(t, i) && (e.line = s || e.line, e.lineStart = c || e.lineStart, e.position = o || e.position, Q(e, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(t, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: a
    }) : t[i] = a, delete n[i];
  return t;
}
function tp(e) {
  var t;
  t = e.input.charCodeAt(e.position), t === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : Q(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function Ce(e, t, n) {
  for (var r = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; qn(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), i = e.input.charCodeAt(++e.position);
    if (t && i === 35)
      do
        i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (Ct(i))
      for (tp(e), i = e.input.charCodeAt(e.position), r++, e.lineIndent = 0; i === 32; )
        e.lineIndent++, i = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return n !== -1 && r !== 0 && e.lineIndent < n && _s(e, "deficient indentation"), r;
}
function ho(e) {
  var t = e.position, n;
  return n = e.input.charCodeAt(t), !!((n === 45 || n === 46) && n === e.input.charCodeAt(t + 1) && n === e.input.charCodeAt(t + 2) && (t += 3, n = e.input.charCodeAt(t), n === 0 || Qe(n)));
}
function np(e, t) {
  t === 1 ? e.result += " " : t > 1 && (e.result += Fn.repeat(`
`, t - 1));
}
function F3(e, t, n) {
  var r, i, a, s, c, o, u, l, p = e.kind, f = e.result, m;
  if (m = e.input.charCodeAt(e.position), Qe(m) || br(m) || m === 35 || m === 38 || m === 42 || m === 33 || m === 124 || m === 62 || m === 39 || m === 34 || m === 37 || m === 64 || m === 96 || (m === 63 || m === 45) && (i = e.input.charCodeAt(e.position + 1), Qe(i) || n && br(i)))
    return !1;
  for (e.kind = "scalar", e.result = "", a = s = e.position, c = !1; m !== 0; ) {
    if (m === 58) {
      if (i = e.input.charCodeAt(e.position + 1), Qe(i) || n && br(i))
        break;
    } else if (m === 35) {
      if (r = e.input.charCodeAt(e.position - 1), Qe(r))
        break;
    } else {
      if (e.position === e.lineStart && ho(e) || n && br(m))
        break;
      if (Ct(m))
        if (o = e.line, u = e.lineStart, l = e.lineIndent, Ce(e, !1, -1), e.lineIndent >= t) {
          c = !0, m = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = s, e.line = o, e.lineStart = u, e.lineIndent = l;
          break;
        }
    }
    c && (on(e, a, s, !1), np(e, e.line - o), a = s = e.position, c = !1), qn(m) || (s = e.position + 1), m = e.input.charCodeAt(++e.position);
  }
  return on(e, a, s, !1), e.result ? !0 : (e.kind = p, e.result = f, !1);
}
function P3(e, t) {
  var n, r, i;
  if (n = e.input.charCodeAt(e.position), n !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = i = e.position; (n = e.input.charCodeAt(e.position)) !== 0; )
    if (n === 39)
      if (on(e, r, e.position, !0), n = e.input.charCodeAt(++e.position), n === 39)
        r = e.position, e.position++, i = e.position;
      else
        return !0;
    else Ct(n) ? (on(e, r, i, !0), np(e, Ce(e, !1, t)), r = i = e.position) : e.position === e.lineStart && ho(e) ? Q(e, "unexpected end of the document within a single quoted scalar") : (e.position++, i = e.position);
  Q(e, "unexpected end of the stream within a single quoted scalar");
}
function k3(e, t) {
  var n, r, i, a, s, c;
  if (c = e.input.charCodeAt(e.position), c !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, n = r = e.position; (c = e.input.charCodeAt(e.position)) !== 0; ) {
    if (c === 34)
      return on(e, n, e.position, !0), e.position++, !0;
    if (c === 92) {
      if (on(e, n, e.position, !0), c = e.input.charCodeAt(++e.position), Ct(c))
        Ce(e, !1, t);
      else if (c < 256 && bg[c])
        e.result += xg[c], e.position++;
      else if ((s = $3(c)) > 0) {
        for (i = s, a = 0; i > 0; i--)
          c = e.input.charCodeAt(++e.position), (s = R3(c)) >= 0 ? a = (a << 4) + s : Q(e, "expected hexadecimal character");
        e.result += I3(a), e.position++;
      } else
        Q(e, "unknown escape sequence");
      n = r = e.position;
    } else Ct(c) ? (on(e, n, r, !0), np(e, Ce(e, !1, t)), n = r = e.position) : e.position === e.lineStart && ho(e) ? Q(e, "unexpected end of the document within a double quoted scalar") : (e.position++, r = e.position);
  }
  Q(e, "unexpected end of the stream within a double quoted scalar");
}
function L3(e, t) {
  var n = !0, r, i, a, s = e.tag, c, o = e.anchor, u, l, p, f, m, g = /* @__PURE__ */ Object.create(null), h, b, x, y;
  if (y = e.input.charCodeAt(e.position), y === 91)
    l = 93, m = !1, c = [];
  else if (y === 123)
    l = 125, m = !0, c = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = c), y = e.input.charCodeAt(++e.position); y !== 0; ) {
    if (Ce(e, !0, t), y = e.input.charCodeAt(e.position), y === l)
      return e.position++, e.tag = s, e.anchor = o, e.kind = m ? "mapping" : "sequence", e.result = c, !0;
    n ? y === 44 && Q(e, "expected the node content, but found ','") : Q(e, "missed comma between flow collection entries"), b = h = x = null, p = f = !1, y === 63 && (u = e.input.charCodeAt(e.position + 1), Qe(u) && (p = f = !0, e.position++, Ce(e, !0, t))), r = e.line, i = e.lineStart, a = e.position, Nr(e, t, ws, !1, !0), b = e.tag, h = e.result, Ce(e, !0, t), y = e.input.charCodeAt(e.position), (f || e.line === r) && y === 58 && (p = !0, y = e.input.charCodeAt(++e.position), Ce(e, !0, t), Nr(e, t, ws, !1, !0), x = e.result), m ? xr(e, c, g, b, h, x, r, i, a) : p ? c.push(xr(e, null, g, b, h, x, r, i, a)) : c.push(h), Ce(e, !0, t), y = e.input.charCodeAt(e.position), y === 44 ? (n = !0, y = e.input.charCodeAt(++e.position)) : n = !1;
  }
  Q(e, "unexpected end of the stream within a flow collection");
}
function N3(e, t) {
  var n, r, i = Jc, a = !1, s = !1, c = t, o = 0, u = !1, l, p;
  if (p = e.input.charCodeAt(e.position), p === 124)
    r = !1;
  else if (p === 62)
    r = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; p !== 0; )
    if (p = e.input.charCodeAt(++e.position), p === 43 || p === 45)
      Jc === i ? i = p === 43 ? sh : S3 : Q(e, "repeat of a chomping mode identifier");
    else if ((l = O3(p)) >= 0)
      l === 0 ? Q(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : s ? Q(e, "repeat of an indentation width identifier") : (c = t + l - 1, s = !0);
    else
      break;
  if (qn(p)) {
    do
      p = e.input.charCodeAt(++e.position);
    while (qn(p));
    if (p === 35)
      do
        p = e.input.charCodeAt(++e.position);
      while (!Ct(p) && p !== 0);
  }
  for (; p !== 0; ) {
    for (tp(e), e.lineIndent = 0, p = e.input.charCodeAt(e.position); (!s || e.lineIndent < c) && p === 32; )
      e.lineIndent++, p = e.input.charCodeAt(++e.position);
    if (!s && e.lineIndent > c && (c = e.lineIndent), Ct(p)) {
      o++;
      continue;
    }
    if (e.lineIndent < c) {
      i === sh ? e.result += Fn.repeat(`
`, a ? 1 + o : o) : i === Jc && a && (e.result += `
`);
      break;
    }
    for (r ? qn(p) ? (u = !0, e.result += Fn.repeat(`
`, a ? 1 + o : o)) : u ? (u = !1, e.result += Fn.repeat(`
`, o + 1)) : o === 0 ? a && (e.result += " ") : e.result += Fn.repeat(`
`, o) : e.result += Fn.repeat(`
`, a ? 1 + o : o), a = !0, s = !0, o = 0, n = e.position; !Ct(p) && p !== 0; )
      p = e.input.charCodeAt(++e.position);
    on(e, n, e.position, !1);
  }
  return !0;
}
function ph(e, t) {
  var n, r = e.tag, i = e.anchor, a = [], s, c = !1, o;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = a), o = e.input.charCodeAt(e.position); o !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, Q(e, "tab characters must not be used in indentation")), !(o !== 45 || (s = e.input.charCodeAt(e.position + 1), !Qe(s)))); ) {
    if (c = !0, e.position++, Ce(e, !0, -1) && e.lineIndent <= t) {
      a.push(null), o = e.input.charCodeAt(e.position);
      continue;
    }
    if (n = e.line, Nr(e, t, mg, !1, !0), a.push(e.result), Ce(e, !0, -1), o = e.input.charCodeAt(e.position), (e.line === n || e.lineIndent > t) && o !== 0)
      Q(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t)
      break;
  }
  return c ? (e.tag = r, e.anchor = i, e.kind = "sequence", e.result = a, !0) : !1;
}
function U3(e, t, n) {
  var r, i, a, s, c, o, u = e.tag, l = e.anchor, p = {}, f = /* @__PURE__ */ Object.create(null), m = null, g = null, h = null, b = !1, x = !1, y;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = p), y = e.input.charCodeAt(e.position); y !== 0; ) {
    if (!b && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, Q(e, "tab characters must not be used in indentation")), r = e.input.charCodeAt(e.position + 1), a = e.line, (y === 63 || y === 58) && Qe(r))
      y === 63 ? (b && (xr(e, p, f, m, g, null, s, c, o), m = g = h = null), x = !0, b = !0, i = !0) : b ? (b = !1, i = !0) : Q(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, y = r;
    else {
      if (s = e.line, c = e.lineStart, o = e.position, !Nr(e, n, hg, !1, !0))
        break;
      if (e.line === a) {
        for (y = e.input.charCodeAt(e.position); qn(y); )
          y = e.input.charCodeAt(++e.position);
        if (y === 58)
          y = e.input.charCodeAt(++e.position), Qe(y) || Q(e, "a whitespace character is expected after the key-value separator within a block mapping"), b && (xr(e, p, f, m, g, null, s, c, o), m = g = h = null), x = !0, b = !1, i = !1, m = e.tag, g = e.result;
        else if (x)
          Q(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = u, e.anchor = l, !0;
      } else if (x)
        Q(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = u, e.anchor = l, !0;
    }
    if ((e.line === a || e.lineIndent > t) && (b && (s = e.line, c = e.lineStart, o = e.position), Nr(e, t, Es, !0, i) && (b ? g = e.result : h = e.result), b || (xr(e, p, f, m, g, h, s, c, o), m = g = h = null), Ce(e, !0, -1), y = e.input.charCodeAt(e.position)), (e.line === a || e.lineIndent > t) && y !== 0)
      Q(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t)
      break;
  }
  return b && xr(e, p, f, m, g, null, s, c, o), x && (e.tag = u, e.anchor = l, e.kind = "mapping", e.result = p), x;
}
function B3(e) {
  var t, n = !1, r = !1, i, a, s;
  if (s = e.input.charCodeAt(e.position), s !== 33) return !1;
  if (e.tag !== null && Q(e, "duplication of a tag property"), s = e.input.charCodeAt(++e.position), s === 60 ? (n = !0, s = e.input.charCodeAt(++e.position)) : s === 33 ? (r = !0, i = "!!", s = e.input.charCodeAt(++e.position)) : i = "!", t = e.position, n) {
    do
      s = e.input.charCodeAt(++e.position);
    while (s !== 0 && s !== 62);
    e.position < e.length ? (a = e.input.slice(t, e.position), s = e.input.charCodeAt(++e.position)) : Q(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; s !== 0 && !Qe(s); )
      s === 33 && (r ? Q(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(t - 1, e.position + 1), vg.test(i) || Q(e, "named tag handle cannot contain such characters"), r = !0, t = e.position + 1)), s = e.input.charCodeAt(++e.position);
    a = e.input.slice(t, e.position), C3.test(a) && Q(e, "tag suffix cannot contain flow indicator characters");
  }
  a && !gg.test(a) && Q(e, "tag name cannot contain such characters: " + a);
  try {
    a = decodeURIComponent(a);
  } catch {
    Q(e, "tag name is malformed: " + a);
  }
  return n ? e.tag = a : hn.call(e.tagMap, i) ? e.tag = e.tagMap[i] + a : i === "!" ? e.tag = "!" + a : i === "!!" ? e.tag = "tag:yaml.org,2002:" + a : Q(e, 'undeclared tag handle "' + i + '"'), !0;
}
function j3(e) {
  var t, n;
  if (n = e.input.charCodeAt(e.position), n !== 38) return !1;
  for (e.anchor !== null && Q(e, "duplication of an anchor property"), n = e.input.charCodeAt(++e.position), t = e.position; n !== 0 && !Qe(n) && !br(n); )
    n = e.input.charCodeAt(++e.position);
  return e.position === t && Q(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
function M3(e) {
  var t, n, r;
  if (r = e.input.charCodeAt(e.position), r !== 42) return !1;
  for (r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !Qe(r) && !br(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === t && Q(e, "name of an alias node must contain at least one character"), n = e.input.slice(t, e.position), hn.call(e.anchorMap, n) || Q(e, 'unidentified alias "' + n + '"'), e.result = e.anchorMap[n], Ce(e, !0, -1), !0;
}
function Nr(e, t, n, r, i) {
  var a, s, c, o = 1, u = !1, l = !1, p, f, m, g, h, b;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, a = s = c = Es === n || mg === n, r && Ce(e, !0, -1) && (u = !0, e.lineIndent > t ? o = 1 : e.lineIndent === t ? o = 0 : e.lineIndent < t && (o = -1)), o === 1)
    for (; B3(e) || j3(e); )
      Ce(e, !0, -1) ? (u = !0, c = a, e.lineIndent > t ? o = 1 : e.lineIndent === t ? o = 0 : e.lineIndent < t && (o = -1)) : c = !1;
  if (c && (c = u || i), (o === 1 || Es === n) && (ws === n || hg === n ? h = t : h = t + 1, b = e.position - e.lineStart, o === 1 ? c && (ph(e, b) || U3(e, b, h)) || L3(e, h) ? l = !0 : (s && N3(e, h) || P3(e, h) || k3(e, h) ? l = !0 : M3(e) ? (l = !0, (e.tag !== null || e.anchor !== null) && Q(e, "alias node should not have any properties")) : F3(e, h, ws === n) && (l = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : o === 0 && (l = c && ph(e, b))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && Q(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), p = 0, f = e.implicitTypes.length; p < f; p += 1)
      if (g = e.implicitTypes[p], g.resolve(e.result)) {
        e.result = g.construct(e.result), e.tag = g.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (hn.call(e.typeMap[e.kind || "fallback"], e.tag))
      g = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (g = null, m = e.typeMap.multi[e.kind || "fallback"], p = 0, f = m.length; p < f; p += 1)
        if (e.tag.slice(0, m[p].tag.length) === m[p].tag) {
          g = m[p];
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          break;
        }
      }
    }
    if (!type2) {
      throwError(state2, "unknown tag !<" + state2.tag + ">");
    }
    if (state2.result !== null && type2.kind !== state2.kind) {
      throwError(state2, "unacceptable node kind for !<" + state2.tag + '> tag; it should be "' + type2.kind + '", not "' + state2.kind + '"');
    }
    if (!type2.resolve(state2.result, state2.tag)) {
      throwError(state2, "cannot resolve a node with !<" + state2.tag + "> explicit tag");
    } else {
      state2.result = type2.construct(state2.result, state2.tag);
      if (state2.anchor !== null) {
        state2.anchorMap[state2.anchor] = state2.result;
      }
    }
  }
  if (state2.listener !== null) {
    state2.listener("close", state2);
  }
  return state2.tag !== null || state2.anchor !== null || hasContent;
}
<<<<<<< HEAD
function readDocument(state2) {
  var documentStart = state2.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state2.version = null;
  state2.checkLineBreaks = state2.legacy;
  state2.tagMap = /* @__PURE__ */ Object.create(null);
  state2.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    skipSeparationSpace(state2, true, -1);
    ch = state2.input.charCodeAt(state2.position);
    if (state2.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state2.input.charCodeAt(++state2.position);
    _position = state2.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    directiveName = state2.input.slice(_position, state2.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state2, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      if (ch === 35) {
        do {
          ch = state2.input.charCodeAt(++state2.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state2.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      directiveArgs.push(state2.input.slice(_position, state2.position));
    }
    if (ch !== 0) readLineBreak(state2);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state2, directiveName, directiveArgs);
    } else {
      throwWarning(state2, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state2, true, -1);
  if (state2.lineIndent === 0 && state2.input.charCodeAt(state2.position) === 45 && state2.input.charCodeAt(state2.position + 1) === 45 && state2.input.charCodeAt(state2.position + 2) === 45) {
    state2.position += 3;
    skipSeparationSpace(state2, true, -1);
  } else if (hasDirectives) {
    throwError(state2, "directives end mark is expected");
  }
  composeNode(state2, state2.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state2, true, -1);
  if (state2.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state2.input.slice(documentStart, state2.position))) {
    throwWarning(state2, "non-ASCII line breaks are interpreted as content");
  }
  state2.documents.push(state2.result);
  if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
    if (state2.input.charCodeAt(state2.position) === 46) {
      state2.position += 3;
      skipSeparationSpace(state2, true, -1);
    }
=======
function q3(e) {
  var t = e.position, n, r, i, a = !1, s;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (s = e.input.charCodeAt(e.position)) !== 0 && (Ce(e, !0, -1), s = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || s !== 37)); ) {
    for (a = !0, s = e.input.charCodeAt(++e.position), n = e.position; s !== 0 && !Qe(s); )
      s = e.input.charCodeAt(++e.position);
    for (r = e.input.slice(n, e.position), i = [], r.length < 1 && Q(e, "directive name must not be less than one character in length"); s !== 0; ) {
      for (; qn(s); )
        s = e.input.charCodeAt(++e.position);
      if (s === 35) {
        do
          s = e.input.charCodeAt(++e.position);
        while (s !== 0 && !Ct(s));
        break;
      }
      if (Ct(s)) break;
      for (n = e.position; s !== 0 && !Qe(s); )
        s = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(n, e.position));
    }
    s !== 0 && tp(e), hn.call(lh, r) ? lh[r](e, r, i) : _s(e, 'unknown document directive "' + r + '"');
  }
  if (Ce(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, Ce(e, !0, -1)) : a && Q(e, "directives end mark is expected"), Nr(e, e.lineIndent - 1, Es, !1, !0), Ce(e, !0, -1), e.checkLineBreaks && T3.test(e.input.slice(t, e.position)) && _s(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && ho(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, Ce(e, !0, -1));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    return;
  }
  if (state2.position < state2.length - 1) {
    throwError(state2, "end of the stream or a document separator is expected");
  } else {
    return;
<<<<<<< HEAD
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state2 = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state2.position = nullpos;
    throwError(state2, "null byte is not allowed in input");
  }
  state2.input += "\0";
  while (state2.input.charCodeAt(state2.position) === 32) {
    state2.lineIndent += 1;
    state2.position += 1;
  }
  while (state2.position < state2.length - 1) {
    readDocument(state2);
  }
  return state2.documents;
}
function loadAll(input, iterator2, options) {
  if (iterator2 !== null && typeof iterator2 === "object" && typeof options === "undefined") {
    options = iterator2;
    iterator2 = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator2 !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator2(documents[index]);
  }
}
function load(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException$1("expected a single document in the stream, but found more");
}
loader$1.loadAll = loadAll;
loader$1.load = load;
var dumper$1 = {};
var common = common$5;
var YAMLException = exception;
var DEFAULT_SCHEMA = _default;
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
=======
}
function wg(e, t) {
  e = String(e), t = t || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var n = new D3(e, t), r = e.indexOf("\0");
  for (r !== -1 && (n.position = r, Q(n, "null byte is not allowed in input")), n.input += "\0"; n.input.charCodeAt(n.position) === 32; )
    n.lineIndent += 1, n.position += 1;
  for (; n.position < n.length - 1; )
    q3(n);
  return n.documents;
}
function z3(e, t, n) {
  t !== null && typeof t == "object" && typeof n > "u" && (n = t, t = null);
  var r = wg(e, n);
  if (typeof t != "function")
    return r;
  for (var i = 0, a = r.length; i < a; i += 1)
    t(r[i]);
}
function H3(e, t) {
  var n = wg(e, t);
  if (n.length !== 0) {
    if (n.length === 1)
      return n[0];
    throw new dg("expected a single document in the stream, but found more");
  }
}
Zu.loadAll = z3;
Zu.load = H3;
var Eg = {}, mo = xt, ta = ea, W3 = ep, _g = Object.prototype.toString, Sg = Object.prototype.hasOwnProperty, rp = 65279, G3 = 9, Ci = 10, V3 = 13, Y3 = 32, X3 = 33, K3 = 34, ql = 35, J3 = 37, Z3 = 38, Q3 = 39, eA = 42, Ag = 44, tA = 45, Ss = 58, nA = 61, rA = 62, iA = 63, aA = 64, Tg = 91, Cg = 93, sA = 96, Rg = 123, oA = 124, $g = 125, Me = {};
Me[0] = "\\0";
Me[7] = "\\a";
Me[8] = "\\b";
Me[9] = "\\t";
Me[10] = "\\n";
Me[11] = "\\v";
Me[12] = "\\f";
Me[13] = "\\r";
Me[27] = "\\e";
Me[34] = '\\"';
Me[92] = "\\\\";
Me[133] = "\\N";
Me[160] = "\\_";
Me[8232] = "\\L";
Me[8233] = "\\P";
var cA = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
<<<<<<< HEAD
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null) return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || DEFAULT_SCHEMA;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state2, level) {
  return "\n" + common.repeat(" ", state2.indent * level);
}
function testImplicitResolving(state2, str2) {
  var index, length, type2;
  for (index = 0, length = state2.implicitTypes.length; index < length; index += 1) {
    type2 = state2.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
=======
], lA = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function uA(e, t) {
  var n, r, i, a, s, c, o;
  if (t === null) return {};
  for (n = {}, r = Object.keys(t), i = 0, a = r.length; i < a; i += 1)
    s = r[i], c = String(t[s]), s.slice(0, 2) === "!!" && (s = "tag:yaml.org,2002:" + s.slice(2)), o = e.compiledTypeMap.fallback[s], o && Sg.call(o.styleAliases, c) && (c = o.styleAliases[c]), n[s] = c;
  return n;
}
function pA(e) {
  var t, n, r;
  if (t = e.toString(16).toUpperCase(), e <= 255)
    n = "x", r = 2;
  else if (e <= 65535)
    n = "u", r = 4;
  else if (e <= 4294967295)
    n = "U", r = 8;
  else
    throw new ta("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + n + mo.repeat("0", r - t.length) + t;
}
var fA = 1, Ri = 2;
function dA(e) {
  this.schema = e.schema || W3, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = mo.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = uA(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? Ri : fA, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer == "function" ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function fh(e, t) {
  for (var n = mo.repeat(" ", t), r = 0, i = -1, a = "", s, c = e.length; r < c; )
    i = e.indexOf(`
`, r), i === -1 ? (s = e.slice(r), r = c) : (s = e.slice(r, i + 1), r = i + 1), s.length && s !== `
` && (a += n), a += s;
  return a;
}
function zl(e, t) {
  return `
` + mo.repeat(" ", e.indent * t);
}
function hA(e, t) {
  var n, r, i;
  for (n = 0, r = e.implicitTypes.length; n < r; n += 1)
    if (i = e.implicitTypes[n], i.resolve(t))
      return !0;
  return !1;
}
function As(e) {
  return e === Y3 || e === G3;
}
function $i(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== rp || 65536 <= e && e <= 1114111;
}
function dh(e) {
  return $i(e) && e !== rp && e !== V3 && e !== Ci;
}
function hh(e, t, n) {
  var r = dh(e), i = r && !As(e);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
<<<<<<< HEAD
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
=======
      r
    ) : r && e !== Ag && e !== Tg && e !== Cg && e !== Rg && e !== $g) && e !== ql && !(t === Ss && !i) || dh(t) && !As(t) && e === ql || t === Ss && i
  );
}
function mA(e) {
  return $i(e) && e !== rp && !As(e) && e !== tA && e !== iA && e !== Ss && e !== Ag && e !== Tg && e !== Cg && e !== Rg && e !== $g && e !== ql && e !== Z3 && e !== eA && e !== X3 && e !== oA && e !== nA && e !== rA && e !== Q3 && e !== K3 && e !== J3 && e !== aA && e !== sA;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
}
function vA(e) {
  return !As(e) && e !== Ss;
}
<<<<<<< HEAD
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state2, string, level, iskey, inblock) {
  state2.dump = function() {
    if (string.length === 0) {
      return state2.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state2.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state2.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state2.indent * Math.max(1, level);
    var lineWidth = state2.lineWidth === -1 ? -1 : Math.max(Math.min(state2.lineWidth, 40), state2.lineWidth - indent);
    var singleLineOnly = iskey || state2.flowLevel > -1 && level >= state2.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state2, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state2.indent,
      lineWidth,
      testAmbiguity,
      state2.quotingType,
      state2.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new YAMLException("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
=======
function ci(e, t) {
  var n = e.charCodeAt(t), r;
  return n >= 55296 && n <= 56319 && t + 1 < e.length && (r = e.charCodeAt(t + 1), r >= 56320 && r <= 57343) ? (n - 55296) * 1024 + r - 56320 + 65536 : n;
}
function Og(e) {
  var t = /^\n* /;
  return t.test(e);
}
var Ig = 1, Hl = 2, Dg = 3, Fg = 4, hr = 5;
function gA(e, t, n, r, i, a, s, c) {
  var o, u = 0, l = null, p = !1, f = !1, m = r !== -1, g = -1, h = mA(ci(e, 0)) && vA(ci(e, e.length - 1));
  if (t || s)
    for (o = 0; o < e.length; u >= 65536 ? o += 2 : o++) {
      if (u = ci(e, o), !$i(u))
        return hr;
      h = h && hh(u, l, c), l = u;
    }
  else {
    for (o = 0; o < e.length; u >= 65536 ? o += 2 : o++) {
      if (u = ci(e, o), u === Ci)
        p = !0, m && (f = f || // Foldable line = too long, and not more-indented.
        o - g - 1 > r && e[g + 1] !== " ", g = o);
      else if (!$i(u))
        return hr;
      h = h && hh(u, l, c), l = u;
    }
    f = f || m && o - g - 1 > r && e[g + 1] !== " ";
  }
  return !p && !f ? h && !s && !i(e) ? Ig : a === Ri ? hr : Hl : n > 9 && Og(e) ? hr : s ? a === Ri ? hr : Hl : f ? Fg : Dg;
}
function bA(e, t, n, r, i) {
  e.dump = function() {
    if (t.length === 0)
      return e.quotingType === Ri ? '""' : "''";
    if (!e.noCompatMode && (cA.indexOf(t) !== -1 || lA.test(t)))
      return e.quotingType === Ri ? '"' + t + '"' : "'" + t + "'";
    var a = e.indent * Math.max(1, n), s = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - a), c = r || e.flowLevel > -1 && n >= e.flowLevel;
    function o(u) {
      return hA(e, u);
    }
    switch (gA(
      t,
      c,
      e.indent,
      s,
      o,
      e.quotingType,
      e.forceQuotes && !r,
      i
    )) {
      case Ig:
        return t;
      case Hl:
        return "'" + t.replace(/'/g, "''") + "'";
      case Dg:
        return "|" + mh(t, e.indent) + vh(fh(t, a));
      case Fg:
        return ">" + mh(t, e.indent) + vh(fh(xA(t, s), a));
      case hr:
        return '"' + yA(t) + '"';
      default:
        throw new ta("impossible error: invalid scalar style");
    }
  }();
}
function mh(e, t) {
  var n = Og(e) ? String(t) : "", r = e[e.length - 1] === `
`, i = r && (e[e.length - 2] === `
` || e === `
`), a = i ? "+" : r ? "" : "-";
  return n + a + `
`;
}
function vh(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
function xA(e, t) {
  for (var n = /(\n+)([^\n]*)/g, r = function() {
    var u = e.indexOf(`
`);
    return u = u !== -1 ? u : e.length, n.lastIndex = u, gh(e.slice(0, u), t);
  }(), i = e[0] === `
` || e[0] === " ", a, s; s = n.exec(e); ) {
    var c = s[1], o = s[2];
    a = o[0] === " ", r += c + (!i && !a && o !== "" ? `
` : "") + gh(o, t), i = a;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  return result;
}
<<<<<<< HEAD
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end2, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end2 = curr > start ? curr : next;
      result += "\n" + line.slice(start, end2);
      start = end2 + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state2, level, object) {
  var _result = "", _tag = state2.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state2.replacer) {
      value = state2.replacer.call(object, String(index), value);
    }
    if (writeNode(state2, level, value, false, false) || typeof value === "undefined" && writeNode(state2, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state2.condenseFlow ? " " : "");
      _result += state2.dump;
    }
  }
  state2.tag = _tag;
  state2.dump = "[" + _result + "]";
}
function writeBlockSequence(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state2.replacer) {
      value = state2.replacer.call(object, String(index), value);
    }
    if (writeNode(state2, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state2, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state2, level);
=======
function gh(e, t) {
  if (e === "" || e[0] === " ") return e;
  for (var n = / [^ ]/g, r, i = 0, a, s = 0, c = 0, o = ""; r = n.exec(e); )
    c = r.index, c - i > t && (a = s > i ? s : c, o += `
` + e.slice(i, a), i = a + 1), s = c;
  return o += `
`, e.length - i > t && s > i ? o += e.slice(i, s) + `
` + e.slice(s + 1) : o += e.slice(i), o.slice(1);
}
function yA(e) {
  for (var t = "", n = 0, r, i = 0; i < e.length; n >= 65536 ? i += 2 : i++)
    n = ci(e, i), r = Me[n], !r && $i(n) ? (t += e[i], n >= 65536 && (t += e[i + 1])) : t += r || pA(n);
  return t;
}
function wA(e, t, n) {
  var r = "", i = e.tag, a, s, c;
  for (a = 0, s = n.length; a < s; a += 1)
    c = n[a], e.replacer && (c = e.replacer.call(n, String(a), c)), (Mt(e, t, c, !1, !1) || typeof c > "u" && Mt(e, t, null, !1, !1)) && (r !== "" && (r += "," + (e.condenseFlow ? "" : " ")), r += e.dump);
  e.tag = i, e.dump = "[" + r + "]";
}
function bh(e, t, n, r) {
  var i = "", a = e.tag, s, c, o;
  for (s = 0, c = n.length; s < c; s += 1)
    o = n[s], e.replacer && (o = e.replacer.call(n, String(s), o)), (Mt(e, t + 1, o, !0, !0, !1, !0) || typeof o > "u" && Mt(e, t + 1, null, !0, !0, !1, !0)) && ((!r || i !== "") && (i += zl(e, t)), e.dump && Ci === e.dump.charCodeAt(0) ? i += "-" : i += "- ", i += e.dump);
  e.tag = a, e.dump = i || "[]";
}
function EA(e, t, n) {
  var r = "", i = e.tag, a = Object.keys(n), s, c, o, u, l;
  for (s = 0, c = a.length; s < c; s += 1)
    l = "", r !== "" && (l += ", "), e.condenseFlow && (l += '"'), o = a[s], u = n[o], e.replacer && (u = e.replacer.call(n, o, u)), Mt(e, t, o, !1, !1) && (e.dump.length > 1024 && (l += "? "), l += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), Mt(e, t, u, !1, !1) && (l += e.dump, r += l));
  e.tag = i, e.dump = "{" + r + "}";
}
function _A(e, t, n, r) {
  var i = "", a = e.tag, s = Object.keys(n), c, o, u, l, p, f;
  if (e.sortKeys === !0)
    s.sort();
  else if (typeof e.sortKeys == "function")
    s.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new ta("sortKeys must be a boolean or a function");
  for (c = 0, o = s.length; c < o; c += 1)
    f = "", (!r || i !== "") && (f += zl(e, t)), u = s[c], l = n[u], e.replacer && (l = e.replacer.call(n, u, l)), Mt(e, t + 1, u, !0, !0, !0) && (p = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, p && (e.dump && Ci === e.dump.charCodeAt(0) ? f += "?" : f += "? "), f += e.dump, p && (f += zl(e, t)), Mt(e, t + 1, l, !0, p) && (e.dump && Ci === e.dump.charCodeAt(0) ? f += ":" : f += ": ", f += e.dump, i += f));
  e.tag = a, e.dump = i || "{}";
}
function xh(e, t, n) {
  var r, i, a, s, c, o;
  for (i = n ? e.explicitTypes : e.implicitTypes, a = 0, s = i.length; a < s; a += 1)
    if (c = i[a], (c.instanceOf || c.predicate) && (!c.instanceOf || typeof t == "object" && t instanceof c.instanceOf) && (!c.predicate || c.predicate(t))) {
      if (n ? c.multi && c.representName ? e.tag = c.representName(t) : e.tag = c.tag : e.tag = "?", c.represent) {
        if (o = e.styleMap[c.tag] || c.defaultStyle, _g.call(c.represent) === "[object Function]")
          r = c.represent(t, o);
        else if (Sg.call(c.represent, o))
          r = c.represent[o](t, o);
        else
          throw new ta("!<" + c.tag + '> tag resolver accepts not "' + o + '" style');
        e.dump = r;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
      if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state2.dump;
    }
<<<<<<< HEAD
=======
  return !1;
}
function Mt(e, t, n, r, i, a, s) {
  e.tag = null, e.dump = n, xh(e, n, !1) || xh(e, n, !0);
  var c = _g.call(e.dump), o = r, u;
  r && (r = e.flowLevel < 0 || e.flowLevel > t);
  var l = c === "[object Object]" || c === "[object Array]", p, f;
  if (l && (p = e.duplicates.indexOf(n), f = p !== -1), (e.tag !== null && e.tag !== "?" || f || e.indent !== 2 && t > 0) && (i = !1), f && e.usedDuplicates[p])
    e.dump = "*ref_" + p;
  else {
    if (l && f && !e.usedDuplicates[p] && (e.usedDuplicates[p] = !0), c === "[object Object]")
      r && Object.keys(e.dump).length !== 0 ? (_A(e, t, e.dump, i), f && (e.dump = "&ref_" + p + e.dump)) : (EA(e, t, e.dump), f && (e.dump = "&ref_" + p + " " + e.dump));
    else if (c === "[object Array]")
      r && e.dump.length !== 0 ? (e.noArrayIndent && !s && t > 0 ? bh(e, t - 1, e.dump, i) : bh(e, t, e.dump, i), f && (e.dump = "&ref_" + p + e.dump)) : (wA(e, t, e.dump), f && (e.dump = "&ref_" + p + " " + e.dump));
    else if (c === "[object String]")
      e.tag !== "?" && bA(e, e.dump, t, a, o);
    else {
      if (c === "[object Undefined]")
        return !1;
      if (e.skipInvalid) return !1;
      throw new ta("unacceptable kind of an object to dump " + c);
    }
    e.tag !== null && e.tag !== "?" && (u = encodeURI(
      e.tag[0] === "!" ? e.tag.slice(1) : e.tag
    ).replace(/!/g, "%21"), e.tag[0] === "!" ? u = "!" + u : u.slice(0, 18) === "tag:yaml.org,2002:" ? u = "!!" + u.slice(18) : u = "!<" + u + ">", e.dump = u + " " + e.dump);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  state2.tag = _tag;
  state2.dump = _result || "[]";
}
<<<<<<< HEAD
function writeFlowMapping(state2, level, object) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state2.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state2.replacer) {
      objectValue = state2.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state2, level, objectKey, false, false)) {
      continue;
    }
    if (state2.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state2.dump + (state2.condenseFlow ? '"' : "") + ":" + (state2.condenseFlow ? "" : " ");
    if (!writeNode(state2, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state2.dump;
    _result += pairBuffer;
  }
  state2.tag = _tag;
  state2.dump = "{" + _result + "}";
}
function writeBlockMapping(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state2.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state2.sortKeys === "function") {
    objectKeyList.sort(state2.sortKeys);
  } else if (state2.sortKeys) {
    throw new YAMLException("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state2, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state2.replacer) {
      objectValue = state2.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state2, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state2.tag !== null && state2.tag !== "?" || state2.dump && state2.dump.length > 1024;
    if (explicitPair) {
      if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state2.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state2, level);
    }
    if (!writeNode(state2, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state2.dump;
    _result += pairBuffer;
  }
  state2.tag = _tag;
  state2.dump = _result || "{}";
}
function detectType(state2, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state2.explicitTypes : state2.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state2.tag = type2.representName(object);
        } else {
          state2.tag = type2.tag;
        }
      } else {
        state2.tag = "?";
      }
      if (type2.represent) {
        style = state2.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state2.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state2, level, object, block, compact, iskey, isblockseq) {
  state2.tag = null;
  state2.dump = object;
  if (!detectType(state2, object, false)) {
    detectType(state2, object, true);
  }
  var type2 = _toString.call(state2.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state2.flowLevel < 0 || state2.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate2;
  if (objectOrArray) {
    duplicateIndex = state2.duplicates.indexOf(object);
    duplicate2 = duplicateIndex !== -1;
  }
  if (state2.tag !== null && state2.tag !== "?" || duplicate2 || state2.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate2 && state2.usedDuplicates[duplicateIndex]) {
    state2.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate2 && !state2.usedDuplicates[duplicateIndex]) {
      state2.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state2.dump).length !== 0) {
        writeBlockMapping(state2, level, state2.dump, compact);
        if (duplicate2) {
          state2.dump = "&ref_" + duplicateIndex + state2.dump;
        }
      } else {
        writeFlowMapping(state2, level, state2.dump);
        if (duplicate2) {
          state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state2.dump.length !== 0) {
        if (state2.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state2, level - 1, state2.dump, compact);
        } else {
          writeBlockSequence(state2, level, state2.dump, compact);
        }
        if (duplicate2) {
          state2.dump = "&ref_" + duplicateIndex + state2.dump;
        }
      } else {
        writeFlowSequence(state2, level, state2.dump);
        if (duplicate2) {
          state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state2.tag !== "?") {
        writeScalar(state2, state2.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state2.skipInvalid) return false;
      throw new YAMLException("unacceptable kind of an object to dump " + type2);
    }
    if (state2.tag !== null && state2.tag !== "?") {
      tagStr = encodeURI(
        state2.tag[0] === "!" ? state2.tag.slice(1) : state2.tag
      ).replace(/!/g, "%21");
      if (state2.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state2.dump = tagStr + " " + state2.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state2) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state2.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state2.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump(input, options) {
  options = options || {};
  var state2 = new State(options);
  if (!state2.noRefs) getDuplicateReferences(input, state2);
  var value = input;
  if (state2.replacer) {
    value = state2.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state2, 0, value, true, true)) return state2.dump + "\n";
  return "";
}
dumper$1.dump = dump;
var loader = loader$1;
var dumper = dumper$1;
function renamed(from, to) {
=======
function SA(e, t) {
  var n = [], r = [], i, a;
  for (Wl(e, n, r), i = 0, a = r.length; i < a; i += 1)
    t.duplicates.push(n[r[i]]);
  t.usedDuplicates = new Array(a);
}
function Wl(e, t, n) {
  var r, i, a;
  if (e !== null && typeof e == "object")
    if (i = t.indexOf(e), i !== -1)
      n.indexOf(i) === -1 && n.push(i);
    else if (t.push(e), Array.isArray(e))
      for (i = 0, a = e.length; i < a; i += 1)
        Wl(e[i], t, n);
    else
      for (r = Object.keys(e), i = 0, a = r.length; i < a; i += 1)
        Wl(e[r[i]], t, n);
}
function AA(e, t) {
  t = t || {};
  var n = new dA(t);
  n.noRefs || SA(e, n);
  var r = e;
  return n.replacer && (r = n.replacer.call({ "": r }, "", r)), Mt(n, 0, r, !0, !0) ? n.dump + `
` : "";
}
Eg.dump = AA;
var Pg = Zu, TA = Eg;
function ip(e, t) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
<<<<<<< HEAD
jsYaml.Type = type;
jsYaml.Schema = schema;
jsYaml.FAILSAFE_SCHEMA = failsafe;
jsYaml.JSON_SCHEMA = json;
jsYaml.CORE_SCHEMA = core;
jsYaml.DEFAULT_SCHEMA = _default;
jsYaml.load = loader.load;
jsYaml.loadAll = loader.loadAll;
jsYaml.dump = dumper.dump;
jsYaml.YAMLException = exception;
jsYaml.types = {
  binary,
  float,
  map,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
jsYaml.safeLoad = renamed("safeLoad", "load");
jsYaml.safeLoadAll = renamed("safeLoadAll", "loadAll");
jsYaml.safeDump = renamed("safeDump", "dump");
var main = {};
Object.defineProperty(main, "__esModule", { value: true });
main.Lazy = void 0;
class Lazy {
  constructor(creator) {
    this._value = null;
    this.creator = creator;
=======
Ue.Type = Xe;
Ue.Schema = Vv;
Ue.FAILSAFE_SCHEMA = Jv;
Ue.JSON_SCHEMA = rg;
Ue.CORE_SCHEMA = ig;
Ue.DEFAULT_SCHEMA = ep;
Ue.load = Pg.load;
Ue.loadAll = Pg.loadAll;
Ue.dump = TA.dump;
Ue.YAMLException = ea;
Ue.types = {
  binary: lg,
  float: ng,
  map: Kv,
  null: Zv,
  pairs: pg,
  set: fg,
  timestamp: og,
  bool: Qv,
  int: eg,
  merge: cg,
  omap: ug,
  seq: Xv,
  str: Yv
};
Ue.safeLoad = ip("safeLoad", "load");
Ue.safeLoadAll = ip("safeLoadAll", "loadAll");
Ue.safeDump = ip("safeDump", "dump");
var vo = {};
Object.defineProperty(vo, "__esModule", { value: !0 });
vo.Lazy = void 0;
class CA {
  constructor(t) {
    this._value = null, this.creator = t;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  get hasValue() {
    return this.creator == null;
  }
  get value() {
    if (this.creator == null) {
      return this._value;
    }
    const result = this.creator();
    this.value = result;
    return result;
  }
  set value(value) {
    this._value = value;
    this.creator = null;
  }
}
<<<<<<< HEAD
main.Lazy = Lazy;
var re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = [
=======
vo.Lazy = CA;
var Gl = { exports: {} };
const RA = "2.0.0", kg = 256, $A = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, OA = 16, IA = kg - 6, DA = [
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
<<<<<<< HEAD
var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
=======
var go = {
  MAX_LENGTH: kg,
  MAX_SAFE_COMPONENT_LENGTH: OA,
  MAX_SAFE_BUILD_LENGTH: IA,
  MAX_SAFE_INTEGER: $A,
  RELEASE_TYPES: DA,
  SEMVER_SPEC_VERSION: RA,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const FA = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
<<<<<<< HEAD
var debug_1 = debug$1;
(function(module, exports) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2,
    MAX_SAFE_BUILD_LENGTH: MAX_SAFE_BUILD_LENGTH2,
    MAX_LENGTH: MAX_LENGTH2
  } = constants$1;
  const debug2 = debug_1;
  exports = module.exports = {};
  const re2 = exports.re = [];
  const safeRe = exports.safeRe = [];
  const src2 = exports.src = [];
  const safeSrc = exports.safeSrc = [];
  const t2 = exports.t = {};
  let R = 0;
  const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  const safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH2],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH2]
  ];
  const makeSafeRegex = (value) => {
    for (const [token, max2] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max2}}`).split(`${token}+`).join(`${token}{1,${max2}}`);
    }
    return value;
  };
  const createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name, index, value);
    t2[name] = index;
    src2[index] = value;
    safeSrc[index] = safe;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src2[t2.NONNUMERICIDENTIFIER]}|${src2[t2.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t2.NONNUMERICIDENTIFIER]}|${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src2[t2.PRERELEASEIDENTIFIER]}(?:\\.${src2[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src2[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src2[t2.BUILDIDENTIFIER]}(?:\\.${src2[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src2[t2.MAINVERSION]}${src2[t2.PRERELEASE]}?${src2[t2.BUILD]}?`);
  createToken("FULL", `^${src2[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src2[t2.MAINVERSIONLOOSE]}${src2[t2.PRERELEASELOOSE]}?${src2[t2.BUILD]}?`);
  createToken("LOOSE", `^${src2[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src2[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src2[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:${src2[t2.PRERELEASE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:${src2[t2.PRERELEASELOOSE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src2[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src2[t2.COERCEPLAIN] + `(?:${src2[t2.PRERELEASE]})?(?:${src2[t2.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src2[t2.COERCE], true);
  createToken("COERCERTLFULL", src2[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src2[t2.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src2[t2.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src2[t2.GTLT]}\\s*(${src2[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]}|${src2[t2.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src2[t2.XRANGEPLAIN]})\\s+-\\s+(${src2[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src2[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src2[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug = debug_1;
const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$1;
const { safeRe: re$1, t: t$1 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor(version, options) {
    options = parseOptions(options);
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
=======
var bo = FA;
(function(e, t) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: n,
    MAX_SAFE_BUILD_LENGTH: r,
    MAX_LENGTH: i
  } = go, a = bo;
  t = e.exports = {};
  const s = t.re = [], c = t.safeRe = [], o = t.src = [], u = t.safeSrc = [], l = t.t = {};
  let p = 0;
  const f = "[a-zA-Z0-9-]", m = [
    ["\\s", 1],
    ["\\d", i],
    [f, r]
  ], g = (b) => {
    for (const [x, y] of m)
      b = b.split(`${x}*`).join(`${x}{0,${y}}`).split(`${x}+`).join(`${x}{1,${y}}`);
    return b;
  }, h = (b, x, y) => {
    const E = g(x), S = p++;
    a(b, S, x), l[b] = S, o[S] = x, u[S] = E, s[S] = new RegExp(x, y ? "g" : void 0), c[S] = new RegExp(E, y ? "g" : void 0);
  };
  h("NUMERICIDENTIFIER", "0|[1-9]\\d*"), h("NUMERICIDENTIFIERLOOSE", "\\d+"), h("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${f}*`), h("MAINVERSION", `(${o[l.NUMERICIDENTIFIER]})\\.(${o[l.NUMERICIDENTIFIER]})\\.(${o[l.NUMERICIDENTIFIER]})`), h("MAINVERSIONLOOSE", `(${o[l.NUMERICIDENTIFIERLOOSE]})\\.(${o[l.NUMERICIDENTIFIERLOOSE]})\\.(${o[l.NUMERICIDENTIFIERLOOSE]})`), h("PRERELEASEIDENTIFIER", `(?:${o[l.NONNUMERICIDENTIFIER]}|${o[l.NUMERICIDENTIFIER]})`), h("PRERELEASEIDENTIFIERLOOSE", `(?:${o[l.NONNUMERICIDENTIFIER]}|${o[l.NUMERICIDENTIFIERLOOSE]})`), h("PRERELEASE", `(?:-(${o[l.PRERELEASEIDENTIFIER]}(?:\\.${o[l.PRERELEASEIDENTIFIER]})*))`), h("PRERELEASELOOSE", `(?:-?(${o[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${o[l.PRERELEASEIDENTIFIERLOOSE]})*))`), h("BUILDIDENTIFIER", `${f}+`), h("BUILD", `(?:\\+(${o[l.BUILDIDENTIFIER]}(?:\\.${o[l.BUILDIDENTIFIER]})*))`), h("FULLPLAIN", `v?${o[l.MAINVERSION]}${o[l.PRERELEASE]}?${o[l.BUILD]}?`), h("FULL", `^${o[l.FULLPLAIN]}$`), h("LOOSEPLAIN", `[v=\\s]*${o[l.MAINVERSIONLOOSE]}${o[l.PRERELEASELOOSE]}?${o[l.BUILD]}?`), h("LOOSE", `^${o[l.LOOSEPLAIN]}$`), h("GTLT", "((?:<|>)?=?)"), h("XRANGEIDENTIFIERLOOSE", `${o[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), h("XRANGEIDENTIFIER", `${o[l.NUMERICIDENTIFIER]}|x|X|\\*`), h("XRANGEPLAIN", `[v=\\s]*(${o[l.XRANGEIDENTIFIER]})(?:\\.(${o[l.XRANGEIDENTIFIER]})(?:\\.(${o[l.XRANGEIDENTIFIER]})(?:${o[l.PRERELEASE]})?${o[l.BUILD]}?)?)?`), h("XRANGEPLAINLOOSE", `[v=\\s]*(${o[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o[l.XRANGEIDENTIFIERLOOSE]})(?:${o[l.PRERELEASELOOSE]})?${o[l.BUILD]}?)?)?`), h("XRANGE", `^${o[l.GTLT]}\\s*${o[l.XRANGEPLAIN]}$`), h("XRANGELOOSE", `^${o[l.GTLT]}\\s*${o[l.XRANGEPLAINLOOSE]}$`), h("COERCEPLAIN", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?`), h("COERCE", `${o[l.COERCEPLAIN]}(?:$|[^\\d])`), h("COERCEFULL", o[l.COERCEPLAIN] + `(?:${o[l.PRERELEASE]})?(?:${o[l.BUILD]})?(?:$|[^\\d])`), h("COERCERTL", o[l.COERCE], !0), h("COERCERTLFULL", o[l.COERCEFULL], !0), h("LONETILDE", "(?:~>?)"), h("TILDETRIM", `(\\s*)${o[l.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", h("TILDE", `^${o[l.LONETILDE]}${o[l.XRANGEPLAIN]}$`), h("TILDELOOSE", `^${o[l.LONETILDE]}${o[l.XRANGEPLAINLOOSE]}$`), h("LONECARET", "(?:\\^)"), h("CARETTRIM", `(\\s*)${o[l.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", h("CARET", `^${o[l.LONECARET]}${o[l.XRANGEPLAIN]}$`), h("CARETLOOSE", `^${o[l.LONECARET]}${o[l.XRANGEPLAINLOOSE]}$`), h("COMPARATORLOOSE", `^${o[l.GTLT]}\\s*(${o[l.LOOSEPLAIN]})$|^$`), h("COMPARATOR", `^${o[l.GTLT]}\\s*(${o[l.FULLPLAIN]})$|^$`), h("COMPARATORTRIM", `(\\s*)${o[l.GTLT]}\\s*(${o[l.LOOSEPLAIN]}|${o[l.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", h("HYPHENRANGE", `^\\s*(${o[l.XRANGEPLAIN]})\\s+-\\s+(${o[l.XRANGEPLAIN]})\\s*$`), h("HYPHENRANGELOOSE", `^\\s*(${o[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${o[l.XRANGEPLAINLOOSE]})\\s*$`), h("STAR", "(<|>)?=?\\s*\\*"), h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Gl, Gl.exports);
var na = Gl.exports;
const PA = Object.freeze({ loose: !0 }), kA = Object.freeze({}), LA = (e) => e ? typeof e != "object" ? PA : e : kA;
var ap = LA;
const yh = /^[0-9]+$/, Lg = (e, t) => {
  const n = yh.test(e), r = yh.test(t);
  return n && r && (e = +e, t = +t), e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1;
}, NA = (e, t) => Lg(t, e);
var Ng = {
  compareIdentifiers: Lg,
  rcompareIdentifiers: NA
};
const ka = bo, { MAX_LENGTH: wh, MAX_SAFE_INTEGER: La } = go, { safeRe: Na, t: Ua } = na, UA = ap, { compareIdentifiers: sr } = Ng;
let BA = class At {
  constructor(t, n) {
    if (n = UA(n), t instanceof At) {
      if (t.loose === !!n.loose && t.includePrerelease === !!n.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > wh)
      throw new TypeError(
        `version is longer than ${wh} characters`
      );
    ka("SemVer", t, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
    const r = t.trim().match(n.loose ? Na[Ua.LOOSE] : Na[Ua.FULL]);
    if (!r)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > La || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > La || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > La || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4] ? this.prerelease = r[4].split(".").map((i) => {
      if (/^[0-9]+$/.test(i)) {
        const a = +i;
        if (a >= 0 && a < La)
          return a;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m = version.trim().match(options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
<<<<<<< HEAD
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug("prerelease compare", i, a, b);
      if (a === void 0 && b === void 0) {
=======
  compare(t) {
    if (ka("SemVer.compare", this.version, this.options, t), !(t instanceof At)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new At(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof At || (t = new At(t, this.options)), sr(this.major, t.major) || sr(this.minor, t.minor) || sr(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof At || (t = new At(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let n = 0;
    do {
      const r = this.prerelease[n], i = t.prerelease[n];
      if (ka("prerelease compare", n, r, i), r === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === i)
        continue;
      return sr(r, i);
    } while (++n);
  }
  compareBuild(t) {
    t instanceof At || (t = new At(t, this.options));
    let n = 0;
    do {
      const r = this.build[n], i = t.build[n];
      if (ka("build compare", n, r, i), r === void 0 && i === void 0)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
<<<<<<< HEAD
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug("build compare", i, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
=======
      return sr(r, i);
    } while (++n);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(release, identifier, identifierBase) {
    if (release.startsWith("pre")) {
      if (!identifier && identifierBase === false) {
        throw new Error("invalid increment argument: identifier is empty");
<<<<<<< HEAD
      }
      if (identifier) {
        const match = `-${identifier}`.match(this.options.loose ? re$1[t$1.PRERELEASELOOSE] : re$1[t$1.PRERELEASE]);
        if (!match || match[1] !== identifier) {
          throw new Error(`invalid identifier: ${identifier}`);
        }
=======
      if (n) {
        const i = `-${n}`.match(this.options.loose ? Na[Ua.PRERELEASELOOSE] : Na[Ua.PRERELEASE]);
        if (!i || i[1] !== n)
          throw new Error(`invalid identifier: ${n}`);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    }
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier, identifierBase);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier, identifierBase);
        this.inc("pre", identifier, identifierBase);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier, identifierBase);
        }
        this.inc("pre", identifier, identifierBase);
        break;
      case "release":
        if (this.prerelease.length === 0) {
          throw new Error(`version ${this.raw} is not a prerelease`);
        }
        this.prerelease.length = 0;
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre": {
        const base = Number(identifierBase) ? 1 : 0;
        if (this.prerelease.length === 0) {
          this.prerelease = [base];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === "number") {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            if (identifier === this.prerelease.join(".") && identifierBase === false) {
              throw new Error("invalid increment argument: identifier already exists");
            }
            this.prerelease.push(base);
          }
        }
<<<<<<< HEAD
        if (identifier) {
          let prerelease2 = [identifier, base];
          if (identifierBase === false) {
            prerelease2 = [identifier];
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease2;
            }
          } else {
            this.prerelease = prerelease2;
          }
=======
        if (n) {
          let a = [n, i];
          r === !1 && (a = [n]), sr(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = a) : this.prerelease = a;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.raw = this.format();
    if (this.build.length) {
      this.raw += `+${this.build.join(".")}`;
    }
    return this;
  }
};
<<<<<<< HEAD
var semver$2 = SemVer$d;
const SemVer$c = semver$2;
const parse$6 = (version, options, throwErrors = false) => {
  if (version instanceof SemVer$c) {
    return version;
  }
  try {
    return new SemVer$c(version, options);
  } catch (er) {
    if (!throwErrors) {
=======
var Ke = BA;
const Eh = Ke, jA = (e, t, n = !1) => {
  if (e instanceof Eh)
    return e;
  try {
    return new Eh(e, t);
  } catch (r) {
    if (!n)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      return null;
    }
    throw er;
  }
};
<<<<<<< HEAD
var parse_1 = parse$6;
const parse$5 = parse_1;
const valid$2 = (version, options) => {
  const v = parse$5(version, options);
  return v ? v.version : null;
};
var valid_1 = valid$2;
const parse$4 = parse_1;
const clean$1 = (version, options) => {
  const s = parse$4(version.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean$1;
const SemVer$b = semver$2;
const inc$1 = (version, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$b(
      version instanceof SemVer$b ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc$1;
const parse$3 = parse_1;
const diff$1 = (version1, version2) => {
  const v1 = parse$3(version1, null, true);
  const v2 = parse$3(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
    return null;
  }
  const v1Higher = comparison > 0;
  const highVersion = v1Higher ? v1 : v2;
  const lowVersion = v1Higher ? v2 : v1;
  const highHasPre = !!highVersion.prerelease.length;
  const lowHasPre = !!lowVersion.prerelease.length;
  if (lowHasPre && !highHasPre) {
    if (!lowVersion.patch && !lowVersion.minor) {
      return "major";
    }
    if (lowVersion.compareMain(highVersion) === 0) {
      if (lowVersion.minor && !lowVersion.patch) {
        return "minor";
      }
      return "patch";
    }
  }
  const prefix = highHasPre ? "pre" : "";
  if (v1.major !== v2.major) {
    return prefix + "major";
  }
  if (v1.minor !== v2.minor) {
    return prefix + "minor";
  }
  if (v1.patch !== v2.patch) {
    return prefix + "patch";
  }
  return "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$2;
const major$1 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$2;
const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$2;
const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$1;
const parse$2 = parse_1;
const prerelease$1 = (version, options) => {
  const parsed = parse$2(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$2;
const compare$b = (a, b, loose) => new SemVer$7(a, loose).compare(new SemVer$7(b, loose));
var compare_1 = compare$b;
const compare$a = compare_1;
const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1;
const compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$2;
const compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;
const compare$8 = compare_1;
const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1;
const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1;
const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1;
const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1;
const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1;
const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
=======
var zr = jA;
const MA = zr, qA = (e, t) => {
  const n = MA(e, t);
  return n ? n.version : null;
};
var zA = qA;
const HA = zr, WA = (e, t) => {
  const n = HA(e.trim().replace(/^[=v]+/, ""), t);
  return n ? n.version : null;
};
var GA = WA;
const _h = Ke, VA = (e, t, n, r, i) => {
  typeof n == "string" && (i = r, r = n, n = void 0);
  try {
    return new _h(
      e instanceof _h ? e.version : e,
      n
    ).inc(t, r, i).version;
  } catch {
    return null;
  }
};
var YA = VA;
const Sh = zr, XA = (e, t) => {
  const n = Sh(e, null, !0), r = Sh(t, null, !0), i = n.compare(r);
  if (i === 0)
    return null;
  const a = i > 0, s = a ? n : r, c = a ? r : n, o = !!s.prerelease.length;
  if (!!c.prerelease.length && !o) {
    if (!c.patch && !c.minor)
      return "major";
    if (c.compareMain(s) === 0)
      return c.minor && !c.patch ? "minor" : "patch";
  }
  const l = o ? "pre" : "";
  return n.major !== r.major ? l + "major" : n.minor !== r.minor ? l + "minor" : n.patch !== r.patch ? l + "patch" : "prerelease";
};
var KA = XA;
const JA = Ke, ZA = (e, t) => new JA(e, t).major;
var QA = ZA;
const eT = Ke, tT = (e, t) => new eT(e, t).minor;
var nT = tT;
const rT = Ke, iT = (e, t) => new rT(e, t).patch;
var aT = iT;
const sT = zr, oT = (e, t) => {
  const n = sT(e, t);
  return n && n.prerelease.length ? n.prerelease : null;
};
var cT = oT;
const Ah = Ke, lT = (e, t, n) => new Ah(e, n).compare(new Ah(t, n));
var yt = lT;
const uT = yt, pT = (e, t, n) => uT(t, e, n);
var fT = pT;
const dT = yt, hT = (e, t) => dT(e, t, !0);
var mT = hT;
const Th = Ke, vT = (e, t, n) => {
  const r = new Th(e, n), i = new Th(t, n);
  return r.compare(i) || r.compareBuild(i);
};
var sp = vT;
const gT = sp, bT = (e, t) => e.sort((n, r) => gT(n, r, t));
var xT = bT;
const yT = sp, wT = (e, t) => e.sort((n, r) => yT(r, n, t));
var ET = wT;
const _T = yt, ST = (e, t, n) => _T(e, t, n) > 0;
var xo = ST;
const AT = yt, TT = (e, t, n) => AT(e, t, n) < 0;
var op = TT;
const CT = yt, RT = (e, t, n) => CT(e, t, n) === 0;
var Ug = RT;
const $T = yt, OT = (e, t, n) => $T(e, t, n) !== 0;
var Bg = OT;
const IT = yt, DT = (e, t, n) => IT(e, t, n) >= 0;
var cp = DT;
const FT = yt, PT = (e, t, n) => FT(e, t, n) <= 0;
var lp = PT;
const kT = Ug, LT = Bg, NT = xo, UT = cp, BT = op, jT = lp, MT = (e, t, n, r) => {
  switch (t) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    case "===":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a === b;
    case "!==":
      if (typeof a === "object") {
        a = a.version;
      }
      if (typeof b === "object") {
        b = b.version;
      }
      return a !== b;
    case "":
    case "=":
    case "==":
<<<<<<< HEAD
      return eq$1(a, b, loose);
=======
      return kT(e, n, r);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    case "!=":
      return LT(e, n, r);
    case ">":
      return NT(e, n, r);
    case ">=":
      return UT(e, n, r);
    case "<":
      return BT(e, n, r);
    case "<=":
<<<<<<< HEAD
      return lte$2(a, b, loose);
=======
      return jT(e, n, r);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
<<<<<<< HEAD
var cmp_1 = cmp$1;
const SemVer$5 = semver$2;
const parse$1 = parse_1;
const { safeRe: re, t } = reExports;
const coerce$1 = (version, options) => {
  if (version instanceof SemVer$5) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  } else {
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    let next;
    while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    coerceRtlRegex.lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  const major2 = match[2];
  const minor2 = match[3] || "0";
  const patch2 = match[4] || "0";
  const prerelease2 = options.includePrerelease && match[5] ? `-${match[5]}` : "";
  const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
  return parse$1(`${major2}.${minor2}.${patch2}${prerelease2}${build}`, options);
};
var coerce_1 = coerce$1;
class LRUCache {
  constructor() {
    this.max = 1e3;
    this.map = /* @__PURE__ */ new Map();
  }
  get(key2) {
    const value = this.map.get(key2);
    if (value === void 0) {
      return void 0;
    } else {
      this.map.delete(key2);
      this.map.set(key2, value);
      return value;
    }
  }
  delete(key2) {
    return this.map.delete(key2);
  }
  set(key2, value) {
    const deleted = this.delete(key2);
    if (!deleted && value !== void 0) {
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value;
        this.delete(firstKey);
      }
      this.map.set(key2, value);
=======
var jg = MT;
const qT = Ke, zT = zr, { safeRe: Ba, t: ja } = na, HT = (e, t) => {
  if (e instanceof qT)
    return e;
  if (typeof e == "number" && (e = String(e)), typeof e != "string")
    return null;
  t = t || {};
  let n = null;
  if (!t.rtl)
    n = e.match(t.includePrerelease ? Ba[ja.COERCEFULL] : Ba[ja.COERCE]);
  else {
    const o = t.includePrerelease ? Ba[ja.COERCERTLFULL] : Ba[ja.COERCERTL];
    let u;
    for (; (u = o.exec(e)) && (!n || n.index + n[0].length !== e.length); )
      (!n || u.index + u[0].length !== n.index + n[0].length) && (n = u), o.lastIndex = u.index + u[1].length + u[2].length;
    o.lastIndex = -1;
  }
  if (n === null)
    return null;
  const r = n[2], i = n[3] || "0", a = n[4] || "0", s = t.includePrerelease && n[5] ? `-${n[5]}` : "", c = t.includePrerelease && n[6] ? `+${n[6]}` : "";
  return zT(`${r}.${i}.${a}${s}${c}`, t);
};
var WT = HT;
class GT {
  constructor() {
    this.max = 1e3, this.map = /* @__PURE__ */ new Map();
  }
  get(t) {
    const n = this.map.get(t);
    if (n !== void 0)
      return this.map.delete(t), this.map.set(t, n), n;
  }
  delete(t) {
    return this.map.delete(t);
  }
  set(t, n) {
    if (!this.delete(t) && n !== void 0) {
      if (this.map.size >= this.max) {
        const i = this.map.keys().next().value;
        this.delete(i);
      }
      this.map.set(t, n);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    return this;
  }
}
<<<<<<< HEAD
var lrucache = LRUCache;
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
=======
var VT = GT, Zc, Ch;
function wt() {
  if (Ch) return Zc;
  Ch = 1;
  const e = /\s+/g;
  class t {
    constructor(O, P) {
      if (P = i(P), O instanceof t)
        return O.loose === !!P.loose && O.includePrerelease === !!P.includePrerelease ? O : new t(O.raw, P);
      if (O instanceof a)
        return this.raw = O.value, this.set = [[O]], this.formatted = void 0, this;
      if (this.options = P, this.loose = !!P.loose, this.includePrerelease = !!P.includePrerelease, this.raw = O.trim().replace(e, " "), this.set = this.raw.split("||").map((w) => this.parseRange(w.trim())).filter((w) => w.length), !this.set.length)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
<<<<<<< HEAD
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
=======
        const w = this.set[0];
        if (this.set = this.set.filter((_) => !h(_[0])), this.set.length === 0)
          this.set = [w];
        else if (this.set.length > 1) {
          for (const _ of this.set)
            if (_.length === 1 && b(_[0])) {
              this.set = [_];
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
              break;
            }
          }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
<<<<<<< HEAD
        for (let i = 0; i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k = 0; k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
=======
        for (let O = 0; O < this.set.length; O++) {
          O > 0 && (this.formatted += "||");
          const P = this.set[O];
          for (let w = 0; w < P.length; w++)
            w > 0 && (this.formatted += " "), this.formatted += P[w].toString().trim();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
<<<<<<< HEAD
    parseRange(range2) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range2;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re2[t2.HYPHENRANGELOOSE] : re2[t2.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug2("hyphen replace", range2);
      range2 = range2.replace(re2[t2.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2);
      range2 = range2.replace(re2[t2.TILDETRIM], tildeTrimReplace);
      debug2("tilde trim", range2);
      range2 = range2.replace(re2[t2.CARETTRIM], caretTrimReplace);
      debug2("caret trim", range2);
      let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug2("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t2.COMPARATORLOOSE]);
        });
      }
      debug2("range list", rangeList);
      const rangeMap = /* @__PURE__ */ new Map();
      const comparators = rangeList.map((comp) => new Comparator2(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range2, options) {
      if (!(range2 instanceof Range2)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer3(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  range = Range2;
  const LRU = lrucache;
  const cache = new LRU();
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1;
  const SemVer3 = semver$2;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
=======
    parseRange(O) {
      const w = ((this.options.includePrerelease && m) | (this.options.loose && g)) + ":" + O, _ = r.get(w);
      if (_)
        return _;
      const R = this.options.loose, L = R ? o[u.HYPHENRANGELOOSE] : o[u.HYPHENRANGE];
      O = O.replace(L, J(this.options.includePrerelease)), s("hyphen replace", O), O = O.replace(o[u.COMPARATORTRIM], l), s("comparator trim", O), O = O.replace(o[u.TILDETRIM], p), s("tilde trim", O), O = O.replace(o[u.CARETTRIM], f), s("caret trim", O);
      let N = O.split(" ").map((q) => y(q, this.options)).join(" ").split(/\s+/).map((q) => M(q, this.options));
      R && (N = N.filter((q) => (s("loose invalid filter", q, this.options), !!q.match(o[u.COMPARATORLOOSE])))), s("range list", N);
      const j = /* @__PURE__ */ new Map(), K = N.map((q) => new a(q, this.options));
      for (const q of K) {
        if (h(q))
          return [q];
        j.set(q.value, q);
      }
      j.size > 1 && j.has("") && j.delete("");
      const Z = [...j.values()];
      return r.set(w, Z), Z;
    }
    intersects(O, P) {
      if (!(O instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((w) => x(w, P) && O.set.some((_) => x(_, P) && w.every((R) => _.every((L) => R.intersects(L, P)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(O) {
      if (!O)
        return !1;
      if (typeof O == "string")
        try {
          O = new c(O, this.options);
        } catch {
          return !1;
        }
      for (let P = 0; P < this.set.length; P++)
        if (re(this.set[P], O, this.options))
          return !0;
      return !1;
    }
  }
  Zc = t;
  const n = VT, r = new n(), i = ap, a = yo(), s = bo, c = Ke, {
    safeRe: o,
    t: u,
    comparatorTrimReplace: l,
    tildeTrimReplace: p,
    caretTrimReplace: f
  } = na, { FLAG_INCLUDE_PRERELEASE: m, FLAG_LOOSE: g } = go, h = (k) => k.value === "<0.0.0-0", b = (k) => k.value === "", x = (k, O) => {
    let P = !0;
    const w = k.slice();
    let _ = w.pop();
    for (; P && w.length; )
      P = w.every((R) => _.intersects(R, O)), _ = w.pop();
    return P;
  }, y = (k, O) => (s("comp", k, O), k = U(k, O), s("caret", k), k = S(k, O), s("tildes", k), k = ee(k, O), s("xrange", k), k = H(k, O), s("stars", k), k), E = (k) => !k || k.toLowerCase() === "x" || k === "*", S = (k, O) => k.trim().split(/\s+/).map((P) => D(P, O)).join(" "), D = (k, O) => {
    const P = O.loose ? o[u.TILDELOOSE] : o[u.TILDE];
    return k.replace(P, (w, _, R, L, N) => {
      s("tilde", k, w, _, R, L, N);
      let j;
      return E(_) ? j = "" : E(R) ? j = `>=${_}.0.0 <${+_ + 1}.0.0-0` : E(L) ? j = `>=${_}.${R}.0 <${_}.${+R + 1}.0-0` : N ? (s("replaceTilde pr", N), j = `>=${_}.${R}.${L}-${N} <${_}.${+R + 1}.0-0`) : j = `>=${_}.${R}.${L} <${_}.${+R + 1}.0-0`, s("tilde return", j), j;
    });
  }, U = (k, O) => k.trim().split(/\s+/).map((P) => z(P, O)).join(" "), z = (k, O) => {
    s("caret", k, O);
    const P = O.loose ? o[u.CARETLOOSE] : o[u.CARET], w = O.includePrerelease ? "-0" : "";
    return k.replace(P, (_, R, L, N, j) => {
      s("caret", k, _, R, L, N, j);
      let K;
      return E(R) ? K = "" : E(L) ? K = `>=${R}.0.0${w} <${+R + 1}.0.0-0` : E(N) ? R === "0" ? K = `>=${R}.${L}.0${w} <${R}.${+L + 1}.0-0` : K = `>=${R}.${L}.0${w} <${+R + 1}.0.0-0` : j ? (s("replaceCaret pr", j), R === "0" ? L === "0" ? K = `>=${R}.${L}.${N}-${j} <${R}.${L}.${+N + 1}-0` : K = `>=${R}.${L}.${N}-${j} <${R}.${+L + 1}.0-0` : K = `>=${R}.${L}.${N}-${j} <${+R + 1}.0.0-0`) : (s("no pr"), R === "0" ? L === "0" ? K = `>=${R}.${L}.${N}${w} <${R}.${L}.${+N + 1}-0` : K = `>=${R}.${L}.${N}${w} <${R}.${+L + 1}.0-0` : K = `>=${R}.${L}.${N} <${+R + 1}.0.0-0`), s("caret return", K), K;
    });
  }, ee = (k, O) => (s("replaceXRanges", k, O), k.split(/\s+/).map((P) => C(P, O)).join(" ")), C = (k, O) => {
    k = k.trim();
    const P = O.loose ? o[u.XRANGELOOSE] : o[u.XRANGE];
    return k.replace(P, (w, _, R, L, N, j) => {
      s("xRange", k, w, _, R, L, N, j);
      const K = E(R), Z = K || E(L), q = Z || E(N), le = q;
      return _ === "=" && le && (_ = ""), j = O.includePrerelease ? "-0" : "", K ? _ === ">" || _ === "<" ? w = "<0.0.0-0" : w = "*" : _ && le ? (Z && (L = 0), N = 0, _ === ">" ? (_ = ">=", Z ? (R = +R + 1, L = 0, N = 0) : (L = +L + 1, N = 0)) : _ === "<=" && (_ = "<", Z ? R = +R + 1 : L = +L + 1), _ === "<" && (j = "-0"), w = `${_ + R}.${L}.${N}${j}`) : Z ? w = `>=${R}.0.0${j} <${+R + 1}.0.0-0` : q && (w = `>=${R}.${L}.0${j} <${R}.${+L + 1}.0-0`), s("xRange return", w), w;
    });
  }, H = (k, O) => (s("replaceStars", k, O), k.trim().replace(o[u.STAR], "")), M = (k, O) => (s("replaceGTE0", k, O), k.trim().replace(o[O.includePrerelease ? u.GTE0PRE : u.GTE0], "")), J = (k) => (O, P, w, _, R, L, N, j, K, Z, q, le) => (E(w) ? P = "" : E(_) ? P = `>=${w}.0.0${k ? "-0" : ""}` : E(R) ? P = `>=${w}.${_}.0${k ? "-0" : ""}` : L ? P = `>=${P}` : P = `>=${P}${k ? "-0" : ""}`, E(K) ? j = "" : E(Z) ? j = `<${+K + 1}.0.0-0` : E(q) ? j = `<${K}.${+Z + 1}.0-0` : le ? j = `<=${K}.${Z}.${q}-${le}` : k ? j = `<${K}.${Z}.${+q + 1}-0` : j = `<=${j}`, `${P} ${j}`.trim()), re = (k, O, P) => {
    for (let w = 0; w < k.length; w++)
      if (!k[w].test(O))
        return !1;
    if (O.prerelease.length && !P.includePrerelease) {
      for (let w = 0; w < k.length; w++)
        if (s(k[w].semver), k[w].semver !== a.ANY && k[w].semver.prerelease.length > 0) {
          const _ = k[w].semver;
          if (_.major === O.major && _.minor === O.minor && _.patch === O.patch)
            return !0;
        }
      return !1;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    return result;
  };
<<<<<<< HEAD
  const parseComparator = (comp, options) => {
    debug2("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug2("caret", comp);
    comp = replaceTildes(comp, options);
    debug2("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug2("xrange", comp);
    comp = replaceStars(comp, options);
    debug2("stars", comp);
    return comp;
  };
  const isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  const replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  const replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t2.TILDELOOSE] : re2[t2.TILDE];
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("tilde", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
      } else if (pr) {
        debug2("replaceTilde pr", pr);
        ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
      } else {
        ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
      }
      debug2("tilde return", ret);
      return ret;
    });
  };
  const replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  const replaceCaret = (comp, options) => {
    debug2("caret", comp, options);
    const r = options.loose ? re2[t2.CARETLOOSE] : re2[t2.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr) => {
      debug2("caret", comp, _, M, m, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug2("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug2("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug2("caret return", ret);
      return ret;
    });
  };
  const replaceXRanges = (comp, options) => {
    debug2("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  const replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t2.XRANGELOOSE] : re2[t2.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
      debug2("xRange", comp, ret, gtlt, M, m, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
      }
      debug2("xRange return", ret);
      return ret;
    });
  };
  const replaceStars = (comp, options) => {
    debug2("replaceStars", comp, options);
    return comp.trim().replace(re2[t2.STAR], "");
  };
  const replaceGTE0 = (comp, options) => {
    debug2("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
  };
  const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  const testSet = (set2, version, options) => {
    for (let i = 0; i < set2.length; i++) {
      if (!set2[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0; i < set2.length; i++) {
        debug2(set2[i].semver);
        if (set2[i].semver === Comparator2.ANY) {
          continue;
        }
        if (set2[i].semver.prerelease.length > 0) {
          const allowed = set2[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
  return range;
}
var comparator;
var hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator) return comparator;
  hasRequiredComparator = 1;
  const ANY2 = Symbol("SemVer ANY");
  class Comparator2 {
    static get ANY() {
      return ANY2;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator2) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY2) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t2.COMPARATORLOOSE] : re2[t2.COMPARATOR];
      const m = comp.match(r);
      if (!m) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY2;
      } else {
        this.semver = new SemVer3(m[2], this.options.loose);
      }
=======
  return Zc;
}
var Qc, Rh;
function yo() {
  if (Rh) return Qc;
  Rh = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(l, p) {
      if (p = n(p), l instanceof t) {
        if (l.loose === !!p.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), s("comparator", l, p), this.options = p, this.loose = !!p.loose, this.parse(l), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, s("comp", this);
    }
    parse(l) {
      const p = this.options.loose ? r[i.COMPARATORLOOSE] : r[i.COMPARATOR], f = l.match(p);
      if (!f)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = f[1] !== void 0 ? f[1] : "", this.operator === "=" && (this.operator = ""), f[2] ? this.semver = new c(f[2], this.options.loose) : this.semver = e;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    toString() {
      return this.value;
    }
<<<<<<< HEAD
    test(version) {
      debug2("Comparator.test", version, this.options.loose);
      if (this.semver === ANY2 || version === ANY2) {
        return true;
      }
      if (typeof version === "string") {
=======
    test(l) {
      if (s("Comparator.test", l, this.options.loose), this.semver === e || l === e)
        return !0;
      if (typeof l == "string")
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        try {
          version = new SemVer3(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp2(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator2)) {
        throw new TypeError("a Comparator is required");
<<<<<<< HEAD
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range2(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range2(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp2(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp2(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1;
  const SemVer3 = semver$2;
  const Range2 = requireRange();
  return comparator;
=======
      return this.operator === "" ? this.value === "" ? !0 : new o(l.value, p).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new o(this.value, p).test(l.semver) : (p = n(p), p.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !p.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || a(this.semver, "<", l.semver, p) && this.operator.startsWith(">") && l.operator.startsWith("<") || a(this.semver, ">", l.semver, p) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  Qc = t;
  const n = ap, { safeRe: r, t: i } = na, a = jg, s = bo, c = Ke, o = wt();
  return Qc;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
}
const YT = wt(), XT = (e, t, n) => {
  try {
<<<<<<< HEAD
    range2 = new Range$9(range2, options);
  } catch (er) {
    return false;
=======
    t = new YT(t, n);
  } catch {
    return !1;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  return range2.test(version);
};
<<<<<<< HEAD
var satisfies_1 = satisfies$4;
const Range$8 = requireRange();
const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$2;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions, range2, options) => {
  let max2 = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max2 || maxSV.compare(v) === -1) {
        max2 = v;
        maxSV = new SemVer$4(max2, options);
      }
    }
  });
  return max2;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$2;
const Range$6 = requireRange();
const minSatisfying$1 = (versions, range2, options) => {
  let min2 = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min2 || minSV.compare(v) === 1) {
        min2 = v;
        minSV = new SemVer$3(min2, options);
      }
    }
  });
  return min2;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$2;
const Range$5 = requireRange();
const gt$2 = gt_1;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
=======
var wo = XT;
const KT = wt(), JT = (e, t) => new KT(e, t).set.map((n) => n.map((r) => r.value).join(" ").trim().split(" "));
var ZT = JT;
const QT = Ke, eC = wt(), tC = (e, t, n) => {
  let r = null, i = null, a = null;
  try {
    a = new eC(t, n);
  } catch {
    return null;
  }
  return e.forEach((s) => {
    a.test(s) && (!r || i.compare(s) === -1) && (r = s, i = new QT(r, n));
  }), r;
};
var nC = tC;
const rC = Ke, iC = wt(), aC = (e, t, n) => {
  let r = null, i = null, a = null;
  try {
    a = new iC(t, n);
  } catch {
    return null;
  }
  return e.forEach((s) => {
    a.test(s) && (!r || i.compare(s) === 1) && (r = s, i = new rC(r, n));
  }), r;
};
var sC = aC;
const el = Ke, oC = wt(), $h = xo, cC = (e, t) => {
  e = new oC(e, t);
  let n = new el("0.0.0");
  if (e.test(n) || (n = new el("0.0.0-0"), e.test(n)))
    return n;
  n = null;
  for (let r = 0; r < e.set.length; ++r) {
    const i = e.set[r];
    let a = null;
    i.forEach((s) => {
      const c = new el(s.semver.version);
      switch (s.operator) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
<<<<<<< HEAD
          if (!setMin || gt$2(compver, setMin)) {
            setMin = compver;
          }
=======
          (!a || $h(c, a)) && (a = c);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          break;
        case "<":
        case "<=":
          break;
        default:
<<<<<<< HEAD
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$2(minver, setMin))) {
      minver = setMin;
    }
=======
          throw new Error(`Unexpected operation: ${s.operator}`);
      }
    }), a && (!n || $h(n, a)) && (n = a);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
<<<<<<< HEAD
var minVersion_1 = minVersion$1;
const Range$4 = requireRange();
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$2;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version, range2, hilo, options) => {
  version = new SemVer$1(version, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
=======
var lC = cC;
const uC = wt(), pC = (e, t) => {
  try {
    return new uC(e, t).range || "*";
  } catch {
    return null;
  }
};
var fC = pC;
const dC = Ke, Mg = yo(), { ANY: hC } = Mg, mC = wt(), vC = wo, Oh = xo, Ih = op, gC = lp, bC = cp, xC = (e, t, n, r) => {
  e = new dC(e, r), t = new mC(t, r);
  let i, a, s, c, o;
  switch (n) {
    case ">":
      i = Oh, a = gC, s = Ih, c = ">", o = ">=";
      break;
    case "<":
      i = Ih, a = bC, s = Oh, c = "<", o = "<=";
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
<<<<<<< HEAD
  if (satisfies$3(version, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
=======
  if (vC(e, t, r))
    return !1;
  for (let u = 0; u < t.set.length; ++u) {
    const l = t.set[u];
    let p = null, f = null;
    if (l.forEach((m) => {
      m.semver === hC && (m = new Mg(">=0.0.0")), p = p || m, f = f || m, i(m.semver, p.semver, r) ? p = m : s(m.semver, f.semver, r) && (f = m);
    }), p.operator === c || p.operator === o || (!f.operator || f.operator === c) && a(e, f.semver))
      return !1;
    if (f.operator === o && s(e, f.semver))
      return !1;
  }
  return !0;
};
var up = xC;
const yC = up, wC = (e, t, n) => yC(e, t, ">", n);
var EC = wC;
const _C = up, SC = (e, t, n) => _C(e, t, "<", n);
var AC = SC;
const Dh = wt(), TC = (e, t, n) => (e = new Dh(e, n), t = new Dh(t, n), e.intersects(t, n));
var CC = TC;
const RC = wo, $C = yt;
var OC = (e, t, n) => {
  const r = [];
  let i = null, a = null;
  const s = e.sort((l, p) => $C(l, p, n));
  for (const l of s)
    RC(l, t, n) ? (a = l, i || (i = l)) : (a && r.push([i, a]), a = null, i = null);
  i && r.push([i, null]);
  const c = [];
  for (const [l, p] of r)
    l === p ? c.push(l) : !p && l === s[0] ? c.push("*") : p ? l === s[0] ? c.push(`<=${p}`) : c.push(`${l} - ${p}`) : c.push(`>=${l}`);
  const o = c.join(" || "), u = typeof t.raw == "string" ? t.raw : String(t);
  return o.length < u.length ? o : t;
};
const Fh = wt(), pp = yo(), { ANY: tl } = pp, ri = wo, fp = yt, IC = (e, t, n = {}) => {
  if (e === t)
    return !0;
  e = new Fh(e, n), t = new Fh(t, n);
  let r = !1;
  e: for (const i of e.set) {
    for (const a of t.set) {
      const s = FC(i, a, n);
      if (r = r || s !== null, s)
        continue e;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
  }
<<<<<<< HEAD
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version, range2, options) => outside$2(version, range2, ">", options);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version, range2, options) => outside$1(version, range2, "<", options);
var ltr_1 = ltr$1;
const Range$2 = requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions, range2, options) => {
  const set2 = [];
  let first = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$2(a, b, options));
  for (const version of v) {
    const included = satisfies$2(version, range2, options);
    if (included) {
      prev = version;
      if (!first) {
        first = version;
      }
    } else {
      if (prev) {
        set2.push([first, prev]);
      }
      prev = null;
      first = null;
    }
  }
  if (first) {
    set2.push([first, null]);
  }
  const ranges = [];
  for (const [min2, max2] of set2) {
    if (min2 === max2) {
      ranges.push(min2);
    } else if (!max2 && min2 === v[0]) {
      ranges.push("*");
    } else if (!max2) {
      ranges.push(`>=${min2}`);
    } else if (min2 === v[0]) {
      ranges.push(`<=${max2}`);
    } else {
      ranges.push(`${min2} - ${max2}`);
    }
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range$1 = requireRange();
const Comparator$1 = requireComparator();
const { ANY } = Comparator$1;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true;
  }
  sub = new Range$1(sub, options);
  dom = new Range$1(dom, options);
  let sawNonNull = false;
  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options);
      sawNonNull = sawNonNull || isSub !== null;
      if (isSub) {
        continue OUTER;
      }
    }
    if (sawNonNull) {
      return false;
    }
  }
  return true;
};
const minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")];
const minimumVersion = [new Comparator$1(">=0.0.0")];
const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true;
  }
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true;
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease;
    } else {
      sub = minimumVersion;
    }
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true;
    } else {
      dom = minimumVersion;
    }
  }
  const eqSet = /* @__PURE__ */ new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=") {
      gt2 = higherGT(gt2, c, options);
    } else if (c.operator === "<" || c.operator === "<=") {
      lt2 = lowerLT(lt2, c, options);
    } else {
      eqSet.add(c.semver);
    }
  }
  if (eqSet.size > 1) {
    return null;
  }
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$1(gt2.semver, lt2.semver, options);
    if (gtltComp > 0) {
      return null;
    } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
      return null;
    }
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$1(eq2, String(gt2), options)) {
      return null;
    }
    if (lt2 && !satisfies$1(eq2, String(lt2), options)) {
      return null;
    }
    for (const c of dom) {
      if (!satisfies$1(eq2, String(c), options)) {
        return false;
      }
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2) {
          return false;
        }
      } else if (gt2.operator === ">=" && !satisfies$1(gt2.semver, String(c), options)) {
        return false;
      }
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2) {
          return false;
        }
      } else if (lt2.operator === "<=" && !satisfies$1(lt2.semver, String(c), options)) {
        return false;
      }
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0) {
      return false;
    }
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
    return false;
  }
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
    return false;
  }
  if (needDomGTPre || needDomLTPre) {
    return false;
  }
  return true;
};
const higherGT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset$1;
const internalRe = reExports;
const constants = constants$1;
const SemVer2 = semver$2;
const identifiers = identifiers$1;
const parse = parse_1;
const valid = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver$1 = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer: SemVer2,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
var DownloadedUpdateHelper$1 = {};
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache, key2) {
    return cache.has(key2);
=======
  return !0;
}, DC = [new pp(">=0.0.0-0")], Ph = [new pp(">=0.0.0")], FC = (e, t, n) => {
  if (e === t)
    return !0;
  if (e.length === 1 && e[0].semver === tl) {
    if (t.length === 1 && t[0].semver === tl)
      return !0;
    n.includePrerelease ? e = DC : e = Ph;
  }
  if (t.length === 1 && t[0].semver === tl) {
    if (n.includePrerelease)
      return !0;
    t = Ph;
  }
  const r = /* @__PURE__ */ new Set();
  let i, a;
  for (const m of e)
    m.operator === ">" || m.operator === ">=" ? i = kh(i, m, n) : m.operator === "<" || m.operator === "<=" ? a = Lh(a, m, n) : r.add(m.semver);
  if (r.size > 1)
    return null;
  let s;
  if (i && a) {
    if (s = fp(i.semver, a.semver, n), s > 0)
      return null;
    if (s === 0 && (i.operator !== ">=" || a.operator !== "<="))
      return null;
  }
  for (const m of r) {
    if (i && !ri(m, String(i), n) || a && !ri(m, String(a), n))
      return null;
    for (const g of t)
      if (!ri(m, String(g), n))
        return !1;
    return !0;
  }
  let c, o, u, l, p = a && !n.includePrerelease && a.semver.prerelease.length ? a.semver : !1, f = i && !n.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
  p && p.prerelease.length === 1 && a.operator === "<" && p.prerelease[0] === 0 && (p = !1);
  for (const m of t) {
    if (l = l || m.operator === ">" || m.operator === ">=", u = u || m.operator === "<" || m.operator === "<=", i) {
      if (f && m.semver.prerelease && m.semver.prerelease.length && m.semver.major === f.major && m.semver.minor === f.minor && m.semver.patch === f.patch && (f = !1), m.operator === ">" || m.operator === ">=") {
        if (c = kh(i, m, n), c === m && c !== i)
          return !1;
      } else if (i.operator === ">=" && !ri(i.semver, String(m), n))
        return !1;
    }
    if (a) {
      if (p && m.semver.prerelease && m.semver.prerelease.length && m.semver.major === p.major && m.semver.minor === p.minor && m.semver.patch === p.patch && (p = !1), m.operator === "<" || m.operator === "<=") {
        if (o = Lh(a, m, n), o === m && o !== a)
          return !1;
      } else if (a.operator === "<=" && !ri(a.semver, String(m), n))
        return !1;
    }
    if (!m.operator && (a || i) && s !== 0)
      return !1;
  }
  return !(i && u && !a && s !== 0 || a && l && !i && s !== 0 || f || p);
}, kh = (e, t, n) => {
  if (!e)
    return t;
  const r = fp(e.semver, t.semver, n);
  return r > 0 ? e : r < 0 || t.operator === ">" && e.operator === ">=" ? t : e;
}, Lh = (e, t, n) => {
  if (!e)
    return t;
  const r = fp(e.semver, t.semver, n);
  return r < 0 ? e : r > 0 || t.operator === "<" && e.operator === "<=" ? t : e;
};
var PC = IC;
const nl = na, Nh = go, kC = Ke, Uh = Ng, LC = zr, NC = zA, UC = GA, BC = YA, jC = KA, MC = QA, qC = nT, zC = aT, HC = cT, WC = yt, GC = fT, VC = mT, YC = sp, XC = xT, KC = ET, JC = xo, ZC = op, QC = Ug, eR = Bg, tR = cp, nR = lp, rR = jg, iR = WT, aR = yo(), sR = wt(), oR = wo, cR = ZT, lR = nC, uR = sC, pR = lC, fR = fC, dR = up, hR = EC, mR = AC, vR = CC, gR = OC, bR = PC;
var qg = {
  parse: LC,
  valid: NC,
  clean: UC,
  inc: BC,
  diff: jC,
  major: MC,
  minor: qC,
  patch: zC,
  prerelease: HC,
  compare: WC,
  rcompare: GC,
  compareLoose: VC,
  compareBuild: YC,
  sort: XC,
  rsort: KC,
  gt: JC,
  lt: ZC,
  eq: QC,
  neq: eR,
  gte: tR,
  lte: nR,
  cmp: rR,
  coerce: iR,
  Comparator: aR,
  Range: sR,
  satisfies: oR,
  toComparators: cR,
  maxSatisfying: lR,
  minSatisfying: uR,
  minVersion: pR,
  validRange: fR,
  outside: dR,
  gtr: hR,
  ltr: mR,
  intersects: vR,
  simplifyRange: gR,
  subset: bR,
  SemVer: kC,
  re: nl.re,
  src: nl.src,
  tokens: nl.t,
  SEMVER_SPEC_VERSION: Nh.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: Nh.RELEASE_TYPES,
  compareIdentifiers: Uh.compareIdentifiers,
  rcompareIdentifiers: Uh.rcompareIdentifiers
}, ra = {}, Ts = { exports: {} };
Ts.exports;
(function(e, t) {
  var n = 200, r = "__lodash_hash_undefined__", i = 1, a = 2, s = 9007199254740991, c = "[object Arguments]", o = "[object Array]", u = "[object AsyncFunction]", l = "[object Boolean]", p = "[object Date]", f = "[object Error]", m = "[object Function]", g = "[object GeneratorFunction]", h = "[object Map]", b = "[object Number]", x = "[object Null]", y = "[object Object]", E = "[object Promise]", S = "[object Proxy]", D = "[object RegExp]", U = "[object Set]", z = "[object String]", ee = "[object Symbol]", C = "[object Undefined]", H = "[object WeakMap]", M = "[object ArrayBuffer]", J = "[object DataView]", re = "[object Float32Array]", k = "[object Float64Array]", O = "[object Int8Array]", P = "[object Int16Array]", w = "[object Int32Array]", _ = "[object Uint8Array]", R = "[object Uint8ClampedArray]", L = "[object Uint16Array]", N = "[object Uint32Array]", j = /[\\^$.*+?()[\]{}|]/g, K = /^\[object .+?Constructor\]$/, Z = /^(?:0|[1-9]\d*)$/, q = {};
  q[re] = q[k] = q[O] = q[P] = q[w] = q[_] = q[R] = q[L] = q[N] = !0, q[c] = q[o] = q[M] = q[l] = q[J] = q[p] = q[f] = q[m] = q[h] = q[b] = q[y] = q[D] = q[U] = q[z] = q[H] = !1;
  var le = typeof Ae == "object" && Ae && Ae.Object === Object && Ae, v = typeof self == "object" && self && self.Object === Object && self, d = le || v || Function("return this")(), $ = t && !t.nodeType && t, T = $ && !0 && e && !e.nodeType && e, G = T && T.exports === $, W = G && le.process, X = function() {
    try {
      return W && W.binding && W.binding("util");
    } catch {
    }
  }(), ve = X && X.isTypedArray;
  function Te(A, I) {
    for (var B = -1, Y = A == null ? 0 : A.length, fe = 0, te = []; ++B < Y; ) {
      var ge = A[B];
      I(ge, B, A) && (te[fe++] = ge);
    }
    return te;
  }
  function pt(A, I) {
    for (var B = -1, Y = I.length, fe = A.length; ++B < Y; )
      A[fe + B] = I[B];
    return A;
  }
  function Se(A, I) {
    for (var B = -1, Y = A == null ? 0 : A.length; ++B < Y; )
      if (I(A[B], B, A))
        return !0;
    return !1;
  }
  function qe(A, I) {
    for (var B = -1, Y = Array(A); ++B < A; )
      Y[B] = I(B);
    return Y;
  }
  function er(A) {
    return function(I) {
      return A(I);
    };
  }
  function Ht(A, I) {
    return A.has(I);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  function Dt(A, I) {
    return A == null ? void 0 : A[I];
  }
<<<<<<< HEAD
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key2) {
      result[++index] = [key2, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData = root2["__core-js_shared__"];
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root2, "DataView"), Map2 = getNative(root2, "Map"), Promise2 = getNative(root2, "Promise"), Set2 = getNative(root2, "Set"), WeakMap2 = getNative(root2, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key2) {
    var result = this.has(key2) && delete this.__data__[key2];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet(key2) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key2];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key2) ? data[key2] : void 0;
  }
  function hashHas(key2) {
    var data = this.__data__;
    return nativeCreate ? data[key2] !== void 0 : hasOwnProperty2.call(data, key2);
  }
  function hashSet(key2, value) {
    var data = this.__data__;
    this.size += this.has(key2) ? 0 : 1;
    data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete(key2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  function listCacheSet(key2, value) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    if (index < 0) {
      ++this.size;
      data.push([key2, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key2) {
    var result = getMapData(this, key2)["delete"](key2);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  function mapCacheSet(key2, value) {
    var data = getMapData(this, key2), size = data.size;
    data.set(key2, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key2) {
    var data = this.__data__, result = data["delete"](key2);
    this.size = data.size;
    return result;
  }
  function stackGet(key2) {
    return this.__data__.get(key2);
  }
  function stackHas(key2) {
    return this.__data__.has(key2);
  }
  function stackSet(key2, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs2 = data.__data__;
      if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key2, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs2);
    }
    data.set(key2, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key2 in value) {
      if (hasOwnProperty2.call(value, key2) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
      isIndex(key2, length)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function assocIndexOf(array, key2) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key2)) {
        return length;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer2(object)) {
      if (!isBuffer2(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key2 in Object(object)) {
      if (hasOwnProperty2.call(object, key2) && key2 != "constructor") {
        result.push(key2);
      }
    }
    return result;
  }
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag2:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key2 = objProps[index];
      if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2))) {
        return false;
      }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key2 = objProps[index];
      var objValue = object[key2], othValue = other[key2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key2 == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  function getMapData(map2, key2) {
    var data = map2.__data__;
    return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
=======
  function Wt(A) {
    var I = -1, B = Array(A.size);
    return A.forEach(function(Y, fe) {
      B[++I] = [fe, Y];
    }), B;
  }
  function En(A, I) {
    return function(B) {
      return A(I(B));
    };
  }
  function Gt(A) {
    var I = -1, B = Array(A.size);
    return A.forEach(function(Y) {
      B[++I] = Y;
    }), B;
  }
  var _n = Array.prototype, rb = Function.prototype, oa = Object.prototype, Oo = d["__core-js_shared__"], vp = rb.toString, Et = oa.hasOwnProperty, gp = function() {
    var A = /[^.]+$/.exec(Oo && Oo.keys && Oo.keys.IE_PROTO || "");
    return A ? "Symbol(src)_1." + A : "";
  }(), bp = oa.toString, ib = RegExp(
    "^" + vp.call(Et).replace(j, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), xp = G ? d.Buffer : void 0, ca = d.Symbol, yp = d.Uint8Array, wp = oa.propertyIsEnumerable, ab = _n.splice, Sn = ca ? ca.toStringTag : void 0, Ep = Object.getOwnPropertySymbols, sb = xp ? xp.isBuffer : void 0, ob = En(Object.keys, Object), Io = tr(d, "DataView"), Wr = tr(d, "Map"), Do = tr(d, "Promise"), Fo = tr(d, "Set"), Po = tr(d, "WeakMap"), Gr = tr(Object, "create"), cb = Cn(Io), lb = Cn(Wr), ub = Cn(Do), pb = Cn(Fo), fb = Cn(Po), _p = ca ? ca.prototype : void 0, ko = _p ? _p.valueOf : void 0;
  function An(A) {
    var I = -1, B = A == null ? 0 : A.length;
    for (this.clear(); ++I < B; ) {
      var Y = A[I];
      this.set(Y[0], Y[1]);
    }
  }
  function db() {
    this.__data__ = Gr ? Gr(null) : {}, this.size = 0;
  }
  function hb(A) {
    var I = this.has(A) && delete this.__data__[A];
    return this.size -= I ? 1 : 0, I;
  }
  function mb(A) {
    var I = this.__data__;
    if (Gr) {
      var B = I[A];
      return B === r ? void 0 : B;
    }
    return Et.call(I, A) ? I[A] : void 0;
  }
  function vb(A) {
    var I = this.__data__;
    return Gr ? I[A] !== void 0 : Et.call(I, A);
  }
  function gb(A, I) {
    var B = this.__data__;
    return this.size += this.has(A) ? 0 : 1, B[A] = Gr && I === void 0 ? r : I, this;
  }
  An.prototype.clear = db, An.prototype.delete = hb, An.prototype.get = mb, An.prototype.has = vb, An.prototype.set = gb;
  function Ft(A) {
    var I = -1, B = A == null ? 0 : A.length;
    for (this.clear(); ++I < B; ) {
      var Y = A[I];
      this.set(Y[0], Y[1]);
    }
  }
  function bb() {
    this.__data__ = [], this.size = 0;
  }
  function xb(A) {
    var I = this.__data__, B = ua(I, A);
    if (B < 0)
      return !1;
    var Y = I.length - 1;
    return B == Y ? I.pop() : ab.call(I, B, 1), --this.size, !0;
  }
  function yb(A) {
    var I = this.__data__, B = ua(I, A);
    return B < 0 ? void 0 : I[B][1];
  }
  function wb(A) {
    return ua(this.__data__, A) > -1;
  }
  function Eb(A, I) {
    var B = this.__data__, Y = ua(B, A);
    return Y < 0 ? (++this.size, B.push([A, I])) : B[Y][1] = I, this;
  }
  Ft.prototype.clear = bb, Ft.prototype.delete = xb, Ft.prototype.get = yb, Ft.prototype.has = wb, Ft.prototype.set = Eb;
  function Tn(A) {
    var I = -1, B = A == null ? 0 : A.length;
    for (this.clear(); ++I < B; ) {
      var Y = A[I];
      this.set(Y[0], Y[1]);
    }
  }
  function _b() {
    this.size = 0, this.__data__ = {
      hash: new An(),
      map: new (Wr || Ft)(),
      string: new An()
    };
  }
  function Sb(A) {
    var I = pa(this, A).delete(A);
    return this.size -= I ? 1 : 0, I;
  }
  function Ab(A) {
    return pa(this, A).get(A);
  }
  function Tb(A) {
    return pa(this, A).has(A);
  }
  function Cb(A, I) {
    var B = pa(this, A), Y = B.size;
    return B.set(A, I), this.size += B.size == Y ? 0 : 1, this;
  }
  Tn.prototype.clear = _b, Tn.prototype.delete = Sb, Tn.prototype.get = Ab, Tn.prototype.has = Tb, Tn.prototype.set = Cb;
  function la(A) {
    var I = -1, B = A == null ? 0 : A.length;
    for (this.__data__ = new Tn(); ++I < B; )
      this.add(A[I]);
  }
  function Rb(A) {
    return this.__data__.set(A, r), this;
  }
  function $b(A) {
    return this.__data__.has(A);
  }
  la.prototype.add = la.prototype.push = Rb, la.prototype.has = $b;
  function Vt(A) {
    var I = this.__data__ = new Ft(A);
    this.size = I.size;
  }
  function Ob() {
    this.__data__ = new Ft(), this.size = 0;
  }
  function Ib(A) {
    var I = this.__data__, B = I.delete(A);
    return this.size = I.size, B;
  }
  function Db(A) {
    return this.__data__.get(A);
  }
  function Fb(A) {
    return this.__data__.has(A);
  }
  function Pb(A, I) {
    var B = this.__data__;
    if (B instanceof Ft) {
      var Y = B.__data__;
      if (!Wr || Y.length < n - 1)
        return Y.push([A, I]), this.size = ++B.size, this;
      B = this.__data__ = new Tn(Y);
    }
    return B.set(A, I), this.size = B.size, this;
  }
  Vt.prototype.clear = Ob, Vt.prototype.delete = Ib, Vt.prototype.get = Db, Vt.prototype.has = Fb, Vt.prototype.set = Pb;
  function kb(A, I) {
    var B = fa(A), Y = !B && Kb(A), fe = !B && !Y && Lo(A), te = !B && !Y && !fe && Dp(A), ge = B || Y || fe || te, $e = ge ? qe(A.length, String) : [], Pe = $e.length;
    for (var de in A)
      Et.call(A, de) && !(ge && // Safari 9 has enumerable `arguments.length` in strict mode.
      (de == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      fe && (de == "offset" || de == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      te && (de == "buffer" || de == "byteLength" || de == "byteOffset") || // Skip index properties.
      Wb(de, Pe))) && $e.push(de);
    return $e;
  }
  function ua(A, I) {
    for (var B = A.length; B--; )
      if (Rp(A[B][0], I))
        return B;
    return -1;
  }
  function Lb(A, I, B) {
    var Y = I(A);
    return fa(A) ? Y : pt(Y, B(A));
  }
  function Vr(A) {
    return A == null ? A === void 0 ? C : x : Sn && Sn in Object(A) ? zb(A) : Xb(A);
  }
  function Sp(A) {
    return Yr(A) && Vr(A) == c;
  }
  function Ap(A, I, B, Y, fe) {
    return A === I ? !0 : A == null || I == null || !Yr(A) && !Yr(I) ? A !== A && I !== I : Nb(A, I, B, Y, Ap, fe);
  }
  function Nb(A, I, B, Y, fe, te) {
    var ge = fa(A), $e = fa(I), Pe = ge ? o : Yt(A), de = $e ? o : Yt(I);
    Pe = Pe == c ? y : Pe, de = de == c ? y : de;
    var rt = Pe == y, ft = de == y, Be = Pe == de;
    if (Be && Lo(A)) {
      if (!Lo(I))
        return !1;
      ge = !0, rt = !1;
    }
    if (Be && !rt)
      return te || (te = new Vt()), ge || Dp(A) ? Tp(A, I, B, Y, fe, te) : Mb(A, I, Pe, B, Y, fe, te);
    if (!(B & i)) {
      var it = rt && Et.call(A, "__wrapped__"), at = ft && Et.call(I, "__wrapped__");
      if (it || at) {
        var Xt = it ? A.value() : A, Pt = at ? I.value() : I;
        return te || (te = new Vt()), fe(Xt, Pt, B, Y, te);
      }
    }
    return Be ? (te || (te = new Vt()), qb(A, I, B, Y, fe, te)) : !1;
  }
  function Ub(A) {
    if (!Ip(A) || Vb(A))
      return !1;
    var I = $p(A) ? ib : K;
    return I.test(Cn(A));
  }
  function Bb(A) {
    return Yr(A) && Op(A.length) && !!q[Vr(A)];
  }
  function jb(A) {
    if (!Yb(A))
      return ob(A);
    var I = [];
    for (var B in Object(A))
      Et.call(A, B) && B != "constructor" && I.push(B);
    return I;
  }
  function Tp(A, I, B, Y, fe, te) {
    var ge = B & i, $e = A.length, Pe = I.length;
    if ($e != Pe && !(ge && Pe > $e))
      return !1;
    var de = te.get(A);
    if (de && te.get(I))
      return de == I;
    var rt = -1, ft = !0, Be = B & a ? new la() : void 0;
    for (te.set(A, I), te.set(I, A); ++rt < $e; ) {
      var it = A[rt], at = I[rt];
      if (Y)
        var Xt = ge ? Y(at, it, rt, I, A, te) : Y(it, at, rt, A, I, te);
      if (Xt !== void 0) {
        if (Xt)
          continue;
        ft = !1;
        break;
      }
      if (Be) {
        if (!Se(I, function(Pt, Rn) {
          if (!Ht(Be, Rn) && (it === Pt || fe(it, Pt, B, Y, te)))
            return Be.push(Rn);
        })) {
          ft = !1;
          break;
        }
      } else if (!(it === at || fe(it, at, B, Y, te))) {
        ft = !1;
        break;
      }
    }
    return te.delete(A), te.delete(I), ft;
  }
  function Mb(A, I, B, Y, fe, te, ge) {
    switch (B) {
      case J:
        if (A.byteLength != I.byteLength || A.byteOffset != I.byteOffset)
          return !1;
        A = A.buffer, I = I.buffer;
      case M:
        return !(A.byteLength != I.byteLength || !te(new yp(A), new yp(I)));
      case l:
      case p:
      case b:
        return Rp(+A, +I);
      case f:
        return A.name == I.name && A.message == I.message;
      case D:
      case z:
        return A == I + "";
      case h:
        var $e = Wt;
      case U:
        var Pe = Y & i;
        if ($e || ($e = Gt), A.size != I.size && !Pe)
          return !1;
        var de = ge.get(A);
        if (de)
          return de == I;
        Y |= a, ge.set(A, I);
        var rt = Tp($e(A), $e(I), Y, fe, te, ge);
        return ge.delete(A), rt;
      case ee:
        if (ko)
          return ko.call(A) == ko.call(I);
    }
    return !1;
  }
  function qb(A, I, B, Y, fe, te) {
    var ge = B & i, $e = Cp(A), Pe = $e.length, de = Cp(I), rt = de.length;
    if (Pe != rt && !ge)
      return !1;
    for (var ft = Pe; ft--; ) {
      var Be = $e[ft];
      if (!(ge ? Be in I : Et.call(I, Be)))
        return !1;
    }
    var it = te.get(A);
    if (it && te.get(I))
      return it == I;
    var at = !0;
    te.set(A, I), te.set(I, A);
    for (var Xt = ge; ++ft < Pe; ) {
      Be = $e[ft];
      var Pt = A[Be], Rn = I[Be];
      if (Y)
        var Fp = ge ? Y(Rn, Pt, Be, I, A, te) : Y(Pt, Rn, Be, A, I, te);
      if (!(Fp === void 0 ? Pt === Rn || fe(Pt, Rn, B, Y, te) : Fp)) {
        at = !1;
        break;
      }
      Xt || (Xt = Be == "constructor");
    }
    if (at && !Xt) {
      var da = A.constructor, ha = I.constructor;
      da != ha && "constructor" in A && "constructor" in I && !(typeof da == "function" && da instanceof da && typeof ha == "function" && ha instanceof ha) && (at = !1);
    }
    return te.delete(A), te.delete(I), at;
  }
  function Cp(A) {
    return Lb(A, Qb, Hb);
  }
  function pa(A, I) {
    var B = A.__data__;
    return Gb(I) ? B[typeof I == "string" ? "string" : "hash"] : B.map;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  function tr(A, I) {
    var B = Dt(A, I);
    return Ub(B) ? B : void 0;
  }
<<<<<<< HEAD
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
=======
  function zb(A) {
    var I = Et.call(A, Sn), B = A[Sn];
    try {
      A[Sn] = void 0;
      var Y = !0;
    } catch {
    }
    var fe = bp.call(A);
    return Y && (I ? A[Sn] = B : delete A[Sn]), fe;
  }
  var Hb = Ep ? function(A) {
    return A == null ? [] : (A = Object(A), Te(Ep(A), function(I) {
      return wp.call(A, I);
    }));
  } : ex, Yt = Vr;
  (Io && Yt(new Io(new ArrayBuffer(1))) != J || Wr && Yt(new Wr()) != h || Do && Yt(Do.resolve()) != E || Fo && Yt(new Fo()) != U || Po && Yt(new Po()) != H) && (Yt = function(A) {
    var I = Vr(A), B = I == y ? A.constructor : void 0, Y = B ? Cn(B) : "";
    if (Y)
      switch (Y) {
        case cb:
          return J;
        case lb:
          return h;
        case ub:
          return E;
        case pb:
          return U;
        case fb:
          return H;
      }
    return I;
  });
  function Wb(A, I) {
    return I = I ?? s, !!I && (typeof A == "number" || Z.test(A)) && A > -1 && A % 1 == 0 && A < I;
  }
  function Gb(A) {
    var I = typeof A;
    return I == "string" || I == "number" || I == "symbol" || I == "boolean" ? A !== "__proto__" : A === null;
  }
  function Vb(A) {
    return !!gp && gp in A;
  }
  function Yb(A) {
    var I = A && A.constructor, B = typeof I == "function" && I.prototype || oa;
    return A === B;
  }
  function Xb(A) {
    return bp.call(A);
  }
  function Cn(A) {
    if (A != null) {
      try {
        return vp.call(A);
      } catch {
      }
      try {
        return A + "";
      } catch {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    }
    return "";
  }
<<<<<<< HEAD
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  var isBuffer2 = nativeIsBuffer || stubFalse;
  function isEqual2(value, other) {
    return baseIsEqual(value, other);
  }
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = isEqual2;
})(lodash_isequal, lodash_isequal.exports);
var lodash_isequalExports = lodash_isequal.exports;
Object.defineProperty(DownloadedUpdateHelper$1, "__esModule", { value: true });
DownloadedUpdateHelper$1.DownloadedUpdateHelper = void 0;
DownloadedUpdateHelper$1.createTempUpdateFile = createTempUpdateFile;
const crypto_1$2 = require$$0$4;
const fs_1$4 = fs$w;
const isEqual = lodash_isequalExports;
const fs_extra_1$6 = lib;
const path$8 = require$$1$4;
class DownloadedUpdateHelper {
  constructor(cacheDir) {
    this.cacheDir = cacheDir;
    this._file = null;
    this._packageFile = null;
    this.versionInfo = null;
    this.fileInfo = null;
    this._downloadedFileInfo = null;
=======
  function Rp(A, I) {
    return A === I || A !== A && I !== I;
  }
  var Kb = Sp(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Sp : function(A) {
    return Yr(A) && Et.call(A, "callee") && !wp.call(A, "callee");
  }, fa = Array.isArray;
  function Jb(A) {
    return A != null && Op(A.length) && !$p(A);
  }
  var Lo = sb || tx;
  function Zb(A, I) {
    return Ap(A, I);
  }
  function $p(A) {
    if (!Ip(A))
      return !1;
    var I = Vr(A);
    return I == m || I == g || I == u || I == S;
  }
  function Op(A) {
    return typeof A == "number" && A > -1 && A % 1 == 0 && A <= s;
  }
  function Ip(A) {
    var I = typeof A;
    return A != null && (I == "object" || I == "function");
  }
  function Yr(A) {
    return A != null && typeof A == "object";
  }
  var Dp = ve ? er(ve) : Bb;
  function Qb(A) {
    return Jb(A) ? kb(A) : jb(A);
  }
  function ex() {
    return [];
  }
  function tx() {
    return !1;
  }
  e.exports = Zb;
})(Ts, Ts.exports);
var xR = Ts.exports;
Object.defineProperty(ra, "__esModule", { value: !0 });
ra.DownloadedUpdateHelper = void 0;
ra.createTempUpdateFile = SR;
const yR = Ur, wR = se, Bh = xR, In = yn, hi = ne;
class ER {
  constructor(t) {
    this.cacheDir = t, this._file = null, this._packageFile = null, this.versionInfo = null, this.fileInfo = null, this._downloadedFileInfo = null;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  get downloadedFileInfo() {
    return this._downloadedFileInfo;
  }
  get file() {
    return this._file;
  }
  get packageFile() {
    return this._packageFile;
  }
  get cacheDirForPendingUpdate() {
<<<<<<< HEAD
    return path$8.join(this.cacheDir, "pending");
  }
  async validateDownloadedPath(updateFile, updateInfo, fileInfo, logger) {
    if (this.versionInfo != null && this.file === updateFile && this.fileInfo != null) {
      if (isEqual(this.versionInfo, updateInfo) && isEqual(this.fileInfo.info, fileInfo.info) && await (0, fs_extra_1$6.pathExists)(updateFile)) {
        return updateFile;
      } else {
        return null;
      }
    }
    const cachedUpdateFile = await this.getValidCachedUpdateFile(fileInfo, logger);
    if (cachedUpdateFile === null) {
      return null;
    }
    logger.info(`Update has already been downloaded to ${updateFile}).`);
    this._file = cachedUpdateFile;
    return cachedUpdateFile;
  }
  async setDownloadedFile(downloadedFile, packageFile, versionInfo, fileInfo, updateFileName, isSaveCache) {
    this._file = downloadedFile;
    this._packageFile = packageFile;
    this.versionInfo = versionInfo;
    this.fileInfo = fileInfo;
    this._downloadedFileInfo = {
      fileName: updateFileName,
      sha512: fileInfo.info.sha512,
      isAdminRightsRequired: fileInfo.info.isAdminRightsRequired === true
    };
    if (isSaveCache) {
      await (0, fs_extra_1$6.outputJson)(this.getUpdateInfoFile(), this._downloadedFileInfo);
    }
=======
    return hi.join(this.cacheDir, "pending");
  }
  async validateDownloadedPath(t, n, r, i) {
    if (this.versionInfo != null && this.file === t && this.fileInfo != null)
      return Bh(this.versionInfo, n) && Bh(this.fileInfo.info, r.info) && await (0, In.pathExists)(t) ? t : null;
    const a = await this.getValidCachedUpdateFile(r, i);
    return a === null ? null : (i.info(`Update has already been downloaded to ${t}).`), this._file = a, a);
  }
  async setDownloadedFile(t, n, r, i, a, s) {
    this._file = t, this._packageFile = n, this.versionInfo = r, this.fileInfo = i, this._downloadedFileInfo = {
      fileName: a,
      sha512: i.info.sha512,
      isAdminRightsRequired: i.info.isAdminRightsRequired === !0
    }, s && await (0, In.outputJson)(this.getUpdateInfoFile(), this._downloadedFileInfo);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  async clear() {
    this._file = null;
    this._packageFile = null;
    this.versionInfo = null;
    this.fileInfo = null;
    await this.cleanCacheDirForPendingUpdate();
  }
  async cleanCacheDirForPendingUpdate() {
    try {
<<<<<<< HEAD
      await (0, fs_extra_1$6.emptyDir)(this.cacheDirForPendingUpdate);
    } catch (_ignore) {
=======
      await (0, In.emptyDir)(this.cacheDirForPendingUpdate);
    } catch {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
  }
  /**
   * Returns "update-info.json" which is created in the update cache directory's "pending" subfolder after the first update is downloaded.  If the update file does not exist then the cache is cleared and recreated.  If the update file exists then its properties are validated.
   * @param fileInfo
   * @param logger
   */
<<<<<<< HEAD
  async getValidCachedUpdateFile(fileInfo, logger) {
    const updateInfoFilePath = this.getUpdateInfoFile();
    const doesUpdateInfoFileExist = await (0, fs_extra_1$6.pathExists)(updateInfoFilePath);
    if (!doesUpdateInfoFileExist) {
      return null;
    }
    let cachedInfo;
    try {
      cachedInfo = await (0, fs_extra_1$6.readJson)(updateInfoFilePath);
    } catch (error2) {
      let message = `No cached update info available`;
      if (error2.code !== "ENOENT") {
        await this.cleanCacheDirForPendingUpdate();
        message += ` (error on read: ${error2.message})`;
      }
      logger.info(message);
      return null;
    }
    const isCachedInfoFileNameValid = (cachedInfo === null || cachedInfo === void 0 ? void 0 : cachedInfo.fileName) !== null;
    if (!isCachedInfoFileNameValid) {
      logger.warn(`Cached update info is corrupted: no fileName, directory for cached update will be cleaned`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    if (fileInfo.info.sha512 !== cachedInfo.sha512) {
      logger.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${cachedInfo.sha512}, expected: ${fileInfo.info.sha512}. Directory for cached update will be cleaned`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    const updateFile = path$8.join(this.cacheDirForPendingUpdate, cachedInfo.fileName);
    if (!await (0, fs_extra_1$6.pathExists)(updateFile)) {
      logger.info("Cached update file doesn't exist");
      return null;
    }
    const sha512 = await hashFile(updateFile);
    if (fileInfo.info.sha512 !== sha512) {
      logger.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    this._downloadedFileInfo = cachedInfo;
    return updateFile;
  }
  getUpdateInfoFile() {
    return path$8.join(this.cacheDirForPendingUpdate, "update-info.json");
  }
}
DownloadedUpdateHelper$1.DownloadedUpdateHelper = DownloadedUpdateHelper;
function hashFile(file2, algorithm = "sha512", encoding = "base64", options) {
  return new Promise((resolve, reject) => {
    const hash = (0, crypto_1$2.createHash)(algorithm);
    hash.on("error", reject).setEncoding(encoding);
    (0, fs_1$4.createReadStream)(file2, {
      ...options,
      highWaterMark: 1024 * 1024
      /* better to use more memory but hash faster */
    }).on("error", reject).on("end", () => {
      hash.end();
      resolve(hash.read());
    }).pipe(hash, { end: false });
  });
}
async function createTempUpdateFile(name, cacheDir, log) {
  let nameCounter = 0;
  let result = path$8.join(cacheDir, name);
  for (let i = 0; i < 3; i++) {
    try {
      await (0, fs_extra_1$6.unlink)(result);
      return result;
    } catch (e) {
      if (e.code === "ENOENT") {
        return result;
      }
      log.warn(`Error on remove temp update file: ${e}`);
      result = path$8.join(cacheDir, `${nameCounter++}-${name}`);
=======
  async getValidCachedUpdateFile(t, n) {
    const r = this.getUpdateInfoFile();
    if (!await (0, In.pathExists)(r))
      return null;
    let a;
    try {
      a = await (0, In.readJson)(r);
    } catch (u) {
      let l = "No cached update info available";
      return u.code !== "ENOENT" && (await this.cleanCacheDirForPendingUpdate(), l += ` (error on read: ${u.message})`), n.info(l), null;
    }
    if (!((a == null ? void 0 : a.fileName) !== null))
      return n.warn("Cached update info is corrupted: no fileName, directory for cached update will be cleaned"), await this.cleanCacheDirForPendingUpdate(), null;
    if (t.info.sha512 !== a.sha512)
      return n.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${a.sha512}, expected: ${t.info.sha512}. Directory for cached update will be cleaned`), await this.cleanCacheDirForPendingUpdate(), null;
    const c = hi.join(this.cacheDirForPendingUpdate, a.fileName);
    if (!await (0, In.pathExists)(c))
      return n.info("Cached update file doesn't exist"), null;
    const o = await _R(c);
    return t.info.sha512 !== o ? (n.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${o}, expected: ${t.info.sha512}`), await this.cleanCacheDirForPendingUpdate(), null) : (this._downloadedFileInfo = a, c);
  }
  getUpdateInfoFile() {
    return hi.join(this.cacheDirForPendingUpdate, "update-info.json");
  }
}
ra.DownloadedUpdateHelper = ER;
function _R(e, t = "sha512", n = "base64", r) {
  return new Promise((i, a) => {
    const s = (0, yR.createHash)(t);
    s.on("error", a).setEncoding(n), (0, wR.createReadStream)(e, {
      ...r,
      highWaterMark: 1024 * 1024
      /* better to use more memory but hash faster */
    }).on("error", a).on("end", () => {
      s.end(), i(s.read());
    }).pipe(s, { end: !1 });
  });
}
async function SR(e, t, n) {
  let r = 0, i = hi.join(t, e);
  for (let a = 0; a < 3; a++)
    try {
      return await (0, In.unlink)(i), i;
    } catch (s) {
      if (s.code === "ENOENT")
        return i;
      n.warn(`Error on remove temp update file: ${s}`), i = hi.join(t, `${r++}-${e}`);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
  }
  return result;
}
<<<<<<< HEAD
var ElectronAppAdapter$1 = {};
var AppAdapter = {};
Object.defineProperty(AppAdapter, "__esModule", { value: true });
AppAdapter.getAppCacheDir = getAppCacheDir;
const path$7 = require$$1$4;
const os_1$1 = require$$2$2;
function getAppCacheDir() {
  const homedir = (0, os_1$1.homedir)();
  let result;
  if (process.platform === "win32") {
    result = process.env["LOCALAPPDATA"] || path$7.join(homedir, "AppData", "Local");
  } else if (process.platform === "darwin") {
    result = path$7.join(homedir, "Library", "Caches");
  } else {
    result = process.env["XDG_CACHE_HOME"] || path$7.join(homedir, ".cache");
  }
  return result;
}
Object.defineProperty(ElectronAppAdapter$1, "__esModule", { value: true });
ElectronAppAdapter$1.ElectronAppAdapter = void 0;
const path$6 = require$$1$4;
const AppAdapter_1 = AppAdapter;
class ElectronAppAdapter {
  constructor(app2 = require$$1$8.app) {
    this.app = app2;
=======
var Eo = {}, dp = {};
Object.defineProperty(dp, "__esModule", { value: !0 });
dp.getAppCacheDir = TR;
const rl = ne, AR = $s;
function TR() {
  const e = (0, AR.homedir)();
  let t;
  return process.platform === "win32" ? t = process.env.LOCALAPPDATA || rl.join(e, "AppData", "Local") : process.platform === "darwin" ? t = rl.join(e, "Library", "Caches") : t = process.env.XDG_CACHE_HOME || rl.join(e, ".cache"), t;
}
Object.defineProperty(Eo, "__esModule", { value: !0 });
Eo.ElectronAppAdapter = void 0;
const jh = ne, CR = dp;
class RR {
  constructor(t = zn.app) {
    this.app = t;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  whenReady() {
    return this.app.whenReady();
  }
  get version() {
    return this.app.getVersion();
  }
  get name() {
    return this.app.getName();
  }
  get isPackaged() {
    return this.app.isPackaged === true;
  }
  get appUpdateConfigPath() {
<<<<<<< HEAD
    return this.isPackaged ? path$6.join(process.resourcesPath, "app-update.yml") : path$6.join(this.app.getAppPath(), "dev-app-update.yml");
=======
    return this.isPackaged ? jh.join(process.resourcesPath, "app-update.yml") : jh.join(this.app.getAppPath(), "dev-app-update.yml");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  get userDataPath() {
    return this.app.getPath("userData");
  }
  get baseCachePath() {
<<<<<<< HEAD
    return (0, AppAdapter_1.getAppCacheDir)();
=======
    return (0, CR.getAppCacheDir)();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  quit() {
    this.app.quit();
  }
  relaunch() {
    this.app.relaunch();
  }
  onQuit(handler) {
    this.app.once("quit", (_, exitCode) => handler(exitCode));
  }
}
<<<<<<< HEAD
ElectronAppAdapter$1.ElectronAppAdapter = ElectronAppAdapter;
var electronHttpExecutor = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ElectronHttpExecutor = exports.NET_SESSION_NAME = void 0;
  exports.getNetSession = getNetSession;
  const builder_util_runtime_12 = out;
  exports.NET_SESSION_NAME = "electron-updater";
  function getNetSession() {
    return require$$1$8.session.fromPartition(exports.NET_SESSION_NAME, {
      cache: false
=======
Eo.ElectronAppAdapter = RR;
var zg = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ElectronHttpExecutor = e.NET_SESSION_NAME = void 0, e.getNetSession = n;
  const t = Fe;
  e.NET_SESSION_NAME = "electron-updater";
  function n() {
    return zn.session.fromPartition(e.NET_SESSION_NAME, {
      cache: !1
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    });
  }
  class ElectronHttpExecutor extends builder_util_runtime_12.HttpExecutor {
    constructor(proxyLoginCallback) {
      super();
      this.proxyLoginCallback = proxyLoginCallback;
      this.cachedSession = null;
    }
<<<<<<< HEAD
    async download(url2, destination, options) {
      return await options.cancellationToken.createPromise((resolve, reject, onCancel) => {
        const requestOptions = {
          headers: options.headers || void 0,
          redirect: "manual"
        };
        (0, builder_util_runtime_12.configureRequestUrl)(url2, requestOptions);
        (0, builder_util_runtime_12.configureRequestOptions)(requestOptions);
        this.doDownload(requestOptions, {
          destination,
          options,
          onCancel,
          callback: (error2) => {
            if (error2 == null) {
              resolve(destination);
            } else {
              reject(error2);
            }
=======
    async download(a, s, c) {
      return await c.cancellationToken.createPromise((o, u, l) => {
        const p = {
          headers: c.headers || void 0,
          redirect: "manual"
        };
        (0, t.configureRequestUrl)(a, p), (0, t.configureRequestOptions)(p), this.doDownload(p, {
          destination: s,
          options: c,
          onCancel: l,
          callback: (f) => {
            f == null ? o(s) : u(f);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          },
          responseHandler: null
        }, 0);
      });
    }
<<<<<<< HEAD
    createRequest(options, callback) {
      if (options.headers && options.headers.Host) {
        options.host = options.headers.Host;
        delete options.headers.Host;
      }
      if (this.cachedSession == null) {
        this.cachedSession = getNetSession();
      }
      const request = require$$1$8.net.request({
        ...options,
        session: this.cachedSession
      });
      request.on("response", callback);
      if (this.proxyLoginCallback != null) {
        request.on("login", this.proxyLoginCallback);
      }
      return request;
    }
    addRedirectHandlers(request, options, reject, redirectCount, handler) {
      request.on("redirect", (statusCode, method, redirectUrl) => {
        request.abort();
        if (redirectCount > this.maxRedirects) {
          reject(this.createMaxRedirectError());
        } else {
          handler(builder_util_runtime_12.HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));
        }
      });
    }
  }
  exports.ElectronHttpExecutor = ElectronHttpExecutor;
})(electronHttpExecutor);
var GenericProvider$1 = {};
var util = {};
var symbolTag = "[object Symbol]";
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var Symbol$1 = root.Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toString4(value) {
  return value == null ? "" : baseToString(value);
}
function escapeRegExp$1(string) {
  string = toString4(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
}
var lodash_escaperegexp = escapeRegExp$1;
Object.defineProperty(util, "__esModule", { value: true });
util.newBaseUrl = newBaseUrl;
util.newUrlFromBase = newUrlFromBase;
util.getChannelFilename = getChannelFilename;
util.blockmapFiles = blockmapFiles;
const url_1$4 = require$$0$3;
const escapeRegExp = lodash_escaperegexp;
function newBaseUrl(url2) {
  const result = new url_1$4.URL(url2);
  if (!result.pathname.endsWith("/")) {
    result.pathname += "/";
  }
  return result;
}
function newUrlFromBase(pathname, baseUrl, addRandomQueryToAvoidCaching = false) {
  const result = new url_1$4.URL(pathname, baseUrl);
  const search = baseUrl.search;
  if (search != null && search.length !== 0) {
    result.search = search;
  } else if (addRandomQueryToAvoidCaching) {
    result.search = `noCache=${Date.now().toString(32)}`;
  }
  return result;
}
function getChannelFilename(channel) {
  return `${channel}.yml`;
}
function blockmapFiles(baseUrl, oldVersion, newVersion) {
  const newBlockMapUrl = newUrlFromBase(`${baseUrl.pathname}.blockmap`, baseUrl);
  const oldBlockMapUrl = newUrlFromBase(`${baseUrl.pathname.replace(new RegExp(escapeRegExp(newVersion), "g"), oldVersion)}.blockmap`, baseUrl);
  return [oldBlockMapUrl, newBlockMapUrl];
}
var Provider$1 = {};
Object.defineProperty(Provider$1, "__esModule", { value: true });
Provider$1.Provider = void 0;
Provider$1.findFile = findFile;
Provider$1.parseUpdateInfo = parseUpdateInfo;
Provider$1.getFileList = getFileList;
Provider$1.resolveFiles = resolveFiles;
const builder_util_runtime_1$e = out;
const js_yaml_1$2 = jsYaml;
const util_1$6 = util;
class Provider {
  constructor(runtimeOptions) {
    this.runtimeOptions = runtimeOptions;
    this.requestHeaders = null;
    this.executor = runtimeOptions.executor;
=======
    createRequest(a, s) {
      a.headers && a.headers.Host && (a.host = a.headers.Host, delete a.headers.Host), this.cachedSession == null && (this.cachedSession = n());
      const c = zn.net.request({
        ...a,
        session: this.cachedSession
      });
      return c.on("response", s), this.proxyLoginCallback != null && c.on("login", this.proxyLoginCallback), c;
    }
    addRedirectHandlers(a, s, c, o, u) {
      a.on("redirect", (l, p, f) => {
        a.abort(), o > this.maxRedirects ? c(this.createMaxRedirectError()) : u(t.HttpExecutor.prepareRedirectUrlOptions(f, s));
      });
    }
  }
  e.ElectronHttpExecutor = r;
})(zg);
var ia = {}, ut = {}, $R = "[object Symbol]", Hg = /[\\^$.*+?()[\]{}|]/g, OR = RegExp(Hg.source), IR = typeof Ae == "object" && Ae && Ae.Object === Object && Ae, DR = typeof self == "object" && self && self.Object === Object && self, FR = IR || DR || Function("return this")(), PR = Object.prototype, kR = PR.toString, Mh = FR.Symbol, qh = Mh ? Mh.prototype : void 0, zh = qh ? qh.toString : void 0;
function LR(e) {
  if (typeof e == "string")
    return e;
  if (UR(e))
    return zh ? zh.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function NR(e) {
  return !!e && typeof e == "object";
}
function UR(e) {
  return typeof e == "symbol" || NR(e) && kR.call(e) == $R;
}
function BR(e) {
  return e == null ? "" : LR(e);
}
function jR(e) {
  return e = BR(e), e && OR.test(e) ? e.replace(Hg, "\\$&") : e;
}
var MR = jR;
Object.defineProperty(ut, "__esModule", { value: !0 });
ut.newBaseUrl = zR;
ut.newUrlFromBase = Vl;
ut.getChannelFilename = HR;
ut.blockmapFiles = WR;
const Wg = $t, qR = MR;
function zR(e) {
  const t = new Wg.URL(e);
  return t.pathname.endsWith("/") || (t.pathname += "/"), t;
}
function Vl(e, t, n = !1) {
  const r = new Wg.URL(e, t), i = t.search;
  return i != null && i.length !== 0 ? r.search = i : n && (r.search = `noCache=${Date.now().toString(32)}`), r;
}
function HR(e) {
  return `${e}.yml`;
}
function WR(e, t, n) {
  const r = Vl(`${e.pathname}.blockmap`, e);
  return [Vl(`${e.pathname.replace(new RegExp(qR(n), "g"), t)}.blockmap`, e), r];
}
var Re = {};
Object.defineProperty(Re, "__esModule", { value: !0 });
Re.Provider = void 0;
Re.findFile = YR;
Re.parseUpdateInfo = XR;
Re.getFileList = Gg;
Re.resolveFiles = KR;
const mn = Fe, GR = Ue, Hh = ut;
class VR {
  constructor(t) {
    this.runtimeOptions = t, this.requestHeaders = null, this.executor = t.executor;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  get isUseMultipleRangeRequest() {
    return this.runtimeOptions.isUseMultipleRangeRequest !== false;
  }
  getChannelFilePrefix() {
    if (this.runtimeOptions.platform === "linux") {
      const arch = process.env["TEST_UPDATER_ARCH"] || process.arch;
      const archSuffix = arch === "x64" ? "" : `-${arch}`;
      return "-linux" + archSuffix;
    } else {
      return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
    }
  }
  // due to historical reasons for windows we use channel name without platform specifier
  getDefaultChannelName() {
    return this.getCustomChannelName("latest");
  }
  getCustomChannelName(channel) {
    return `${channel}${this.getChannelFilePrefix()}`;
  }
  get fileExtraDownloadHeaders() {
    return null;
  }
  setRequestHeaders(value) {
    this.requestHeaders = value;
  }
  /**
   * Method to perform API request only to resolve update info, but not to download update.
   */
  httpRequest(url2, headers2, cancellationToken) {
    return this.executor.request(this.createRequestOptions(url2, headers2), cancellationToken);
  }
<<<<<<< HEAD
  createRequestOptions(url2, headers2) {
    const result = {};
    if (this.requestHeaders == null) {
      if (headers2 != null) {
        result.headers = headers2;
      }
    } else {
      result.headers = headers2 == null ? this.requestHeaders : { ...this.requestHeaders, ...headers2 };
    }
    (0, builder_util_runtime_1$e.configureRequestUrl)(url2, result);
    return result;
  }
}
Provider$1.Provider = Provider;
function findFile(files, extension, not) {
  if (files.length === 0) {
    throw (0, builder_util_runtime_1$e.newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
  }
  const result = files.find((it) => it.url.pathname.toLowerCase().endsWith(`.${extension}`));
  if (result != null) {
    return result;
  } else if (not == null) {
    return files[0];
  } else {
    return files.find((fileInfo) => !not.some((ext) => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));
  }
}
function parseUpdateInfo(rawData, channelFile, channelFileUrl) {
  if (rawData == null) {
    throw (0, builder_util_runtime_1$e.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  }
  let result;
  try {
    result = (0, js_yaml_1$2.load)(rawData);
  } catch (e) {
    throw (0, builder_util_runtime_1$e.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
=======
  createRequestOptions(t, n) {
    const r = {};
    return this.requestHeaders == null ? n != null && (r.headers = n) : r.headers = n == null ? this.requestHeaders : { ...this.requestHeaders, ...n }, (0, mn.configureRequestUrl)(t, r), r;
  }
}
Re.Provider = VR;
function YR(e, t, n) {
  if (e.length === 0)
    throw (0, mn.newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
  const r = e.find((i) => i.url.pathname.toLowerCase().endsWith(`.${t}`));
  return r ?? (n == null ? e[0] : e.find((i) => !n.some((a) => i.url.pathname.toLowerCase().endsWith(`.${a}`))));
}
function XR(e, t, n) {
  if (e == null)
    throw (0, mn.newError)(`Cannot parse update info from ${t} in the latest release artifacts (${n}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  let r;
  try {
    r = (0, GR.load)(e);
  } catch (i) {
    throw (0, mn.newError)(`Cannot parse update info from ${t} in the latest release artifacts (${n}): ${i.stack || i.message}, rawData: ${e}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  return result;
}
<<<<<<< HEAD
function getFileList(updateInfo) {
  const files = updateInfo.files;
  if (files != null && files.length > 0) {
    return files;
  }
  if (updateInfo.path != null) {
=======
function Gg(e) {
  const t = e.files;
  if (t != null && t.length > 0)
    return t;
  if (e.path != null)
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    return [
      {
        url: updateInfo.path,
        sha2: updateInfo.sha2,
        sha512: updateInfo.sha512
      }
    ];
<<<<<<< HEAD
  } else {
    throw (0, builder_util_runtime_1$e.newError)(`No files provided: ${(0, builder_util_runtime_1$e.safeStringifyJson)(updateInfo)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
  }
}
function resolveFiles(updateInfo, baseUrl, pathTransformer = (p) => p) {
  const files = getFileList(updateInfo);
  const result = files.map((fileInfo) => {
    if (fileInfo.sha2 == null && fileInfo.sha512 == null) {
      throw (0, builder_util_runtime_1$e.newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, builder_util_runtime_1$e.safeStringifyJson)(fileInfo)}`, "ERR_UPDATER_NO_CHECKSUM");
    }
    return {
      url: (0, util_1$6.newUrlFromBase)(pathTransformer(fileInfo.url), baseUrl),
      info: fileInfo
    };
  });
  const packages = updateInfo.packages;
  const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;
  if (packageInfo != null) {
    result[0].packageInfo = {
      ...packageInfo,
      path: (0, util_1$6.newUrlFromBase)(pathTransformer(packageInfo.path), baseUrl).href
    };
  }
  return result;
}
Object.defineProperty(GenericProvider$1, "__esModule", { value: true });
GenericProvider$1.GenericProvider = void 0;
const builder_util_runtime_1$d = out;
const util_1$5 = util;
const Provider_1$a = Provider$1;
class GenericProvider extends Provider_1$a.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super(runtimeOptions);
    this.configuration = configuration;
    this.updater = updater;
    this.baseUrl = (0, util_1$5.newBaseUrl)(this.configuration.url);
=======
  throw (0, mn.newError)(`No files provided: ${(0, mn.safeStringifyJson)(e)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
}
function KR(e, t, n = (r) => r) {
  const i = Gg(e).map((c) => {
    if (c.sha2 == null && c.sha512 == null)
      throw (0, mn.newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, mn.safeStringifyJson)(c)}`, "ERR_UPDATER_NO_CHECKSUM");
    return {
      url: (0, Hh.newUrlFromBase)(n(c.url), t),
      info: c
    };
  }), a = e.packages, s = a == null ? null : a[process.arch] || a.ia32;
  return s != null && (i[0].packageInfo = {
    ...s,
    path: (0, Hh.newUrlFromBase)(n(s.path), t).href
  }), i;
}
Object.defineProperty(ia, "__esModule", { value: !0 });
ia.GenericProvider = void 0;
const Wh = Fe, il = ut, al = Re;
class JR extends al.Provider {
  constructor(t, n, r) {
    super(r), this.configuration = t, this.updater = n, this.baseUrl = (0, il.newBaseUrl)(this.configuration.url);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  get channel() {
    const result = this.updater.channel || this.configuration.channel;
    return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);
  }
  async getLatestVersion() {
<<<<<<< HEAD
    const channelFile = (0, util_1$5.getChannelFilename)(this.channel);
    const channelUrl = (0, util_1$5.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
    for (let attemptNumber = 0; ; attemptNumber++) {
      try {
        return (0, Provider_1$a.parseUpdateInfo)(await this.httpRequest(channelUrl), channelFile, channelUrl);
      } catch (e) {
        if (e instanceof builder_util_runtime_1$d.HttpError && e.statusCode === 404) {
          throw (0, builder_util_runtime_1$d.newError)(`Cannot find channel "${channelFile}" update info: ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        } else if (e.code === "ECONNREFUSED") {
          if (attemptNumber < 3) {
            await new Promise((resolve, reject) => {
              try {
                setTimeout(resolve, 1e3 * attemptNumber);
              } catch (e2) {
                reject(e2);
              }
            });
            continue;
          }
=======
    const t = (0, il.getChannelFilename)(this.channel), n = (0, il.newUrlFromBase)(t, this.baseUrl, this.updater.isAddNoCacheQuery);
    for (let r = 0; ; r++)
      try {
        return (0, al.parseUpdateInfo)(await this.httpRequest(n), t, n);
      } catch (i) {
        if (i instanceof Wh.HttpError && i.statusCode === 404)
          throw (0, Wh.newError)(`Cannot find channel "${t}" update info: ${i.stack || i.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        if (i.code === "ECONNREFUSED" && r < 3) {
          await new Promise((a, s) => {
            try {
              setTimeout(a, 1e3 * r);
            } catch (c) {
              s(c);
            }
          });
          continue;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        }
        throw e;
      }
    }
  }
<<<<<<< HEAD
  resolveFiles(updateInfo) {
    return (0, Provider_1$a.resolveFiles)(updateInfo, this.baseUrl);
  }
}
GenericProvider$1.GenericProvider = GenericProvider;
var providerFactory = {};
var BitbucketProvider$1 = {};
Object.defineProperty(BitbucketProvider$1, "__esModule", { value: true });
BitbucketProvider$1.BitbucketProvider = void 0;
const builder_util_runtime_1$c = out;
const util_1$4 = util;
const Provider_1$9 = Provider$1;
class BitbucketProvider extends Provider_1$9.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super({
      ...runtimeOptions,
      isUseMultipleRangeRequest: false
    });
    this.configuration = configuration;
    this.updater = updater;
    const { owner, slug } = configuration;
    this.baseUrl = (0, util_1$4.newBaseUrl)(`https://api.bitbucket.org/2.0/repositories/${owner}/${slug}/downloads`);
=======
  resolveFiles(t) {
    return (0, al.resolveFiles)(t, this.baseUrl);
  }
}
ia.GenericProvider = JR;
var _o = {}, So = {};
Object.defineProperty(So, "__esModule", { value: !0 });
So.BitbucketProvider = void 0;
const Gh = Fe, sl = ut, ol = Re;
class ZR extends ol.Provider {
  constructor(t, n, r) {
    super({
      ...r,
      isUseMultipleRangeRequest: !1
    }), this.configuration = t, this.updater = n;
    const { owner: i, slug: a } = t;
    this.baseUrl = (0, sl.newBaseUrl)(`https://api.bitbucket.org/2.0/repositories/${i}/${a}/downloads`);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "latest";
  }
  async getLatestVersion() {
<<<<<<< HEAD
    const cancellationToken = new builder_util_runtime_1$c.CancellationToken();
    const channelFile = (0, util_1$4.getChannelFilename)(this.getCustomChannelName(this.channel));
    const channelUrl = (0, util_1$4.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const updateInfo = await this.httpRequest(channelUrl, void 0, cancellationToken);
      return (0, Provider_1$9.parseUpdateInfo)(updateInfo, channelFile, channelUrl);
    } catch (e) {
      throw (0, builder_util_runtime_1$c.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(updateInfo) {
    return (0, Provider_1$9.resolveFiles)(updateInfo, this.baseUrl);
=======
    const t = new Gh.CancellationToken(), n = (0, sl.getChannelFilename)(this.getCustomChannelName(this.channel)), r = (0, sl.newUrlFromBase)(n, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const i = await this.httpRequest(r, void 0, t);
      return (0, ol.parseUpdateInfo)(i, n, r);
    } catch (i) {
      throw (0, Gh.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${i.stack || i.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(t) {
    return (0, ol.resolveFiles)(t, this.baseUrl);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  toString() {
    const { owner, slug } = this.configuration;
    return `Bitbucket (owner: ${owner}, slug: ${slug}, channel: ${this.channel})`;
  }
}
<<<<<<< HEAD
BitbucketProvider$1.BitbucketProvider = BitbucketProvider;
var GitHubProvider$1 = {};
Object.defineProperty(GitHubProvider$1, "__esModule", { value: true });
GitHubProvider$1.GitHubProvider = GitHubProvider$1.BaseGitHubProvider = void 0;
GitHubProvider$1.computeReleaseNotes = computeReleaseNotes;
const builder_util_runtime_1$b = out;
const semver = semver$1;
const url_1$3 = require$$0$3;
const util_1$3 = util;
const Provider_1$8 = Provider$1;
const hrefRegExp = /\/tag\/([^/]+)$/;
class BaseGitHubProvider extends Provider_1$8.Provider {
  constructor(options, defaultHost, runtimeOptions) {
=======
So.BitbucketProvider = ZR;
var vn = {};
Object.defineProperty(vn, "__esModule", { value: !0 });
vn.GitHubProvider = vn.BaseGitHubProvider = void 0;
vn.computeReleaseNotes = Yg;
const Ut = Fe, yr = qg, QR = $t, wr = ut, Yl = Re, cl = /\/tag\/([^/]+)$/;
class Vg extends Yl.Provider {
  constructor(t, n, r) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    super({
      ...runtimeOptions,
      /* because GitHib uses S3 */
<<<<<<< HEAD
      isUseMultipleRangeRequest: false
    });
    this.options = options;
    this.baseUrl = (0, util_1$3.newBaseUrl)((0, builder_util_runtime_1$b.githubUrl)(options, defaultHost));
    const apiHost = defaultHost === "github.com" ? "api.github.com" : defaultHost;
    this.baseApiUrl = (0, util_1$3.newBaseUrl)((0, builder_util_runtime_1$b.githubUrl)(options, apiHost));
=======
      isUseMultipleRangeRequest: !1
    }), this.options = t, this.baseUrl = (0, wr.newBaseUrl)((0, Ut.githubUrl)(t, n));
    const i = n === "github.com" ? "api.github.com" : n;
    this.baseApiUrl = (0, wr.newBaseUrl)((0, Ut.githubUrl)(t, i));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  computeGithubBasePath(result) {
    const host = this.options.host;
    return host && !["github.com", "api.github.com"].includes(host) ? `/api/v3${result}` : result;
  }
}
<<<<<<< HEAD
GitHubProvider$1.BaseGitHubProvider = BaseGitHubProvider;
class GitHubProvider extends BaseGitHubProvider {
  constructor(options, updater, runtimeOptions) {
    super(options, "github.com", runtimeOptions);
    this.options = options;
    this.updater = updater;
=======
vn.BaseGitHubProvider = Vg;
class e$ extends Vg {
  constructor(t, n, r) {
    super(t, "github.com", r), this.options = t, this.updater = n;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  get channel() {
    const result = this.updater.channel || this.options.channel;
    return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);
  }
  async getLatestVersion() {
<<<<<<< HEAD
    var _a, _b, _c, _d, _e;
    const cancellationToken = new builder_util_runtime_1$b.CancellationToken();
    const feedXml = await this.httpRequest((0, util_1$3.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl), {
      accept: "application/xml, application/atom+xml, text/xml, */*"
    }, cancellationToken);
    const feed = (0, builder_util_runtime_1$b.parseXml)(feedXml);
    let latestRelease = feed.element("entry", false, `No published versions on GitHub`);
    let tag = null;
    try {
      if (this.updater.allowPrerelease) {
        const currentChannel = ((_a = this.updater) === null || _a === void 0 ? void 0 : _a.channel) || ((_b = semver.prerelease(this.updater.currentVersion)) === null || _b === void 0 ? void 0 : _b[0]) || null;
        if (currentChannel === null) {
          tag = hrefRegExp.exec(latestRelease.element("link").attribute("href"))[1];
        } else {
          for (const element of feed.getElements("entry")) {
            const hrefElement = hrefRegExp.exec(element.element("link").attribute("href"));
            if (hrefElement === null)
              continue;
            const hrefTag = hrefElement[1];
            const hrefChannel = ((_c = semver.prerelease(hrefTag)) === null || _c === void 0 ? void 0 : _c[0]) || null;
            const shouldFetchVersion = !currentChannel || ["alpha", "beta"].includes(currentChannel);
            const isCustomChannel = hrefChannel !== null && !["alpha", "beta"].includes(String(hrefChannel));
            const channelMismatch = currentChannel === "beta" && hrefChannel === "alpha";
            if (shouldFetchVersion && !isCustomChannel && !channelMismatch) {
              tag = hrefTag;
              break;
            }
            const isNextPreRelease = hrefChannel && hrefChannel === currentChannel;
            if (isNextPreRelease) {
              tag = hrefTag;
=======
    var t, n, r, i, a;
    const s = new Ut.CancellationToken(), c = await this.httpRequest((0, wr.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl), {
      accept: "application/xml, application/atom+xml, text/xml, */*"
    }, s), o = (0, Ut.parseXml)(c);
    let u = o.element("entry", !1, "No published versions on GitHub"), l = null;
    try {
      if (this.updater.allowPrerelease) {
        const b = ((t = this.updater) === null || t === void 0 ? void 0 : t.channel) || ((n = yr.prerelease(this.updater.currentVersion)) === null || n === void 0 ? void 0 : n[0]) || null;
        if (b === null)
          l = cl.exec(u.element("link").attribute("href"))[1];
        else
          for (const x of o.getElements("entry")) {
            const y = cl.exec(x.element("link").attribute("href"));
            if (y === null)
              continue;
            const E = y[1], S = ((r = yr.prerelease(E)) === null || r === void 0 ? void 0 : r[0]) || null, D = !b || ["alpha", "beta"].includes(b), U = S !== null && !["alpha", "beta"].includes(String(S));
            if (D && !U && !(b === "beta" && S === "alpha")) {
              l = E;
              break;
            }
            if (S && S === b) {
              l = E;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
              break;
            }
          }
        }
      } else {
<<<<<<< HEAD
        tag = await this.getLatestTagName(cancellationToken);
        for (const element of feed.getElements("entry")) {
          if (hrefRegExp.exec(element.element("link").attribute("href"))[1] === tag) {
            latestRelease = element;
=======
        l = await this.getLatestTagName(s);
        for (const b of o.getElements("entry"))
          if (cl.exec(b.element("link").attribute("href"))[1] === l) {
            u = b;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
            break;
          }
        }
      }
<<<<<<< HEAD
    } catch (e) {
      throw (0, builder_util_runtime_1$b.newError)(`Cannot parse releases feed: ${e.stack || e.message},
=======
    } catch (b) {
      throw (0, Ut.newError)(`Cannot parse releases feed: ${b.stack || b.message},
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
XML:
${feedXml}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
    }
<<<<<<< HEAD
    if (tag == null) {
      throw (0, builder_util_runtime_1$b.newError)(`No published versions on GitHub`, "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
    }
    let rawData;
    let channelFile = "";
    let channelFileUrl = "";
    const fetchData = async (channelName) => {
      channelFile = (0, util_1$3.getChannelFilename)(channelName);
      channelFileUrl = (0, util_1$3.newUrlFromBase)(this.getBaseDownloadPath(String(tag), channelFile), this.baseUrl);
      const requestOptions = this.createRequestOptions(channelFileUrl);
      try {
        return await this.executor.request(requestOptions, cancellationToken);
      } catch (e) {
        if (e instanceof builder_util_runtime_1$b.HttpError && e.statusCode === 404) {
          throw (0, builder_util_runtime_1$b.newError)(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        }
        throw e;
      }
    };
    try {
      let channel = this.channel;
      if (this.updater.allowPrerelease && ((_d = semver.prerelease(tag)) === null || _d === void 0 ? void 0 : _d[0])) {
        channel = this.getCustomChannelName(String((_e = semver.prerelease(tag)) === null || _e === void 0 ? void 0 : _e[0]));
      }
      rawData = await fetchData(channel);
    } catch (e) {
      if (this.updater.allowPrerelease) {
        rawData = await fetchData(this.getDefaultChannelName());
      } else {
        throw e;
      }
    }
    const result = (0, Provider_1$8.parseUpdateInfo)(rawData, channelFile, channelFileUrl);
    if (result.releaseName == null) {
      result.releaseName = latestRelease.elementValueOrEmpty("title");
    }
    if (result.releaseNotes == null) {
      result.releaseNotes = computeReleaseNotes(this.updater.currentVersion, this.updater.fullChangelog, feed, latestRelease);
    }
    return {
      tag,
      ...result
    };
  }
  async getLatestTagName(cancellationToken) {
    const options = this.options;
    const url2 = options.host == null || options.host === "github.com" ? (0, util_1$3.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl) : new url_1$3.URL(`${this.computeGithubBasePath(`/repos/${options.owner}/${options.repo}/releases`)}/latest`, this.baseApiUrl);
    try {
      const rawData = await this.httpRequest(url2, { Accept: "application/json" }, cancellationToken);
      if (rawData == null) {
        return null;
      }
      const releaseInfo = JSON.parse(rawData);
      return releaseInfo.tag_name;
    } catch (e) {
      throw (0, builder_util_runtime_1$b.newError)(`Unable to find latest version on GitHub (${url2}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
=======
    if (l == null)
      throw (0, Ut.newError)("No published versions on GitHub", "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
    let p, f = "", m = "";
    const g = async (b) => {
      f = (0, wr.getChannelFilename)(b), m = (0, wr.newUrlFromBase)(this.getBaseDownloadPath(String(l), f), this.baseUrl);
      const x = this.createRequestOptions(m);
      try {
        return await this.executor.request(x, s);
      } catch (y) {
        throw y instanceof Ut.HttpError && y.statusCode === 404 ? (0, Ut.newError)(`Cannot find ${f} in the latest release artifacts (${m}): ${y.stack || y.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND") : y;
      }
    };
    try {
      let b = this.channel;
      this.updater.allowPrerelease && (!((i = yr.prerelease(l)) === null || i === void 0) && i[0]) && (b = this.getCustomChannelName(String((a = yr.prerelease(l)) === null || a === void 0 ? void 0 : a[0]))), p = await g(b);
    } catch (b) {
      if (this.updater.allowPrerelease)
        p = await g(this.getDefaultChannelName());
      else
        throw b;
    }
    const h = (0, Yl.parseUpdateInfo)(p, f, m);
    return h.releaseName == null && (h.releaseName = u.elementValueOrEmpty("title")), h.releaseNotes == null && (h.releaseNotes = Yg(this.updater.currentVersion, this.updater.fullChangelog, o, u)), {
      tag: l,
      ...h
    };
  }
  async getLatestTagName(t) {
    const n = this.options, r = n.host == null || n.host === "github.com" ? (0, wr.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl) : new QR.URL(`${this.computeGithubBasePath(`/repos/${n.owner}/${n.repo}/releases`)}/latest`, this.baseApiUrl);
    try {
      const i = await this.httpRequest(r, { Accept: "application/json" }, t);
      return i == null ? null : JSON.parse(i).tag_name;
    } catch (i) {
      throw (0, Ut.newError)(`Unable to find latest version on GitHub (${r}), please ensure a production release exists: ${i.stack || i.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
  }
  get basePath() {
    return `/${this.options.owner}/${this.options.repo}/releases`;
  }
<<<<<<< HEAD
  resolveFiles(updateInfo) {
    return (0, Provider_1$8.resolveFiles)(updateInfo, this.baseUrl, (p) => this.getBaseDownloadPath(updateInfo.tag, p.replace(/ /g, "-")));
=======
  resolveFiles(t) {
    return (0, Yl.resolveFiles)(t, this.baseUrl, (n) => this.getBaseDownloadPath(t.tag, n.replace(/ /g, "-")));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  getBaseDownloadPath(tag, fileName) {
    return `${this.basePath}/download/${tag}/${fileName}`;
  }
}
<<<<<<< HEAD
GitHubProvider$1.GitHubProvider = GitHubProvider;
function getNoteValue(parent) {
  const result = parent.elementValueOrEmpty("content");
  return result === "No content." ? "" : result;
}
function computeReleaseNotes(currentVersion, isFullChangelog, feed, latestRelease) {
  if (!isFullChangelog) {
    return getNoteValue(latestRelease);
  }
  const releaseNotes = [];
  for (const release of feed.getElements("entry")) {
    const versionRelease = /\/tag\/v?([^/]+)$/.exec(release.element("link").attribute("href"))[1];
    if (semver.lt(currentVersion, versionRelease)) {
      releaseNotes.push({
        version: versionRelease,
        note: getNoteValue(release)
      });
    }
  }
  return releaseNotes.sort((a, b) => semver.rcompare(a.version, b.version));
}
var KeygenProvider$1 = {};
Object.defineProperty(KeygenProvider$1, "__esModule", { value: true });
KeygenProvider$1.KeygenProvider = void 0;
const builder_util_runtime_1$a = out;
const util_1$2 = util;
const Provider_1$7 = Provider$1;
class KeygenProvider extends Provider_1$7.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super({
      ...runtimeOptions,
      isUseMultipleRangeRequest: false
    });
    this.configuration = configuration;
    this.updater = updater;
    this.defaultHostname = "api.keygen.sh";
    const host = this.configuration.host || this.defaultHostname;
    this.baseUrl = (0, util_1$2.newBaseUrl)(`https://${host}/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`);
=======
vn.GitHubProvider = e$;
function Vh(e) {
  const t = e.elementValueOrEmpty("content");
  return t === "No content." ? "" : t;
}
function Yg(e, t, n, r) {
  if (!t)
    return Vh(r);
  const i = [];
  for (const a of n.getElements("entry")) {
    const s = /\/tag\/v?([^/]+)$/.exec(a.element("link").attribute("href"))[1];
    yr.lt(e, s) && i.push({
      version: s,
      note: Vh(a)
    });
  }
  return i.sort((a, s) => yr.rcompare(a.version, s.version));
}
var Ao = {};
Object.defineProperty(Ao, "__esModule", { value: !0 });
Ao.KeygenProvider = void 0;
const Yh = Fe, ll = ut, ul = Re;
class t$ extends ul.Provider {
  constructor(t, n, r) {
    super({
      ...r,
      isUseMultipleRangeRequest: !1
    }), this.configuration = t, this.updater = n, this.defaultHostname = "api.keygen.sh";
    const i = this.configuration.host || this.defaultHostname;
    this.baseUrl = (0, ll.newBaseUrl)(`https://${i}/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "stable";
  }
  async getLatestVersion() {
<<<<<<< HEAD
    const cancellationToken = new builder_util_runtime_1$a.CancellationToken();
    const channelFile = (0, util_1$2.getChannelFilename)(this.getCustomChannelName(this.channel));
    const channelUrl = (0, util_1$2.newUrlFromBase)(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
=======
    const t = new Yh.CancellationToken(), n = (0, ll.getChannelFilename)(this.getCustomChannelName(this.channel)), r = (0, ll.newUrlFromBase)(n, this.baseUrl, this.updater.isAddNoCacheQuery);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    try {
      const updateInfo = await this.httpRequest(channelUrl, {
        Accept: "application/vnd.api+json",
        "Keygen-Version": "1.1"
<<<<<<< HEAD
      }, cancellationToken);
      return (0, Provider_1$7.parseUpdateInfo)(updateInfo, channelFile, channelUrl);
    } catch (e) {
      throw (0, builder_util_runtime_1$a.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(updateInfo) {
    return (0, Provider_1$7.resolveFiles)(updateInfo, this.baseUrl);
=======
      }, t);
      return (0, ul.parseUpdateInfo)(i, n, r);
    } catch (i) {
      throw (0, Yh.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${i.stack || i.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(t) {
    return (0, ul.resolveFiles)(t, this.baseUrl);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  toString() {
    const { account, product, platform: platform2 } = this.configuration;
    return `Keygen (account: ${account}, product: ${product}, platform: ${platform2}, channel: ${this.channel})`;
  }
}
<<<<<<< HEAD
KeygenProvider$1.KeygenProvider = KeygenProvider;
var PrivateGitHubProvider$1 = {};
Object.defineProperty(PrivateGitHubProvider$1, "__esModule", { value: true });
PrivateGitHubProvider$1.PrivateGitHubProvider = void 0;
const builder_util_runtime_1$9 = out;
const js_yaml_1$1 = jsYaml;
const path$5 = require$$1$4;
const url_1$2 = require$$0$3;
const util_1$1 = util;
const GitHubProvider_1$1 = GitHubProvider$1;
const Provider_1$6 = Provider$1;
class PrivateGitHubProvider extends GitHubProvider_1$1.BaseGitHubProvider {
  constructor(options, updater, token, runtimeOptions) {
    super(options, "api.github.com", runtimeOptions);
    this.updater = updater;
    this.token = token;
=======
Ao.KeygenProvider = t$;
var To = {};
Object.defineProperty(To, "__esModule", { value: !0 });
To.PrivateGitHubProvider = void 0;
const or = Fe, n$ = Ue, r$ = ne, Xh = $t, Kh = ut, i$ = vn, a$ = Re;
class s$ extends i$.BaseGitHubProvider {
  constructor(t, n, r, i) {
    super(t, "api.github.com", i), this.updater = n, this.token = r;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  createRequestOptions(url2, headers2) {
    const result = super.createRequestOptions(url2, headers2);
    result.redirect = "manual";
    return result;
  }
  async getLatestVersion() {
<<<<<<< HEAD
    const cancellationToken = new builder_util_runtime_1$9.CancellationToken();
    const channelFile = (0, util_1$1.getChannelFilename)(this.getDefaultChannelName());
    const releaseInfo = await this.getLatestVersionInfo(cancellationToken);
    const asset = releaseInfo.assets.find((it) => it.name === channelFile);
    if (asset == null) {
      throw (0, builder_util_runtime_1$9.newError)(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
    }
    const url2 = new url_1$2.URL(asset.url);
    let result;
    try {
      result = (0, js_yaml_1$1.load)(await this.httpRequest(url2, this.configureHeaders("application/octet-stream"), cancellationToken));
    } catch (e) {
      if (e instanceof builder_util_runtime_1$9.HttpError && e.statusCode === 404) {
        throw (0, builder_util_runtime_1$9.newError)(`Cannot find ${channelFile} in the latest release artifacts (${url2}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
      }
      throw e;
    }
    result.assets = releaseInfo.assets;
    return result;
=======
    const t = new or.CancellationToken(), n = (0, Kh.getChannelFilename)(this.getDefaultChannelName()), r = await this.getLatestVersionInfo(t), i = r.assets.find((c) => c.name === n);
    if (i == null)
      throw (0, or.newError)(`Cannot find ${n} in the release ${r.html_url || r.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
    const a = new Xh.URL(i.url);
    let s;
    try {
      s = (0, n$.load)(await this.httpRequest(a, this.configureHeaders("application/octet-stream"), t));
    } catch (c) {
      throw c instanceof or.HttpError && c.statusCode === 404 ? (0, or.newError)(`Cannot find ${n} in the latest release artifacts (${a}): ${c.stack || c.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND") : c;
    }
    return s.assets = r.assets, s;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  get fileExtraDownloadHeaders() {
    return this.configureHeaders("application/octet-stream");
  }
  configureHeaders(accept) {
    return {
      accept,
      authorization: `token ${this.token}`
    };
  }
<<<<<<< HEAD
  async getLatestVersionInfo(cancellationToken) {
    const allowPrerelease = this.updater.allowPrerelease;
    let basePath = this.basePath;
    if (!allowPrerelease) {
      basePath = `${basePath}/latest`;
    }
    const url2 = (0, util_1$1.newUrlFromBase)(basePath, this.baseUrl);
    try {
      const version = JSON.parse(await this.httpRequest(url2, this.configureHeaders("application/vnd.github.v3+json"), cancellationToken));
      if (allowPrerelease) {
        return version.find((it) => it.prerelease) || version[0];
      } else {
        return version;
      }
    } catch (e) {
      throw (0, builder_util_runtime_1$9.newError)(`Unable to find latest version on GitHub (${url2}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
=======
  async getLatestVersionInfo(t) {
    const n = this.updater.allowPrerelease;
    let r = this.basePath;
    n || (r = `${r}/latest`);
    const i = (0, Kh.newUrlFromBase)(r, this.baseUrl);
    try {
      const a = JSON.parse(await this.httpRequest(i, this.configureHeaders("application/vnd.github.v3+json"), t));
      return n ? a.find((s) => s.prerelease) || a[0] : a;
    } catch (a) {
      throw (0, or.newError)(`Unable to find latest version on GitHub (${i}), please ensure a production release exists: ${a.stack || a.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
  }
  get basePath() {
    return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
  }
<<<<<<< HEAD
  resolveFiles(updateInfo) {
    return (0, Provider_1$6.getFileList)(updateInfo).map((it) => {
      const name = path$5.posix.basename(it.url).replace(/ /g, "-");
      const asset = updateInfo.assets.find((it2) => it2 != null && it2.name === name);
      if (asset == null) {
        throw (0, builder_util_runtime_1$9.newError)(`Cannot find asset "${name}" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
      }
      return {
        url: new url_1$2.URL(asset.url),
        info: it
=======
  resolveFiles(t) {
    return (0, a$.getFileList)(t).map((n) => {
      const r = r$.posix.basename(n.url).replace(/ /g, "-"), i = t.assets.find((a) => a != null && a.name === r);
      if (i == null)
        throw (0, or.newError)(`Cannot find asset "${r}" in: ${JSON.stringify(t.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
      return {
        url: new Xh.URL(i.url),
        info: n
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      };
    });
  }
}
<<<<<<< HEAD
PrivateGitHubProvider$1.PrivateGitHubProvider = PrivateGitHubProvider;
Object.defineProperty(providerFactory, "__esModule", { value: true });
providerFactory.isUrlProbablySupportMultiRangeRequests = isUrlProbablySupportMultiRangeRequests;
providerFactory.createClient = createClient;
const builder_util_runtime_1$8 = out;
const BitbucketProvider_1 = BitbucketProvider$1;
const GenericProvider_1$1 = GenericProvider$1;
const GitHubProvider_1 = GitHubProvider$1;
const KeygenProvider_1 = KeygenProvider$1;
const PrivateGitHubProvider_1 = PrivateGitHubProvider$1;
function isUrlProbablySupportMultiRangeRequests(url2) {
  return !url2.includes("s3.amazonaws.com");
}
function createClient(data, updater, runtimeOptions) {
  if (typeof data === "string") {
    throw (0, builder_util_runtime_1$8.newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
  }
  const provider = data.provider;
  switch (provider) {
    case "github": {
      const githubOptions = data;
      const token = (githubOptions.private ? process.env["GH_TOKEN"] || process.env["GITHUB_TOKEN"] : null) || githubOptions.token;
      if (token == null) {
        return new GitHubProvider_1.GitHubProvider(githubOptions, updater, runtimeOptions);
      } else {
        return new PrivateGitHubProvider_1.PrivateGitHubProvider(githubOptions, updater, token, runtimeOptions);
      }
    }
    case "bitbucket":
      return new BitbucketProvider_1.BitbucketProvider(data, updater, runtimeOptions);
    case "keygen":
      return new KeygenProvider_1.KeygenProvider(data, updater, runtimeOptions);
    case "s3":
    case "spaces":
      return new GenericProvider_1$1.GenericProvider({
        provider: "generic",
        url: (0, builder_util_runtime_1$8.getS3LikeProviderBaseUrl)(data),
        channel: data.channel || null
      }, updater, {
        ...runtimeOptions,
=======
To.PrivateGitHubProvider = s$;
Object.defineProperty(_o, "__esModule", { value: !0 });
_o.isUrlProbablySupportMultiRangeRequests = Xg;
_o.createClient = p$;
const Ma = Fe, o$ = So, Jh = ia, c$ = vn, l$ = Ao, u$ = To;
function Xg(e) {
  return !e.includes("s3.amazonaws.com");
}
function p$(e, t, n) {
  if (typeof e == "string")
    throw (0, Ma.newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
  const r = e.provider;
  switch (r) {
    case "github": {
      const i = e, a = (i.private ? process.env.GH_TOKEN || process.env.GITHUB_TOKEN : null) || i.token;
      return a == null ? new c$.GitHubProvider(i, t, n) : new u$.PrivateGitHubProvider(i, t, a, n);
    }
    case "bitbucket":
      return new o$.BitbucketProvider(e, t, n);
    case "keygen":
      return new l$.KeygenProvider(e, t, n);
    case "s3":
    case "spaces":
      return new Jh.GenericProvider({
        provider: "generic",
        url: (0, Ma.getS3LikeProviderBaseUrl)(e),
        channel: e.channel || null
      }, t, {
        ...n,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        // https://github.com/minio/minio/issues/5285#issuecomment-350428955
        isUseMultipleRangeRequest: false
      });
    case "generic": {
<<<<<<< HEAD
      const options = data;
      return new GenericProvider_1$1.GenericProvider(options, updater, {
        ...runtimeOptions,
        isUseMultipleRangeRequest: options.useMultipleRangeRequest !== false && isUrlProbablySupportMultiRangeRequests(options.url)
      });
    }
    case "custom": {
      const options = data;
      const constructor = options.updateProvider;
      if (!constructor) {
        throw (0, builder_util_runtime_1$8.newError)("Custom provider not specified", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
      }
      return new constructor(options, updater, runtimeOptions);
    }
    default:
      throw (0, builder_util_runtime_1$8.newError)(`Unsupported provider: ${provider}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
  }
}
var GenericDifferentialDownloader$1 = {};
var DifferentialDownloader$1 = {};
var DataSplitter$1 = {};
var downloadPlanBuilder = {};
Object.defineProperty(downloadPlanBuilder, "__esModule", { value: true });
downloadPlanBuilder.OperationKind = void 0;
downloadPlanBuilder.computeOperations = computeOperations;
var OperationKind$1;
(function(OperationKind2) {
  OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
  OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
})(OperationKind$1 || (downloadPlanBuilder.OperationKind = OperationKind$1 = {}));
function computeOperations(oldBlockMap, newBlockMap, logger) {
  const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);
  const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);
  let lastOperation = null;
  const blockMapFile = newBlockMap.files[0];
  const operations = [];
  const name = blockMapFile.name;
  const oldEntry = nameToOldBlocks.get(name);
  if (oldEntry == null) {
    throw new Error(`no file ${name} in old blockmap`);
  }
  const newFile = nameToNewBlocks.get(name);
  let changedBlockCount = 0;
  const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset, logger);
  let newOffset = blockMapFile.offset;
  for (let i = 0; i < newFile.checksums.length; newOffset += newFile.sizes[i], i++) {
    const blockSize = newFile.sizes[i];
    const checksum = newFile.checksums[i];
    let oldOffset = checksumToOldOffset.get(checksum);
    if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {
      logger.warn(`Checksum ("${checksum}") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);
      oldOffset = void 0;
    }
    if (oldOffset === void 0) {
      changedBlockCount++;
      if (lastOperation != null && lastOperation.kind === OperationKind$1.DOWNLOAD && lastOperation.end === newOffset) {
        lastOperation.end += blockSize;
      } else {
        lastOperation = {
          kind: OperationKind$1.DOWNLOAD,
          start: newOffset,
          end: newOffset + blockSize
          // oldBlocks: null,
        };
        validateAndAdd(lastOperation, operations, checksum, i);
      }
    } else {
      if (lastOperation != null && lastOperation.kind === OperationKind$1.COPY && lastOperation.end === oldOffset) {
        lastOperation.end += blockSize;
      } else {
        lastOperation = {
          kind: OperationKind$1.COPY,
          start: oldOffset,
          end: oldOffset + blockSize
          // oldBlocks: [checksum]
        };
        validateAndAdd(lastOperation, operations, checksum, i);
      }
    }
  }
  if (changedBlockCount > 0) {
    logger.info(`File${blockMapFile.name === "file" ? "" : " " + blockMapFile.name} has ${changedBlockCount} changed blocks`);
  }
  return operations;
}
const isValidateOperationRange = process.env["DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES"] === "true";
function validateAndAdd(operation, operations, checksum, index) {
  if (isValidateOperationRange && operations.length !== 0) {
    const lastOperation = operations[operations.length - 1];
    if (lastOperation.kind === operation.kind && operation.start < lastOperation.end && operation.start > lastOperation.start) {
      const min2 = [lastOperation.start, lastOperation.end, operation.start, operation.end].reduce((p, v) => p < v ? p : v);
      throw new Error(`operation (block index: ${index}, checksum: ${checksum}, kind: ${OperationKind$1[operation.kind]}) overlaps previous operation (checksum: ${checksum}):
abs: ${lastOperation.start} until ${lastOperation.end} and ${operation.start} until ${operation.end}
rel: ${lastOperation.start - min2} until ${lastOperation.end - min2} and ${operation.start - min2} until ${operation.end - min2}`);
=======
      const i = e;
      return new Jh.GenericProvider(i, t, {
        ...n,
        isUseMultipleRangeRequest: i.useMultipleRangeRequest !== !1 && Xg(i.url)
      });
    }
    case "custom": {
      const i = e, a = i.updateProvider;
      if (!a)
        throw (0, Ma.newError)("Custom provider not specified", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
      return new a(i, t, n);
    }
    default:
      throw (0, Ma.newError)(`Unsupported provider: ${r}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
  }
}
var Co = {}, aa = {}, Hr = {}, Qn = {};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.OperationKind = void 0;
Qn.computeOperations = f$;
var Ln;
(function(e) {
  e[e.COPY = 0] = "COPY", e[e.DOWNLOAD = 1] = "DOWNLOAD";
})(Ln || (Qn.OperationKind = Ln = {}));
function f$(e, t, n) {
  const r = Qh(e.files), i = Qh(t.files);
  let a = null;
  const s = t.files[0], c = [], o = s.name, u = r.get(o);
  if (u == null)
    throw new Error(`no file ${o} in old blockmap`);
  const l = i.get(o);
  let p = 0;
  const { checksumToOffset: f, checksumToOldSize: m } = h$(r.get(o), u.offset, n);
  let g = s.offset;
  for (let h = 0; h < l.checksums.length; g += l.sizes[h], h++) {
    const b = l.sizes[h], x = l.checksums[h];
    let y = f.get(x);
    y != null && m.get(x) !== b && (n.warn(`Checksum ("${x}") matches, but size differs (old: ${m.get(x)}, new: ${b})`), y = void 0), y === void 0 ? (p++, a != null && a.kind === Ln.DOWNLOAD && a.end === g ? a.end += b : (a = {
      kind: Ln.DOWNLOAD,
      start: g,
      end: g + b
      // oldBlocks: null,
    }, Zh(a, c, x, h))) : a != null && a.kind === Ln.COPY && a.end === y ? a.end += b : (a = {
      kind: Ln.COPY,
      start: y,
      end: y + b
      // oldBlocks: [checksum]
    }, Zh(a, c, x, h));
  }
  return p > 0 && n.info(`File${s.name === "file" ? "" : " " + s.name} has ${p} changed blocks`), c;
}
const d$ = process.env.DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES === "true";
function Zh(e, t, n, r) {
  if (d$ && t.length !== 0) {
    const i = t[t.length - 1];
    if (i.kind === e.kind && e.start < i.end && e.start > i.start) {
      const a = [i.start, i.end, e.start, e.end].reduce((s, c) => s < c ? s : c);
      throw new Error(`operation (block index: ${r}, checksum: ${n}, kind: ${Ln[e.kind]}) overlaps previous operation (checksum: ${n}):
abs: ${i.start} until ${i.end} and ${e.start} until ${e.end}
rel: ${i.start - a} until ${i.end - a} and ${e.start - a} until ${e.end - a}`);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
  }
  operations.push(operation);
}
<<<<<<< HEAD
function buildChecksumMap(file2, fileOffset, logger) {
  const checksumToOffset = /* @__PURE__ */ new Map();
  const checksumToSize = /* @__PURE__ */ new Map();
  let offset = fileOffset;
  for (let i = 0; i < file2.checksums.length; i++) {
    const checksum = file2.checksums[i];
    const size = file2.sizes[i];
    const existing = checksumToSize.get(checksum);
    if (existing === void 0) {
      checksumToOffset.set(checksum, offset);
      checksumToSize.set(checksum, size);
    } else if (logger.debug != null) {
      const sizeExplanation = existing === size ? "(same size)" : `(size: ${existing}, this size: ${size})`;
      logger.debug(`${checksum} duplicated in blockmap ${sizeExplanation}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
    }
    offset += size;
  }
  return { checksumToOffset, checksumToOldSize: checksumToSize };
}
function buildBlockFileMap(list) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    result.set(item.name, item);
  }
  return result;
}
Object.defineProperty(DataSplitter$1, "__esModule", { value: true });
DataSplitter$1.DataSplitter = void 0;
DataSplitter$1.copyData = copyData;
const builder_util_runtime_1$7 = out;
const fs_1$3 = fs$w;
const stream_1$1 = require$$1$2;
const downloadPlanBuilder_1$2 = downloadPlanBuilder;
const DOUBLE_CRLF = Buffer.from("\r\n\r\n");
var ReadState;
(function(ReadState2) {
  ReadState2[ReadState2["INIT"] = 0] = "INIT";
  ReadState2[ReadState2["HEADER"] = 1] = "HEADER";
  ReadState2[ReadState2["BODY"] = 2] = "BODY";
})(ReadState || (ReadState = {}));
function copyData(task, out2, oldFileFd, reject, resolve) {
  const readStream2 = (0, fs_1$3.createReadStream)("", {
    fd: oldFileFd,
    autoClose: false,
    start: task.start,
=======
function h$(e, t, n) {
  const r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  let a = t;
  for (let s = 0; s < e.checksums.length; s++) {
    const c = e.checksums[s], o = e.sizes[s], u = i.get(c);
    if (u === void 0)
      r.set(c, a), i.set(c, o);
    else if (n.debug != null) {
      const l = u === o ? "(same size)" : `(size: ${u}, this size: ${o})`;
      n.debug(`${c} duplicated in blockmap ${l}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
    }
    a += o;
  }
  return { checksumToOffset: r, checksumToOldSize: i };
}
function Qh(e) {
  const t = /* @__PURE__ */ new Map();
  for (const n of e)
    t.set(n.name, n);
  return t;
}
Object.defineProperty(Hr, "__esModule", { value: !0 });
Hr.DataSplitter = void 0;
Hr.copyData = Kg;
const qa = Fe, m$ = se, v$ = ae, g$ = Qn, em = Buffer.from(`\r
\r
`);
var en;
(function(e) {
  e[e.INIT = 0] = "INIT", e[e.HEADER = 1] = "HEADER", e[e.BODY = 2] = "BODY";
})(en || (en = {}));
function Kg(e, t, n, r, i) {
  const a = (0, m$.createReadStream)("", {
    fd: n,
    autoClose: !1,
    start: e.start,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    // end is inclusive
    end: task.end - 1
  });
  readStream2.on("error", reject);
  readStream2.once("end", resolve);
  readStream2.pipe(out2, {
    end: false
  });
}
<<<<<<< HEAD
class DataSplitter extends stream_1$1.Writable {
  constructor(out2, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {
    super();
    this.out = out2;
    this.options = options;
    this.partIndexToTaskIndex = partIndexToTaskIndex;
    this.partIndexToLength = partIndexToLength;
    this.finishHandler = finishHandler;
    this.partIndex = -1;
    this.headerListBuffer = null;
    this.readState = ReadState.INIT;
    this.ignoreByteCount = 0;
    this.remainingPartDataCount = 0;
    this.actualPartLength = 0;
    this.boundaryLength = boundary.length + 4;
    this.ignoreByteCount = this.boundaryLength - 2;
=======
class b$ extends v$.Writable {
  constructor(t, n, r, i, a, s) {
    super(), this.out = t, this.options = n, this.partIndexToTaskIndex = r, this.partIndexToLength = a, this.finishHandler = s, this.partIndex = -1, this.headerListBuffer = null, this.readState = en.INIT, this.ignoreByteCount = 0, this.remainingPartDataCount = 0, this.actualPartLength = 0, this.boundaryLength = i.length + 4, this.ignoreByteCount = this.boundaryLength - 2;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  get isFinished() {
    return this.partIndex === this.partIndexToLength.length;
  }
  // noinspection JSUnusedGlobalSymbols
  _write(data, encoding, callback) {
    if (this.isFinished) {
      console.error(`Trailing ignored data: ${data.length} bytes`);
      return;
    }
    this.handleData(data).then(callback).catch(callback);
  }
<<<<<<< HEAD
  async handleData(chunk) {
    let start = 0;
    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {
      throw (0, builder_util_runtime_1$7.newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
    }
    if (this.ignoreByteCount > 0) {
      const toIgnore = Math.min(this.ignoreByteCount, chunk.length);
      this.ignoreByteCount -= toIgnore;
      start = toIgnore;
    } else if (this.remainingPartDataCount > 0) {
      const toRead = Math.min(this.remainingPartDataCount, chunk.length);
      this.remainingPartDataCount -= toRead;
      await this.processPartData(chunk, 0, toRead);
      start = toRead;
    }
    if (start === chunk.length) {
      return;
    }
    if (this.readState === ReadState.HEADER) {
      const headerListEnd = this.searchHeaderListEnd(chunk, start);
      if (headerListEnd === -1) {
        return;
      }
      start = headerListEnd;
      this.readState = ReadState.BODY;
      this.headerListBuffer = null;
    }
    while (true) {
      if (this.readState === ReadState.BODY) {
        this.readState = ReadState.INIT;
      } else {
        this.partIndex++;
        let taskIndex = this.partIndexToTaskIndex.get(this.partIndex);
        if (taskIndex == null) {
          if (this.isFinished) {
            taskIndex = this.options.end;
          } else {
            throw (0, builder_util_runtime_1$7.newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
          }
        }
        const prevTaskIndex = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
        if (prevTaskIndex < taskIndex) {
          await this.copyExistingData(prevTaskIndex, taskIndex);
        } else if (prevTaskIndex > taskIndex) {
          throw (0, builder_util_runtime_1$7.newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
        }
        if (this.isFinished) {
          this.onPartEnd();
          this.finishHandler();
          return;
        }
        start = this.searchHeaderListEnd(chunk, start);
        if (start === -1) {
          this.readState = ReadState.HEADER;
          return;
        }
=======
  async handleData(t) {
    let n = 0;
    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0)
      throw (0, qa.newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
    if (this.ignoreByteCount > 0) {
      const r = Math.min(this.ignoreByteCount, t.length);
      this.ignoreByteCount -= r, n = r;
    } else if (this.remainingPartDataCount > 0) {
      const r = Math.min(this.remainingPartDataCount, t.length);
      this.remainingPartDataCount -= r, await this.processPartData(t, 0, r), n = r;
    }
    if (n !== t.length) {
      if (this.readState === en.HEADER) {
        const r = this.searchHeaderListEnd(t, n);
        if (r === -1)
          return;
        n = r, this.readState = en.BODY, this.headerListBuffer = null;
      }
      for (; ; ) {
        if (this.readState === en.BODY)
          this.readState = en.INIT;
        else {
          this.partIndex++;
          let s = this.partIndexToTaskIndex.get(this.partIndex);
          if (s == null)
            if (this.isFinished)
              s = this.options.end;
            else
              throw (0, qa.newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
          const c = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
          if (c < s)
            await this.copyExistingData(c, s);
          else if (c > s)
            throw (0, qa.newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
          if (this.isFinished) {
            this.onPartEnd(), this.finishHandler();
            return;
          }
          if (n = this.searchHeaderListEnd(t, n), n === -1) {
            this.readState = en.HEADER;
            return;
          }
        }
        const r = this.partIndexToLength[this.partIndex], i = n + r, a = Math.min(i, t.length);
        if (await this.processPartStarted(t, n, a), this.remainingPartDataCount = r - (a - n), this.remainingPartDataCount > 0)
          return;
        if (n = i + this.boundaryLength, n >= t.length) {
          this.ignoreByteCount = this.boundaryLength - (t.length - i);
          return;
        }
      }
    }
  }
  copyExistingData(t, n) {
    return new Promise((r, i) => {
      const a = () => {
        if (t === n) {
          r();
          return;
        }
        const s = this.options.tasks[t];
        if (s.kind !== g$.OperationKind.COPY) {
          i(new Error("Task kind must be COPY"));
          return;
        }
        Kg(s, this.out, this.options.oldFileFd, i, () => {
          t++, a();
        });
      };
      a();
    });
  }
  searchHeaderListEnd(t, n) {
    const r = t.indexOf(em, n);
    if (r !== -1)
      return r + em.length;
    const i = n === 0 ? t : t.slice(n);
    return this.headerListBuffer == null ? this.headerListBuffer = i : this.headerListBuffer = Buffer.concat([this.headerListBuffer, i]), -1;
  }
  onPartEnd() {
    const t = this.partIndexToLength[this.partIndex - 1];
    if (this.actualPartLength !== t)
      throw (0, qa.newError)(`Expected length: ${t} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
    this.actualPartLength = 0;
  }
  processPartStarted(t, n, r) {
    return this.partIndex !== 0 && this.onPartEnd(), this.processPartData(t, n, r);
  }
  processPartData(t, n, r) {
    this.actualPartLength += r - n;
    const i = this.out;
    return i.write(n === 0 && t.length === r ? t : t.slice(n, r)) ? Promise.resolve() : new Promise((a, s) => {
      i.on("error", s), i.once("drain", () => {
        i.removeListener("error", s), a();
      });
    });
  }
}
Hr.DataSplitter = b$;
var Ro = {};
Object.defineProperty(Ro, "__esModule", { value: !0 });
Ro.executeTasksUsingMultipleRangeRequests = x$;
Ro.checkIsRangesSupported = Kl;
const Xl = Fe, tm = Hr, nm = Qn;
function x$(e, t, n, r, i) {
  const a = (s) => {
    if (s >= t.length) {
      e.fileMetadataBuffer != null && n.write(e.fileMetadataBuffer), n.end();
      return;
    }
    const c = s + 1e3;
    y$(e, {
      tasks: t,
      start: s,
      end: Math.min(t.length, c),
      oldFileFd: r
    }, n, () => a(c), i);
  };
  return a;
}
function y$(e, t, n, r, i) {
  let a = "bytes=", s = 0;
  const c = /* @__PURE__ */ new Map(), o = [];
  for (let p = t.start; p < t.end; p++) {
    const f = t.tasks[p];
    f.kind === nm.OperationKind.DOWNLOAD && (a += `${f.start}-${f.end - 1}, `, c.set(s, p), s++, o.push(f.end - f.start));
  }
  if (s <= 1) {
    const p = (f) => {
      if (f >= t.end) {
        r();
        return;
      }
      const m = t.tasks[f++];
      if (m.kind === nm.OperationKind.COPY)
        (0, tm.copyData)(m, n, t.oldFileFd, i, () => p(f));
      else {
        const g = e.createRequestOptions();
        g.headers.Range = `bytes=${m.start}-${m.end - 1}`;
        const h = e.httpExecutor.createRequest(g, (b) => {
          Kl(b, i) && (b.pipe(n, {
            end: !1
          }), b.once("end", () => p(f)));
        });
        e.httpExecutor.addErrorAndTimeoutHandlers(h, i), h.end();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
      const partLength = this.partIndexToLength[this.partIndex];
      const end2 = start + partLength;
      const effectiveEnd = Math.min(end2, chunk.length);
      await this.processPartStarted(chunk, start, effectiveEnd);
      this.remainingPartDataCount = partLength - (effectiveEnd - start);
      if (this.remainingPartDataCount > 0) {
        return;
      }
      start = end2 + this.boundaryLength;
      if (start >= chunk.length) {
        this.ignoreByteCount = this.boundaryLength - (chunk.length - end2);
        return;
      }
    }
  }
<<<<<<< HEAD
  copyExistingData(index, end2) {
    return new Promise((resolve, reject) => {
      const w = () => {
        if (index === end2) {
          resolve();
          return;
        }
        const task = this.options.tasks[index];
        if (task.kind !== downloadPlanBuilder_1$2.OperationKind.COPY) {
          reject(new Error("Task kind must be COPY"));
          return;
        }
        copyData(task, this.out, this.options.oldFileFd, reject, () => {
          index++;
          w();
        });
      };
      w();
    });
  }
  searchHeaderListEnd(chunk, readOffset) {
    const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset);
    if (headerListEnd !== -1) {
      return headerListEnd + DOUBLE_CRLF.length;
    }
    const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset);
    if (this.headerListBuffer == null) {
      this.headerListBuffer = partialChunk;
    } else {
      this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk]);
    }
    return -1;
  }
  onPartEnd() {
    const expectedLength = this.partIndexToLength[this.partIndex - 1];
    if (this.actualPartLength !== expectedLength) {
      throw (0, builder_util_runtime_1$7.newError)(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
    }
    this.actualPartLength = 0;
  }
  processPartStarted(data, start, end2) {
    if (this.partIndex !== 0) {
      this.onPartEnd();
    }
    return this.processPartData(data, start, end2);
  }
  processPartData(data, start, end2) {
    this.actualPartLength += end2 - start;
    const out2 = this.out;
    if (out2.write(start === 0 && data.length === end2 ? data : data.slice(start, end2))) {
      return Promise.resolve();
    } else {
      return new Promise((resolve, reject) => {
        out2.on("error", reject);
        out2.once("drain", () => {
          out2.removeListener("error", reject);
          resolve();
        });
      });
    }
  }
}
DataSplitter$1.DataSplitter = DataSplitter;
var multipleRangeDownloader = {};
Object.defineProperty(multipleRangeDownloader, "__esModule", { value: true });
multipleRangeDownloader.executeTasksUsingMultipleRangeRequests = executeTasksUsingMultipleRangeRequests;
multipleRangeDownloader.checkIsRangesSupported = checkIsRangesSupported;
const builder_util_runtime_1$6 = out;
const DataSplitter_1$1 = DataSplitter$1;
const downloadPlanBuilder_1$1 = downloadPlanBuilder;
function executeTasksUsingMultipleRangeRequests(differentialDownloader, tasks, out2, oldFileFd, reject) {
  const w = (taskOffset) => {
    if (taskOffset >= tasks.length) {
      if (differentialDownloader.fileMetadataBuffer != null) {
        out2.write(differentialDownloader.fileMetadataBuffer);
      }
      out2.end();
      return;
    }
    const nextOffset = taskOffset + 1e3;
    doExecuteTasks(differentialDownloader, {
      tasks,
      start: taskOffset,
      end: Math.min(tasks.length, nextOffset),
      oldFileFd
    }, out2, () => w(nextOffset), reject);
  };
  return w;
}
function doExecuteTasks(differentialDownloader, options, out2, resolve, reject) {
  let ranges = "bytes=";
  let partCount = 0;
  const partIndexToTaskIndex = /* @__PURE__ */ new Map();
  const partIndexToLength = [];
  for (let i = options.start; i < options.end; i++) {
    const task = options.tasks[i];
    if (task.kind === downloadPlanBuilder_1$1.OperationKind.DOWNLOAD) {
      ranges += `${task.start}-${task.end - 1}, `;
      partIndexToTaskIndex.set(partCount, i);
      partCount++;
      partIndexToLength.push(task.end - task.start);
    }
  }
  if (partCount <= 1) {
    const w = (index) => {
      if (index >= options.end) {
        resolve();
        return;
      }
      const task = options.tasks[index++];
      if (task.kind === downloadPlanBuilder_1$1.OperationKind.COPY) {
        (0, DataSplitter_1$1.copyData)(task, out2, options.oldFileFd, reject, () => w(index));
      } else {
        const requestOptions2 = differentialDownloader.createRequestOptions();
        requestOptions2.headers.Range = `bytes=${task.start}-${task.end - 1}`;
        const request2 = differentialDownloader.httpExecutor.createRequest(requestOptions2, (response) => {
          if (!checkIsRangesSupported(response, reject)) {
            return;
          }
          response.pipe(out2, {
            end: false
          });
          response.once("end", () => w(index));
        });
        differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request2, reject);
        request2.end();
      }
    };
    w(options.start);
    return;
  }
  const requestOptions = differentialDownloader.createRequestOptions();
  requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);
  const request = differentialDownloader.httpExecutor.createRequest(requestOptions, (response) => {
    if (!checkIsRangesSupported(response, reject)) {
      return;
    }
    const contentType = (0, builder_util_runtime_1$6.safeGetHeader)(response, "content-type");
    const m = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(contentType);
    if (m == null) {
      reject(new Error(`Content-Type "multipart/byteranges" is expected, but got "${contentType}"`));
      return;
    }
    const dicer = new DataSplitter_1$1.DataSplitter(out2, options, partIndexToTaskIndex, m[1] || m[2], partIndexToLength, resolve);
    dicer.on("error", reject);
    response.pipe(dicer);
    response.on("end", () => {
=======
  const u = e.createRequestOptions();
  u.headers.Range = a.substring(0, a.length - 2);
  const l = e.httpExecutor.createRequest(u, (p) => {
    if (!Kl(p, i))
      return;
    const f = (0, Xl.safeGetHeader)(p, "content-type"), m = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(f);
    if (m == null) {
      i(new Error(`Content-Type "multipart/byteranges" is expected, but got "${f}"`));
      return;
    }
    const g = new tm.DataSplitter(n, t, c, m[1] || m[2], o, r);
    g.on("error", i), p.pipe(g), p.on("end", () => {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      setTimeout(() => {
        request.abort();
        reject(new Error("Response ends without calling any handlers"));
      }, 1e4);
    });
  });
  differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
  request.end();
}
<<<<<<< HEAD
function checkIsRangesSupported(response, reject) {
  if (response.statusCode >= 400) {
    reject((0, builder_util_runtime_1$6.createHttpError)(response));
    return false;
=======
function Kl(e, t) {
  if (e.statusCode >= 400)
    return t((0, Xl.createHttpError)(e)), !1;
  if (e.statusCode !== 206) {
    const n = (0, Xl.safeGetHeader)(e, "accept-ranges");
    if (n == null || n === "none")
      return t(new Error(`Server doesn't support Accept-Ranges (response code ${e.statusCode})`)), !1;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  if (response.statusCode !== 206) {
    const acceptRanges = (0, builder_util_runtime_1$6.safeGetHeader)(response, "accept-ranges");
    if (acceptRanges == null || acceptRanges === "none") {
      reject(new Error(`Server doesn't support Accept-Ranges (response code ${response.statusCode})`));
      return false;
    }
  }
  return true;
}
<<<<<<< HEAD
var ProgressDifferentialDownloadCallbackTransform$1 = {};
Object.defineProperty(ProgressDifferentialDownloadCallbackTransform$1, "__esModule", { value: true });
ProgressDifferentialDownloadCallbackTransform$1.ProgressDifferentialDownloadCallbackTransform = void 0;
const stream_1 = require$$1$2;
var OperationKind;
(function(OperationKind2) {
  OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
  OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
})(OperationKind || (OperationKind = {}));
class ProgressDifferentialDownloadCallbackTransform extends stream_1.Transform {
  constructor(progressDifferentialDownloadInfo, cancellationToken, onProgress) {
    super();
    this.progressDifferentialDownloadInfo = progressDifferentialDownloadInfo;
    this.cancellationToken = cancellationToken;
    this.onProgress = onProgress;
    this.start = Date.now();
    this.transferred = 0;
    this.delta = 0;
    this.expectedBytes = 0;
    this.index = 0;
    this.operationType = OperationKind.COPY;
    this.nextUpdate = this.start + 1e3;
=======
var $o = {};
Object.defineProperty($o, "__esModule", { value: !0 });
$o.ProgressDifferentialDownloadCallbackTransform = void 0;
const w$ = ae;
var Er;
(function(e) {
  e[e.COPY = 0] = "COPY", e[e.DOWNLOAD = 1] = "DOWNLOAD";
})(Er || (Er = {}));
class E$ extends w$.Transform {
  constructor(t, n, r) {
    super(), this.progressDifferentialDownloadInfo = t, this.cancellationToken = n, this.onProgress = r, this.start = Date.now(), this.transferred = 0, this.delta = 0, this.expectedBytes = 0, this.index = 0, this.operationType = Er.COPY, this.nextUpdate = this.start + 1e3;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  _transform(chunk, encoding, callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"), null);
      return;
    }
<<<<<<< HEAD
    if (this.operationType == OperationKind.COPY) {
      callback(null, chunk);
=======
    if (this.operationType == Er.COPY) {
      r(null, t);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      return;
    }
    this.transferred += chunk.length;
    this.delta += chunk.length;
    const now = Date.now();
    if (now >= this.nextUpdate && this.transferred !== this.expectedBytes && this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
      this.nextUpdate = now + 1e3;
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
        bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))
      });
      this.delta = 0;
    }
    callback(null, chunk);
  }
  beginFileCopy() {
<<<<<<< HEAD
    this.operationType = OperationKind.COPY;
  }
  beginRangeDownload() {
    this.operationType = OperationKind.DOWNLOAD;
    this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];
=======
    this.operationType = Er.COPY;
  }
  beginRangeDownload() {
    this.operationType = Er.DOWNLOAD, this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  endRangeDownload() {
    if (this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
        bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
      });
    }
  }
  // Called when we are 100% done with the connection/download
  _flush(callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
    this.delta = 0;
    this.transferred = 0;
    callback(null);
  }
}
<<<<<<< HEAD
ProgressDifferentialDownloadCallbackTransform$1.ProgressDifferentialDownloadCallbackTransform = ProgressDifferentialDownloadCallbackTransform;
Object.defineProperty(DifferentialDownloader$1, "__esModule", { value: true });
DifferentialDownloader$1.DifferentialDownloader = void 0;
const builder_util_runtime_1$5 = out;
const fs_extra_1$5 = lib;
const fs_1$2 = fs$w;
const DataSplitter_1 = DataSplitter$1;
const url_1$1 = require$$0$3;
const downloadPlanBuilder_1 = downloadPlanBuilder;
const multipleRangeDownloader_1 = multipleRangeDownloader;
const ProgressDifferentialDownloadCallbackTransform_1 = ProgressDifferentialDownloadCallbackTransform$1;
class DifferentialDownloader {
=======
$o.ProgressDifferentialDownloadCallbackTransform = E$;
Object.defineProperty(aa, "__esModule", { value: !0 });
aa.DifferentialDownloader = void 0;
const ii = Fe, pl = yn, _$ = se, S$ = Hr, A$ = $t, za = Qn, rm = Ro, T$ = $o;
class C$ {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
  constructor(blockAwareFileInfo, httpExecutor2, options) {
    this.blockAwareFileInfo = blockAwareFileInfo;
    this.httpExecutor = httpExecutor2;
    this.options = options;
    this.fileMetadataBuffer = null;
    this.logger = options.logger;
  }
  createRequestOptions() {
    const result = {
      headers: {
        ...this.options.requestHeaders,
        accept: "*/*"
      }
    };
<<<<<<< HEAD
    (0, builder_util_runtime_1$5.configureRequestUrl)(this.options.newUrl, result);
    (0, builder_util_runtime_1$5.configureRequestOptions)(result);
    return result;
  }
  doDownload(oldBlockMap, newBlockMap) {
    if (oldBlockMap.version !== newBlockMap.version) {
      throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);
    }
    const logger = this.logger;
    const operations = (0, downloadPlanBuilder_1.computeOperations)(oldBlockMap, newBlockMap, logger);
    if (logger.debug != null) {
      logger.debug(JSON.stringify(operations, null, 2));
    }
    let downloadSize = 0;
    let copySize = 0;
    for (const operation of operations) {
      const length = operation.end - operation.start;
      if (operation.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
        downloadSize += length;
      } else {
        copySize += length;
      }
    }
    const newSize = this.blockAwareFileInfo.size;
    if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== newSize) {
      throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newSize: ${newSize}`);
    }
    logger.info(`Full: ${formatBytes(newSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newSize / 100))}%)`);
    return this.downloadFile(operations);
  }
  downloadFile(tasks) {
    const fdList = [];
    const closeFiles = () => {
      return Promise.all(fdList.map((openedFile) => {
        return (0, fs_extra_1$5.close)(openedFile.descriptor).catch((e) => {
          this.logger.error(`cannot close file "${openedFile.path}": ${e}`);
        });
      }));
    };
    return this.doDownloadFile(tasks, fdList).then(closeFiles).catch((e) => {
      return closeFiles().catch((closeFilesError) => {
        try {
          this.logger.error(`cannot close files: ${closeFilesError}`);
        } catch (errorOnLog) {
=======
    return (0, ii.configureRequestUrl)(this.options.newUrl, t), (0, ii.configureRequestOptions)(t), t;
  }
  doDownload(t, n) {
    if (t.version !== n.version)
      throw new Error(`version is different (${t.version} - ${n.version}), full download is required`);
    const r = this.logger, i = (0, za.computeOperations)(t, n, r);
    r.debug != null && r.debug(JSON.stringify(i, null, 2));
    let a = 0, s = 0;
    for (const o of i) {
      const u = o.end - o.start;
      o.kind === za.OperationKind.DOWNLOAD ? a += u : s += u;
    }
    const c = this.blockAwareFileInfo.size;
    if (a + s + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== c)
      throw new Error(`Internal error, size mismatch: downloadSize: ${a}, copySize: ${s}, newSize: ${c}`);
    return r.info(`Full: ${im(c)}, To download: ${im(a)} (${Math.round(a / (c / 100))}%)`), this.downloadFile(i);
  }
  downloadFile(t) {
    const n = [], r = () => Promise.all(n.map((i) => (0, pl.close)(i.descriptor).catch((a) => {
      this.logger.error(`cannot close file "${i.path}": ${a}`);
    })));
    return this.doDownloadFile(t, n).then(r).catch((i) => r().catch((a) => {
      try {
        this.logger.error(`cannot close files: ${a}`);
      } catch (s) {
        try {
          console.error(s);
        } catch {
        }
      }
      throw i;
    }).then(() => {
      throw i;
    }));
  }
  async doDownloadFile(t, n) {
    const r = await (0, pl.open)(this.options.oldFile, "r");
    n.push({ descriptor: r, path: this.options.oldFile });
    const i = await (0, pl.open)(this.options.newFile, "w");
    n.push({ descriptor: i, path: this.options.newFile });
    const a = (0, _$.createWriteStream)(this.options.newFile, { fd: i });
    await new Promise((s, c) => {
      const o = [];
      let u;
      if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
        const x = [];
        let y = 0;
        for (const S of t)
          S.kind === za.OperationKind.DOWNLOAD && (x.push(S.end - S.start), y += S.end - S.start);
        const E = {
          expectedByteCounts: x,
          grandTotal: y
        };
        u = new T$.ProgressDifferentialDownloadCallbackTransform(E, this.options.cancellationToken, this.options.onProgress), o.push(u);
      }
      const l = new ii.DigestTransform(this.blockAwareFileInfo.sha512);
      l.isValidateOnEnd = !1, o.push(l), a.on("finish", () => {
        a.close(() => {
          n.splice(1, 1);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          try {
            console.error(errorOnLog);
          } catch (_ignored) {
          }
        }
        throw e;
      }).then(() => {
        throw e;
      });
    });
  }
  async doDownloadFile(tasks, fdList) {
    const oldFileFd = await (0, fs_extra_1$5.open)(this.options.oldFile, "r");
    fdList.push({ descriptor: oldFileFd, path: this.options.oldFile });
    const newFileFd = await (0, fs_extra_1$5.open)(this.options.newFile, "w");
    fdList.push({ descriptor: newFileFd, path: this.options.newFile });
    const fileOut = (0, fs_1$2.createWriteStream)(this.options.newFile, { fd: newFileFd });
    await new Promise((resolve, reject) => {
      const streams2 = [];
      let downloadInfoTransform = void 0;
      if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
        const expectedByteCounts = [];
        let grandTotalBytes = 0;
        for (const task of tasks) {
          if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
            expectedByteCounts.push(task.end - task.start);
            grandTotalBytes += task.end - task.start;
          }
        }
        const progressDifferentialDownloadInfo = {
          expectedByteCounts,
          grandTotal: grandTotalBytes
        };
        downloadInfoTransform = new ProgressDifferentialDownloadCallbackTransform_1.ProgressDifferentialDownloadCallbackTransform(progressDifferentialDownloadInfo, this.options.cancellationToken, this.options.onProgress);
        streams2.push(downloadInfoTransform);
      }
      const digestTransform = new builder_util_runtime_1$5.DigestTransform(this.blockAwareFileInfo.sha512);
      digestTransform.isValidateOnEnd = false;
      streams2.push(digestTransform);
      fileOut.on("finish", () => {
        fileOut.close(() => {
          fdList.splice(1, 1);
          try {
            digestTransform.validate();
          } catch (e) {
            reject(e);
            return;
          }
<<<<<<< HEAD
          resolve(void 0);
        });
      });
      streams2.push(fileOut);
      let lastStream = null;
      for (const stream2 of streams2) {
        stream2.on("error", reject);
        if (lastStream == null) {
          lastStream = stream2;
        } else {
          lastStream = lastStream.pipe(stream2);
        }
      }
      const firstStream = streams2[0];
      let w;
      if (this.options.isUseMultipleRangeRequest) {
        w = (0, multipleRangeDownloader_1.executeTasksUsingMultipleRangeRequests)(this, tasks, firstStream, oldFileFd, reject);
        w(0);
        return;
      }
      let downloadOperationCount = 0;
      let actualUrl = null;
      this.logger.info(`Differential download: ${this.options.newUrl}`);
      const requestOptions = this.createRequestOptions();
      requestOptions.redirect = "manual";
      w = (index) => {
        var _a, _b;
        if (index >= tasks.length) {
          if (this.fileMetadataBuffer != null) {
            firstStream.write(this.fileMetadataBuffer);
          }
          firstStream.end();
          return;
        }
        const operation = tasks[index++];
        if (operation.kind === downloadPlanBuilder_1.OperationKind.COPY) {
          if (downloadInfoTransform) {
            downloadInfoTransform.beginFileCopy();
          }
          (0, DataSplitter_1.copyData)(operation, firstStream, oldFileFd, reject, () => w(index));
          return;
        }
        const range2 = `bytes=${operation.start}-${operation.end - 1}`;
        requestOptions.headers.range = range2;
        (_b = (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, `download range: ${range2}`);
        if (downloadInfoTransform) {
          downloadInfoTransform.beginRangeDownload();
        }
        const request = this.httpExecutor.createRequest(requestOptions, (response) => {
          response.on("error", reject);
          response.on("aborted", () => {
            reject(new Error("response has been aborted by the server"));
          });
          if (response.statusCode >= 400) {
            reject((0, builder_util_runtime_1$5.createHttpError)(response));
          }
          response.pipe(firstStream, {
            end: false
          });
          response.once("end", () => {
            if (downloadInfoTransform) {
              downloadInfoTransform.endRangeDownload();
            }
            if (++downloadOperationCount === 100) {
              downloadOperationCount = 0;
              setTimeout(() => w(index), 1e3);
            } else {
              w(index);
            }
          });
        });
        request.on("redirect", (statusCode, method, redirectUrl) => {
          this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);
          actualUrl = redirectUrl;
          (0, builder_util_runtime_1$5.configureRequestUrl)(new url_1$1.URL(actualUrl), requestOptions);
          request.followRedirect();
        });
        this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
        request.end();
      };
      w(0);
    });
  }
  async readRemoteBytes(start, endInclusive) {
    const buffer2 = Buffer.allocUnsafe(endInclusive + 1 - start);
    const requestOptions = this.createRequestOptions();
    requestOptions.headers.range = `bytes=${start}-${endInclusive}`;
    let position = 0;
    await this.request(requestOptions, (chunk) => {
      chunk.copy(buffer2, position);
      position += chunk.length;
    });
    if (position !== buffer2.length) {
      throw new Error(`Received data length ${position} is not equal to expected ${buffer2.length}`);
    }
    return buffer2;
  }
  request(requestOptions, dataHandler) {
    return new Promise((resolve, reject) => {
      const request = this.httpExecutor.createRequest(requestOptions, (response) => {
        if (!(0, multipleRangeDownloader_1.checkIsRangesSupported)(response, reject)) {
          return;
        }
        response.on("error", reject);
        response.on("aborted", () => {
          reject(new Error("response has been aborted by the server"));
        });
        response.on("data", dataHandler);
        response.on("end", () => resolve());
=======
          s(void 0);
        });
      }), o.push(a);
      let p = null;
      for (const x of o)
        x.on("error", c), p == null ? p = x : p = p.pipe(x);
      const f = o[0];
      let m;
      if (this.options.isUseMultipleRangeRequest) {
        m = (0, rm.executeTasksUsingMultipleRangeRequests)(this, t, f, r, c), m(0);
        return;
      }
      let g = 0, h = null;
      this.logger.info(`Differential download: ${this.options.newUrl}`);
      const b = this.createRequestOptions();
      b.redirect = "manual", m = (x) => {
        var y, E;
        if (x >= t.length) {
          this.fileMetadataBuffer != null && f.write(this.fileMetadataBuffer), f.end();
          return;
        }
        const S = t[x++];
        if (S.kind === za.OperationKind.COPY) {
          u && u.beginFileCopy(), (0, S$.copyData)(S, f, r, c, () => m(x));
          return;
        }
        const D = `bytes=${S.start}-${S.end - 1}`;
        b.headers.range = D, (E = (y = this.logger) === null || y === void 0 ? void 0 : y.debug) === null || E === void 0 || E.call(y, `download range: ${D}`), u && u.beginRangeDownload();
        const U = this.httpExecutor.createRequest(b, (z) => {
          z.on("error", c), z.on("aborted", () => {
            c(new Error("response has been aborted by the server"));
          }), z.statusCode >= 400 && c((0, ii.createHttpError)(z)), z.pipe(f, {
            end: !1
          }), z.once("end", () => {
            u && u.endRangeDownload(), ++g === 100 ? (g = 0, setTimeout(() => m(x), 1e3)) : m(x);
          });
        });
        U.on("redirect", (z, ee, C) => {
          this.logger.info(`Redirect to ${R$(C)}`), h = C, (0, ii.configureRequestUrl)(new A$.URL(h), b), U.followRedirect();
        }), this.httpExecutor.addErrorAndTimeoutHandlers(U, c), U.end();
      }, m(0);
    });
  }
  async readRemoteBytes(t, n) {
    const r = Buffer.allocUnsafe(n + 1 - t), i = this.createRequestOptions();
    i.headers.range = `bytes=${t}-${n}`;
    let a = 0;
    if (await this.request(i, (s) => {
      s.copy(r, a), a += s.length;
    }), a !== r.length)
      throw new Error(`Received data length ${a} is not equal to expected ${r.length}`);
    return r;
  }
  request(t, n) {
    return new Promise((r, i) => {
      const a = this.httpExecutor.createRequest(t, (s) => {
        (0, rm.checkIsRangesSupported)(s, i) && (s.on("error", i), s.on("aborted", () => {
          i(new Error("response has been aborted by the server"));
        }), s.on("data", n), s.on("end", () => r()));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      });
      this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
      request.end();
    });
  }
}
<<<<<<< HEAD
DifferentialDownloader$1.DifferentialDownloader = DifferentialDownloader;
function formatBytes(value, symbol = " KB") {
  return new Intl.NumberFormat("en").format((value / 1024).toFixed(2)) + symbol;
}
function removeQuery(url2) {
  const index = url2.indexOf("?");
  return index < 0 ? url2 : url2.substring(0, index);
}
Object.defineProperty(GenericDifferentialDownloader$1, "__esModule", { value: true });
GenericDifferentialDownloader$1.GenericDifferentialDownloader = void 0;
const DifferentialDownloader_1$1 = DifferentialDownloader$1;
class GenericDifferentialDownloader extends DifferentialDownloader_1$1.DifferentialDownloader {
  download(oldBlockMap, newBlockMap) {
    return this.doDownload(oldBlockMap, newBlockMap);
  }
}
GenericDifferentialDownloader$1.GenericDifferentialDownloader = GenericDifferentialDownloader;
var types = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdaterSignal = exports.UPDATE_DOWNLOADED = exports.DOWNLOAD_PROGRESS = exports.CancellationToken = void 0;
  exports.addHandler = addHandler;
  const builder_util_runtime_12 = out;
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return builder_util_runtime_12.CancellationToken;
  } });
  exports.DOWNLOAD_PROGRESS = "download-progress";
  exports.UPDATE_DOWNLOADED = "update-downloaded";
  class UpdaterSignal {
    constructor(emitter) {
      this.emitter = emitter;
=======
aa.DifferentialDownloader = C$;
function im(e, t = " KB") {
  return new Intl.NumberFormat("en").format((e / 1024).toFixed(2)) + t;
}
function R$(e) {
  const t = e.indexOf("?");
  return t < 0 ? e : e.substring(0, t);
}
Object.defineProperty(Co, "__esModule", { value: !0 });
Co.GenericDifferentialDownloader = void 0;
const $$ = aa;
class O$ extends $$.DifferentialDownloader {
  download(t, n) {
    return this.doDownload(t, n);
  }
}
Co.GenericDifferentialDownloader = O$;
var wn = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.UpdaterSignal = e.UPDATE_DOWNLOADED = e.DOWNLOAD_PROGRESS = e.CancellationToken = void 0, e.addHandler = r;
  const t = Fe;
  Object.defineProperty(e, "CancellationToken", { enumerable: !0, get: function() {
    return t.CancellationToken;
  } }), e.DOWNLOAD_PROGRESS = "download-progress", e.UPDATE_DOWNLOADED = "update-downloaded";
  class n {
    constructor(a) {
      this.emitter = a;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    /**
     * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).
     */
    login(handler) {
      addHandler(this.emitter, "login", handler);
    }
    progress(handler) {
      addHandler(this.emitter, exports.DOWNLOAD_PROGRESS, handler);
    }
    updateDownloaded(handler) {
      addHandler(this.emitter, exports.UPDATE_DOWNLOADED, handler);
    }
    updateCancelled(handler) {
      addHandler(this.emitter, "update-cancelled", handler);
    }
  }
<<<<<<< HEAD
  exports.UpdaterSignal = UpdaterSignal;
  function addHandler(emitter, event, handler) {
    {
      emitter.on(event, handler);
    }
  }
})(types);
Object.defineProperty(AppUpdater$1, "__esModule", { value: true });
AppUpdater$1.NoOpLogger = AppUpdater$1.AppUpdater = void 0;
const builder_util_runtime_1$4 = out;
const crypto_1$1 = require$$0$4;
const os_1 = require$$2$2;
const events_1 = require$$0$6;
const fs_extra_1$4 = lib;
const js_yaml_1 = jsYaml;
const lazy_val_1 = main;
const path$4 = require$$1$4;
const semver_1 = semver$1;
const DownloadedUpdateHelper_1 = DownloadedUpdateHelper$1;
const ElectronAppAdapter_1 = ElectronAppAdapter$1;
const electronHttpExecutor_1 = electronHttpExecutor;
const GenericProvider_1 = GenericProvider$1;
const providerFactory_1 = providerFactory;
const zlib_1$1 = zlib$4;
const util_1 = util;
const GenericDifferentialDownloader_1 = GenericDifferentialDownloader$1;
const types_1$5 = types;
class AppUpdater extends events_1.EventEmitter {
=======
  e.UpdaterSignal = n;
  function r(i, a, s) {
    i.on(a, s);
  }
})(wn);
Object.defineProperty(fn, "__esModule", { value: !0 });
fn.NoOpLogger = fn.AppUpdater = void 0;
const ze = Fe, I$ = Ur, D$ = $s, F$ = Yn, cr = yn, P$ = Ue, fl = vo, On = ne, Dn = qg, am = ra, k$ = Eo, sm = zg, L$ = ia, dl = _o, N$ = et, U$ = ut, B$ = Co, lr = wn;
class hp extends F$.EventEmitter {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  /**
   * Get the update channel. Doesn't return `channel` from the update configuration, only if was previously set.
   */
  get channel() {
    return this._channel;
  }
  /**
   * Set the update channel. Overrides `channel` in the update configuration.
   *
   * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.
   */
  set channel(value) {
    if (this._channel != null) {
      if (typeof value !== "string") {
        throw (0, builder_util_runtime_1$4.newError)(`Channel must be a string, but got: ${value}`, "ERR_UPDATER_INVALID_CHANNEL");
      } else if (value.length === 0) {
        throw (0, builder_util_runtime_1$4.newError)(`Channel must be not an empty string`, "ERR_UPDATER_INVALID_CHANNEL");
      }
    }
    this._channel = value;
    this.allowDowngrade = true;
  }
  /**
   *  Shortcut for explicitly adding auth tokens to request headers
   */
  addAuthHeader(token) {
    this.requestHeaders = Object.assign({}, this.requestHeaders, {
      authorization: token
    });
  }
  // noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
  get netSession() {
<<<<<<< HEAD
    return (0, electronHttpExecutor_1.getNetSession)();
=======
    return (0, sm.getNetSession)();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  /**
   * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.
   * Set it to `null` if you would like to disable a logging feature.
   */
  get logger() {
    return this._logger;
  }
<<<<<<< HEAD
  set logger(value) {
    this._logger = value == null ? new NoOpLogger() : value;
=======
  set logger(t) {
    this._logger = t ?? new Jg();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  // noinspection JSUnusedGlobalSymbols
  /**
   * test only
   * @private
   */
<<<<<<< HEAD
  set updateConfigPath(value) {
    this.clientPromise = null;
    this._appUpdateConfigPath = value;
    this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
=======
  set updateConfigPath(t) {
    this.clientPromise = null, this._appUpdateConfigPath = t, this.configOnDisk = new fl.Lazy(() => this.loadUpdateConfig());
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  /**
   * Allows developer to override default logic for determining if an update is supported.
   * The default logic compares the `UpdateInfo` minimum system version against the `os.release()` with `semver` package
   */
  get isUpdateSupported() {
    return this._isUpdateSupported;
  }
  set isUpdateSupported(value) {
    if (value) {
      this._isUpdateSupported = value;
    }
  }
<<<<<<< HEAD
  constructor(options, app2) {
    super();
    this.autoDownload = true;
    this.autoInstallOnAppQuit = true;
    this.autoRunAppAfterInstall = true;
    this.allowPrerelease = false;
    this.fullChangelog = false;
    this.allowDowngrade = false;
    this.disableWebInstaller = false;
    this.disableDifferentialDownload = false;
    this.forceDevUpdateConfig = false;
    this._channel = null;
    this.downloadedUpdateHelper = null;
    this.requestHeaders = null;
    this._logger = console;
    this.signals = new types_1$5.UpdaterSignal(this);
    this._appUpdateConfigPath = null;
    this._isUpdateSupported = (updateInfo) => this.checkIfUpdateSupported(updateInfo);
    this.clientPromise = null;
    this.stagingUserIdPromise = new lazy_val_1.Lazy(() => this.getOrCreateStagingUserId());
    this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
    this.checkForUpdatesPromise = null;
    this.downloadPromise = null;
    this.updateInfoAndProvider = null;
    this._testOnlyOptions = null;
    this.on("error", (error2) => {
      this._logger.error(`Error: ${error2.stack || error2.message}`);
    });
    if (app2 == null) {
      this.app = new ElectronAppAdapter_1.ElectronAppAdapter();
      this.httpExecutor = new electronHttpExecutor_1.ElectronHttpExecutor((authInfo, callback) => this.emit("login", authInfo, callback));
    } else {
      this.app = app2;
      this.httpExecutor = null;
    }
    const currentVersionString = this.app.version;
    const currentVersion = (0, semver_1.parse)(currentVersionString);
    if (currentVersion == null) {
      throw (0, builder_util_runtime_1$4.newError)(`App version is not a valid semver version: "${currentVersionString}"`, "ERR_UPDATER_INVALID_VERSION");
    }
    this.currentVersion = currentVersion;
    this.allowPrerelease = hasPrereleaseComponents(currentVersion);
    if (options != null) {
      this.setFeedURL(options);
      if (typeof options !== "string" && options.requestHeaders) {
        this.requestHeaders = options.requestHeaders;
      }
    }
=======
  constructor(t, n) {
    super(), this.autoDownload = !0, this.autoInstallOnAppQuit = !0, this.autoRunAppAfterInstall = !0, this.allowPrerelease = !1, this.fullChangelog = !1, this.allowDowngrade = !1, this.disableWebInstaller = !1, this.disableDifferentialDownload = !1, this.forceDevUpdateConfig = !1, this._channel = null, this.downloadedUpdateHelper = null, this.requestHeaders = null, this._logger = console, this.signals = new lr.UpdaterSignal(this), this._appUpdateConfigPath = null, this._isUpdateSupported = (a) => this.checkIfUpdateSupported(a), this.clientPromise = null, this.stagingUserIdPromise = new fl.Lazy(() => this.getOrCreateStagingUserId()), this.configOnDisk = new fl.Lazy(() => this.loadUpdateConfig()), this.checkForUpdatesPromise = null, this.downloadPromise = null, this.updateInfoAndProvider = null, this._testOnlyOptions = null, this.on("error", (a) => {
      this._logger.error(`Error: ${a.stack || a.message}`);
    }), n == null ? (this.app = new k$.ElectronAppAdapter(), this.httpExecutor = new sm.ElectronHttpExecutor((a, s) => this.emit("login", a, s))) : (this.app = n, this.httpExecutor = null);
    const r = this.app.version, i = (0, Dn.parse)(r);
    if (i == null)
      throw (0, ze.newError)(`App version is not a valid semver version: "${r}"`, "ERR_UPDATER_INVALID_VERSION");
    this.currentVersion = i, this.allowPrerelease = j$(i), t != null && (this.setFeedURL(t), typeof t != "string" && t.requestHeaders && (this.requestHeaders = t.requestHeaders));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
  getFeedURL() {
    return "Deprecated. Do not use it.";
  }
  /**
   * Configure update provider. If value is `string`, [GenericServerOptions](./publish.md#genericserveroptions) will be set with value as `url`.
   * @param options If you want to override configuration in the `app-update.yml`.
   */
<<<<<<< HEAD
  setFeedURL(options) {
    const runtimeOptions = this.createProviderRuntimeOptions();
    let provider;
    if (typeof options === "string") {
      provider = new GenericProvider_1.GenericProvider({ provider: "generic", url: options }, this, {
        ...runtimeOptions,
        isUseMultipleRangeRequest: (0, providerFactory_1.isUrlProbablySupportMultiRangeRequests)(options)
      });
    } else {
      provider = (0, providerFactory_1.createClient)(options, this, runtimeOptions);
    }
    this.clientPromise = Promise.resolve(provider);
=======
  setFeedURL(t) {
    const n = this.createProviderRuntimeOptions();
    let r;
    typeof t == "string" ? r = new L$.GenericProvider({ provider: "generic", url: t }, this, {
      ...n,
      isUseMultipleRangeRequest: (0, dl.isUrlProbablySupportMultiRangeRequests)(t)
    }) : r = (0, dl.createClient)(t, this, n), this.clientPromise = Promise.resolve(r);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  /**
   * Asks the server whether there is an update.
   * @returns null if the updater is disabled, otherwise info about the latest version
   */
  checkForUpdates() {
    if (!this.isUpdaterActive()) {
      return Promise.resolve(null);
    }
    let checkForUpdatesPromise = this.checkForUpdatesPromise;
    if (checkForUpdatesPromise != null) {
      this._logger.info("Checking for update (already in progress)");
      return checkForUpdatesPromise;
    }
    const nullizePromise = () => this.checkForUpdatesPromise = null;
    this._logger.info("Checking for update");
    checkForUpdatesPromise = this.doCheckForUpdates().then((it) => {
      nullizePromise();
      return it;
    }).catch((e) => {
      nullizePromise();
      this.emit("error", e, `Cannot check for updates: ${(e.stack || e).toString()}`);
      throw e;
    });
    this.checkForUpdatesPromise = checkForUpdatesPromise;
    return checkForUpdatesPromise;
  }
  isUpdaterActive() {
    const isEnabled = this.app.isPackaged || this.forceDevUpdateConfig;
    if (!isEnabled) {
      this._logger.info("Skip checkForUpdates because application is not packed and dev update config is not forced");
      return false;
    }
    return true;
  }
  // noinspection JSUnusedGlobalSymbols
<<<<<<< HEAD
  checkForUpdatesAndNotify(downloadNotification) {
    return this.checkForUpdates().then((it) => {
      if (!(it === null || it === void 0 ? void 0 : it.downloadPromise)) {
        if (this._logger.debug != null) {
          this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null");
        }
        return it;
      }
      void it.downloadPromise.then(() => {
        const notificationContent = AppUpdater.formatDownloadNotification(it.updateInfo.version, this.app.name, downloadNotification);
        new require$$1$8.Notification(notificationContent).show();
      });
      return it;
    });
  }
  static formatDownloadNotification(version, appName, downloadNotification) {
    if (downloadNotification == null) {
      downloadNotification = {
        title: "A new update is ready to install",
        body: `{appName} version {version} has been downloaded and will be automatically installed on exit`
      };
    }
    downloadNotification = {
      title: downloadNotification.title.replace("{appName}", appName).replace("{version}", version),
      body: downloadNotification.body.replace("{appName}", appName).replace("{version}", version)
    };
    return downloadNotification;
  }
  async isStagingMatch(updateInfo) {
    const rawStagingPercentage = updateInfo.stagingPercentage;
    let stagingPercentage = rawStagingPercentage;
    if (stagingPercentage == null) {
      return true;
    }
    stagingPercentage = parseInt(stagingPercentage, 10);
    if (isNaN(stagingPercentage)) {
      this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);
      return true;
    }
    stagingPercentage = stagingPercentage / 100;
    const stagingUserId = await this.stagingUserIdPromise.value;
    const val = builder_util_runtime_1$4.UUID.parse(stagingUserId).readUInt32BE(12);
    const percentage = val / 4294967295;
    this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);
    return percentage < stagingPercentage;
  }
  computeFinalHeaders(headers2) {
    if (this.requestHeaders != null) {
      Object.assign(headers2, this.requestHeaders);
    }
    return headers2;
  }
  async isUpdateAvailable(updateInfo) {
    const latestVersion = (0, semver_1.parse)(updateInfo.version);
    if (latestVersion == null) {
      throw (0, builder_util_runtime_1$4.newError)(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${updateInfo.version}"`, "ERR_UPDATER_INVALID_VERSION");
    }
    const currentVersion = this.currentVersion;
    if ((0, semver_1.eq)(latestVersion, currentVersion)) {
      return false;
    }
    if (!await Promise.resolve(this.isUpdateSupported(updateInfo))) {
      return false;
    }
    const isStagingMatch = await this.isStagingMatch(updateInfo);
    if (!isStagingMatch) {
      return false;
    }
    const isLatestVersionNewer = (0, semver_1.gt)(latestVersion, currentVersion);
    const isLatestVersionOlder = (0, semver_1.lt)(latestVersion, currentVersion);
    if (isLatestVersionNewer) {
      return true;
    }
    return this.allowDowngrade && isLatestVersionOlder;
  }
  checkIfUpdateSupported(updateInfo) {
    const minimumSystemVersion = updateInfo === null || updateInfo === void 0 ? void 0 : updateInfo.minimumSystemVersion;
    const currentOSVersion = (0, os_1.release)();
    if (minimumSystemVersion) {
      try {
        if ((0, semver_1.lt)(currentOSVersion, minimumSystemVersion)) {
          this._logger.info(`Current OS version ${currentOSVersion} is less than the minimum OS version required ${minimumSystemVersion} for version ${currentOSVersion}`);
          return false;
        }
      } catch (e) {
        this._logger.warn(`Failed to compare current OS version(${currentOSVersion}) with minimum OS version(${minimumSystemVersion}): ${(e.message || e).toString()}`);
      }
    }
    return true;
  }
  async getUpdateInfoAndProvider() {
    await this.app.whenReady();
    if (this.clientPromise == null) {
      this.clientPromise = this.configOnDisk.value.then((it) => (0, providerFactory_1.createClient)(it, this, this.createProviderRuntimeOptions()));
    }
    const client = await this.clientPromise;
    const stagingUserId = await this.stagingUserIdPromise.value;
    client.setRequestHeaders(this.computeFinalHeaders({ "x-user-staging-id": stagingUserId }));
    return {
      info: await client.getLatestVersion(),
      provider: client
=======
  checkForUpdatesAndNotify(t) {
    return this.checkForUpdates().then((n) => n != null && n.downloadPromise ? (n.downloadPromise.then(() => {
      const r = hp.formatDownloadNotification(n.updateInfo.version, this.app.name, t);
      new zn.Notification(r).show();
    }), n) : (this._logger.debug != null && this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null"), n));
  }
  static formatDownloadNotification(t, n, r) {
    return r == null && (r = {
      title: "A new update is ready to install",
      body: "{appName} version {version} has been downloaded and will be automatically installed on exit"
    }), r = {
      title: r.title.replace("{appName}", n).replace("{version}", t),
      body: r.body.replace("{appName}", n).replace("{version}", t)
    }, r;
  }
  async isStagingMatch(t) {
    const n = t.stagingPercentage;
    let r = n;
    if (r == null)
      return !0;
    if (r = parseInt(r, 10), isNaN(r))
      return this._logger.warn(`Staging percentage is NaN: ${n}`), !0;
    r = r / 100;
    const i = await this.stagingUserIdPromise.value, s = ze.UUID.parse(i).readUInt32BE(12) / 4294967295;
    return this._logger.info(`Staging percentage: ${r}, percentage: ${s}, user id: ${i}`), s < r;
  }
  computeFinalHeaders(t) {
    return this.requestHeaders != null && Object.assign(t, this.requestHeaders), t;
  }
  async isUpdateAvailable(t) {
    const n = (0, Dn.parse)(t.version);
    if (n == null)
      throw (0, ze.newError)(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${t.version}"`, "ERR_UPDATER_INVALID_VERSION");
    const r = this.currentVersion;
    if ((0, Dn.eq)(n, r) || !await Promise.resolve(this.isUpdateSupported(t)) || !await this.isStagingMatch(t))
      return !1;
    const a = (0, Dn.gt)(n, r), s = (0, Dn.lt)(n, r);
    return a ? !0 : this.allowDowngrade && s;
  }
  checkIfUpdateSupported(t) {
    const n = t == null ? void 0 : t.minimumSystemVersion, r = (0, D$.release)();
    if (n)
      try {
        if ((0, Dn.lt)(r, n))
          return this._logger.info(`Current OS version ${r} is less than the minimum OS version required ${n} for version ${r}`), !1;
      } catch (i) {
        this._logger.warn(`Failed to compare current OS version(${r}) with minimum OS version(${n}): ${(i.message || i).toString()}`);
      }
    return !0;
  }
  async getUpdateInfoAndProvider() {
    await this.app.whenReady(), this.clientPromise == null && (this.clientPromise = this.configOnDisk.value.then((r) => (0, dl.createClient)(r, this, this.createProviderRuntimeOptions())));
    const t = await this.clientPromise, n = await this.stagingUserIdPromise.value;
    return t.setRequestHeaders(this.computeFinalHeaders({ "x-user-staging-id": n })), {
      info: await t.getLatestVersion(),
      provider: t
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    };
  }
  createProviderRuntimeOptions() {
    return {
      isUseMultipleRangeRequest: true,
      platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,
      executor: this.httpExecutor
    };
  }
  async doCheckForUpdates() {
    this.emit("checking-for-update");
    const result = await this.getUpdateInfoAndProvider();
    const updateInfo = result.info;
    if (!await this.isUpdateAvailable(updateInfo)) {
      this._logger.info(`Update for version ${this.currentVersion.format()} is not available (latest version: ${updateInfo.version}, downgrade is ${this.allowDowngrade ? "allowed" : "disallowed"}).`);
      this.emit("update-not-available", updateInfo);
      return {
        isUpdateAvailable: false,
        versionInfo: updateInfo,
        updateInfo
      };
    }
    this.updateInfoAndProvider = result;
    this.onUpdateAvailable(updateInfo);
    const cancellationToken = new builder_util_runtime_1$4.CancellationToken();
    return {
      isUpdateAvailable: true,
      versionInfo: updateInfo,
      updateInfo,
      cancellationToken,
      downloadPromise: this.autoDownload ? this.downloadUpdate(cancellationToken) : null
    };
  }
  onUpdateAvailable(updateInfo) {
    this._logger.info(`Found version ${updateInfo.version} (url: ${(0, builder_util_runtime_1$4.asArray)(updateInfo.files).map((it) => it.url).join(", ")})`);
    this.emit("update-available", updateInfo);
  }
  /**
   * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.
   * @returns {Promise<Array<string>>} Paths to downloaded files.
   */
  downloadUpdate(cancellationToken = new builder_util_runtime_1$4.CancellationToken()) {
    const updateInfoAndProvider = this.updateInfoAndProvider;
    if (updateInfoAndProvider == null) {
      const error2 = new Error("Please check update first");
      this.dispatchError(error2);
      return Promise.reject(error2);
    }
    if (this.downloadPromise != null) {
      this._logger.info("Downloading update (already in progress)");
      return this.downloadPromise;
    }
    this._logger.info(`Downloading update from ${(0, builder_util_runtime_1$4.asArray)(updateInfoAndProvider.info.files).map((it) => it.url).join(", ")}`);
    const errorHandler = (e) => {
      if (!(e instanceof builder_util_runtime_1$4.CancellationError)) {
        try {
          this.dispatchError(e);
        } catch (nestedError) {
          this._logger.warn(`Cannot dispatch error event: ${nestedError.stack || nestedError}`);
        }
      }
      return e;
    };
    this.downloadPromise = this.doDownloadUpdate({
      updateInfoAndProvider,
      requestHeaders: this.computeRequestHeaders(updateInfoAndProvider.provider),
      cancellationToken,
      disableWebInstaller: this.disableWebInstaller,
      disableDifferentialDownload: this.disableDifferentialDownload
    }).catch((e) => {
      throw errorHandler(e);
    }).finally(() => {
      this.downloadPromise = null;
    });
    return this.downloadPromise;
  }
  dispatchError(e) {
    this.emit("error", e, (e.stack || e).toString());
  }
<<<<<<< HEAD
  dispatchUpdateDownloaded(event) {
    this.emit(types_1$5.UPDATE_DOWNLOADED, event);
  }
  async loadUpdateConfig() {
    if (this._appUpdateConfigPath == null) {
      this._appUpdateConfigPath = this.app.appUpdateConfigPath;
    }
    return (0, js_yaml_1.load)(await (0, fs_extra_1$4.readFile)(this._appUpdateConfigPath, "utf-8"));
=======
  dispatchUpdateDownloaded(t) {
    this.emit(lr.UPDATE_DOWNLOADED, t);
  }
  async loadUpdateConfig() {
    return this._appUpdateConfigPath == null && (this._appUpdateConfigPath = this.app.appUpdateConfigPath), (0, P$.load)(await (0, cr.readFile)(this._appUpdateConfigPath, "utf-8"));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  computeRequestHeaders(provider) {
    const fileExtraDownloadHeaders = provider.fileExtraDownloadHeaders;
    if (fileExtraDownloadHeaders != null) {
      const requestHeaders = this.requestHeaders;
      return requestHeaders == null ? fileExtraDownloadHeaders : {
        ...fileExtraDownloadHeaders,
        ...requestHeaders
      };
    }
    return this.computeFinalHeaders({ accept: "*/*" });
  }
  async getOrCreateStagingUserId() {
<<<<<<< HEAD
    const file2 = path$4.join(this.app.userDataPath, ".updaterId");
    try {
      const id2 = await (0, fs_extra_1$4.readFile)(file2, "utf-8");
      if (builder_util_runtime_1$4.UUID.check(id2)) {
        return id2;
      } else {
        this._logger.warn(`Staging user id file exists, but content was invalid: ${id2}`);
      }
    } catch (e) {
      if (e.code !== "ENOENT") {
        this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${e}`);
      }
    }
    const id = builder_util_runtime_1$4.UUID.v5((0, crypto_1$1.randomBytes)(4096), builder_util_runtime_1$4.UUID.OID);
    this._logger.info(`Generated new staging user ID: ${id}`);
    try {
      await (0, fs_extra_1$4.outputFile)(file2, id);
    } catch (e) {
      this._logger.warn(`Couldn't write out staging user ID: ${e}`);
=======
    const t = On.join(this.app.userDataPath, ".updaterId");
    try {
      const r = await (0, cr.readFile)(t, "utf-8");
      if (ze.UUID.check(r))
        return r;
      this._logger.warn(`Staging user id file exists, but content was invalid: ${r}`);
    } catch (r) {
      r.code !== "ENOENT" && this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${r}`);
    }
    const n = ze.UUID.v5((0, I$.randomBytes)(4096), ze.UUID.OID);
    this._logger.info(`Generated new staging user ID: ${n}`);
    try {
      await (0, cr.outputFile)(t, n);
    } catch (r) {
      this._logger.warn(`Couldn't write out staging user ID: ${r}`);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    return id;
  }
  /** @internal */
  get isAddNoCacheQuery() {
    const headers2 = this.requestHeaders;
    if (headers2 == null) {
      return true;
    }
    for (const headerName of Object.keys(headers2)) {
      const s = headerName.toLowerCase();
      if (s === "authorization" || s === "private-token") {
        return false;
      }
    }
    return true;
  }
  async getOrCreateDownloadHelper() {
<<<<<<< HEAD
    let result = this.downloadedUpdateHelper;
    if (result == null) {
      const dirName = (await this.configOnDisk.value).updaterCacheDirName;
      const logger = this._logger;
      if (dirName == null) {
        logger.error("updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?");
      }
      const cacheDir = path$4.join(this.app.baseCachePath, dirName || this.app.name);
      if (logger.debug != null) {
        logger.debug(`updater cache dir: ${cacheDir}`);
      }
      result = new DownloadedUpdateHelper_1.DownloadedUpdateHelper(cacheDir);
      this.downloadedUpdateHelper = result;
=======
    let t = this.downloadedUpdateHelper;
    if (t == null) {
      const n = (await this.configOnDisk.value).updaterCacheDirName, r = this._logger;
      n == null && r.error("updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?");
      const i = On.join(this.app.baseCachePath, n || this.app.name);
      r.debug != null && r.debug(`updater cache dir: ${i}`), t = new am.DownloadedUpdateHelper(i), this.downloadedUpdateHelper = t;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    return result;
  }
  async executeDownload(taskOptions) {
    const fileInfo = taskOptions.fileInfo;
    const downloadOptions = {
      headers: taskOptions.downloadUpdateOptions.requestHeaders,
      cancellationToken: taskOptions.downloadUpdateOptions.cancellationToken,
      sha2: fileInfo.info.sha2,
      sha512: fileInfo.info.sha512
    };
<<<<<<< HEAD
    if (this.listenerCount(types_1$5.DOWNLOAD_PROGRESS) > 0) {
      downloadOptions.onProgress = (it) => this.emit(types_1$5.DOWNLOAD_PROGRESS, it);
    }
    const updateInfo = taskOptions.downloadUpdateOptions.updateInfoAndProvider.info;
    const version = updateInfo.version;
    const packageInfo = fileInfo.packageInfo;
    function getCacheUpdateFileName() {
      const urlPath = decodeURIComponent(taskOptions.fileInfo.url.pathname);
      if (urlPath.endsWith(`.${taskOptions.fileExtension}`)) {
        return path$4.basename(urlPath);
      } else {
        return taskOptions.fileInfo.info.url;
      }
    }
    const downloadedUpdateHelper = await this.getOrCreateDownloadHelper();
    const cacheDir = downloadedUpdateHelper.cacheDirForPendingUpdate;
    await (0, fs_extra_1$4.mkdir)(cacheDir, { recursive: true });
    const updateFileName = getCacheUpdateFileName();
    let updateFile = path$4.join(cacheDir, updateFileName);
    const packageFile = packageInfo == null ? null : path$4.join(cacheDir, `package-${version}${path$4.extname(packageInfo.path) || ".7z"}`);
    const done = async (isSaveCache) => {
      await downloadedUpdateHelper.setDownloadedFile(updateFile, packageFile, updateInfo, fileInfo, updateFileName, isSaveCache);
      await taskOptions.done({
        ...updateInfo,
        downloadedFile: updateFile
      });
      return packageFile == null ? [updateFile] : [updateFile, packageFile];
    };
    const log = this._logger;
    const cachedUpdateFile = await downloadedUpdateHelper.validateDownloadedPath(updateFile, updateInfo, fileInfo, log);
    if (cachedUpdateFile != null) {
      updateFile = cachedUpdateFile;
      return await done(false);
    }
    const removeFileIfAny = async () => {
      await downloadedUpdateHelper.clear().catch(() => {
      });
      return await (0, fs_extra_1$4.unlink)(updateFile).catch(() => {
      });
    };
    const tempUpdateFile = await (0, DownloadedUpdateHelper_1.createTempUpdateFile)(`temp-${updateFileName}`, cacheDir, log);
    try {
      await taskOptions.task(tempUpdateFile, downloadOptions, packageFile, removeFileIfAny);
      await (0, builder_util_runtime_1$4.retry)(() => (0, fs_extra_1$4.rename)(tempUpdateFile, updateFile), 60, 500, 0, 0, (error2) => error2 instanceof Error && /^EBUSY:/.test(error2.message));
    } catch (e) {
      await removeFileIfAny();
      if (e instanceof builder_util_runtime_1$4.CancellationError) {
        log.info("cancelled");
        this.emit("update-cancelled", updateInfo);
      }
      throw e;
=======
    this.listenerCount(lr.DOWNLOAD_PROGRESS) > 0 && (r.onProgress = (y) => this.emit(lr.DOWNLOAD_PROGRESS, y));
    const i = t.downloadUpdateOptions.updateInfoAndProvider.info, a = i.version, s = n.packageInfo;
    function c() {
      const y = decodeURIComponent(t.fileInfo.url.pathname);
      return y.endsWith(`.${t.fileExtension}`) ? On.basename(y) : t.fileInfo.info.url;
    }
    const o = await this.getOrCreateDownloadHelper(), u = o.cacheDirForPendingUpdate;
    await (0, cr.mkdir)(u, { recursive: !0 });
    const l = c();
    let p = On.join(u, l);
    const f = s == null ? null : On.join(u, `package-${a}${On.extname(s.path) || ".7z"}`), m = async (y) => (await o.setDownloadedFile(p, f, i, n, l, y), await t.done({
      ...i,
      downloadedFile: p
    }), f == null ? [p] : [p, f]), g = this._logger, h = await o.validateDownloadedPath(p, i, n, g);
    if (h != null)
      return p = h, await m(!1);
    const b = async () => (await o.clear().catch(() => {
    }), await (0, cr.unlink)(p).catch(() => {
    })), x = await (0, am.createTempUpdateFile)(`temp-${l}`, u, g);
    try {
      await t.task(x, r, f, b), await (0, ze.retry)(() => (0, cr.rename)(x, p), 60, 500, 0, 0, (y) => y instanceof Error && /^EBUSY:/.test(y.message));
    } catch (y) {
      throw await b(), y instanceof ze.CancellationError && (g.info("cancelled"), this.emit("update-cancelled", i)), y;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
    log.info(`New version ${version} has been downloaded to ${updateFile}`);
    return await done(true);
  }
  async differentialDownloadInstaller(fileInfo, downloadUpdateOptions, installerPath, provider, oldInstallerFileName) {
    try {
<<<<<<< HEAD
      if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload) {
        return true;
      }
      const blockmapFileUrls = (0, util_1.blockmapFiles)(fileInfo.url, this.app.version, downloadUpdateOptions.updateInfoAndProvider.info.version);
      this._logger.info(`Download block maps (old: "${blockmapFileUrls[0]}", new: ${blockmapFileUrls[1]})`);
      const downloadBlockMap = async (url2) => {
        const data = await this.httpExecutor.downloadToBuffer(url2, {
          headers: downloadUpdateOptions.requestHeaders,
          cancellationToken: downloadUpdateOptions.cancellationToken
        });
        if (data == null || data.length === 0) {
          throw new Error(`Blockmap "${url2.href}" is empty`);
        }
        try {
          return JSON.parse((0, zlib_1$1.gunzipSync)(data).toString());
        } catch (e) {
          throw new Error(`Cannot parse blockmap "${url2.href}", error: ${e}`);
        }
      };
      const downloadOptions = {
        newUrl: fileInfo.url,
        oldFile: path$4.join(this.downloadedUpdateHelper.cacheDir, oldInstallerFileName),
=======
      if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload)
        return !0;
      const s = (0, U$.blockmapFiles)(t.url, this.app.version, n.updateInfoAndProvider.info.version);
      this._logger.info(`Download block maps (old: "${s[0]}", new: ${s[1]})`);
      const c = async (l) => {
        const p = await this.httpExecutor.downloadToBuffer(l, {
          headers: n.requestHeaders,
          cancellationToken: n.cancellationToken
        });
        if (p == null || p.length === 0)
          throw new Error(`Blockmap "${l.href}" is empty`);
        try {
          return JSON.parse((0, N$.gunzipSync)(p).toString());
        } catch (f) {
          throw new Error(`Cannot parse blockmap "${l.href}", error: ${f}`);
        }
      }, o = {
        newUrl: t.url,
        oldFile: On.join(this.downloadedUpdateHelper.cacheDir, a),
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        logger: this._logger,
        newFile: installerPath,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        requestHeaders: downloadUpdateOptions.requestHeaders,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
<<<<<<< HEAD
      if (this.listenerCount(types_1$5.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(types_1$5.DOWNLOAD_PROGRESS, it);
      }
      const blockMapDataList = await Promise.all(blockmapFileUrls.map((u2) => downloadBlockMap(u2)));
      await new GenericDifferentialDownloader_1.GenericDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download(blockMapDataList[0], blockMapDataList[1]);
      return false;
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      if (this._testOnlyOptions != null) {
        throw e;
      }
      return true;
    }
  }
}
AppUpdater$1.AppUpdater = AppUpdater;
function hasPrereleaseComponents(version) {
  const versionPrereleaseComponent = (0, semver_1.prerelease)(version);
  return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;
}
class NoOpLogger {
=======
      this.listenerCount(lr.DOWNLOAD_PROGRESS) > 0 && (o.onProgress = (l) => this.emit(lr.DOWNLOAD_PROGRESS, l));
      const u = await Promise.all(s.map((l) => c(l)));
      return await new B$.GenericDifferentialDownloader(t.info, this.httpExecutor, o).download(u[0], u[1]), !1;
    } catch (s) {
      if (this._logger.error(`Cannot download differentially, fallback to full download: ${s.stack || s}`), this._testOnlyOptions != null)
        throw s;
      return !0;
    }
  }
}
fn.AppUpdater = hp;
function j$(e) {
  const t = (0, Dn.prerelease)(e);
  return t != null && t.length > 0;
}
class Jg {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  info(message) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  warn(message) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  error(message) {
  }
}
<<<<<<< HEAD
AppUpdater$1.NoOpLogger = NoOpLogger;
Object.defineProperty(BaseUpdater$1, "__esModule", { value: true });
BaseUpdater$1.BaseUpdater = void 0;
const child_process_1$3 = require$$1$9;
const AppUpdater_1$1 = AppUpdater$1;
class BaseUpdater extends AppUpdater_1$1.AppUpdater {
  constructor(options, app2) {
    super(options, app2);
    this.quitAndInstallCalled = false;
    this.quitHandlerAdded = false;
  }
  quitAndInstall(isSilent = false, isForceRunAfter = false) {
    this._logger.info(`Install on explicit quitAndInstall`);
    const isInstalled = this.install(isSilent, isSilent ? isForceRunAfter : this.autoRunAppAfterInstall);
    if (isInstalled) {
      setImmediate(() => {
        require$$1$8.autoUpdater.emit("before-quit-for-update");
        this.app.quit();
      });
    } else {
      this.quitAndInstallCalled = false;
    }
  }
  executeDownload(taskOptions) {
=======
fn.NoOpLogger = Jg;
Object.defineProperty(zt, "__esModule", { value: !0 });
zt.BaseUpdater = void 0;
const om = Is, M$ = fn;
class q$ extends M$.AppUpdater {
  constructor(t, n) {
    super(t, n), this.quitAndInstallCalled = !1, this.quitHandlerAdded = !1;
  }
  quitAndInstall(t = !1, n = !1) {
    this._logger.info("Install on explicit quitAndInstall"), this.install(t, t ? n : this.autoRunAppAfterInstall) ? setImmediate(() => {
      zn.autoUpdater.emit("before-quit-for-update"), this.app.quit();
    }) : this.quitAndInstallCalled = !1;
  }
  executeDownload(t) {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    return super.executeDownload({
      ...taskOptions,
      done: (event) => {
        this.dispatchUpdateDownloaded(event);
        this.addQuitHandler();
        return Promise.resolve();
      }
    });
  }
  get installerPath() {
    return this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.file;
  }
  // must be sync (because quit even handler is not async)
  install(isSilent = false, isForceRunAfter = false) {
    if (this.quitAndInstallCalled) {
      this._logger.warn("install call ignored: quitAndInstallCalled is set to true");
      return false;
    }
    const downloadedUpdateHelper = this.downloadedUpdateHelper;
    const installerPath = this.installerPath;
    const downloadedFileInfo = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.downloadedFileInfo;
    if (installerPath == null || downloadedFileInfo == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    this.quitAndInstallCalled = true;
    try {
      this._logger.info(`Install: isSilent: ${isSilent}, isForceRunAfter: ${isForceRunAfter}`);
      return this.doInstall({
        isSilent,
        isForceRunAfter,
        isAdminRightsRequired: downloadedFileInfo.isAdminRightsRequired
      });
<<<<<<< HEAD
    } catch (e) {
      this.dispatchError(e);
      return false;
=======
    } catch (s) {
      return this.dispatchError(s), !1;
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    }
  }
  addQuitHandler() {
    if (this.quitHandlerAdded || !this.autoInstallOnAppQuit) {
      return;
    }
    this.quitHandlerAdded = true;
    this.app.onQuit((exitCode) => {
      if (this.quitAndInstallCalled) {
        this._logger.info("Update installer has already been triggered. Quitting application.");
        return;
      }
      if (!this.autoInstallOnAppQuit) {
        this._logger.info("Update will not be installed on quit because autoInstallOnAppQuit is set to false.");
        return;
      }
      if (exitCode !== 0) {
        this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${exitCode}`);
        return;
      }
      this._logger.info("Auto install update on quit");
      this.install(true, false);
    });
  }
  wrapSudo() {
    const { name } = this.app;
    const installComment = `"${name} would like to update"`;
    const sudo = this.spawnSyncLog("which gksudo || which kdesudo || which pkexec || which beesu");
    const command = [sudo];
    if (/kdesudo/i.test(sudo)) {
      command.push("--comment", installComment);
      command.push("-c");
    } else if (/gksudo/i.test(sudo)) {
      command.push("--message", installComment);
    } else if (/pkexec/i.test(sudo)) {
      command.push("--disable-internal-agent");
    }
    return command.join(" ");
  }
<<<<<<< HEAD
  spawnSyncLog(cmd, args = [], env = {}) {
    this._logger.info(`Executing: ${cmd} with args: ${args}`);
    const response = (0, child_process_1$3.spawnSync)(cmd, args, {
      env: { ...process.env, ...env },
      encoding: "utf-8",
      shell: true
    });
    const { error: error2, status, stdout, stderr } = response;
    if (error2 != null) {
      this._logger.error(stderr);
      throw error2;
    } else if (status != null && status !== 0) {
      this._logger.error(stderr);
      throw new Error(`Command ${cmd} exited with code ${status}`);
    }
    return stdout.trim();
=======
  spawnSyncLog(t, n = [], r = {}) {
    this._logger.info(`Executing: ${t} with args: ${n}`);
    const i = (0, om.spawnSync)(t, n, {
      env: { ...process.env, ...r },
      encoding: "utf-8",
      shell: !0
    }), { error: a, status: s, stdout: c, stderr: o } = i;
    if (a != null)
      throw this._logger.error(o), a;
    if (s != null && s !== 0)
      throw this._logger.error(o), new Error(`Command ${t} exited with code ${s}`);
    return c.trim();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  /**
   * This handles both node 8 and node 10 way of emitting error when spawning a process
   *   - node 8: Throws the error
   *   - node 10: Emit the error(Need to listen with on)
   */
  // https://github.com/electron-userland/electron-builder/issues/1129
  // Node 8 sends errors: https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_common_system_errors
<<<<<<< HEAD
  async spawnLog(cmd, args = [], env = void 0, stdio = "ignore") {
    this._logger.info(`Executing: ${cmd} with args: ${args}`);
    return new Promise((resolve, reject) => {
      try {
        const params = { stdio, env, detached: true };
        const p = (0, child_process_1$3.spawn)(cmd, args, params);
        p.on("error", (error2) => {
          reject(error2);
        });
        p.unref();
        if (p.pid !== void 0) {
          resolve(true);
        }
      } catch (error2) {
        reject(error2);
=======
  async spawnLog(t, n = [], r = void 0, i = "ignore") {
    return this._logger.info(`Executing: ${t} with args: ${n}`), new Promise((a, s) => {
      try {
        const c = { stdio: i, env: r, detached: !0 }, o = (0, om.spawn)(t, n, c);
        o.on("error", (u) => {
          s(u);
        }), o.unref(), o.pid !== void 0 && a(!0);
      } catch (c) {
        s(c);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    });
  }
}
<<<<<<< HEAD
BaseUpdater$1.BaseUpdater = BaseUpdater;
var AppImageUpdater$1 = {};
var FileWithEmbeddedBlockMapDifferentialDownloader$1 = {};
Object.defineProperty(FileWithEmbeddedBlockMapDifferentialDownloader$1, "__esModule", { value: true });
FileWithEmbeddedBlockMapDifferentialDownloader$1.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
const fs_extra_1$3 = lib;
const DifferentialDownloader_1 = DifferentialDownloader$1;
const zlib_1 = zlib$4;
class FileWithEmbeddedBlockMapDifferentialDownloader extends DifferentialDownloader_1.DifferentialDownloader {
  async download() {
    const packageInfo = this.blockAwareFileInfo;
    const fileSize = packageInfo.size;
    const offset = fileSize - (packageInfo.blockMapSize + 4);
    this.fileMetadataBuffer = await this.readRemoteBytes(offset, fileSize - 1);
    const newBlockMap = readBlockMap(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
    await this.doDownload(await readEmbeddedBlockMapData(this.options.oldFile), newBlockMap);
  }
}
FileWithEmbeddedBlockMapDifferentialDownloader$1.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader;
function readBlockMap(data) {
  return JSON.parse((0, zlib_1.inflateRawSync)(data).toString());
}
async function readEmbeddedBlockMapData(file2) {
  const fd = await (0, fs_extra_1$3.open)(file2, "r");
  try {
    const fileSize = (await (0, fs_extra_1$3.fstat)(fd)).size;
    const sizeBuffer = Buffer.allocUnsafe(4);
    await (0, fs_extra_1$3.read)(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);
    const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));
    await (0, fs_extra_1$3.read)(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);
    await (0, fs_extra_1$3.close)(fd);
    return readBlockMap(dataBuffer);
  } catch (e) {
    await (0, fs_extra_1$3.close)(fd);
    throw e;
  }
}
Object.defineProperty(AppImageUpdater$1, "__esModule", { value: true });
AppImageUpdater$1.AppImageUpdater = void 0;
const builder_util_runtime_1$3 = out;
const child_process_1$2 = require$$1$9;
const fs_extra_1$2 = lib;
const fs_1$1 = fs$w;
const path$3 = require$$1$4;
const BaseUpdater_1$4 = BaseUpdater$1;
const FileWithEmbeddedBlockMapDifferentialDownloader_1$1 = FileWithEmbeddedBlockMapDifferentialDownloader$1;
const Provider_1$5 = Provider$1;
const types_1$4 = types;
class AppImageUpdater extends BaseUpdater_1$4.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
=======
zt.BaseUpdater = q$;
var Oi = {}, sa = {};
Object.defineProperty(sa, "__esModule", { value: !0 });
sa.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
const ur = yn, z$ = aa, H$ = et;
class W$ extends z$.DifferentialDownloader {
  async download() {
    const t = this.blockAwareFileInfo, n = t.size, r = n - (t.blockMapSize + 4);
    this.fileMetadataBuffer = await this.readRemoteBytes(r, n - 1);
    const i = Zg(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
    await this.doDownload(await G$(this.options.oldFile), i);
  }
}
sa.FileWithEmbeddedBlockMapDifferentialDownloader = W$;
function Zg(e) {
  return JSON.parse((0, H$.inflateRawSync)(e).toString());
}
async function G$(e) {
  const t = await (0, ur.open)(e, "r");
  try {
    const n = (await (0, ur.fstat)(t)).size, r = Buffer.allocUnsafe(4);
    await (0, ur.read)(t, r, 0, r.length, n - r.length);
    const i = Buffer.allocUnsafe(r.readUInt32BE(0));
    return await (0, ur.read)(t, i, 0, i.length, n - r.length - i.length), await (0, ur.close)(t), Zg(i);
  } catch (n) {
    throw await (0, ur.close)(t), n;
  }
}
Object.defineProperty(Oi, "__esModule", { value: !0 });
Oi.AppImageUpdater = void 0;
const cm = Fe, lm = Is, V$ = yn, Y$ = se, ai = ne, X$ = zt, K$ = sa, J$ = Re, um = wn;
class Z$ extends X$.BaseUpdater {
  constructor(t, n) {
    super(t, n);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  isUpdaterActive() {
    if (process.env["APPIMAGE"] == null) {
      if (process.env["SNAP"] == null) {
        this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage");
      } else {
        this._logger.info("SNAP env is defined, updater is disabled");
      }
      return false;
    }
    return super.isUpdaterActive();
  }
  /*** @private */
<<<<<<< HEAD
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$5.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "AppImage", ["rpm", "deb", "pacman"]);
    return this.executeDownload({
      fileExtension: "AppImage",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        const oldFile = process.env["APPIMAGE"];
        if (oldFile == null) {
          throw (0, builder_util_runtime_1$3.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        }
        if (downloadUpdateOptions.disableDifferentialDownload || await this.downloadDifferential(fileInfo, oldFile, updateFile, provider, downloadUpdateOptions)) {
          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
        }
        await (0, fs_extra_1$2.chmod)(updateFile, 493);
=======
  doDownloadUpdate(t) {
    const n = t.updateInfoAndProvider.provider, r = (0, J$.findFile)(n.resolveFiles(t.updateInfoAndProvider.info), "AppImage", ["rpm", "deb", "pacman"]);
    return this.executeDownload({
      fileExtension: "AppImage",
      fileInfo: r,
      downloadUpdateOptions: t,
      task: async (i, a) => {
        const s = process.env.APPIMAGE;
        if (s == null)
          throw (0, cm.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        (t.disableDifferentialDownload || await this.downloadDifferential(r, s, i, n, t)) && await this.httpExecutor.download(r.url, i, a), await (0, V$.chmod)(i, 493);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    });
  }
  async downloadDifferential(fileInfo, oldFile, updateFile, provider, downloadUpdateOptions) {
    try {
<<<<<<< HEAD
      const downloadOptions = {
        newUrl: fileInfo.url,
        oldFile,
=======
      const s = {
        newUrl: t.url,
        oldFile: n,
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        logger: this._logger,
        newFile: updateFile,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        requestHeaders: downloadUpdateOptions.requestHeaders,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
<<<<<<< HEAD
      if (this.listenerCount(types_1$4.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(types_1$4.DOWNLOAD_PROGRESS, it);
      }
      await new FileWithEmbeddedBlockMapDifferentialDownloader_1$1.FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download();
      return false;
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      return process.platform === "linux";
    }
  }
  doInstall(options) {
    const appImageFile = process.env["APPIMAGE"];
    if (appImageFile == null) {
      throw (0, builder_util_runtime_1$3.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
    }
    (0, fs_1$1.unlinkSync)(appImageFile);
    let destination;
    const existingBaseName = path$3.basename(appImageFile);
    const installerPath = this.installerPath;
    if (installerPath == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    if (path$3.basename(installerPath) === existingBaseName || !/\d+\.\d+\.\d+/.test(existingBaseName)) {
      destination = appImageFile;
    } else {
      destination = path$3.join(path$3.dirname(appImageFile), path$3.basename(installerPath));
    }
    (0, child_process_1$2.execFileSync)("mv", ["-f", installerPath, destination]);
    if (destination !== appImageFile) {
      this.emit("appimage-filename-updated", destination);
    }
    const env = {
      ...process.env,
      APPIMAGE_SILENT_INSTALL: "true"
    };
    if (options.isForceRunAfter) {
      this.spawnLog(destination, [], env);
    } else {
      env.APPIMAGE_EXIT_AFTER_INSTALL = "true";
      (0, child_process_1$2.execFileSync)(destination, [], { env });
    }
    return true;
  }
}
AppImageUpdater$1.AppImageUpdater = AppImageUpdater;
var DebUpdater$1 = {};
Object.defineProperty(DebUpdater$1, "__esModule", { value: true });
DebUpdater$1.DebUpdater = void 0;
const BaseUpdater_1$3 = BaseUpdater$1;
const Provider_1$4 = Provider$1;
const types_1$3 = types;
class DebUpdater extends BaseUpdater_1$3.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  /*** @private */
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$4.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "deb", ["AppImage", "rpm", "pacman"]);
    return this.executeDownload({
      fileExtension: "deb",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        if (this.listenerCount(types_1$3.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(types_1$3.DOWNLOAD_PROGRESS, it);
        }
        await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
=======
      return this.listenerCount(um.DOWNLOAD_PROGRESS) > 0 && (s.onProgress = (c) => this.emit(um.DOWNLOAD_PROGRESS, c)), await new K$.FileWithEmbeddedBlockMapDifferentialDownloader(t.info, this.httpExecutor, s).download(), !1;
    } catch (s) {
      return this._logger.error(`Cannot download differentially, fallback to full download: ${s.stack || s}`), process.platform === "linux";
    }
  }
  doInstall(t) {
    const n = process.env.APPIMAGE;
    if (n == null)
      throw (0, cm.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
    (0, Y$.unlinkSync)(n);
    let r;
    const i = ai.basename(n), a = this.installerPath;
    if (a == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    ai.basename(a) === i || !/\d+\.\d+\.\d+/.test(i) ? r = n : r = ai.join(ai.dirname(n), ai.basename(a)), (0, lm.execFileSync)("mv", ["-f", a, r]), r !== n && this.emit("appimage-filename-updated", r);
    const s = {
      ...process.env,
      APPIMAGE_SILENT_INSTALL: "true"
    };
    return t.isForceRunAfter ? this.spawnLog(r, [], s) : (s.APPIMAGE_EXIT_AFTER_INSTALL = "true", (0, lm.execFileSync)(r, [], { env: s })), !0;
  }
}
Oi.AppImageUpdater = Z$;
var Ii = {};
Object.defineProperty(Ii, "__esModule", { value: !0 });
Ii.DebUpdater = void 0;
const Q$ = zt, eO = Re, pm = wn;
class tO extends Q$.BaseUpdater {
  constructor(t, n) {
    super(t, n);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const n = t.updateInfoAndProvider.provider, r = (0, eO.findFile)(n.resolveFiles(t.updateInfoAndProvider.info), "deb", ["AppImage", "rpm", "pacman"]);
    return this.executeDownload({
      fileExtension: "deb",
      fileInfo: r,
      downloadUpdateOptions: t,
      task: async (i, a) => {
        this.listenerCount(pm.DOWNLOAD_PROGRESS) > 0 && (a.onProgress = (s) => this.emit(pm.DOWNLOAD_PROGRESS, s)), await this.httpExecutor.download(r.url, i, a);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    });
  }
  get installerPath() {
    var _a, _b;
    return (_b = (_a = super.installerPath) === null || _a === void 0 ? void 0 : _a.replace(/ /g, "\\ ")) !== null && _b !== void 0 ? _b : null;
  }
  doInstall(options) {
    const sudo = this.wrapSudo();
    const wrapper = /pkexec/i.test(sudo) ? "" : `"`;
    const installerPath = this.installerPath;
    if (installerPath == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    const cmd = ["dpkg", "-i", installerPath, "||", "apt-get", "install", "-f", "-y"];
    this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, "-c", `'${cmd.join(" ")}'${wrapper}`]);
    if (options.isForceRunAfter) {
      this.app.relaunch();
    }
    return true;
  }
}
<<<<<<< HEAD
DebUpdater$1.DebUpdater = DebUpdater;
var PacmanUpdater$1 = {};
Object.defineProperty(PacmanUpdater$1, "__esModule", { value: true });
PacmanUpdater$1.PacmanUpdater = void 0;
const BaseUpdater_1$2 = BaseUpdater$1;
const types_1$2 = types;
const Provider_1$3 = Provider$1;
class PacmanUpdater extends BaseUpdater_1$2.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  /*** @private */
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$3.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "pacman", ["AppImage", "deb", "rpm"]);
    return this.executeDownload({
      fileExtension: "pacman",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        if (this.listenerCount(types_1$2.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(types_1$2.DOWNLOAD_PROGRESS, it);
        }
        await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
=======
Ii.DebUpdater = tO;
var Di = {};
Object.defineProperty(Di, "__esModule", { value: !0 });
Di.PacmanUpdater = void 0;
const nO = zt, fm = wn, rO = Re;
class iO extends nO.BaseUpdater {
  constructor(t, n) {
    super(t, n);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const n = t.updateInfoAndProvider.provider, r = (0, rO.findFile)(n.resolveFiles(t.updateInfoAndProvider.info), "pacman", ["AppImage", "deb", "rpm"]);
    return this.executeDownload({
      fileExtension: "pacman",
      fileInfo: r,
      downloadUpdateOptions: t,
      task: async (i, a) => {
        this.listenerCount(fm.DOWNLOAD_PROGRESS) > 0 && (a.onProgress = (s) => this.emit(fm.DOWNLOAD_PROGRESS, s)), await this.httpExecutor.download(r.url, i, a);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    });
  }
  get installerPath() {
    var _a, _b;
    return (_b = (_a = super.installerPath) === null || _a === void 0 ? void 0 : _a.replace(/ /g, "\\ ")) !== null && _b !== void 0 ? _b : null;
  }
  doInstall(options) {
    const sudo = this.wrapSudo();
    const wrapper = /pkexec/i.test(sudo) ? "" : `"`;
    const installerPath = this.installerPath;
    if (installerPath == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    const cmd = ["pacman", "-U", "--noconfirm", installerPath];
    this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, "-c", `'${cmd.join(" ")}'${wrapper}`]);
    if (options.isForceRunAfter) {
      this.app.relaunch();
    }
    return true;
  }
}
<<<<<<< HEAD
PacmanUpdater$1.PacmanUpdater = PacmanUpdater;
var RpmUpdater$1 = {};
Object.defineProperty(RpmUpdater$1, "__esModule", { value: true });
RpmUpdater$1.RpmUpdater = void 0;
const BaseUpdater_1$1 = BaseUpdater$1;
const types_1$1 = types;
const Provider_1$2 = Provider$1;
class RpmUpdater extends BaseUpdater_1$1.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  /*** @private */
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$2.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "rpm", ["AppImage", "deb", "pacman"]);
    return this.executeDownload({
      fileExtension: "rpm",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        if (this.listenerCount(types_1$1.DOWNLOAD_PROGRESS) > 0) {
          downloadOptions.onProgress = (it) => this.emit(types_1$1.DOWNLOAD_PROGRESS, it);
        }
        await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
=======
Di.PacmanUpdater = iO;
var Fi = {};
Object.defineProperty(Fi, "__esModule", { value: !0 });
Fi.RpmUpdater = void 0;
const aO = zt, dm = wn, sO = Re;
class oO extends aO.BaseUpdater {
  constructor(t, n) {
    super(t, n);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const n = t.updateInfoAndProvider.provider, r = (0, sO.findFile)(n.resolveFiles(t.updateInfoAndProvider.info), "rpm", ["AppImage", "deb", "pacman"]);
    return this.executeDownload({
      fileExtension: "rpm",
      fileInfo: r,
      downloadUpdateOptions: t,
      task: async (i, a) => {
        this.listenerCount(dm.DOWNLOAD_PROGRESS) > 0 && (a.onProgress = (s) => this.emit(dm.DOWNLOAD_PROGRESS, s)), await this.httpExecutor.download(r.url, i, a);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    });
  }
  get installerPath() {
    var _a, _b;
    return (_b = (_a = super.installerPath) === null || _a === void 0 ? void 0 : _a.replace(/ /g, "\\ ")) !== null && _b !== void 0 ? _b : null;
  }
<<<<<<< HEAD
  doInstall(options) {
    const sudo = this.wrapSudo();
    const wrapper = /pkexec/i.test(sudo) ? "" : `"`;
    const packageManager = this.spawnSyncLog("which zypper");
    const installerPath = this.installerPath;
    if (installerPath == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    let cmd;
    if (!packageManager) {
      const packageManager2 = this.spawnSyncLog("which dnf || which yum");
      cmd = [packageManager2, "-y", "install", installerPath];
    } else {
      cmd = [packageManager, "--no-refresh", "install", "--allow-unsigned-rpm", "-y", "-f", installerPath];
    }
    this.spawnSyncLog(sudo, [`${wrapper}/bin/bash`, "-c", `'${cmd.join(" ")}'${wrapper}`]);
    if (options.isForceRunAfter) {
      this.app.relaunch();
    }
    return true;
  }
}
RpmUpdater$1.RpmUpdater = RpmUpdater;
var MacUpdater$1 = {};
Object.defineProperty(MacUpdater$1, "__esModule", { value: true });
MacUpdater$1.MacUpdater = void 0;
const builder_util_runtime_1$2 = out;
const fs_extra_1$1 = lib;
const fs_1 = fs$w;
const path$2 = require$$1$4;
const http_1 = require$$3$2;
const AppUpdater_1 = AppUpdater$1;
const Provider_1$1 = Provider$1;
const child_process_1$1 = require$$1$9;
const crypto_1 = require$$0$4;
class MacUpdater extends AppUpdater_1.AppUpdater {
  constructor(options, app2) {
    super(options, app2);
    this.nativeUpdater = require$$1$8.autoUpdater;
    this.squirrelDownloadedUpdate = false;
    this.nativeUpdater.on("error", (it) => {
      this._logger.warn(it);
      this.emit("error", it);
    });
    this.nativeUpdater.on("update-downloaded", () => {
      this.squirrelDownloadedUpdate = true;
      this.debug("nativeUpdater.update-downloaded");
=======
  doInstall(t) {
    const n = this.wrapSudo(), r = /pkexec/i.test(n) ? "" : '"', i = this.spawnSyncLog("which zypper"), a = this.installerPath;
    if (a == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    let s;
    return i ? s = [i, "--no-refresh", "install", "--allow-unsigned-rpm", "-y", "-f", a] : s = [this.spawnSyncLog("which dnf || which yum"), "-y", "install", a], this.spawnSyncLog(n, [`${r}/bin/bash`, "-c", `'${s.join(" ")}'${r}`]), t.isForceRunAfter && this.app.relaunch(), !0;
  }
}
Fi.RpmUpdater = oO;
var Pi = {};
Object.defineProperty(Pi, "__esModule", { value: !0 });
Pi.MacUpdater = void 0;
const hm = Fe, hl = yn, cO = se, mm = ne, lO = Cs, uO = fn, pO = Re, vm = Is, gm = Ur;
class fO extends uO.AppUpdater {
  constructor(t, n) {
    super(t, n), this.nativeUpdater = zn.autoUpdater, this.squirrelDownloadedUpdate = !1, this.nativeUpdater.on("error", (r) => {
      this._logger.warn(r), this.emit("error", r);
    }), this.nativeUpdater.on("update-downloaded", () => {
      this.squirrelDownloadedUpdate = !0, this.debug("nativeUpdater.update-downloaded");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    });
  }
  debug(message) {
    if (this._logger.debug != null) {
      this._logger.debug(message);
    }
  }
  closeServerIfExists() {
<<<<<<< HEAD
    if (this.server) {
      this.debug("Closing proxy server");
      this.server.close((err) => {
        if (err) {
          this.debug("proxy server wasn't already open, probably attempted closing again as a safety check before quit");
        }
      });
    }
  }
  async doDownloadUpdate(downloadUpdateOptions) {
    let files = downloadUpdateOptions.updateInfoAndProvider.provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info);
    const log = this._logger;
    const sysctlRosettaInfoKey = "sysctl.proc_translated";
    let isRosetta = false;
    try {
      this.debug("Checking for macOS Rosetta environment");
      const result = (0, child_process_1$1.execFileSync)("sysctl", [sysctlRosettaInfoKey], { encoding: "utf8" });
      isRosetta = result.includes(`${sysctlRosettaInfoKey}: 1`);
      log.info(`Checked for macOS Rosetta environment (isRosetta=${isRosetta})`);
    } catch (e) {
      log.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${e}`);
    }
    let isArm64Mac = false;
    try {
      this.debug("Checking for arm64 in uname");
      const result = (0, child_process_1$1.execFileSync)("uname", ["-a"], { encoding: "utf8" });
      const isArm = result.includes("ARM");
      log.info(`Checked 'uname -a': arm64=${isArm}`);
      isArm64Mac = isArm64Mac || isArm;
    } catch (e) {
      log.warn(`uname shell command to check for arm64 failed: ${e}`);
    }
    isArm64Mac = isArm64Mac || process.arch === "arm64" || isRosetta;
    const isArm64 = (file2) => {
      var _a;
      return file2.url.pathname.includes("arm64") || ((_a = file2.info.url) === null || _a === void 0 ? void 0 : _a.includes("arm64"));
    };
    if (isArm64Mac && files.some(isArm64)) {
      files = files.filter((file2) => isArm64Mac === isArm64(file2));
    } else {
      files = files.filter((file2) => !isArm64(file2));
    }
    const zipFileInfo = (0, Provider_1$1.findFile)(files, "zip", ["pkg", "dmg"]);
    if (zipFileInfo == null) {
      throw (0, builder_util_runtime_1$2.newError)(`ZIP file not provided: ${(0, builder_util_runtime_1$2.safeStringifyJson)(files)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
    }
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const CURRENT_MAC_APP_ZIP_FILE_NAME = "update.zip";
    return this.executeDownload({
      fileExtension: "zip",
      fileInfo: zipFileInfo,
      downloadUpdateOptions,
      task: async (destinationFile, downloadOptions) => {
        const cachedUpdateFilePath = path$2.join(this.downloadedUpdateHelper.cacheDir, CURRENT_MAC_APP_ZIP_FILE_NAME);
        const canDifferentialDownload = () => {
          if (!(0, fs_extra_1$1.pathExistsSync)(cachedUpdateFilePath)) {
            log.info("Unable to locate previous update.zip for differential download (is this first install?), falling back to full download");
            return false;
          }
          return !downloadUpdateOptions.disableDifferentialDownload;
        };
        let differentialDownloadFailed = true;
        if (canDifferentialDownload()) {
          differentialDownloadFailed = await this.differentialDownloadInstaller(zipFileInfo, downloadUpdateOptions, destinationFile, provider, CURRENT_MAC_APP_ZIP_FILE_NAME);
        }
        if (differentialDownloadFailed) {
          await this.httpExecutor.download(zipFileInfo.url, destinationFile, downloadOptions);
        }
      },
      done: async (event) => {
        if (!downloadUpdateOptions.disableDifferentialDownload) {
          try {
            const cachedUpdateFilePath = path$2.join(this.downloadedUpdateHelper.cacheDir, CURRENT_MAC_APP_ZIP_FILE_NAME);
            await (0, fs_extra_1$1.copyFile)(event.downloadedFile, cachedUpdateFilePath);
          } catch (error2) {
            this._logger.warn(`Unable to copy file for caching for future differential downloads: ${error2.message}`);
          }
        }
        return this.updateDownloaded(zipFileInfo, event);
      }
    });
  }
  async updateDownloaded(zipFileInfo, event) {
    var _a;
    const downloadedFile = event.downloadedFile;
    const updateFileSize = (_a = zipFileInfo.info.size) !== null && _a !== void 0 ? _a : (await (0, fs_extra_1$1.stat)(downloadedFile)).size;
    const log = this._logger;
    const logContext = `fileToProxy=${zipFileInfo.url.href}`;
    this.closeServerIfExists();
    this.debug(`Creating proxy server for native Squirrel.Mac (${logContext})`);
    this.server = (0, http_1.createServer)();
    this.debug(`Proxy server for native Squirrel.Mac is created (${logContext})`);
    this.server.on("close", () => {
      log.info(`Proxy server for native Squirrel.Mac is closed (${logContext})`);
    });
    const getServerUrl = (s) => {
      const address = s.address();
      if (typeof address === "string") {
        return address;
      }
      return `http://127.0.0.1:${address === null || address === void 0 ? void 0 : address.port}`;
    };
    return await new Promise((resolve, reject) => {
      const pass = (0, crypto_1.randomBytes)(64).toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
      const authInfo = Buffer.from(`autoupdater:${pass}`, "ascii");
      const fileUrl = `/${(0, crypto_1.randomBytes)(64).toString("hex")}.zip`;
      this.server.on("request", (request, response) => {
        const requestUrl = request.url;
        log.info(`${requestUrl} requested`);
        if (requestUrl === "/") {
          if (!request.headers.authorization || request.headers.authorization.indexOf("Basic ") === -1) {
            response.statusCode = 401;
            response.statusMessage = "Invalid Authentication Credentials";
            response.end();
            log.warn("No authenthication info");
            return;
          }
          const base64Credentials = request.headers.authorization.split(" ")[1];
          const credentials = Buffer.from(base64Credentials, "base64").toString("ascii");
          const [username, password] = credentials.split(":");
          if (username !== "autoupdater" || password !== pass) {
            response.statusCode = 401;
            response.statusMessage = "Invalid Authentication Credentials";
            response.end();
            log.warn("Invalid authenthication credentials");
            return;
          }
          const data = Buffer.from(`{ "url": "${getServerUrl(this.server)}${fileUrl}" }`);
          response.writeHead(200, { "Content-Type": "application/json", "Content-Length": data.length });
          response.end(data);
          return;
        }
        if (!requestUrl.startsWith(fileUrl)) {
          log.warn(`${requestUrl} requested, but not supported`);
          response.writeHead(404);
          response.end();
          return;
        }
        log.info(`${fileUrl} requested by Squirrel.Mac, pipe ${downloadedFile}`);
        let errorOccurred = false;
        response.on("finish", () => {
          if (!errorOccurred) {
            this.nativeUpdater.removeListener("error", reject);
            resolve([]);
          }
        });
        const readStream2 = (0, fs_1.createReadStream)(downloadedFile);
        readStream2.on("error", (error2) => {
          try {
            response.end();
          } catch (e) {
            log.warn(`cannot end response: ${e}`);
          }
          errorOccurred = true;
          this.nativeUpdater.removeListener("error", reject);
          reject(new Error(`Cannot pipe "${downloadedFile}": ${error2}`));
        });
        response.writeHead(200, {
          "Content-Type": "application/zip",
          "Content-Length": updateFileSize
        });
        readStream2.pipe(response);
      });
      this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${logContext})`);
      this.server.listen(0, "127.0.0.1", () => {
        this.debug(`Proxy server for native Squirrel.Mac is listening (address=${getServerUrl(this.server)}, ${logContext})`);
        this.nativeUpdater.setFeedURL({
          url: getServerUrl(this.server),
          headers: {
            "Cache-Control": "no-cache",
            Authorization: `Basic ${authInfo.toString("base64")}`
=======
    this.server && (this.debug("Closing proxy server"), this.server.close((t) => {
      t && this.debug("proxy server wasn't already open, probably attempted closing again as a safety check before quit");
    }));
  }
  async doDownloadUpdate(t) {
    let n = t.updateInfoAndProvider.provider.resolveFiles(t.updateInfoAndProvider.info);
    const r = this._logger, i = "sysctl.proc_translated";
    let a = !1;
    try {
      this.debug("Checking for macOS Rosetta environment"), a = (0, vm.execFileSync)("sysctl", [i], { encoding: "utf8" }).includes(`${i}: 1`), r.info(`Checked for macOS Rosetta environment (isRosetta=${a})`);
    } catch (p) {
      r.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${p}`);
    }
    let s = !1;
    try {
      this.debug("Checking for arm64 in uname");
      const f = (0, vm.execFileSync)("uname", ["-a"], { encoding: "utf8" }).includes("ARM");
      r.info(`Checked 'uname -a': arm64=${f}`), s = s || f;
    } catch (p) {
      r.warn(`uname shell command to check for arm64 failed: ${p}`);
    }
    s = s || process.arch === "arm64" || a;
    const c = (p) => {
      var f;
      return p.url.pathname.includes("arm64") || ((f = p.info.url) === null || f === void 0 ? void 0 : f.includes("arm64"));
    };
    s && n.some(c) ? n = n.filter((p) => s === c(p)) : n = n.filter((p) => !c(p));
    const o = (0, pO.findFile)(n, "zip", ["pkg", "dmg"]);
    if (o == null)
      throw (0, hm.newError)(`ZIP file not provided: ${(0, hm.safeStringifyJson)(n)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
    const u = t.updateInfoAndProvider.provider, l = "update.zip";
    return this.executeDownload({
      fileExtension: "zip",
      fileInfo: o,
      downloadUpdateOptions: t,
      task: async (p, f) => {
        const m = mm.join(this.downloadedUpdateHelper.cacheDir, l), g = () => (0, hl.pathExistsSync)(m) ? !t.disableDifferentialDownload : (r.info("Unable to locate previous update.zip for differential download (is this first install?), falling back to full download"), !1);
        let h = !0;
        g() && (h = await this.differentialDownloadInstaller(o, t, p, u, l)), h && await this.httpExecutor.download(o.url, p, f);
      },
      done: async (p) => {
        if (!t.disableDifferentialDownload)
          try {
            const f = mm.join(this.downloadedUpdateHelper.cacheDir, l);
            await (0, hl.copyFile)(p.downloadedFile, f);
          } catch (f) {
            this._logger.warn(`Unable to copy file for caching for future differential downloads: ${f.message}`);
          }
        return this.updateDownloaded(o, p);
      }
    });
  }
  async updateDownloaded(t, n) {
    var r;
    const i = n.downloadedFile, a = (r = t.info.size) !== null && r !== void 0 ? r : (await (0, hl.stat)(i)).size, s = this._logger, c = `fileToProxy=${t.url.href}`;
    this.closeServerIfExists(), this.debug(`Creating proxy server for native Squirrel.Mac (${c})`), this.server = (0, lO.createServer)(), this.debug(`Proxy server for native Squirrel.Mac is created (${c})`), this.server.on("close", () => {
      s.info(`Proxy server for native Squirrel.Mac is closed (${c})`);
    });
    const o = (u) => {
      const l = u.address();
      return typeof l == "string" ? l : `http://127.0.0.1:${l == null ? void 0 : l.port}`;
    };
    return await new Promise((u, l) => {
      const p = (0, gm.randomBytes)(64).toString("base64").replace(/\//g, "_").replace(/\+/g, "-"), f = Buffer.from(`autoupdater:${p}`, "ascii"), m = `/${(0, gm.randomBytes)(64).toString("hex")}.zip`;
      this.server.on("request", (g, h) => {
        const b = g.url;
        if (s.info(`${b} requested`), b === "/") {
          if (!g.headers.authorization || g.headers.authorization.indexOf("Basic ") === -1) {
            h.statusCode = 401, h.statusMessage = "Invalid Authentication Credentials", h.end(), s.warn("No authenthication info");
            return;
          }
          const E = g.headers.authorization.split(" ")[1], S = Buffer.from(E, "base64").toString("ascii"), [D, U] = S.split(":");
          if (D !== "autoupdater" || U !== p) {
            h.statusCode = 401, h.statusMessage = "Invalid Authentication Credentials", h.end(), s.warn("Invalid authenthication credentials");
            return;
          }
          const z = Buffer.from(`{ "url": "${o(this.server)}${m}" }`);
          h.writeHead(200, { "Content-Type": "application/json", "Content-Length": z.length }), h.end(z);
          return;
        }
        if (!b.startsWith(m)) {
          s.warn(`${b} requested, but not supported`), h.writeHead(404), h.end();
          return;
        }
        s.info(`${m} requested by Squirrel.Mac, pipe ${i}`);
        let x = !1;
        h.on("finish", () => {
          x || (this.nativeUpdater.removeListener("error", l), u([]));
        });
        const y = (0, cO.createReadStream)(i);
        y.on("error", (E) => {
          try {
            h.end();
          } catch (S) {
            s.warn(`cannot end response: ${S}`);
          }
          x = !0, this.nativeUpdater.removeListener("error", l), l(new Error(`Cannot pipe "${i}": ${E}`));
        }), h.writeHead(200, {
          "Content-Type": "application/zip",
          "Content-Length": a
        }), y.pipe(h);
      }), this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${c})`), this.server.listen(0, "127.0.0.1", () => {
        this.debug(`Proxy server for native Squirrel.Mac is listening (address=${o(this.server)}, ${c})`), this.nativeUpdater.setFeedURL({
          url: o(this.server),
          headers: {
            "Cache-Control": "no-cache",
            Authorization: `Basic ${f.toString("base64")}`
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
          }
        });
        this.dispatchUpdateDownloaded(event);
        if (this.autoInstallOnAppQuit) {
          this.nativeUpdater.once("error", reject);
          this.nativeUpdater.checkForUpdates();
        } else {
          resolve([]);
        }
      });
    });
  }
  handleUpdateDownloaded() {
    if (this.autoRunAppAfterInstall) {
      this.nativeUpdater.quitAndInstall();
    } else {
      this.app.quit();
    }
    this.closeServerIfExists();
  }
  quitAndInstall() {
    if (this.squirrelDownloadedUpdate) {
      this.handleUpdateDownloaded();
    } else {
      this.nativeUpdater.on("update-downloaded", () => this.handleUpdateDownloaded());
      if (!this.autoInstallOnAppQuit) {
        this.nativeUpdater.checkForUpdates();
      }
    }
  }
}
<<<<<<< HEAD
MacUpdater$1.MacUpdater = MacUpdater;
var NsisUpdater$1 = {};
var windowsExecutableCodeSignatureVerifier = {};
Object.defineProperty(windowsExecutableCodeSignatureVerifier, "__esModule", { value: true });
windowsExecutableCodeSignatureVerifier.verifySignature = verifySignature;
const builder_util_runtime_1$1 = out;
const child_process_1 = require$$1$9;
const os = require$$2$2;
const path$1 = require$$1$4;
function verifySignature(publisherNames, unescapedTempUpdateFile, logger) {
  return new Promise((resolve, reject) => {
    const tempUpdateFile = unescapedTempUpdateFile.replace(/'/g, "''");
    logger.info(`Verifying signature ${tempUpdateFile}`);
    (0, child_process_1.execFile)(`set "PSModulePath=" & chcp 65001 >NUL & powershell.exe`, ["-NoProfile", "-NonInteractive", "-InputFormat", "None", "-Command", `"Get-AuthenticodeSignature -LiteralPath '${tempUpdateFile}' | ConvertTo-Json -Compress"`], {
      shell: true,
      timeout: 20 * 1e3
    }, (error2, stdout, stderr) => {
      var _a;
      try {
        if (error2 != null || stderr) {
          handleError(logger, error2, stderr, reject);
          resolve(null);
          return;
        }
        const data = parseOut(stdout);
        if (data.Status === 0) {
          try {
            const normlaizedUpdateFilePath = path$1.normalize(data.Path);
            const normalizedTempUpdateFile = path$1.normalize(unescapedTempUpdateFile);
            logger.info(`LiteralPath: ${normlaizedUpdateFilePath}. Update Path: ${normalizedTempUpdateFile}`);
            if (normlaizedUpdateFilePath !== normalizedTempUpdateFile) {
              handleError(logger, new Error(`LiteralPath of ${normlaizedUpdateFilePath} is different than ${normalizedTempUpdateFile}`), stderr, reject);
              resolve(null);
=======
Pi.MacUpdater = fO;
var ki = {}, mp = {};
Object.defineProperty(mp, "__esModule", { value: !0 });
mp.verifySignature = hO;
const bm = Fe, Qg = Is, dO = $s, xm = ne;
function hO(e, t, n) {
  return new Promise((r, i) => {
    const a = t.replace(/'/g, "''");
    n.info(`Verifying signature ${a}`), (0, Qg.execFile)('set "PSModulePath=" & chcp 65001 >NUL & powershell.exe', ["-NoProfile", "-NonInteractive", "-InputFormat", "None", "-Command", `"Get-AuthenticodeSignature -LiteralPath '${a}' | ConvertTo-Json -Compress"`], {
      shell: !0,
      timeout: 20 * 1e3
    }, (s, c, o) => {
      var u;
      try {
        if (s != null || o) {
          ml(n, s, o, i), r(null);
          return;
        }
        const l = mO(c);
        if (l.Status === 0) {
          try {
            const g = xm.normalize(l.Path), h = xm.normalize(t);
            if (n.info(`LiteralPath: ${g}. Update Path: ${h}`), g !== h) {
              ml(n, new Error(`LiteralPath of ${g} is different than ${h}`), o, i), r(null);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
              return;
            }
          } catch (error3) {
            logger.warn(`Unable to verify LiteralPath of update asset due to missing data.Path. Skipping this step of validation. Message: ${(_a = error3.message) !== null && _a !== void 0 ? _a : error3.stack}`);
          }
<<<<<<< HEAD
          const subject = (0, builder_util_runtime_1$1.parseDn)(data.SignerCertificate.Subject);
          let match = false;
          for (const name of publisherNames) {
            const dn = (0, builder_util_runtime_1$1.parseDn)(name);
            if (dn.size) {
              const allKeys = Array.from(dn.keys());
              match = allKeys.every((key2) => {
                return dn.get(key2) === subject.get(key2);
              });
            } else if (name === subject.get("CN")) {
              logger.warn(`Signature validated using only CN ${name}. Please add your full Distinguished Name (DN) to publisherNames configuration`);
              match = true;
            }
            if (match) {
              resolve(null);
=======
          const f = (0, bm.parseDn)(l.SignerCertificate.Subject);
          let m = !1;
          for (const g of e) {
            const h = (0, bm.parseDn)(g);
            if (h.size ? m = Array.from(h.keys()).every((x) => h.get(x) === f.get(x)) : g === f.get("CN") && (n.warn(`Signature validated using only CN ${g}. Please add your full Distinguished Name (DN) to publisherNames configuration`), m = !0), m) {
              r(null);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
              return;
            }
          }
        }
<<<<<<< HEAD
        const result = `publisherNames: ${publisherNames.join(" | ")}, raw info: ` + JSON.stringify(data, (name, value) => name === "RawData" ? void 0 : value, 2);
        logger.warn(`Sign verification failed, installer signed with incorrect certificate: ${result}`);
        resolve(result);
      } catch (e) {
        handleError(logger, e, null, reject);
        resolve(null);
=======
        const p = `publisherNames: ${e.join(" | ")}, raw info: ` + JSON.stringify(l, (f, m) => f === "RawData" ? void 0 : m, 2);
        n.warn(`Sign verification failed, installer signed with incorrect certificate: ${p}`), r(p);
      } catch (l) {
        ml(n, l, null, i), r(null);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
        return;
      }
    });
  });
}
<<<<<<< HEAD
function parseOut(out2) {
  const data = JSON.parse(out2);
  delete data.PrivateKey;
  delete data.IsOSBinary;
  delete data.SignatureType;
  const signerCertificate = data.SignerCertificate;
  if (signerCertificate != null) {
    delete signerCertificate.Archived;
    delete signerCertificate.Extensions;
    delete signerCertificate.Handle;
    delete signerCertificate.HasPrivateKey;
    delete signerCertificate.SubjectName;
  }
  return data;
}
function handleError(logger, error2, stderr, reject) {
  if (isOldWin6()) {
    logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error2 || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  try {
    (0, child_process_1.execFileSync)("powershell.exe", ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"], { timeout: 10 * 1e3 });
  } catch (testError) {
    logger.warn(`Cannot execute ConvertTo-Json: ${testError.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
=======
function mO(e) {
  const t = JSON.parse(e);
  delete t.PrivateKey, delete t.IsOSBinary, delete t.SignatureType;
  const n = t.SignerCertificate;
  return n != null && (delete n.Archived, delete n.Extensions, delete n.Handle, delete n.HasPrivateKey, delete n.SubjectName), t;
}
function ml(e, t, n, r) {
  if (vO()) {
    e.warn(`Cannot execute Get-AuthenticodeSignature: ${t || n}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  try {
    (0, Qg.execFileSync)("powershell.exe", ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"], { timeout: 10 * 1e3 });
  } catch (i) {
    e.warn(`Cannot execute ConvertTo-Json: ${i.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    return;
  }
  if (error2 != null) {
    reject(error2);
  }
  if (stderr) {
    reject(new Error(`Cannot execute Get-AuthenticodeSignature, stderr: ${stderr}. Failing signature validation due to unknown stderr.`));
  }
}
<<<<<<< HEAD
function isOldWin6() {
  const winVersion = os.release();
  return winVersion.startsWith("6.") && !winVersion.startsWith("6.3");
}
Object.defineProperty(NsisUpdater$1, "__esModule", { value: true });
NsisUpdater$1.NsisUpdater = void 0;
const builder_util_runtime_1 = out;
const path = require$$1$4;
const BaseUpdater_1 = BaseUpdater$1;
const FileWithEmbeddedBlockMapDifferentialDownloader_1 = FileWithEmbeddedBlockMapDifferentialDownloader$1;
const types_1 = types;
const Provider_1 = Provider$1;
const fs_extra_1 = lib;
const windowsExecutableCodeSignatureVerifier_1 = windowsExecutableCodeSignatureVerifier;
const url_1 = require$$0$3;
class NsisUpdater extends BaseUpdater_1.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
    this._verifyUpdateCodeSignature = (publisherNames, unescapedTempUpdateFile) => (0, windowsExecutableCodeSignatureVerifier_1.verifySignature)(publisherNames, unescapedTempUpdateFile, this._logger);
=======
function vO() {
  const e = dO.release();
  return e.startsWith("6.") && !e.startsWith("6.3");
}
Object.defineProperty(ki, "__esModule", { value: !0 });
ki.NsisUpdater = void 0;
const Ha = Fe, ym = ne, gO = zt, bO = sa, wm = wn, xO = Re, yO = yn, wO = mp, Em = $t;
class EO extends gO.BaseUpdater {
  constructor(t, n) {
    super(t, n), this._verifyUpdateCodeSignature = (r, i) => (0, wO.verifySignature)(r, i, this._logger);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  }
  /**
   * The verifyUpdateCodeSignature. You can pass [win-verify-signature](https://github.com/beyondkmp/win-verify-trust) or another custom verify function: ` (publisherName: string[], path: string) => Promise<string | null>`.
   * The default verify function uses [windowsExecutableCodeSignatureVerifier](https://github.com/electron-userland/electron-builder/blob/master/packages/electron-updater/src/windowsExecutableCodeSignatureVerifier.ts)
   */
  get verifyUpdateCodeSignature() {
    return this._verifyUpdateCodeSignature;
  }
  set verifyUpdateCodeSignature(value) {
    if (value) {
      this._verifyUpdateCodeSignature = value;
    }
  }
  /*** @private */
<<<<<<< HEAD
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "exe");
    return this.executeDownload({
      fileExtension: "exe",
      downloadUpdateOptions,
      fileInfo,
      task: async (destinationFile, downloadOptions, packageFile, removeTempDirIfAny) => {
        const packageInfo = fileInfo.packageInfo;
        const isWebInstaller = packageInfo != null && packageFile != null;
        if (isWebInstaller && downloadUpdateOptions.disableWebInstaller) {
          throw (0, builder_util_runtime_1.newError)(`Unable to download new version ${downloadUpdateOptions.updateInfoAndProvider.info.version}. Web Installers are disabled`, "ERR_UPDATER_WEB_INSTALLER_DISABLED");
        }
        if (!isWebInstaller && !downloadUpdateOptions.disableWebInstaller) {
          this._logger.warn("disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version.");
        }
        if (isWebInstaller || downloadUpdateOptions.disableDifferentialDownload || await this.differentialDownloadInstaller(fileInfo, downloadUpdateOptions, destinationFile, provider, builder_util_runtime_1.CURRENT_APP_INSTALLER_FILE_NAME)) {
          await this.httpExecutor.download(fileInfo.url, destinationFile, downloadOptions);
        }
        const signatureVerificationStatus = await this.verifySignature(destinationFile);
        if (signatureVerificationStatus != null) {
          await removeTempDirIfAny();
          throw (0, builder_util_runtime_1.newError)(`New version ${downloadUpdateOptions.updateInfoAndProvider.info.version} is not signed by the application owner: ${signatureVerificationStatus}`, "ERR_UPDATER_INVALID_SIGNATURE");
        }
        if (isWebInstaller) {
          if (await this.differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packageFile, provider)) {
            try {
              await this.httpExecutor.download(new url_1.URL(packageInfo.path), packageFile, {
                headers: downloadUpdateOptions.requestHeaders,
                cancellationToken: downloadUpdateOptions.cancellationToken,
                sha512: packageInfo.sha512
              });
            } catch (e) {
              try {
                await (0, fs_extra_1.unlink)(packageFile);
              } catch (_ignored) {
              }
              throw e;
=======
  doDownloadUpdate(t) {
    const n = t.updateInfoAndProvider.provider, r = (0, xO.findFile)(n.resolveFiles(t.updateInfoAndProvider.info), "exe");
    return this.executeDownload({
      fileExtension: "exe",
      downloadUpdateOptions: t,
      fileInfo: r,
      task: async (i, a, s, c) => {
        const o = r.packageInfo, u = o != null && s != null;
        if (u && t.disableWebInstaller)
          throw (0, Ha.newError)(`Unable to download new version ${t.updateInfoAndProvider.info.version}. Web Installers are disabled`, "ERR_UPDATER_WEB_INSTALLER_DISABLED");
        !u && !t.disableWebInstaller && this._logger.warn("disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version."), (u || t.disableDifferentialDownload || await this.differentialDownloadInstaller(r, t, i, n, Ha.CURRENT_APP_INSTALLER_FILE_NAME)) && await this.httpExecutor.download(r.url, i, a);
        const l = await this.verifySignature(i);
        if (l != null)
          throw await c(), (0, Ha.newError)(`New version ${t.updateInfoAndProvider.info.version} is not signed by the application owner: ${l}`, "ERR_UPDATER_INVALID_SIGNATURE");
        if (u && await this.differentialDownloadWebPackage(t, o, s, n))
          try {
            await this.httpExecutor.download(new Em.URL(o.path), s, {
              headers: t.requestHeaders,
              cancellationToken: t.cancellationToken,
              sha512: o.sha512
            });
          } catch (p) {
            try {
              await (0, yO.unlink)(s);
            } catch {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
            }
          }
        }
      }
    });
  }
  // $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
  // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
  // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
  async verifySignature(tempUpdateFile) {
    let publisherName;
    try {
      publisherName = (await this.configOnDisk.value).publisherName;
      if (publisherName == null) {
        return null;
      }
    } catch (e) {
      if (e.code === "ENOENT") {
        return null;
      }
      throw e;
    }
    return await this._verifyUpdateCodeSignature(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile);
  }
<<<<<<< HEAD
  doInstall(options) {
    const installerPath = this.installerPath;
    if (installerPath == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    const args = ["--updated"];
    if (options.isSilent) {
      args.push("/S");
    }
    if (options.isForceRunAfter) {
      args.push("--force-run");
    }
    if (this.installDirectory) {
      args.push(`/D=${this.installDirectory}`);
    }
    const packagePath = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;
    if (packagePath != null) {
      args.push(`--package-file=${packagePath}`);
    }
    const callUsingElevation = () => {
      this.spawnLog(path.join(process.resourcesPath, "elevate.exe"), [installerPath].concat(args)).catch((e) => this.dispatchError(e));
    };
    if (options.isAdminRightsRequired) {
      this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe");
      callUsingElevation();
      return true;
    }
    this.spawnLog(installerPath, args).catch((e) => {
      const errorCode = e.code;
      this._logger.info(`Cannot run installer: error code: ${errorCode}, error message: "${e.message}", will be executed again using elevate if EACCES, and will try to use electron.shell.openItem if ENOENT`);
      if (errorCode === "UNKNOWN" || errorCode === "EACCES") {
        callUsingElevation();
      } else if (errorCode === "ENOENT") {
        require$$1$8.shell.openPath(installerPath).catch((err) => this.dispatchError(err));
      } else {
        this.dispatchError(e);
      }
    });
    return true;
  }
  async differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packagePath, provider) {
    if (packageInfo.blockMapSize == null) {
      return true;
    }
    try {
      const downloadOptions = {
        newUrl: new url_1.URL(packageInfo.path),
        oldFile: path.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_PACKAGE_FILE_NAME),
        logger: this._logger,
        newFile: packagePath,
        requestHeaders: this.requestHeaders,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
      if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);
      }
      await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, this.httpExecutor, downloadOptions).download();
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      return process.platform === "win32";
    }
    return false;
  }
}
NsisUpdater$1.NsisUpdater = NsisUpdater;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NsisUpdater = exports.MacUpdater = exports.RpmUpdater = exports.PacmanUpdater = exports.DebUpdater = exports.AppImageUpdater = exports.Provider = exports.NoOpLogger = exports.AppUpdater = exports.BaseUpdater = void 0;
  const fs_extra_12 = lib;
  const path2 = require$$1$4;
  var BaseUpdater_12 = BaseUpdater$1;
  Object.defineProperty(exports, "BaseUpdater", { enumerable: true, get: function() {
    return BaseUpdater_12.BaseUpdater;
  } });
  var AppUpdater_12 = AppUpdater$1;
  Object.defineProperty(exports, "AppUpdater", { enumerable: true, get: function() {
    return AppUpdater_12.AppUpdater;
  } });
  Object.defineProperty(exports, "NoOpLogger", { enumerable: true, get: function() {
    return AppUpdater_12.NoOpLogger;
  } });
  var Provider_12 = Provider$1;
  Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
    return Provider_12.Provider;
  } });
  var AppImageUpdater_1 = AppImageUpdater$1;
  Object.defineProperty(exports, "AppImageUpdater", { enumerable: true, get: function() {
    return AppImageUpdater_1.AppImageUpdater;
  } });
  var DebUpdater_1 = DebUpdater$1;
  Object.defineProperty(exports, "DebUpdater", { enumerable: true, get: function() {
    return DebUpdater_1.DebUpdater;
  } });
  var PacmanUpdater_1 = PacmanUpdater$1;
  Object.defineProperty(exports, "PacmanUpdater", { enumerable: true, get: function() {
    return PacmanUpdater_1.PacmanUpdater;
  } });
  var RpmUpdater_1 = RpmUpdater$1;
  Object.defineProperty(exports, "RpmUpdater", { enumerable: true, get: function() {
    return RpmUpdater_1.RpmUpdater;
  } });
  var MacUpdater_1 = MacUpdater$1;
  Object.defineProperty(exports, "MacUpdater", { enumerable: true, get: function() {
    return MacUpdater_1.MacUpdater;
  } });
  var NsisUpdater_1 = NsisUpdater$1;
  Object.defineProperty(exports, "NsisUpdater", { enumerable: true, get: function() {
    return NsisUpdater_1.NsisUpdater;
  } });
  __exportStar(types, exports);
  let _autoUpdater;
  function doLoadAutoUpdater() {
    if (process.platform === "win32") {
      _autoUpdater = new NsisUpdater$1.NsisUpdater();
    } else if (process.platform === "darwin") {
      _autoUpdater = new MacUpdater$1.MacUpdater();
    } else {
      _autoUpdater = new AppImageUpdater$1.AppImageUpdater();
      try {
        const identity = path2.join(process.resourcesPath, "package-type");
        if (!(0, fs_extra_12.existsSync)(identity)) {
          return _autoUpdater;
        }
        console.info("Checking for beta autoupdate feature for deb/rpm distributions");
        const fileType = (0, fs_extra_12.readFileSync)(identity).toString().trim();
        console.info("Found package-type:", fileType);
        switch (fileType) {
          case "deb":
            _autoUpdater = new DebUpdater$1.DebUpdater();
            break;
          case "rpm":
            _autoUpdater = new RpmUpdater$1.RpmUpdater();
            break;
          case "pacman":
            _autoUpdater = new PacmanUpdater$1.PacmanUpdater();
=======
  doInstall(t) {
    const n = this.installerPath;
    if (n == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    const r = ["--updated"];
    t.isSilent && r.push("/S"), t.isForceRunAfter && r.push("--force-run"), this.installDirectory && r.push(`/D=${this.installDirectory}`);
    const i = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;
    i != null && r.push(`--package-file=${i}`);
    const a = () => {
      this.spawnLog(ym.join(process.resourcesPath, "elevate.exe"), [n].concat(r)).catch((s) => this.dispatchError(s));
    };
    return t.isAdminRightsRequired ? (this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe"), a(), !0) : (this.spawnLog(n, r).catch((s) => {
      const c = s.code;
      this._logger.info(`Cannot run installer: error code: ${c}, error message: "${s.message}", will be executed again using elevate if EACCES, and will try to use electron.shell.openItem if ENOENT`), c === "UNKNOWN" || c === "EACCES" ? a() : c === "ENOENT" ? zn.shell.openPath(n).catch((o) => this.dispatchError(o)) : this.dispatchError(s);
    }), !0);
  }
  async differentialDownloadWebPackage(t, n, r, i) {
    if (n.blockMapSize == null)
      return !0;
    try {
      const a = {
        newUrl: new Em.URL(n.path),
        oldFile: ym.join(this.downloadedUpdateHelper.cacheDir, Ha.CURRENT_APP_PACKAGE_FILE_NAME),
        logger: this._logger,
        newFile: r,
        requestHeaders: this.requestHeaders,
        isUseMultipleRangeRequest: i.isUseMultipleRangeRequest,
        cancellationToken: t.cancellationToken
      };
      this.listenerCount(wm.DOWNLOAD_PROGRESS) > 0 && (a.onProgress = (s) => this.emit(wm.DOWNLOAD_PROGRESS, s)), await new bO.FileWithEmbeddedBlockMapDifferentialDownloader(n, this.httpExecutor, a).download();
    } catch (a) {
      return this._logger.error(`Cannot download differentially, fallback to full download: ${a.stack || a}`), process.platform === "win32";
    }
    return !1;
  }
}
ki.NsisUpdater = EO;
(function(e) {
  var t = Ae && Ae.__createBinding || (Object.create ? function(b, x, y, E) {
    E === void 0 && (E = y);
    var S = Object.getOwnPropertyDescriptor(x, y);
    (!S || ("get" in S ? !x.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
      return x[y];
    } }), Object.defineProperty(b, E, S);
  } : function(b, x, y, E) {
    E === void 0 && (E = y), b[E] = x[y];
  }), n = Ae && Ae.__exportStar || function(b, x) {
    for (var y in b) y !== "default" && !Object.prototype.hasOwnProperty.call(x, y) && t(x, b, y);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.NsisUpdater = e.MacUpdater = e.RpmUpdater = e.PacmanUpdater = e.DebUpdater = e.AppImageUpdater = e.Provider = e.NoOpLogger = e.AppUpdater = e.BaseUpdater = void 0;
  const r = yn, i = ne;
  var a = zt;
  Object.defineProperty(e, "BaseUpdater", { enumerable: !0, get: function() {
    return a.BaseUpdater;
  } });
  var s = fn;
  Object.defineProperty(e, "AppUpdater", { enumerable: !0, get: function() {
    return s.AppUpdater;
  } }), Object.defineProperty(e, "NoOpLogger", { enumerable: !0, get: function() {
    return s.NoOpLogger;
  } });
  var c = Re;
  Object.defineProperty(e, "Provider", { enumerable: !0, get: function() {
    return c.Provider;
  } });
  var o = Oi;
  Object.defineProperty(e, "AppImageUpdater", { enumerable: !0, get: function() {
    return o.AppImageUpdater;
  } });
  var u = Ii;
  Object.defineProperty(e, "DebUpdater", { enumerable: !0, get: function() {
    return u.DebUpdater;
  } });
  var l = Di;
  Object.defineProperty(e, "PacmanUpdater", { enumerable: !0, get: function() {
    return l.PacmanUpdater;
  } });
  var p = Fi;
  Object.defineProperty(e, "RpmUpdater", { enumerable: !0, get: function() {
    return p.RpmUpdater;
  } });
  var f = Pi;
  Object.defineProperty(e, "MacUpdater", { enumerable: !0, get: function() {
    return f.MacUpdater;
  } });
  var m = ki;
  Object.defineProperty(e, "NsisUpdater", { enumerable: !0, get: function() {
    return m.NsisUpdater;
  } }), n(wn, e);
  let g;
  function h() {
    if (process.platform === "win32")
      g = new ki.NsisUpdater();
    else if (process.platform === "darwin")
      g = new Pi.MacUpdater();
    else {
      g = new Oi.AppImageUpdater();
      try {
        const b = i.join(process.resourcesPath, "package-type");
        if (!(0, r.existsSync)(b))
          return g;
        console.info("Checking for beta autoupdate feature for deb/rpm distributions");
        const x = (0, r.readFileSync)(b).toString().trim();
        switch (console.info("Found package-type:", x), x) {
          case "deb":
            g = new Ii.DebUpdater();
            break;
          case "rpm":
            g = new Fi.RpmUpdater();
            break;
          case "pacman":
            g = new Di.PacmanUpdater();
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
            break;
          default:
            break;
        }
<<<<<<< HEAD
      } catch (error2) {
        console.warn("Unable to detect 'package-type' for autoUpdater (beta rpm/deb support). If you'd like to expand support, please consider contributing to electron-builder", error2.message);
=======
      } catch (b) {
        console.warn("Unable to detect 'package-type' for autoUpdater (beta rpm/deb support). If you'd like to expand support, please consider contributing to electron-builder", b.message);
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    }
    return _autoUpdater;
  }
<<<<<<< HEAD
  Object.defineProperty(exports, "autoUpdater", {
    enumerable: true,
    get: () => {
      return _autoUpdater || doLoadAutoUpdater();
    }
  });
})(main$1);
class ElectronUpdate extends DevTools {
  constructor(win2) {
    super(win2);
    __publicField(this, "updateInProgress");
    __publicField(this, "proxyurl");
    __publicField(this, "is_download");
    __publicField(this, "setUpdatSetFeedUrl", async () => {
      var _a, _b;
      const tag = await this.getLatestVersion();
      const proxyurl = ((_a = this.runConfig) == null ? void 0 : _a.proxy_url) ? ((_b = this.runConfig) == null ? void 0 : _b.proxy_url) + "/" : "";
      if (tag) {
        const url2 = `${proxyurl}https://github.com/forget-pro/sync-code-tool/releases/download/${tag}`;
        if (url2 === this.proxyurl) return;
        this.proxyurl = url2;
        main$1.autoUpdater.setFeedURL({
          provider: "generic",
          url: url2,
          requestHeaders: {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36"
          }
        });
        this.sendLog(`: ${tag}`);
      }
    });
    // APP
    __publicField(this, "getLatestVersion", async () => {
      try {
        const url2 = `https://api.github.com/repos/forget-pro/sync-code-tool/releases/latest`;
        const res = await axios.get(url2, { timeout: 6e3 });
        if (res.status !== 200) {
          this.sendLog("", "ERROR");
          return null;
        }
        const data = res.data;
        const latestAppVersion = data.filter((item) => /^app-v/.test(item.tag_name))[0] || null;
        return latestAppVersion.tag_name || null;
      } catch (err) {
        this.sendLog(err.message, "ERROR");
        return null;
      }
    });
    // 
    __publicField(this, "checkElectronUpdate", async () => {
      try {
        if (!app.isPackaged) return 0;
        if (this.updateInProgress) return 2;
        if (this.is_download) return 3;
        this.updateInProgress = true;
        await this.setUpdatSetFeedUrl();
        const res = await main$1.autoUpdater.checkForUpdatesAndNotify();
        this.updateInProgress = false;
        main$1.autoUpdater.on("checking-for-update", () => {
          var _a;
          (_a = this.windown) == null ? void 0 : _a.webContents.send("main-process-message", " ...");
        });
        main$1.autoUpdater.on("update-available", () => {
          var _a;
          (_a = this.windown) == null ? void 0 : _a.webContents.send("main-process-message", "update-available");
        });
        main$1.autoUpdater.on("update-not-available", () => {
          var _a;
          (_a = this.windown) == null ? void 0 : _a.webContents.send("main-process-message", "update-not-available");
        });
        main$1.autoUpdater.on("download-progress", () => {
          this.is_download = true;
        });
        main$1.autoUpdater.on("error", (err) => {
          var _a;
          this.is_download = false;
          this.updateInProgress = false;
          (_a = this.windown) == null ? void 0 : _a.webContents.send("main-process-message", err.message);
        });
        main$1.autoUpdater.on("update-downloaded", () => {
          this.is_download = false;
          dialog.showMessageBox({
=======
  Object.defineProperty(e, "autoUpdater", {
    enumerable: !0,
    get: () => g || h()
  });
})(St);
class _O extends V1 {
  constructor(n) {
    super(n);
    be(this, "updateInProgress");
    be(this, "proxyurl");
    be(this, "is_download");
    be(this, "setUpdatSetFeedUrl", async () => {
      var i, a;
      const n = await this.getLatestVersion(), r = (i = this.runConfig) != null && i.proxy_url ? ((a = this.runConfig) == null ? void 0 : a.proxy_url) + "/" : "";
      if (n) {
        const s = `${r}https://github.com/forget-pro/sync-code-tool/releases/download/${n}`;
        if (s === this.proxyurl) return;
        this.proxyurl = s, St.autoUpdater.setFeedURL({
          provider: "generic",
          url: s,
          requestHeaders: {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36"
          }
        }), this.sendLog(`: ${n}`);
      }
    });
    // APP
    be(this, "getLatestVersion", async () => {
      try {
        const r = await Ee.get("https://api.github.com/repos/forget-pro/sync-code-tool/releases", { timeout: 6e3 });
        return r.status !== 200 ? (this.sendLog("", "ERROR"), null) : (r.data.filter((s) => /^app-v/.test(s.tag_name))[0] || null).tag_name || null;
      } catch (n) {
        return this.sendLog(n.message, "ERROR"), null;
      }
    });
    // 
    be(this, "checkElectronUpdate", async () => {
      try {
        if (!cn.isPackaged) return 0;
        if (this.updateInProgress) return 2;
        if (this.is_download) return 3;
        this.updateInProgress = !0, await this.setUpdatSetFeedUrl();
        const n = await St.autoUpdater.checkForUpdatesAndNotify();
        return this.updateInProgress = !1, St.autoUpdater.on("checking-for-update", () => {
          var r;
          (r = this.windown) == null || r.webContents.send("main-process-message", " ...");
        }), St.autoUpdater.on("update-available", () => {
          var r;
          (r = this.windown) == null || r.webContents.send("main-process-message", "update-available");
        }), St.autoUpdater.on("update-not-available", () => {
          var r;
          (r = this.windown) == null || r.webContents.send("main-process-message", "update-not-available");
        }), St.autoUpdater.on("download-progress", () => {
          this.is_download = !0;
        }), St.autoUpdater.on("error", (r) => {
          var i;
          this.is_download = !1, this.updateInProgress = !1, (i = this.windown) == null || i.webContents.send("main-process-message", r.message);
        }), St.autoUpdater.on("update-downloaded", () => {
          this.is_download = !1, _m.showMessageBox({
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
            type: "info",
            title: "",
            message: "",
            buttons: ["", ""]
<<<<<<< HEAD
          }).then((result) => {
            if (result.response === 0) {
              main$1.autoUpdater.quitAndInstall();
            }
            this.updateInProgress = false;
          });
        });
        if (res && (res == null ? void 0 : res.updateInfo.version) !== app.getVersion()) {
          return 1;
        } else {
          return 0;
        }
      } catch (err) {
        this.updateInProgress = false;
        this.sendLog(err.message, "ERROR");
=======
          }).then((r) => {
            r.response === 0 && St.autoUpdater.quitAndInstall(), this.updateInProgress = !1;
          });
        }), n && (n == null ? void 0 : n.updateInfo.version) !== cn.getVersion() ? 1 : 0;
      } catch (n) {
        this.updateInProgress = !1, this.sendLog(n.message, "ERROR");
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
      }
    });
    this.updateInProgress = false;
    this.proxyurl = "";
    this.is_download = false;
  }
}
<<<<<<< HEAD
createRequire(import.meta.url);
const __dirname = path$t.dirname(fileURLToPath(import.meta.url));
process.env.APP_ROOT = path$t.join(__dirname, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path$t.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path$t.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path$t.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
let devTools = null;
let electronUpdate = null;
function createWindow() {
  win = new BrowserWindow({
=======
Tm(import.meta.url);
const eb = lt.dirname(sx(import.meta.url));
process.env.APP_ROOT = lt.join(eb, "..");
const Jl = process.env.VITE_DEV_SERVER_URL, AI = lt.join(process.env.APP_ROOT, "dist-electron"), tb = lt.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = Jl ? lt.join(process.env.APP_ROOT, "public") : tb;
let st, xe = null, Wa = null;
function nb() {
  st = new Am({
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    width: 1200,
    height: 800,
    minWidth: 1200,
    minHeight: 800,
<<<<<<< HEAD
    icon: path$t.join(process.env.VITE_PUBLIC || "", "logo.png"),
=======
    icon: lt.join(process.env.VITE_PUBLIC || "", "logo.png"),
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    webPreferences: {
      preload: lt.join(eb, "preload.mjs")
    }
  }), xe = new V1(st), Wa = new _O(st), st.webContents.on("did-finish-load", () => {
    Wa == null || Wa.checkElectronUpdate(), xe == null || xe.reportConfig(), xe == null || xe.sendLog(" ");
  }), ax.register("CommandOrControl+Shift+I", () => {
    st == null || st.webContents.toggleDevTools();
  }), Jl ? (st.loadURL(Jl), st.webContents.openDevTools()) : st.loadFile(lt.join(tb, "index.html"));
}
<<<<<<< HEAD
const menu = Menu.buildFromTemplate([]);
Menu.setApplicationMenu(menu);
ipcMain.handle("downloadFile", async (_, data) => {
  const app_dir = path$t.join(app.getPath("documents"), "code-sync");
  const filepath = path$t.join(app_dir, `${data.type}/${data.appid}`);
  if (!fs$x.existsSync(filepath)) {
    fs$x.mkdirSync(filepath, { recursive: true });
  }
  const dest = path$t.join(filepath, "code.tar.gz");
  const result = await (devTools == null ? void 0 : devTools.downloadFile(data.url, dest));
=======
const SO = Sm.buildFromTemplate([]);
Sm.setApplicationMenu(SO);
Vn.handle("downloadFile", async (e, t) => {
  const n = lt.join(cn.getPath("documents"), "code-sync"), r = lt.join(n, `${t.type}/${t.appid}`);
  kp.existsSync(r) || kp.mkdirSync(r, { recursive: !0 });
  const i = lt.join(r, "code.tar.gz"), a = await (xe == null ? void 0 : xe.downloadFile(t.url, i));
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
  return {
    path: dest,
    result
  };
});
<<<<<<< HEAD
ipcMain.handle("unzipFile", async (_, data) => {
  return await (devTools == null ? void 0 : devTools.unzipFile(data.filepath, path$t.dirname(data.filepath)));
});
ipcMain.handle("DevToolsOpen", async (_, data) => {
  devTools == null ? void 0 : devTools.startDevTool(data.type, data.url);
});
ipcMain.handle("open:url", (_, url2) => {
  shell.openExternal(url2);
});
ipcMain.handle("saveConfig", (_, data) => {
  devTools == null ? void 0 : devTools.writeConfig(data);
});
ipcMain.handle("getConfig", () => {
  return (devTools == null ? void 0 : devTools.reportConfig()) || {};
});
ipcMain.handle("dialog:open", async (_, type2) => {
  const result = await dialog.showOpenDialog(win, {
=======
Vn.handle("unzipFile", async (e, t) => await (xe == null ? void 0 : xe.unzipFile(t.filepath, lt.dirname(t.filepath))));
Vn.handle("DevToolsOpen", async (e, t) => {
  xe == null || xe.startDevTool(t.type, t.url);
});
Vn.handle("open:url", (e, t) => {
  ix.openExternal(t);
});
Vn.handle("saveConfig", (e, t) => {
  xe == null || xe.writeConfig(t);
});
Vn.handle("getConfig", () => (xe == null ? void 0 : xe.reportConfig()) || {});
Vn.handle("dialog:open", async (e, t) => {
  const n = await _m.showOpenDialog(st, {
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
    title: "",
    properties: [type2, "showHiddenFiles", "createDirectory", "treatPackageAsDirectory"],
    filters: [
      { name: "", extensions: ["app"] },
      { name: "", extensions: ["*"] }
    ]
  });
  if (result.filePaths.length) {
    return result.filePaths[0];
  }
});
<<<<<<< HEAD
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
    win = null;
  }
});
app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
app.whenReady().then(createWindow);
export {
  MAIN_DIST,
  RENDERER_DIST,
  VITE_DEV_SERVER_URL
=======
cn.on("window-all-closed", () => {
  process.platform !== "darwin" && (cn.quit(), st = null);
});
cn.on("activate", () => {
  Am.getAllWindows().length === 0 && nb();
});
cn.whenReady().then(nb);
export {
  AI as MAIN_DIST,
  tb as RENDERER_DIST,
  Jl as VITE_DEV_SERVER_URL
>>>>>>> 051525988026e3d26bd3ed8c533c4b49eb5d3c76
};
