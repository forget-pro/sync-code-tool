<<<<<<< HEAD
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
import require$$1$8, { app, dialog, Menu, ipcMain, shell, BrowserWindow, globalShortcut } from "electron";
import { createRequire } from "node:module";
import { fileURLToPath } from "node:url";
import require$$1$3 from "util";
import require$$1$2, { Readable as Readable$2 } from "stream";
import require$$1$4 from "path";
import require$$3$2 from "http";
import require$$4$2 from "https";
import require$$0$3 from "url";
import fs$w from "fs";
import require$$0$4 from "crypto";
import require$$2$3 from "assert";
import require$$1$5 from "tty";
import require$$2$2 from "os";
import zlib$4 from "zlib";
import require$$0$6, { EventEmitter as EventEmitter$4 } from "events";
import require$$0$5 from "buffer";
import require$$1$6 from "constants";
import require$$1$7 from "string_decoder";
import require$$1$9, { spawn } from "child_process";
import fs$x from "node:fs";
import path$t from "node:path";
function bind$2(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString$2 } = Object.prototype;
const { getPrototypeOf: getPrototypeOf$1 } = Object;
const { iterator, toStringTag: toStringTag$1 } = Symbol;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str2 = toString$2.call(thing);
  return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray: isArray$1 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer$1(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$1 = typeOfTest("string");
const isFunction$1 = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean$1 = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf$1(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag$1 in val) && !(iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction$1(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest$2, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key2;
    for (i = 0; i < len; i++) {
      key2 = keys[i];
      fn.call(null, obj[key2], key2, obj);
    }
  }
}
function findKey(obj, key2) {
  key2 = key2.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key2 === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge$1() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key2) => {
    const targetKey = caseless && findKey(result, key2) || key2;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge$1(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge$1({}, val);
    } else if (isArray$1(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
=======
var _y = Object.defineProperty;
var Sy = (e, t, n) => t in e ? _y(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var xe = (e, t, n) => Sy(e, typeof t != "symbol" ? t + "" : t, n);
import Bn, { app as rn, dialog as Wh, Menu as Vh, ipcMain as zn, shell as Ty, BrowserWindow as Yh, globalShortcut as Ay } from "electron";
import { createRequire as Xh } from "node:module";
import { fileURLToPath as Ry } from "node:url";
import Pe from "util";
import ie, { Readable as Cy } from "stream";
import oe from "path";
import bo from "http";
import Nl from "https";
import At from "url";
import ae from "fs";
import Dr from "crypto";
import wo from "assert";
import Kh from "tty";
import Eo from "os";
import Qe from "zlib";
import Hn, { EventEmitter as Oy } from "events";
import Nt from "buffer";
import Jh from "constants";
import kl from "string_decoder";
import _o, { spawn as mp } from "child_process";
import vp from "node:fs";
import ot from "node:path";
function Zh(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: $y } = Object.prototype, { getPrototypeOf: Ll } = Object, { iterator: So, toStringTag: Qh } = Symbol, To = /* @__PURE__ */ ((e) => (t) => {
  const n = $y.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), dt = (e) => (e = e.toLowerCase(), (t) => To(t) === e), Ao = (e) => (t) => typeof t === e, { isArray: Fr } = Array, li = Ao("undefined");
function Iy(e) {
  return e !== null && !li(e) && e.constructor !== null && !li(e.constructor) && et(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const em = dt("ArrayBuffer");
function Py(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && em(e.buffer), t;
}
const Dy = Ao("string"), et = Ao("function"), tm = Ao("number"), Ro = (e) => e !== null && typeof e == "object", Fy = (e) => e === !0 || e === !1, Ba = (e) => {
  if (To(e) !== "object")
    return !1;
  const t = Ll(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Qh in e) && !(So in e);
}, Ny = dt("Date"), ky = dt("File"), Ly = dt("Blob"), Uy = dt("FileList"), By = (e) => Ro(e) && et(e.pipe), jy = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || et(e.append) && ((t = To(e)) === "formdata" || // detect form-data instance
  t === "object" && et(e.toString) && e.toString() === "[object FormData]"));
}, My = dt("URLSearchParams"), [qy, zy, Hy, Gy] = ["ReadableStream", "Request", "Response", "Headers"].map(dt), Wy = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function $i(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), Fr(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e), o = a.length;
    let c;
    for (r = 0; r < o; r++)
      c = a[r], t.call(null, e[c], c, e);
  }
}
function nm(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const $n = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, rm = (e) => !li(e) && e !== $n;
function Qc() {
  const { caseless: e } = rm(this) && this || {}, t = {}, n = (r, i) => {
    const a = e && nm(t, i) || i;
    Ba(t[a]) && Ba(r) ? t[a] = Qc(t[a], r) : Ba(r) ? t[a] = Qc({}, r) : Fr(r) ? t[a] = r.slice() : t[a] = r;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && $i(arguments[r], n);
  return t;
}
<<<<<<< HEAD
const extend$2 = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key2) => {
    if (thisArg && isFunction$1(val)) {
      a[key2] = bind$2(val, thisArg);
    } else {
      a[key2] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits$1 = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
=======
const Vy = (e, t, n, { allOwnKeys: r } = {}) => ($i(t, (i, a) => {
  n && et(i) ? e[a] = Zh(i, n) : e[a] = i;
}, { allOwnKeys: r }), e), Yy = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Xy = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, Ky = (e, t, n, r) => {
  let i, a, o;
  const c = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), a = i.length; a-- > 0; )
      o = i[a], (!r || r(o, e, t)) && !c[o] && (t[o] = e[o], c[o] = !0);
    e = n !== !1 && Ll(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, Jy = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, Zy = (e) => {
  if (!e) return null;
  if (Fr(e)) return e;
  let t = e.length;
  if (!tm(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, Qy = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Ll(Uint8Array)), eb = (e, t) => {
  const r = (e && e[So]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const a = i.value;
    t.call(e, a[0], a[1]);
  }
}, tb = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, nb = dt("HTMLFormElement"), rb = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), gp = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), ib = dt("RegExp"), im = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  $i(n, (i, a) => {
    let o;
    (o = t(i, a, e)) !== !1 && (r[a] = o || i);
  }), Object.defineProperties(e, r);
}, ab = (e) => {
  im(e, (t, n) => {
    if (et(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (et(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
<<<<<<< HEAD
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction$1(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$6 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$1(thing.append) && thing[toStringTag$1] === "FormData" && thing[iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray$1(source) ? [] : {};
        forEach(source, (value, key2) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key2] = reducedValue);
        });
        stack[i] = void 0;
        return target;
=======
}, ob = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((a) => {
      n[a] = !0;
    });
  };
  return Fr(e) ? r(e) : r(String(e).split(t)), n;
}, sb = () => {
}, cb = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function lb(e) {
  return !!(e && et(e.append) && e[Qh] === "FormData" && e[So]);
}
const ub = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (Ro(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const a = Fr(r) ? [] : {};
        return $i(r, (o, c) => {
          const s = n(o, i + 1);
          !li(s) && (a[c] = s);
        }), t[i] = void 0, a;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
    }
    return r;
  };
<<<<<<< HEAD
  return visit(obj, 0);
=======
  return n(e, 0);
}, pb = dt("AsyncFunction"), fb = (e) => e && (Ro(e) || et(e)) && et(e.then) && et(e.catch), am = ((e, t) => e ? setImmediate : t ? ((n, r) => ($n.addEventListener("message", ({ source: i, data: a }) => {
  i === $n && a === n && r.length && r.shift()();
}, !1), (i) => {
  r.push(i), $n.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  et($n.postMessage)
), db = typeof queueMicrotask < "u" ? queueMicrotask.bind($n) : typeof process < "u" && process.nextTick || am, hb = (e) => e != null && et(e[So]), P = {
  isArray: Fr,
  isArrayBuffer: em,
  isBuffer: Iy,
  isFormData: jy,
  isArrayBufferView: Py,
  isString: Dy,
  isNumber: tm,
  isBoolean: Fy,
  isObject: Ro,
  isPlainObject: Ba,
  isReadableStream: qy,
  isRequest: zy,
  isResponse: Hy,
  isHeaders: Gy,
  isUndefined: li,
  isDate: Ny,
  isFile: ky,
  isBlob: Ly,
  isRegExp: ib,
  isFunction: et,
  isStream: By,
  isURLSearchParams: My,
  isTypedArray: Qy,
  isFileList: Uy,
  forEach: $i,
  merge: Qc,
  extend: Vy,
  trim: Wy,
  stripBOM: Yy,
  inherits: Xy,
  toFlatObject: Ky,
  kindOf: To,
  kindOfTest: dt,
  endsWith: Jy,
  toArray: Zy,
  forEachEntry: eb,
  matchAll: tb,
  isHTMLForm: nb,
  hasOwnProperty: gp,
  hasOwnProp: gp,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: im,
  freezeMethods: ab,
  toObjectSet: ob,
  toCamelCase: rb,
  noop: sb,
  toFiniteNumber: cb,
  findKey: nm,
  global: $n,
  isContextDefined: rm,
  isSpecCompliantForm: lb,
  toJSONObject: ub,
  isAsyncFn: pb,
  isThenable: fb,
  setImmediate: am,
  asap: db,
  isIterable: hb
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
};
function V(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null);
}
P.inherits(V, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: P.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const om = V.prototype, sm = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  sm[e] = { value: e };
});
Object.defineProperties(V, sm);
Object.defineProperty(om, "isAxiosError", { value: !0 });
V.from = (e, t, n, r, i, a) => {
  const o = Object.create(om);
  return P.toFlatObject(e, o, function(s) {
    return s !== Error.prototype;
  }, (c) => c !== "isAxiosError"), V.call(o, e.message, t, n, r, i), o.cause = e, o.name = e.name, a && Object.assign(o, a), o;
};
var Te = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ul(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
<<<<<<< HEAD
var Stream$3 = require$$1$2.Stream;
var util$d = require$$1$3;
var delayed_stream = DelayedStream$1;
function DelayedStream$1() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;
  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util$d.inherits(DelayedStream$1, Stream$3);
DelayedStream$1.create = function(source, options) {
  var delayedStream = new this();
  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }
  delayedStream.source = source;
  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };
  source.on("error", function() {
  });
  if (delayedStream.pauseStream) {
    source.pause();
  }
  return delayedStream;
};
Object.defineProperty(DelayedStream$1.prototype, "readable", {
  configurable: true,
  enumerable: true,
=======
var cm = ie.Stream, mb = Pe, vb = ht;
function ht() {
  this.source = null, this.dataSize = 0, this.maxDataSize = 1024 * 1024, this.pauseStream = !0, this._maxDataSizeExceeded = !1, this._released = !1, this._bufferedEvents = [];
}
mb.inherits(ht, cm);
ht.create = function(e, t) {
  var n = new this();
  t = t || {};
  for (var r in t)
    n[r] = t[r];
  n.source = e;
  var i = e.emit;
  return e.emit = function() {
    return n._handleEmit(arguments), i.apply(e, arguments);
  }, e.on("error", function() {
  }), n.pauseStream && e.pause(), n;
};
Object.defineProperty(ht.prototype, "readable", {
  configurable: !0,
  enumerable: !0,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  get: function() {
    return this.source.readable;
  }
});
<<<<<<< HEAD
DelayedStream$1.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream$1.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }
  this.source.resume();
};
DelayedStream$1.prototype.pause = function() {
  this.source.pause();
};
DelayedStream$1.prototype.release = function() {
  this._released = true;
  this._bufferedEvents.forEach((function(args) {
    this.emit.apply(this, args);
  }).bind(this));
  this._bufferedEvents = [];
};
DelayedStream$1.prototype.pipe = function() {
  var r = Stream$3.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};
DelayedStream$1.prototype._handleEmit = function(args) {
=======
ht.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
ht.prototype.resume = function() {
  this._released || this.release(), this.source.resume();
};
ht.prototype.pause = function() {
  this.source.pause();
};
ht.prototype.release = function() {
  this._released = !0, this._bufferedEvents.forEach((function(e) {
    this.emit.apply(this, e);
  }).bind(this)), this._bufferedEvents = [];
};
ht.prototype.pipe = function() {
  var e = cm.prototype.pipe.apply(this, arguments);
  return this.resume(), e;
};
ht.prototype._handleEmit = function(e) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  if (this._released) {
    this.emit.apply(this, e);
    return;
  }
<<<<<<< HEAD
  if (args[0] === "data") {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
=======
  e[0] === "data" && (this.dataSize += e[1].length, this._checkIfMaxDataSizeExceeded()), this._bufferedEvents.push(e);
};
ht.prototype._checkIfMaxDataSizeExceeded = function() {
  if (!this._maxDataSizeExceeded && !(this.dataSize <= this.maxDataSize)) {
    this._maxDataSizeExceeded = !0;
    var e = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(e));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
};
<<<<<<< HEAD
DelayedStream$1.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  this._maxDataSizeExceeded = true;
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this.emit("error", new Error(message));
};
var util$c = require$$1$3;
var Stream$2 = require$$1$2.Stream;
var DelayedStream = delayed_stream;
var combined_stream = CombinedStream$1;
function CombinedStream$1() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;
  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util$c.inherits(CombinedStream$1, Stream$2);
CombinedStream$1.create = function(options) {
  var combinedStream = new this();
  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }
  return combinedStream;
=======
var gb = Pe, lm = ie.Stream, xp = vb, xb = we;
function we() {
  this.writable = !1, this.readable = !0, this.dataSize = 0, this.maxDataSize = 2 * 1024 * 1024, this.pauseStreams = !0, this._released = !1, this._streams = [], this._currentStream = null, this._insideLoop = !1, this._pendingNext = !1;
}
gb.inherits(we, lm);
we.create = function(e) {
  var t = new this();
  e = e || {};
  for (var n in e)
    t[n] = e[n];
  return t;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
};
we.isStreamLike = function(e) {
  return typeof e != "function" && typeof e != "string" && typeof e != "boolean" && typeof e != "number" && !Buffer.isBuffer(e);
};
we.prototype.append = function(e) {
  var t = we.isStreamLike(e);
  if (t) {
    if (!(e instanceof xp)) {
      var n = xp.create(e, {
        maxDataSize: 1 / 0,
        pauseStream: this.pauseStreams
      });
      e.on("data", this._checkDataSize.bind(this)), e = n;
    }
    this._handleErrors(e), this.pauseStreams && e.pause();
  }
  return this._streams.push(e), this;
};
we.prototype.pipe = function(e, t) {
  return lm.prototype.pipe.call(this, e, t), this.resume(), e;
};
we.prototype._getNext = function() {
  if (this._currentStream = null, this._insideLoop) {
    this._pendingNext = !0;
    return;
  }
  this._insideLoop = !0;
  try {
    do
      this._pendingNext = !1, this._realGetNext();
    while (this._pendingNext);
  } finally {
    this._insideLoop = !1;
  }
};
we.prototype._realGetNext = function() {
  var e = this._streams.shift();
  if (typeof e > "u") {
    this.end();
    return;
  }
  if (typeof e != "function") {
    this._pipeNext(e);
    return;
  }
  var t = e;
  t((function(n) {
    var r = we.isStreamLike(n);
    r && (n.on("data", this._checkDataSize.bind(this)), this._handleErrors(n)), this._pipeNext(n);
  }).bind(this));
};
we.prototype._pipeNext = function(e) {
  this._currentStream = e;
  var t = we.isStreamLike(e);
  if (t) {
    e.on("end", this._getNext.bind(this)), e.pipe(this, { end: !1 });
    return;
  }
  var n = e;
  this.write(n), this._getNext();
};
we.prototype._handleErrors = function(e) {
  var t = this;
  e.on("error", function(n) {
    t._emitError(n);
  });
};
we.prototype.write = function(e) {
  this.emit("data", e);
};
we.prototype.pause = function() {
  this.pauseStreams && (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function" && this._currentStream.pause(), this.emit("pause"));
};
we.prototype.resume = function() {
  this._released || (this._released = !0, this.writable = !0, this._getNext()), this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function" && this._currentStream.resume(), this.emit("resume");
};
we.prototype.end = function() {
  this._reset(), this.emit("end");
};
we.prototype.destroy = function() {
  this._reset(), this.emit("close");
};
we.prototype._reset = function() {
  this.writable = !1, this._streams = [], this._currentStream = null;
};
we.prototype._checkDataSize = function() {
  if (this._updateDataSize(), !(this.dataSize <= this.maxDataSize)) {
    var e = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(e));
  }
};
we.prototype._updateDataSize = function() {
  this.dataSize = 0;
  var e = this;
  this._streams.forEach(function(t) {
    t.dataSize && (e.dataSize += t.dataSize);
  }), this._currentStream && this._currentStream.dataSize && (this.dataSize += this._currentStream.dataSize);
};
<<<<<<< HEAD
CombinedStream$1.prototype._emitError = function(err) {
  this._reset();
  this.emit("error", err);
};
var mimeTypes = {};
const require$$0$2 = {
=======
we.prototype._emitError = function(e) {
  this._reset(), this.emit("error", e);
};
var um = {};
const yb = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: !0
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: !0
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: !0
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: !0
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: !0
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: !0
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: !0
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: !1
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: !1,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/calendar+json": {
    source: "iana",
    compressible: !0
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: !0
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: !0
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: !0
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: !0
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: !0
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/csvm+json": {
    source: "iana",
    compressible: !0
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: !0
  },
  "application/dash+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: !0
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: !0
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: !0,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: !1
  },
  "application/edifact": {
    source: "iana",
    compressible: !1
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/elm+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: !0
  },
  "application/emma+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/epub+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: !0
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/fido.trusted-apps+json": {
    compressible: !0
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: !1
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/geo+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: !0
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: !1,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: !1,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: !0
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: !0
  },
  "application/jrd+json": {
    source: "iana",
    compressible: !0
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: !0
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: !0,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: !0
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: !0
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/ld+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/lost+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: !0
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: !1
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: !0
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/msword": {
    source: "iana",
    compressible: !1,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: !0
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: !1,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: !0
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: !0
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: !1
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/postscript": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: !0
  },
  "application/problem+json": {
    source: "iana",
    compressible: !0
  },
  "application/problem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: !1
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: !0
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: !0,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: !0
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: !0
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: !0
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sarif+json": {
    source: "iana",
    compressible: !0
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: !0
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: !0
  },
  "application/scim+json": {
    source: "iana",
    compressible: !0
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: !0
  },
  "application/senml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: !0
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: !0
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: !0
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: !0
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: !0
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: !0
  },
  "application/swid+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: !0
  },
  "application/taxii+json": {
    source: "iana",
    compressible: !0
  },
  "application/td+json": {
    source: "iana",
    compressible: !0
  },
  "application/tei+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: !0
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: !0,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: !1,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vcard+json": {
    source: "iana",
    compressible: !0
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: !1,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: !1,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: !1,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: !1,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: !1,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: !1,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: !1,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: !1
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: !0,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: !0
  },
  "application/vnd.ms-outlook": {
    compressible: !1,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: !0
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: !1,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: !1,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: !1,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: !1,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: !0
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: !0
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: !0
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: !1,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: !1,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: !1,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: !1,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: !1,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: !1
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: !1,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: !0,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: !1,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: !0
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: !1,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: !1
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: !0,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: !1,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: !1,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: !0,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: !1,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: !1,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: !0,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: !0,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: !0,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: !0,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: !0,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: !1,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: !0,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: !0,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: !0,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: !0,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: !0
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: !1,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: !0
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: !0
  },
  "application/xop+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: !0,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: !0
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: !0
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: !0
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: !0
  },
  "application/yin+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: !1,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: !1,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: !1
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: !1,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: !1,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: !1
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: !1
  },
  "audio/vorbis": {
    source: "iana",
    compressible: !1
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: !1,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: !1,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: !1,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: !1,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: !1,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: !1,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: !0,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: !1,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: !1,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: !1
  },
  "image/png": {
    source: "iana",
    compressible: !1,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: !1,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: !0,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: !0,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: !0,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: !0,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: !0,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: !1
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: !1
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: !0
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: !1
  },
  "message/rfc822": {
    source: "iana",
    compressible: !0,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: !0,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: !0,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: !1,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: !1,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: !0
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: !1,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: !1,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: !1,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: !1,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: !1
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: !1
  },
  "multipart/form-data": {
    source: "iana",
    compressible: !1
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: !1
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: !1
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: !0,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: !0
  },
  "text/cmd": {
    compressible: !0
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: !0,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: !0,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: !0
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: !0,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: !0,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: !0,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: !0,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: !0,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: !0,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: !0,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: !0,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: !0,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: !0
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: !0
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: !0,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: !0,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: !0,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: !0,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: !0,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: !0,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: !1,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: !1,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: !1,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: !1,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: !1,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: !1,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: !0
  },
  "x-shader/x-vertex": {
    compressible: !0
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
<<<<<<< HEAD
var mimeDb = require$$0$2;
=======
var bb = yb;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
<<<<<<< HEAD
(function(exports) {
  var db = mimeDb;
  var extname = require$$1$4.extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = /* @__PURE__ */ Object.create(null);
  exports.lookup = lookup;
  exports.types = /* @__PURE__ */ Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type2) {
    if (!type2 || typeof type2 !== "string") {
      return false;
=======
(function(e) {
  var t = bb, n = oe.extname, r = /^\s*([^;\s]*)(?:;|\s|$)/, i = /^text\//i;
  e.charset = a, e.charsets = { lookup: a }, e.contentType = o, e.extension = c, e.extensions = /* @__PURE__ */ Object.create(null), e.lookup = s, e.types = /* @__PURE__ */ Object.create(null), u(e.extensions, e.types);
  function a(l) {
    if (!l || typeof l != "string")
      return !1;
    var p = r.exec(l), d = p && t[p[1].toLowerCase()];
    return d && d.charset ? d.charset : p && i.test(p[1]) ? "UTF-8" : !1;
  }
  function o(l) {
    if (!l || typeof l != "string")
      return !1;
    var p = l.indexOf("/") === -1 ? e.lookup(l) : l;
    if (!p)
      return !1;
    if (p.indexOf("charset") === -1) {
      var d = e.charset(p);
      d && (p += "; charset=" + d.toLowerCase());
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    return p;
  }
  function c(l) {
    if (!l || typeof l != "string")
      return !1;
    var p = r.exec(l), d = p && e.extensions[p[1].toLowerCase()];
    return !d || !d.length ? !1 : d[0];
  }
  function s(l) {
    if (!l || typeof l != "string")
      return !1;
    var p = n("x." + l).toLowerCase().substr(1);
    return p && e.types[p] || !1;
  }
  function u(l, p) {
    var d = ["nginx", "apache", void 0, "iana"];
    Object.keys(t).forEach(function(g) {
      var v = t[g], y = v.extensions;
      if (!(!y || !y.length)) {
        l[g] = y;
        for (var x = 0; x < y.length; x++) {
          var w = y[x];
          if (p[w]) {
            var A = d.indexOf(t[p[w]].source), O = d.indexOf(v.source);
            if (p[w] !== "application/octet-stream" && (A > O || A === O && p[w].substr(0, 12) === "application/"))
              continue;
          }
          p[w] = g;
        }
      }
    });
  }
<<<<<<< HEAD
})(mimeTypes);
var defer_1 = defer$1;
function defer$1(fn) {
  var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  if (nextTick) {
    nextTick(fn);
  } else {
    setTimeout(fn, 0);
  }
}
var defer = defer_1;
var async_1 = async$2;
function async$2(callback) {
  var isAsync = false;
  defer(function() {
    isAsync = true;
  });
  return function async_callback(err, result) {
    if (isAsync) {
      callback(err, result);
    } else {
      defer(function nextTick_callback() {
        callback(err, result);
      });
    }
  };
}
var abort_1 = abort$2;
function abort$2(state2) {
  Object.keys(state2.jobs).forEach(clean$2.bind(state2));
  state2.jobs = {};
}
function clean$2(key2) {
  if (typeof this.jobs[key2] == "function") {
    this.jobs[key2]();
  }
}
var async$1 = async_1, abort$1 = abort_1;
var iterate_1 = iterate$2;
function iterate$2(list, iterator2, state2, callback) {
  var key2 = state2["keyedList"] ? state2["keyedList"][state2.index] : state2.index;
  state2.jobs[key2] = runJob(iterator2, key2, list[key2], function(error2, output) {
    if (!(key2 in state2.jobs)) {
      return;
    }
    delete state2.jobs[key2];
    if (error2) {
      abort$1(state2);
    } else {
      state2.results[key2] = output;
    }
    callback(error2, state2.results);
  });
}
function runJob(iterator2, key2, item, callback) {
  var aborter;
  if (iterator2.length == 2) {
    aborter = iterator2(item, async$1(callback));
  } else {
    aborter = iterator2(item, key2, async$1(callback));
  }
  return aborter;
}
var state_1 = state;
function state(list, sortMethod) {
  var isNamedList = !Array.isArray(list), initState2 = {
=======
})(um);
var wb = Eb;
function Eb(e) {
  var t = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  t ? t(e) : setTimeout(e, 0);
}
var yp = wb, pm = _b;
function _b(e) {
  var t = !1;
  return yp(function() {
    t = !0;
  }), function(r, i) {
    t ? e(r, i) : yp(function() {
      e(r, i);
    });
  };
}
var fm = Sb;
function Sb(e) {
  Object.keys(e.jobs).forEach(Tb.bind(e)), e.jobs = {};
}
function Tb(e) {
  typeof this.jobs[e] == "function" && this.jobs[e]();
}
var bp = pm, Ab = fm, dm = Rb;
function Rb(e, t, n, r) {
  var i = n.keyedList ? n.keyedList[n.index] : n.index;
  n.jobs[i] = Cb(t, i, e[i], function(a, o) {
    i in n.jobs && (delete n.jobs[i], a ? Ab(n) : n.results[i] = o, r(a, n.results));
  });
}
function Cb(e, t, n, r) {
  var i;
  return e.length == 2 ? i = e(n, bp(r)) : i = e(n, t, bp(r)), i;
}
var hm = Ob;
function Ob(e, t) {
  var n = !Array.isArray(e), r = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    index: 0,
    keyedList: n || t ? Object.keys(e) : null,
    jobs: {},
    results: n ? {} : [],
    size: n ? Object.keys(e).length : e.length
  };
  return t && r.keyedList.sort(n ? t : function(i, a) {
    return t(e[i], e[a]);
  }), r;
}
<<<<<<< HEAD
var abort = abort_1, async = async_1;
var terminator_1 = terminator$2;
function terminator$2(callback) {
  if (!Object.keys(this.jobs).length) {
    return;
  }
  this.index = this.size;
  abort(this);
  async(callback)(null, this.results);
}
var iterate$1 = iterate_1, initState$1 = state_1, terminator$1 = terminator_1;
var parallel_1 = parallel;
function parallel(list, iterator2, callback) {
  var state2 = initState$1(list);
  while (state2.index < (state2["keyedList"] || list).length) {
    iterate$1(list, iterator2, state2, function(error2, result) {
      if (error2) {
        callback(error2, result);
=======
var $b = fm, Ib = pm, mm = Pb;
function Pb(e) {
  Object.keys(this.jobs).length && (this.index = this.size, $b(this), Ib(e)(null, this.results));
}
var Db = dm, Fb = hm, Nb = mm, kb = Lb;
function Lb(e, t, n) {
  for (var r = Fb(e); r.index < (r.keyedList || e).length; )
    Db(e, t, r, function(i, a) {
      if (i) {
        n(i, a);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        return;
      }
      if (Object.keys(r.jobs).length === 0) {
        n(null, r.results);
        return;
      }
<<<<<<< HEAD
    });
    state2.index++;
  }
  return terminator$1.bind(state2, callback);
}
var serialOrdered$2 = { exports: {} };
var iterate = iterate_1, initState = state_1, terminator = terminator_1;
serialOrdered$2.exports = serialOrdered$1;
serialOrdered$2.exports.ascending = ascending;
serialOrdered$2.exports.descending = descending;
function serialOrdered$1(list, iterator2, sortMethod, callback) {
  var state2 = initState(list, sortMethod);
  iterate(list, iterator2, state2, function iteratorHandler(error2, result) {
    if (error2) {
      callback(error2, result);
=======
    }), r.index++;
  return Nb.bind(r, n);
}
var Co = { exports: {} }, wp = dm, Ub = hm, Bb = mm;
Co.exports = jb;
Co.exports.ascending = vm;
Co.exports.descending = Mb;
function jb(e, t, n, r) {
  var i = Ub(e, n);
  return wp(e, t, i, function a(o, c) {
    if (o) {
      r(o, c);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      return;
    }
    if (i.index++, i.index < (i.keyedList || e).length) {
      wp(e, t, i, a);
      return;
    }
<<<<<<< HEAD
    callback(null, state2.results);
  });
  return terminator.bind(state2, callback);
=======
    r(null, i.results);
  }), Bb.bind(i, r);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function vm(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
<<<<<<< HEAD
function descending(a, b) {
  return -1 * ascending(a, b);
=======
function Mb(e, t) {
  return -1 * vm(e, t);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
var gm = Co.exports, qb = gm, zb = Hb;
function Hb(e, t, n) {
  return qb(e, t, null, n);
}
<<<<<<< HEAD
var asynckit$1 = {
  parallel: parallel_1,
  serial: serial_1,
  serialOrdered: serialOrderedExports
};
var esObjectAtoms = Object;
var esErrors = Error;
var _eval = EvalError;
var range$1 = RangeError;
var ref = ReferenceError;
var syntax = SyntaxError;
var type$1 = TypeError;
var uri = URIError;
var abs$1 = Math.abs;
var floor$1 = Math.floor;
var max$2 = Math.max;
var min$1 = Math.min;
var pow$1 = Math.pow;
var round$1 = Math.round;
var _isNaN = Number.isNaN || function isNaN2(a) {
  return a !== a;
};
var $isNaN = _isNaN;
var sign$1 = function sign(number) {
  if ($isNaN(number) || number === 0) {
    return number;
=======
var Gb = {
  parallel: kb,
  serial: zb,
  serialOrdered: gm
}, xm = Object, Wb = Error, Vb = EvalError, Yb = RangeError, Xb = ReferenceError, Kb = SyntaxError, Bl = TypeError, Jb = URIError, Zb = Math.abs, Qb = Math.floor, e1 = Math.max, t1 = Math.min, n1 = Math.pow, r1 = Math.round, i1 = Number.isNaN || function(t) {
  return t !== t;
}, a1 = i1, o1 = function(t) {
  return a1(t) || t === 0 ? t : t < 0 ? -1 : 1;
}, s1 = Object.getOwnPropertyDescriptor, ja = s1;
if (ja)
  try {
    ja([], "length");
  } catch {
    ja = null;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
var ym = ja, Ma = Object.defineProperty || !1;
if (Ma)
  try {
    Ma({}, "a", { value: 1 });
  } catch {
    Ma = !1;
  }
<<<<<<< HEAD
}
var gopd = $gOPD$1;
var $defineProperty$2 = Object.defineProperty || false;
if ($defineProperty$2) {
  try {
    $defineProperty$2({}, "a", { value: 1 });
  } catch (e) {
    $defineProperty$2 = false;
  }
}
var esDefineProperty = $defineProperty$2;
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _ in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
=======
var c1 = Ma, Cs, Ep;
function bm() {
  return Ep || (Ep = 1, Cs = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, n = Symbol("test"), r = Object(n);
    if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
      return !1;
    var i = 42;
    t[n] = i;
    for (var a in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var o = Object.getOwnPropertySymbols(t);
    if (o.length !== 1 || o[0] !== n || !Object.prototype.propertyIsEnumerable.call(t, n))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var c = (
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, n)
      );
      if (c.value !== i || c.enumerable !== !0)
        return !1;
    }
    return !0;
  }), Cs;
}
<<<<<<< HEAD
var hasSymbols$1;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols$1;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols$1 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols$1;
=======
var Os, _p;
function l1() {
  if (_p) return Os;
  _p = 1;
  var e = typeof Symbol < "u" && Symbol, t = bm();
  return Os = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, Os;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
var $s, Sp;
function wm() {
  return Sp || (Sp = 1, $s = typeof Reflect < "u" && Reflect.getPrototypeOf || null), $s;
}
var Is, Tp;
function Em() {
  if (Tp) return Is;
  Tp = 1;
  var e = xm;
  return Is = e.getPrototypeOf || null, Is;
}
<<<<<<< HEAD
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var toStr = Object.prototype.toString;
var max$1 = Math.max;
var funcType = "[object Function]";
var concatty = function concatty2(a, b) {
  var arr = [];
  for (var i = 0; i < a.length; i += 1) {
    arr[i] = a[i];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }
  return arr;
};
var slicy = function slicy2(arrLike, offset) {
  var arr = [];
  for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
    arr[j] = arrLike[i];
  }
  return arr;
};
var joiny = function(arr, joiner) {
  var str2 = "";
  for (var i = 0; i < arr.length; i += 1) {
    str2 += arr[i];
    if (i + 1 < arr.length) {
      str2 += joiner;
    }
  }
  return str2;
};
var implementation$1 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
=======
var u1 = "Function.prototype.bind called on incompatible ", p1 = Object.prototype.toString, f1 = Math.max, d1 = "[object Function]", Ap = function(t, n) {
  for (var r = [], i = 0; i < t.length; i += 1)
    r[i] = t[i];
  for (var a = 0; a < n.length; a += 1)
    r[a + t.length] = n[a];
  return r;
}, h1 = function(t, n) {
  for (var r = [], i = n, a = 0; i < t.length; i += 1, a += 1)
    r[a] = t[i];
  return r;
}, m1 = function(e, t) {
  for (var n = "", r = 0; r < e.length; r += 1)
    n += e[r], r + 1 < e.length && (n += t);
  return n;
}, v1 = function(t) {
  var n = this;
  if (typeof n != "function" || p1.apply(n) !== d1)
    throw new TypeError(u1 + n);
  for (var r = h1(arguments, 1), i, a = function() {
    if (this instanceof i) {
      var l = n.apply(
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        this,
        Ap(r, arguments)
      );
      return Object(l) === l ? l : this;
    }
    return n.apply(
      t,
      Ap(r, arguments)
    );
<<<<<<< HEAD
  };
  var boundLength = max$1(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = "$" + i;
  }
  bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
=======
  }, o = f1(0, n.length - r.length), c = [], s = 0; s < o; s++)
    c[s] = "$" + s;
  if (i = Function("binder", "return function (" + m1(c, ",") + "){ return binder.apply(this,arguments); }")(a), n.prototype) {
    var u = function() {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    };
    u.prototype = n.prototype, i.prototype = new u(), u.prototype = null;
  }
<<<<<<< HEAD
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
=======
  return i;
}, g1 = v1, Oo = Function.prototype.bind || g1, Ps, Rp;
function jl() {
  return Rp || (Rp = 1, Ps = Function.prototype.call), Ps;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
var Ds, Cp;
function _m() {
  return Cp || (Cp = 1, Ds = Function.prototype.apply), Ds;
}
<<<<<<< HEAD
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind3 = functionBind;
  var $apply2 = requireFunctionApply();
  var $call2 = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind3.call($call2, $apply2);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind3 = functionBind;
  var $TypeError2 = type$1;
  var $call2 = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError2("a function is required");
    }
    return $actualApply(bind3, $call2, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = gopd;
  var hasProtoAccessor;
=======
var Fs, Op;
function x1() {
  return Op || (Op = 1, Fs = typeof Reflect < "u" && Reflect && Reflect.apply), Fs;
}
var Ns, $p;
function y1() {
  if ($p) return Ns;
  $p = 1;
  var e = Oo, t = _m(), n = jl(), r = x1();
  return Ns = r || e.call(n, t), Ns;
}
var ks, Ip;
function b1() {
  if (Ip) return ks;
  Ip = 1;
  var e = Oo, t = Bl, n = jl(), r = y1();
  return ks = function(a) {
    if (a.length < 1 || typeof a[0] != "function")
      throw new t("a function is required");
    return r(e, n, a);
  }, ks;
}
var Ls, Pp;
function w1() {
  if (Pp) return Ls;
  Pp = 1;
  var e = b1(), t = ym, n;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    n = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (o) {
    if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS")
      throw o;
  }
  var r = !!n && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), i = Object, a = i.getPrototypeOf;
  return Ls = r && typeof r.get == "function" ? e([r.get]) : typeof a == "function" ? (
    /** @type {import('./get')} */
    function(c) {
      return a(c == null ? c : i(c));
    }
  ) : !1, Ls;
}
<<<<<<< HEAD
var getProto$1;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto$1;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = requireGet();
  getProto$1 = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
=======
var Us, Dp;
function E1() {
  if (Dp) return Us;
  Dp = 1;
  var e = wm(), t = Em(), n = w1();
  return Us = e ? function(i) {
    return e(i);
  } : t ? function(i) {
    if (!i || typeof i != "object" && typeof i != "function")
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      throw new TypeError("getProto: not an object");
    return t(i);
  } : n ? function(i) {
    return n(i);
  } : null, Us;
}
<<<<<<< HEAD
var call$1 = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind$1 = functionBind;
var hasown = bind$1.call(call$1, $hasOwn);
var undefined$1;
var $Object = esObjectAtoms;
var $Error = esErrors;
var $EvalError = _eval;
var $RangeError = range$1;
var $ReferenceError = ref;
var $SyntaxError = syntax;
var $TypeError$1 = type$1;
var $URIError = uri;
var abs = abs$1;
var floor = floor$1;
var max = max$2;
var min = min$1;
var pow = pow$1;
var round = round$1;
var sign2 = sign$1;
var $Function = Function;
var getEvalledConstructor = function(expressionSyntax) {
=======
var _1 = Function.prototype.call, S1 = Object.prototype.hasOwnProperty, T1 = Oo, Ml = T1.call(_1, S1), re, A1 = xm, R1 = Wb, C1 = Vb, O1 = Yb, $1 = Xb, Ar = Kb, br = Bl, I1 = Jb, P1 = Zb, D1 = Qb, F1 = e1, N1 = t1, k1 = n1, L1 = r1, U1 = o1, Sm = Function, Bs = function(e) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    return Sm('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
<<<<<<< HEAD
};
var $gOPD = gopd;
var $defineProperty$1 = esDefineProperty;
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
=======
}, ui = ym, B1 = c1, js = function() {
  throw new br();
}, j1 = ui ? function() {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    return arguments.callee, js;
  } catch {
    try {
      return ui(arguments, "callee").get;
    } catch {
      return js;
    }
  }
<<<<<<< HEAD
}() : throwTypeError;
var hasSymbols = requireHasSymbols()();
var getProto = requireGetProto();
var $ObjectGPO = requireObject_getPrototypeOf();
var $ReflectGPO = requireReflect_getPrototypeOf();
var $apply = requireFunctionApply();
var $call = requireFunctionCall();
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
=======
}() : js, Qn = l1()(), $e = E1(), M1 = Em(), q1 = wm(), Tm = _m(), Ii = jl(), cr = {}, z1 = typeof Uint8Array > "u" || !$e ? re : $e(Uint8Array), Dn = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? re : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? re : ArrayBuffer,
  "%ArrayIteratorPrototype%": Qn && $e ? $e([][Symbol.iterator]()) : re,
  "%AsyncFromSyncIteratorPrototype%": re,
  "%AsyncFunction%": cr,
  "%AsyncGenerator%": cr,
  "%AsyncGeneratorFunction%": cr,
  "%AsyncIteratorPrototype%": cr,
  "%Atomics%": typeof Atomics > "u" ? re : Atomics,
  "%BigInt%": typeof BigInt > "u" ? re : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? re : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? re : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? re : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
<<<<<<< HEAD
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
=======
  "%Error%": R1,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": C1,
  "%Float16Array%": typeof Float16Array > "u" ? re : Float16Array,
  "%Float32Array%": typeof Float32Array > "u" ? re : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? re : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? re : FinalizationRegistry,
  "%Function%": Sm,
  "%GeneratorFunction%": cr,
  "%Int8Array%": typeof Int8Array > "u" ? re : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? re : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? re : Int32Array,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Qn && $e ? $e($e([][Symbol.iterator]())) : re,
  "%JSON%": typeof JSON == "object" ? JSON : re,
  "%Map%": typeof Map > "u" ? re : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Qn || !$e ? re : $e((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
<<<<<<< HEAD
  "%Object%": $Object,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
=======
  "%Object%": A1,
  "%Object.getOwnPropertyDescriptor%": ui,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? re : Promise,
  "%Proxy%": typeof Proxy > "u" ? re : Proxy,
  "%RangeError%": O1,
  "%ReferenceError%": $1,
  "%Reflect%": typeof Reflect > "u" ? re : Reflect,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? re : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Qn || !$e ? re : $e((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? re : SharedArrayBuffer,
  "%String%": String,
<<<<<<< HEAD
  "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply,
  "%Object.defineProperty%": $defineProperty$1,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round,
  "%Math.sign%": sign2,
  "%Reflect.getPrototypeOf%": $ReflectGPO
=======
  "%StringIteratorPrototype%": Qn && $e ? $e(""[Symbol.iterator]()) : re,
  "%Symbol%": Qn ? Symbol : re,
  "%SyntaxError%": Ar,
  "%ThrowTypeError%": j1,
  "%TypedArray%": z1,
  "%TypeError%": br,
  "%Uint8Array%": typeof Uint8Array > "u" ? re : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? re : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? re : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? re : Uint32Array,
  "%URIError%": I1,
  "%WeakMap%": typeof WeakMap > "u" ? re : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? re : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? re : WeakSet,
  "%Function.prototype.call%": Ii,
  "%Function.prototype.apply%": Tm,
  "%Object.defineProperty%": B1,
  "%Object.getPrototypeOf%": M1,
  "%Math.abs%": P1,
  "%Math.floor%": D1,
  "%Math.max%": F1,
  "%Math.min%": N1,
  "%Math.pow%": k1,
  "%Math.round%": L1,
  "%Math.sign%": U1,
  "%Reflect.getPrototypeOf%": q1
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
};
if ($e)
  try {
    null.error;
  } catch (e) {
<<<<<<< HEAD
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
}
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
=======
    var H1 = $e($e(e));
    Dn["%Error.prototype%"] = H1;
  }
var G1 = function e(t) {
  var n;
  if (t === "%AsyncFunction%")
    n = Bs("async function () {}");
  else if (t === "%GeneratorFunction%")
    n = Bs("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    n = Bs("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var r = e("%AsyncGeneratorFunction%");
    r && (n = r.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var i = e("%AsyncGenerator%");
    i && $e && (n = $e(i.prototype));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return Dn[t] = n, n;
}, Fp = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
<<<<<<< HEAD
};
var bind2 = functionBind;
var hasOwn$2 = hasown;
var $concat = bind2.call($call, Array.prototype.concat);
var $spliceApply = bind2.call($apply, Array.prototype.splice);
var $replace = bind2.call($call, String.prototype.replace);
var $strSlice = bind2.call($call, String.prototype.slice);
var $exec = bind2.call($call, RegExp.prototype.exec);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === "%" && last !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$2(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$2(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
=======
}, Pi = Oo, Za = Ml, W1 = Pi.call(Ii, Array.prototype.concat), V1 = Pi.call(Tm, Array.prototype.splice), Np = Pi.call(Ii, String.prototype.replace), Qa = Pi.call(Ii, String.prototype.slice), Y1 = Pi.call(Ii, RegExp.prototype.exec), X1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, K1 = /\\(\\)?/g, J1 = function(t) {
  var n = Qa(t, 0, 1), r = Qa(t, -1);
  if (n === "%" && r !== "%")
    throw new Ar("invalid intrinsic syntax, expected closing `%`");
  if (r === "%" && n !== "%")
    throw new Ar("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return Np(t, X1, function(a, o, c, s) {
    i[i.length] = c ? Np(s, K1, "$1") : o || a;
  }), i;
}, Z1 = function(t, n) {
  var r = t, i;
  if (Za(Fp, r) && (i = Fp[r], r = "%" + i[0] + "%"), Za(Dn, r)) {
    var a = Dn[r];
    if (a === cr && (a = G1(r)), typeof a > "u" && !n)
      throw new br("intrinsic " + t + " exists, but is not available. Please file an issue!");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return {
      alias: i,
      name: r,
      value: a
    };
  }
<<<<<<< HEAD
  throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$2(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$2(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
=======
  throw new Ar("intrinsic " + t + " does not exist!");
}, Q1 = function(t, n) {
  if (typeof t != "string" || t.length === 0)
    throw new br("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new br('"allowMissing" argument must be a boolean');
  if (Y1(/^%?[^%]*%?$/, t) === null)
    throw new Ar("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var r = J1(t), i = r.length > 0 ? r[0] : "", a = Z1("%" + i + "%", n), o = a.name, c = a.value, s = !1, u = a.alias;
  u && (i = u[0], V1(r, W1([0, 1], u)));
  for (var l = 1, p = !0; l < r.length; l += 1) {
    var d = r[l], m = Qa(d, 0, 1), g = Qa(d, -1);
    if ((m === '"' || m === "'" || m === "`" || g === '"' || g === "'" || g === "`") && m !== g)
      throw new Ar("property names with quotes must have matching quotes");
    if ((d === "constructor" || !p) && (s = !0), i += "." + d, o = "%" + i + "%", Za(Dn, o))
      c = Dn[o];
    else if (c != null) {
      if (!(d in c)) {
        if (!n)
          throw new br("base intrinsic for " + t + " exists, but the property is not available.");
        return;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
      if (ui && l + 1 >= r.length) {
        var v = ui(c, d);
        p = !!v, p && "get" in v && !("originalValue" in v.get) ? c = v.get : c = c[d];
      } else
        p = Za(c, d), c = c[d];
      p && !s && (Dn[o] = c);
    }
  }
<<<<<<< HEAD
  return value;
};
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var GetIntrinsic2 = getIntrinsic;
var $defineProperty = GetIntrinsic2("%Object.defineProperty%", true);
var hasToStringTag = requireShams()();
var hasOwn$1 = hasown;
var $TypeError = type$1;
var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
var esSetTostringtag = function setToStringTag(object, value) {
  var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
  var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
  if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
    throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
  }
  if (toStringTag && (overrideIfSet || !hasOwn$1(object, toStringTag))) {
    if ($defineProperty) {
      $defineProperty(object, toStringTag, {
        configurable: !nonConfigurable,
        enumerable: false,
        value,
        writable: false
      });
    } else {
      object[toStringTag] = value;
    }
  }
};
var populate$1 = function(dst, src2) {
  Object.keys(src2).forEach(function(prop) {
    dst[prop] = dst[prop] || src2[prop];
  });
  return dst;
};
var CombinedStream = combined_stream;
var util$b = require$$1$3;
var path$s = require$$1$4;
var http$1 = require$$3$2;
var https$1 = require$$4$2;
var parseUrl$2 = require$$0$3.parse;
var fs$v = fs$w;
var Stream$1 = require$$1$2.Stream;
var mime = mimeTypes;
var asynckit = asynckit$1;
var setToStringTag2 = esSetTostringtag;
var hasOwn = hasown;
var populate = populate$1;
function FormData$1(options) {
  if (!(this instanceof FormData$1)) {
    return new FormData$1(options);
  }
  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];
  CombinedStream.call(this);
  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}
util$b.inherits(FormData$1, CombinedStream);
FormData$1.LINE_BREAK = "\r\n";
FormData$1.DEFAULT_CONTENT_TYPE = "application/octet-stream";
FormData$1.prototype.append = function(field, value, options) {
  options = options || {};
  if (typeof options === "string") {
    options = { filename: options };
  }
  var append3 = CombinedStream.prototype.append.bind(this);
  if (typeof value === "number" || value == null) {
    value = String(value);
  }
  if (Array.isArray(value)) {
=======
  return c;
}, Ms, kp;
function ew() {
  if (kp) return Ms;
  kp = 1;
  var e = bm();
  return Ms = function() {
    return e() && !!Symbol.toStringTag;
  }, Ms;
}
var tw = Q1, Lp = tw("%Object.defineProperty%", !0), nw = ew()(), rw = Ml, iw = Bl, la = nw ? Symbol.toStringTag : null, aw = function(t, n) {
  var r = arguments.length > 2 && !!arguments[2] && arguments[2].force, i = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
  if (typeof r < "u" && typeof r != "boolean" || typeof i < "u" && typeof i != "boolean")
    throw new iw("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
  la && (r || !rw(t, la)) && (Lp ? Lp(t, la, {
    configurable: !i,
    enumerable: !1,
    value: n,
    writable: !1
  }) : t[la] = n);
}, ow = function(e, t) {
  return Object.keys(t).forEach(function(n) {
    e[n] = e[n] || t[n];
  }), e;
}, ql = xb, sw = Pe, qs = oe, cw = bo, lw = Nl, uw = At.parse, pw = ae, fw = ie.Stream, zs = um, dw = Gb, hw = aw, tn = Ml, el = ow;
function se(e) {
  if (!(this instanceof se))
    return new se(e);
  this._overheadLength = 0, this._valueLength = 0, this._valuesToMeasure = [], ql.call(this), e = e || {};
  for (var t in e)
    this[t] = e[t];
}
sw.inherits(se, ql);
se.LINE_BREAK = `\r
`;
se.DEFAULT_CONTENT_TYPE = "application/octet-stream";
se.prototype.append = function(e, t, n) {
  n = n || {}, typeof n == "string" && (n = { filename: n });
  var r = ql.prototype.append.bind(this);
  if ((typeof t == "number" || t == null) && (t = String(t)), Array.isArray(t)) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    this._error(new Error("Arrays are not supported."));
    return;
  }
  var i = this._multiPartHeader(e, t, n), a = this._multiPartFooter();
  r(i), r(t), r(a), this._trackLength(i, t, n);
};
<<<<<<< HEAD
FormData$1.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;
  if (options.knownLength != null) {
    valueLength += Number(options.knownLength);
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === "string") {
    valueLength = Buffer.byteLength(value);
  }
  this._valueLength += valueLength;
  this._overheadLength += Buffer.byteLength(header) + FormData$1.LINE_BREAK.length;
  if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream$1)) {
    return;
  }
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};
FormData$1.prototype._lengthRetriever = function(value, callback) {
  if (hasOwn(value, "fd")) {
    if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
      callback(null, value.end + 1 - (value.start ? value.start : 0));
    } else {
      fs$v.stat(value.path, function(err, stat2) {
        if (err) {
          callback(err);
          return;
        }
        var fileSize = stat2.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }
  } else if (hasOwn(value, "httpVersion")) {
    callback(null, Number(value.headers["content-length"]));
  } else if (hasOwn(value, "httpModule")) {
    value.on("response", function(response) {
      value.pause();
      callback(null, Number(response.headers["content-length"]));
    });
    value.resume();
  } else {
    callback("Unknown stream");
  }
};
FormData$1.prototype._multiPartHeader = function(field, value, options) {
  if (typeof options.header === "string") {
    return options.header;
  }
  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);
  var contents = "";
  var headers2 = {
    // add custom disposition as third element or keep it two elements if not
    "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    "Content-Type": [].concat(contentType || [])
  };
  if (typeof options.header === "object") {
    populate(headers2, options.header);
  }
  var header;
  for (var prop in headers2) {
    if (hasOwn(headers2, prop)) {
      header = headers2[prop];
      if (header == null) {
        continue;
      }
      if (!Array.isArray(header)) {
        header = [header];
      }
      if (header.length) {
        contents += prop + ": " + header.join("; ") + FormData$1.LINE_BREAK;
      }
    }
  }
  return "--" + this.getBoundary() + FormData$1.LINE_BREAK + contents + FormData$1.LINE_BREAK;
};
FormData$1.prototype._getContentDisposition = function(value, options) {
  var filename;
  if (typeof options.filepath === "string") {
    filename = path$s.normalize(options.filepath).replace(/\\/g, "/");
  } else if (options.filename || value && (value.name || value.path)) {
    filename = path$s.basename(options.filename || value && (value.name || value.path));
  } else if (value && value.readable && hasOwn(value, "httpVersion")) {
    filename = path$s.basename(value.client._httpMessage.path || "");
  }
  if (filename) {
    return 'filename="' + filename + '"';
  }
};
FormData$1.prototype._getContentType = function(value, options) {
  var contentType = options.contentType;
  if (!contentType && value && value.name) {
    contentType = mime.lookup(value.name);
  }
  if (!contentType && value && value.path) {
    contentType = mime.lookup(value.path);
  }
  if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
    contentType = value.headers["content-type"];
  }
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }
  if (!contentType && value && typeof value === "object") {
    contentType = FormData$1.DEFAULT_CONTENT_TYPE;
  }
  return contentType;
};
FormData$1.prototype._multiPartFooter = function() {
  return (function(next) {
    var footer = FormData$1.LINE_BREAK;
    var lastPart = this._streams.length === 0;
    if (lastPart) {
      footer += this._lastBoundary();
    }
    next(footer);
  }).bind(this);
};
FormData$1.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + FormData$1.LINE_BREAK;
};
FormData$1.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    "content-type": "multipart/form-data; boundary=" + this.getBoundary()
  };
  for (header in userHeaders) {
    if (hasOwn(userHeaders, header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }
  return formHeaders;
};
FormData$1.prototype.setBoundary = function(boundary) {
  if (typeof boundary !== "string") {
    throw new TypeError("FormData boundary must be a string");
  }
  this._boundary = boundary;
};
FormData$1.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }
  return this._boundary;
};
FormData$1.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc(0);
  var boundary = this.getBoundary();
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== "function") {
      if (Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
      } else {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
      }
      if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData$1.LINE_BREAK)]);
      }
    }
  }
  return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
};
FormData$1.prototype._generateBoundary = function() {
  var boundary = "--------------------------";
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }
  this._boundary = boundary;
};
FormData$1.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this.hasKnownLength()) {
    this._error(new Error("Cannot calculate proper length in synchronous way."));
  }
  return knownLength;
};
FormData$1.prototype.hasKnownLength = function() {
  var hasKnownLength = true;
  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }
  return hasKnownLength;
};
FormData$1.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }
  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
=======
se.prototype._trackLength = function(e, t, n) {
  var r = 0;
  n.knownLength != null ? r += Number(n.knownLength) : Buffer.isBuffer(t) ? r = t.length : typeof t == "string" && (r = Buffer.byteLength(t)), this._valueLength += r, this._overheadLength += Buffer.byteLength(e) + se.LINE_BREAK.length, !(!t || !t.path && !(t.readable && tn(t, "httpVersion")) && !(t instanceof fw)) && (n.knownLength || this._valuesToMeasure.push(t));
};
se.prototype._lengthRetriever = function(e, t) {
  tn(e, "fd") ? e.end != null && e.end != 1 / 0 && e.start != null ? t(null, e.end + 1 - (e.start ? e.start : 0)) : pw.stat(e.path, function(n, r) {
    if (n) {
      t(n);
      return;
    }
    var i = r.size - (e.start ? e.start : 0);
    t(null, i);
  }) : tn(e, "httpVersion") ? t(null, Number(e.headers["content-length"])) : tn(e, "httpModule") ? (e.on("response", function(n) {
    e.pause(), t(null, Number(n.headers["content-length"]));
  }), e.resume()) : t("Unknown stream");
};
se.prototype._multiPartHeader = function(e, t, n) {
  if (typeof n.header == "string")
    return n.header;
  var r = this._getContentDisposition(t, n), i = this._getContentType(t, n), a = "", o = {
    // add custom disposition as third element or keep it two elements if not
    "Content-Disposition": ["form-data", 'name="' + e + '"'].concat(r || []),
    // if no content type. allow it to be empty array
    "Content-Type": [].concat(i || [])
  };
  typeof n.header == "object" && el(o, n.header);
  var c;
  for (var s in o)
    if (tn(o, s)) {
      if (c = o[s], c == null)
        continue;
      Array.isArray(c) || (c = [c]), c.length && (a += s + ": " + c.join("; ") + se.LINE_BREAK);
    }
  return "--" + this.getBoundary() + se.LINE_BREAK + a + se.LINE_BREAK;
};
se.prototype._getContentDisposition = function(e, t) {
  var n;
  if (typeof t.filepath == "string" ? n = qs.normalize(t.filepath).replace(/\\/g, "/") : t.filename || e && (e.name || e.path) ? n = qs.basename(t.filename || e && (e.name || e.path)) : e && e.readable && tn(e, "httpVersion") && (n = qs.basename(e.client._httpMessage.path || "")), n)
    return 'filename="' + n + '"';
};
se.prototype._getContentType = function(e, t) {
  var n = t.contentType;
  return !n && e && e.name && (n = zs.lookup(e.name)), !n && e && e.path && (n = zs.lookup(e.path)), !n && e && e.readable && tn(e, "httpVersion") && (n = e.headers["content-type"]), !n && (t.filepath || t.filename) && (n = zs.lookup(t.filepath || t.filename)), !n && e && typeof e == "object" && (n = se.DEFAULT_CONTENT_TYPE), n;
};
se.prototype._multiPartFooter = function() {
  return (function(e) {
    var t = se.LINE_BREAK, n = this._streams.length === 0;
    n && (t += this._lastBoundary()), e(t);
  }).bind(this);
};
se.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + se.LINE_BREAK;
};
se.prototype.getHeaders = function(e) {
  var t, n = {
    "content-type": "multipart/form-data; boundary=" + this.getBoundary()
  };
  for (t in e)
    tn(e, t) && (n[t.toLowerCase()] = e[t]);
  return n;
};
se.prototype.setBoundary = function(e) {
  if (typeof e != "string")
    throw new TypeError("FormData boundary must be a string");
  this._boundary = e;
};
se.prototype.getBoundary = function() {
  return this._boundary || this._generateBoundary(), this._boundary;
};
se.prototype.getBuffer = function() {
  for (var e = new Buffer.alloc(0), t = this.getBoundary(), n = 0, r = this._streams.length; n < r; n++)
    typeof this._streams[n] != "function" && (Buffer.isBuffer(this._streams[n]) ? e = Buffer.concat([e, this._streams[n]]) : e = Buffer.concat([e, Buffer.from(this._streams[n])]), (typeof this._streams[n] != "string" || this._streams[n].substring(2, t.length + 2) !== t) && (e = Buffer.concat([e, Buffer.from(se.LINE_BREAK)])));
  return Buffer.concat([e, Buffer.from(this._lastBoundary())]);
};
se.prototype._generateBoundary = function() {
  for (var e = "--------------------------", t = 0; t < 24; t++)
    e += Math.floor(Math.random() * 10).toString(16);
  this._boundary = e;
};
se.prototype.getLengthSync = function() {
  var e = this._overheadLength + this._valueLength;
  return this._streams.length && (e += this._lastBoundary().length), this.hasKnownLength() || this._error(new Error("Cannot calculate proper length in synchronous way.")), e;
};
se.prototype.hasKnownLength = function() {
  var e = !0;
  return this._valuesToMeasure.length && (e = !1), e;
};
se.prototype.getLength = function(e) {
  var t = this._overheadLength + this._valueLength;
  if (this._streams.length && (t += this._lastBoundary().length), !this._valuesToMeasure.length) {
    process.nextTick(e.bind(this, null, t));
    return;
  }
  dw.parallel(this._valuesToMeasure, this._lengthRetriever, function(n, r) {
    if (n) {
      e(n);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      return;
    }
    r.forEach(function(i) {
      t += i;
    }), e(null, t);
  });
};
<<<<<<< HEAD
FormData$1.prototype.submit = function(params, cb) {
  var request;
  var options;
  var defaults2 = { method: "post" };
  if (typeof params === "string") {
    params = parseUrl$2(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults2);
  } else {
    options = populate(params, defaults2);
    if (!options.port) {
      options.port = options.protocol === "https:" ? 443 : 80;
    }
  }
  options.headers = this.getHeaders(params.headers);
  if (options.protocol === "https:") {
    request = https$1.request(options);
  } else {
    request = http$1.request(options);
  }
  this.getLength((function(err, length) {
    if (err && err !== "Unknown stream") {
      this._error(err);
=======
se.prototype.submit = function(e, t) {
  var n, r, i = { method: "post" };
  return typeof e == "string" ? (e = uw(e), r = el({
    port: e.port,
    path: e.pathname,
    host: e.hostname,
    protocol: e.protocol
  }, i)) : (r = el(e, i), r.port || (r.port = r.protocol === "https:" ? 443 : 80)), r.headers = this.getHeaders(e.headers), r.protocol === "https:" ? n = lw.request(r) : n = cw.request(r), this.getLength((function(a, o) {
    if (a && a !== "Unknown stream") {
      this._error(a);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      return;
    }
    if (o && n.setHeader("Content-Length", o), this.pipe(n), t) {
      var c, s = function(u, l) {
        return n.removeListener("error", s), n.removeListener("response", c), t.call(this, u, l);
      };
      c = s.bind(this, null), n.on("error", s), n.on("response", c);
    }
  }).bind(this)), n;
};
se.prototype._error = function(e) {
  this.error || (this.error = e, this.pause(), this.emit("error", e));
};
se.prototype.toString = function() {
  return "[object FormData]";
};
<<<<<<< HEAD
setToStringTag2(FormData$1, "FormData");
var form_data = FormData$1;
const FormData$2 = /* @__PURE__ */ getDefaultExportFromCjs(form_data);
function isVisitable(thing) {
  return utils$h.isPlainObject(thing) || utils$h.isArray(thing);
}
function removeBrackets(key2) {
  return utils$h.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
}
function renderKey(path2, key2, dots) {
  if (!path2) return key2;
  return path2.concat(key2).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$h.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$h.toFlatObject(utils$h, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
=======
hw(se, "FormData");
var mw = se;
const Am = /* @__PURE__ */ Ul(mw);
function tl(e) {
  return P.isPlainObject(e) || P.isArray(e);
}
function Rm(e) {
  return P.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Up(e, t, n) {
  return e ? e.concat(t).map(function(i, a) {
    return i = Rm(i), !n && a ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function vw(e) {
  return P.isArray(e) && !e.some(tl);
}
const gw = P.toFlatObject(P, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
});
function $o(e, t, n) {
  if (!P.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new (Am || FormData)(), n = P.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(v, y) {
    return !P.isUndefined(y[v]);
  });
  const r = n.metaTokens, i = n.visitor || l, a = n.dots, o = n.indexes, s = (n.Blob || typeof Blob < "u" && Blob) && P.isSpecCompliantForm(t);
  if (!P.isFunction(i))
    throw new TypeError("visitor must be a function");
  function u(g) {
    if (g === null) return "";
    if (P.isDate(g))
      return g.toISOString();
    if (P.isBoolean(g))
      return g.toString();
    if (!s && P.isBlob(g))
      throw new V("Blob is not supported. Use a Buffer instead.");
    return P.isArrayBuffer(g) || P.isTypedArray(g) ? s && typeof Blob == "function" ? new Blob([g]) : Buffer.from(g) : g;
  }
<<<<<<< HEAD
  function convertValue(value) {
    if (value === null) return "";
    if (utils$h.isDate(value)) {
      return value.toISOString();
    }
    if (utils$h.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils$h.isBlob(value)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$h.isArrayBuffer(value) || utils$h.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key2, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils$h.endsWith(key2, "{}")) {
        key2 = metaTokens ? key2 : key2.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$h.isArray(value) && isFlatArray(value) || (utils$h.isFileList(value) || utils$h.endsWith(key2, "[]")) && (arr = utils$h.toArray(value))) {
        key2 = removeBrackets(key2);
        arr.forEach(function each(el, index) {
          !(utils$h.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key2], index, dots) : indexes === null ? key2 : key2 + "[]",
            convertValue(el)
=======
  function l(g, v, y) {
    let x = g;
    if (g && !y && typeof g == "object") {
      if (P.endsWith(v, "{}"))
        v = r ? v : v.slice(0, -2), g = JSON.stringify(g);
      else if (P.isArray(g) && vw(g) || (P.isFileList(g) || P.endsWith(v, "[]")) && (x = P.toArray(g)))
        return v = Rm(v), x.forEach(function(A, O) {
          !(P.isUndefined(A) || A === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? Up([v], O, a) : o === null ? v : v + "[]",
            u(A)
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
          );
        }), !1;
    }
<<<<<<< HEAD
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key2, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
=======
    return tl(g) ? !0 : (t.append(Up(y, v, a), u(g)), !1);
  }
  const p = [], d = Object.assign(gw, {
    defaultVisitor: l,
    convertValue: u,
    isVisitable: tl
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  });
  function m(g, v) {
    if (!P.isUndefined(g)) {
      if (p.indexOf(g) !== -1)
        throw Error("Circular reference detected in " + v.join("."));
      p.push(g), P.forEach(g, function(x, w) {
        (!(P.isUndefined(x) || x === null) && i.call(
          t,
          x,
          P.isString(w) ? w.trim() : w,
          v,
          d
        )) === !0 && m(x, v ? v.concat(w) : [w]);
      }), p.pop();
    }
<<<<<<< HEAD
    stack.push(value);
    utils$h.forEach(value, function each(el, key2) {
      const result = !(utils$h.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$h.isString(key2) ? key2.trim() : key2,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key2) : [key2]);
      }
    });
    stack.pop();
=======
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  if (!P.isObject(e))
    throw new TypeError("data must be an object");
  return m(e), t;
}
function Bp(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function Cm(e, t) {
  this._pairs = [], e && $o(e, this, t);
}
const Om = Cm.prototype;
Om.append = function(t, n) {
  this._pairs.push([t, n]);
};
Om.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, Bp);
  } : Bp;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
<<<<<<< HEAD
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
=======
function xw(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function zl(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || xw;
  P.isFunction(n) && (n = {
    serialize: n
  });
  const i = n && n.serialize;
  let a;
  if (i ? a = i(t, n) : a = P.isURLSearchParams(t) ? t.toString() : new Cm(t, n).toString(r), a) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return e;
}
class jp {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    P.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
<<<<<<< HEAD
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams = require$$0$3.URLSearchParams;
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str2 = "";
  const { length } = alphabet;
  const randomValues = new Uint32Array(size);
  require$$0$4.randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str2 += alphabet[randomValues[i] % length];
  }
  return str2;
};
const platform$2 = {
  isNode: true,
  classes: {
    URLSearchParams,
    FormData: FormData$2,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: ["http", "https", "file", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils$g = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform$1 = {
  ...utils$g,
  ...platform$2
};
function toURLEncodedForm(data, options) {
  return toFormData$1(data, new platform$1.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key2, path2, helpers) {
      if (platform$1.isNode && utils$h.isBuffer(value)) {
        this.append(key2, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$h.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key2;
  for (i = 0; i < len; i++) {
    key2 = keys[i];
    obj[key2] = arr[key2];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name = path2[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path2.length;
    name = !name && utils$h.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$h.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$h.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index);
    if (result && utils$h.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$h.isFormData(formData) && utils$h.isFunction(formData.entries)) {
    const obj = {};
    utils$h.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$h.isString(rawValue)) {
=======
const Hl = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, yw = At.URLSearchParams, Hs = "abcdefghijklmnopqrstuvwxyz", Mp = "0123456789", $m = {
  DIGIT: Mp,
  ALPHA: Hs,
  ALPHA_DIGIT: Hs + Hs.toUpperCase() + Mp
}, bw = (e = 16, t = $m.ALPHA_DIGIT) => {
  let n = "";
  const { length: r } = t, i = new Uint32Array(e);
  Dr.randomFillSync(i);
  for (let a = 0; a < e; a++)
    n += t[i[a] % r];
  return n;
}, ww = {
  isNode: !0,
  classes: {
    URLSearchParams: yw,
    FormData: Am,
    Blob: typeof Blob < "u" && Blob || null
  },
  ALPHABET: $m,
  generateString: bw,
  protocols: ["http", "https", "file", "data"]
}, Gl = typeof window < "u" && typeof document < "u", nl = typeof navigator == "object" && navigator || void 0, Ew = Gl && (!nl || ["ReactNative", "NativeScript", "NS"].indexOf(nl.product) < 0), _w = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Sw = Gl && window.location.href || "http://localhost", Tw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Gl,
  hasStandardBrowserEnv: Ew,
  hasStandardBrowserWebWorkerEnv: _w,
  navigator: nl,
  origin: Sw
}, Symbol.toStringTag, { value: "Module" })), be = {
  ...Tw,
  ...ww
};
function Aw(e, t) {
  return $o(e, new be.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, a) {
      return be.isNode && P.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function Rw(e) {
  return P.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function Cw(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let a;
  for (r = 0; r < i; r++)
    a = n[r], t[a] = e[a];
  return t;
}
function Im(e) {
  function t(n, r, i, a) {
    let o = n[a++];
    if (o === "__proto__") return !0;
    const c = Number.isFinite(+o), s = a >= n.length;
    return o = !o && P.isArray(i) ? i.length : o, s ? (P.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !c) : ((!i[o] || !P.isObject(i[o])) && (i[o] = []), t(n, r, i[o], a) && P.isArray(i[o]) && (i[o] = Cw(i[o])), !c);
  }
  if (P.isFormData(e) && P.isFunction(e.entries)) {
    const n = {};
    return P.forEachEntry(e, (r, i) => {
      t(Rw(r), i, n, 0);
    }), n;
  }
  return null;
}
function Ow(e, t, n) {
  if (P.isString(e))
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    try {
      return (t || JSON.parse)(e), P.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const Di = {
  transitional: Hl,
  adapter: ["xhr", "http", "fetch"],
<<<<<<< HEAD
  transformRequest: [function transformRequest(data, headers2) {
    const contentType = headers2.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$h.isObject(data);
    if (isObjectPayload && utils$h.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$h.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$h.isArrayBuffer(data) || utils$h.isBuffer(data) || utils$h.isStream(data) || utils$h.isFile(data) || utils$h.isBlob(data) || utils$h.isReadableStream(data)) {
      return data;
    }
    if (utils$h.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$h.isURLSearchParams(data)) {
      headers2.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$h.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
=======
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, a = P.isObject(t);
    if (a && P.isHTMLForm(t) && (t = new FormData(t)), P.isFormData(t))
      return i ? JSON.stringify(Im(t)) : t;
    if (P.isArrayBuffer(t) || P.isBuffer(t) || P.isStream(t) || P.isFile(t) || P.isBlob(t) || P.isReadableStream(t))
      return t;
    if (P.isArrayBufferView(t))
      return t.buffer;
    if (P.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let c;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return Aw(t, this.formSerializer).toString();
      if ((c = P.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const s = this.env && this.env.FormData;
        return $o(
          c ? { "files[]": t } : t,
          s && new s(),
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
          this.formSerializer
        );
      }
    }
<<<<<<< HEAD
    if (isObjectPayload || hasJSONContentType) {
      headers2.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
=======
    return a || i ? (n.setContentType("application/json", !1), Ow(t)) : t;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }],
  transformResponse: [function(t) {
    const n = this.transitional || Di.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (P.isResponse(t) || P.isReadableStream(t))
      return t;
    if (t && P.isString(t) && (r && !this.responseType || i)) {
      const o = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (c) {
        if (o)
          throw c.name === "SyntaxError" ? V.from(c, V.ERR_BAD_RESPONSE, this, null, this.response) : c;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: be.classes.FormData,
    Blob: be.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
P.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Di.headers[e] = {};
});
<<<<<<< HEAD
const ignoreDuplicateOf = utils$h.toObjectSet([
=======
const $w = P.toObjectSet([
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
<<<<<<< HEAD
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key2;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key2 = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
      return;
    }
    if (key2 === "set-cookie") {
      if (parsed[key2]) {
        parsed[key2].push(val);
      } else {
        parsed[key2] = [val];
      }
    } else {
      parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
=======
]), Iw = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || t[n] && $w[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, qp = Symbol("internals");
function Hr(e) {
  return e && String(e).trim().toLowerCase();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function qa(e) {
  return e === !1 || e == null ? e : P.isArray(e) ? e.map(qa) : String(e);
}
<<<<<<< HEAD
function parseTokens(str2) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str2)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$h.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$h.isString(value)) return;
  if (utils$h.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$h.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str2) => {
    return char.toUpperCase() + str2;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$h.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
=======
function Pw(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const Dw = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Gs(e, t, n, r, i) {
  if (P.isFunction(r))
    return r.call(this, t, n);
  if (i && (t = n), !!P.isString(t)) {
    if (P.isString(r))
      return t.indexOf(r) !== -1;
    if (P.isRegExp(r))
      return r.test(t);
  }
}
function Fw(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function Nw(e, t) {
  const n = P.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, a, o) {
        return this[r].call(this, t, i, a, o);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      },
      configurable: !0
    });
  });
}
let Le = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function a(c, s, u) {
      const l = Hr(s);
      if (!l)
        throw new Error("header name must be a non-empty string");
<<<<<<< HEAD
      }
      const key2 = utils$h.findKey(self2, lHeader);
      if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
        self2[key2 || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers2, _rewrite) => utils$h.forEach(headers2, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$h.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$h.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$h.isObject(header) && utils$h.isIterable(header)) {
      let obj = {}, dest, key2;
      for (const entry of header) {
        if (!utils$h.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key2 = entry[0]] = (dest = obj[key2]) ? utils$h.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key2 = utils$h.findKey(this, header);
      if (key2) {
        const value = this[key2];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$h.isFunction(parser)) {
          return parser.call(this, value, key2);
        }
        if (utils$h.isRegExp(parser)) {
          return parser.exec(value);
        }
=======
      const p = P.findKey(i, l);
      (!p || i[p] === void 0 || u === !0 || u === void 0 && i[p] !== !1) && (i[p || s] = qa(c));
    }
    const o = (c, s) => P.forEach(c, (u, l) => a(u, l, s));
    if (P.isPlainObject(t) || t instanceof this.constructor)
      o(t, n);
    else if (P.isString(t) && (t = t.trim()) && !Dw(t))
      o(Iw(t), n);
    else if (P.isObject(t) && P.isIterable(t)) {
      let c = {}, s, u;
      for (const l of t) {
        if (!P.isArray(l))
          throw TypeError("Object iterator must return a key-value pair");
        c[u = l[0]] = (s = c[u]) ? P.isArray(s) ? [...s, l[1]] : [s, l[1]] : l[1];
      }
      o(c, n);
    } else
      t != null && a(n, t, r);
    return this;
  }
  get(t, n) {
    if (t = Hr(t), t) {
      const r = P.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return Pw(i);
        if (P.isFunction(n))
          return n.call(this, i, r);
        if (P.isRegExp(n))
          return n.exec(i);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
<<<<<<< HEAD
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key2 = utils$h.findKey(this, header);
      return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
=======
  has(t, n) {
    if (t = Hr(t), t) {
      const r = P.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || Gs(this, this[r], r, n)));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    return !1;
  }
<<<<<<< HEAD
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key2 = utils$h.findKey(self2, _header);
        if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
          delete self2[key2];
          deleted = true;
        }
=======
  delete(t, n) {
    const r = this;
    let i = !1;
    function a(o) {
      if (o = Hr(o), o) {
        const c = P.findKey(r, o);
        c && (!n || Gs(r, r[c], c, n)) && (delete r[c], i = !0);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
    }
    return P.isArray(t) ? t.forEach(a) : a(t), i;
  }
<<<<<<< HEAD
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key2 = keys[i];
      if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
        delete this[key2];
        deleted = true;
      }
=======
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, i = !1;
    for (; r--; ) {
      const a = n[r];
      (!t || Gs(this, this[a], a, t, !0)) && (delete this[a], i = !0);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    return i;
  }
<<<<<<< HEAD
  normalize(format) {
    const self2 = this;
    const headers2 = {};
    utils$h.forEach(this, (value, header) => {
      const key2 = utils$h.findKey(headers2, header);
      if (key2) {
        self2[key2] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers2[normalized] = true;
    });
    return this;
=======
  normalize(t) {
    const n = this, r = {};
    return P.forEach(this, (i, a) => {
      const o = P.findKey(r, a);
      if (o) {
        n[o] = qa(i), delete n[a];
        return;
      }
      const c = t ? Fw(a) : String(a).trim();
      c !== a && delete n[a], n[c] = qa(i), r[c] = !0;
    }), this;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return P.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && P.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[qp] = this[qp] = {
      accessors: {}
<<<<<<< HEAD
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
=======
    }).accessors, i = this.prototype;
    function a(o) {
      const c = Hr(o);
      r[c] || (Nw(i, o), r[c] = !0);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    return P.isArray(t) ? t.forEach(a) : a(t), this;
  }
};
<<<<<<< HEAD
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$h.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key2) => {
  let mapped = key2[0].toUpperCase() + key2.slice(1);
=======
Le.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
P.reduceDescriptors(Le.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
P.freezeMethods(Le);
function Ws(e, t) {
  const n = this || Di, r = t || n, i = Le.from(r.headers);
  let a = r.data;
  return P.forEach(e, function(c) {
    a = c.call(n, a, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), a;
}
function Pm(e) {
  return !!(e && e.__CANCEL__);
}
function an(e, t, n) {
  V.call(this, e ?? "canceled", V.ERR_CANCELED, t, n), this.name = "CanceledError";
}
P.inherits(an, V, {
  __CANCEL__: !0
});
function fr(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new V(
    "Request failed with status code " + n.status,
    [V.ERR_BAD_REQUEST, V.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
<<<<<<< HEAD
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var proxyFromEnv = {};
var parseUrl$1 = require$$0$3.parse;
var DEFAULT_PORTS = {
=======
function kw(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function Lw(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function Wl(e, t, n) {
  let r = !kw(t);
  return e && (r || n == !1) ? Lw(e, t) : t;
}
var Dm = {}, Uw = At.parse, Bw = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
<<<<<<< HEAD
};
var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
};
function getProxyForUrl(url2) {
  var parsedUrl = typeof url2 === "string" ? parseUrl$1(url2) : url2 || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
=======
}, jw = String.prototype.endsWith || function(e) {
  return e.length <= this.length && this.indexOf(e, this.length - e.length) !== -1;
};
function Mw(e) {
  var t = typeof e == "string" ? Uw(e) : e || {}, n = t.protocol, r = t.host, i = t.port;
  if (typeof r != "string" || !r || typeof n != "string" || (n = n.split(":", 1)[0], r = r.replace(/:\d*$/, ""), i = parseInt(i) || Bw[n] || 0, !qw(r, i)))
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return "";
  var a = dr("npm_config_" + n + "_proxy") || dr(n + "_proxy") || dr("npm_config_proxy") || dr("all_proxy");
  return a && a.indexOf("://") === -1 && (a = n + "://" + a), a;
}
<<<<<<< HEAD
function shouldProxy(hostname, port) {
  var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
  if (!NO_PROXY) {
    return true;
  }
  if (NO_PROXY === "*") {
    return false;
  }
  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;
    }
    if (!/^[.*]/.test(parsedProxyHostname)) {
      return hostname !== parsedProxyHostname;
    }
    if (parsedProxyHostname.charAt(0) === "*") {
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}
function getEnv(key2) {
  return process.env[key2.toLowerCase()] || process.env[key2.toUpperCase()] || "";
}
proxyFromEnv.getProxyForUrl = getProxyForUrl;
var followRedirects$1 = { exports: {} };
var src = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
=======
function qw(e, t) {
  var n = (dr("npm_config_no_proxy") || dr("no_proxy")).toLowerCase();
  return n ? n === "*" ? !1 : n.split(/[,\s]/).every(function(r) {
    if (!r)
      return !0;
    var i = r.match(/^(.+):(\d+)$/), a = i ? i[1] : r, o = i ? parseInt(i[2]) : 0;
    return o && o !== t ? !0 : /^[.*]/.test(a) ? (a.charAt(0) === "*" && (a = a.slice(1)), !jw.call(e, a)) : e !== a;
  }) : !0;
}
function dr(e) {
  return process.env[e.toLowerCase()] || process.env[e.toUpperCase()] || "";
}
Dm.getProxyForUrl = Mw;
var Vl = { exports: {} }, rl = { exports: {} }, ua = { exports: {} }, Vs, zp;
function zw() {
  if (zp) return Vs;
  zp = 1;
  var e = 1e3, t = e * 60, n = t * 60, r = n * 24, i = r * 7, a = r * 365.25;
  Vs = function(l, p) {
    p = p || {};
    var d = typeof l;
    if (d === "string" && l.length > 0)
      return o(l);
    if (d === "number" && isFinite(l))
      return p.long ? s(l) : c(l);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(l)
    );
  };
  function o(l) {
    if (l = String(l), !(l.length > 100)) {
      var p = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        l
      );
      if (p) {
        var d = parseFloat(p[1]), m = (p[2] || "ms").toLowerCase();
        switch (m) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return d * a;
          case "weeks":
          case "week":
          case "w":
            return d * i;
          case "days":
          case "day":
          case "d":
            return d * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return d * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return d * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return d * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return d;
          default:
            return;
        }
      }
    }
  }
  function c(l) {
    var p = Math.abs(l);
    return p >= r ? Math.round(l / r) + "d" : p >= n ? Math.round(l / n) + "h" : p >= t ? Math.round(l / t) + "m" : p >= e ? Math.round(l / e) + "s" : l + "ms";
  }
  function s(l) {
    var p = Math.abs(l);
    return p >= r ? u(l, p, r, "day") : p >= n ? u(l, p, n, "hour") : p >= t ? u(l, p, t, "minute") : p >= e ? u(l, p, e, "second") : l + " ms";
  }
  function u(l, p, d, m) {
    var g = p >= d * 1.5;
    return Math.round(l / d) + " " + m + (g ? "s" : "");
  }
  return Vs;
}
<<<<<<< HEAD
var common$6;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common$6;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy3;
    Object.keys(env).forEach((key2) => {
      createDebug[key2] = env[key2];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
=======
var Ys, Hp;
function Fm() {
  if (Hp) return Ys;
  Hp = 1;
  function e(t) {
    r.debug = r, r.default = r, r.coerce = u, r.disable = c, r.enable = a, r.enabled = s, r.humanize = zw(), r.destroy = l, Object.keys(t).forEach((p) => {
      r[p] = t[p];
    }), r.names = [], r.skips = [], r.formatters = {};
    function n(p) {
      let d = 0;
      for (let m = 0; m < p.length; m++)
        d = (d << 5) - d + p.charCodeAt(m), d |= 0;
      return r.colors[Math.abs(d) % r.colors.length];
    }
    r.selectColor = n;
    function r(p) {
      let d, m = null, g, v;
      function y(...x) {
        if (!y.enabled)
          return;
        const w = y, A = Number(/* @__PURE__ */ new Date()), O = A - (d || A);
        w.diff = O, w.prev = d, w.curr = A, d = A, x[0] = r.coerce(x[0]), typeof x[0] != "string" && x.unshift("%O");
        let k = 0;
        x[0] = x[0].replace(/%([a-zA-Z%])/g, (W, te) => {
          if (W === "%%")
            return "%";
          k++;
          const T = r.formatters[te];
          if (typeof T == "function") {
            const H = x[k];
            W = T.call(w, H), x.splice(k, 1), k--;
          }
          return W;
        }), r.formatArgs.call(w, x), (w.log || r.log).apply(w, x);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
      return y.namespace = p, y.useColors = r.useColors(), y.color = r.selectColor(p), y.extend = i, y.destroy = r.destroy, Object.defineProperty(y, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => m !== null ? m : (g !== r.namespaces && (g = r.namespaces, v = r.enabled(p)), v),
        set: (x) => {
          m = x;
        }
      }), typeof r.init == "function" && r.init(y), y;
    }
    function i(p, d) {
      const m = r(this.namespace + (typeof d > "u" ? ":" : d) + p);
      return m.log = this.log, m;
    }
    function a(p) {
      r.save(p), r.namespaces = p, r.names = [], r.skips = [];
      const d = (typeof p == "string" ? p : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const m of d)
        m[0] === "-" ? r.skips.push(m.slice(1)) : r.names.push(m);
    }
    function o(p, d) {
      let m = 0, g = 0, v = -1, y = 0;
      for (; m < p.length; )
        if (g < d.length && (d[g] === p[m] || d[g] === "*"))
          d[g] === "*" ? (v = g, y = m, g++) : (m++, g++);
        else if (v !== -1)
          g = v + 1, y++, m = y;
        else
          return !1;
      for (; g < d.length && d[g] === "*"; )
        g++;
      return g === d.length;
    }
    function c() {
      const p = [
        ...r.names,
        ...r.skips.map((d) => "-" + d)
      ].join(",");
      return r.enable(""), p;
    }
    function s(p) {
      for (const d of r.skips)
        if (o(p, d))
          return !1;
      for (const d of r.names)
        if (o(p, d))
          return !0;
      return !1;
    }
    function u(p) {
      return p instanceof Error ? p.stack || p.message : p;
    }
    function l() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return r.enable(r.load()), r;
  }
  return Ys = e, Ys;
}
<<<<<<< HEAD
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
=======
var Gp;
function Hw() {
  return Gp || (Gp = 1, function(e, t) {
    t.formatArgs = r, t.save = i, t.load = a, t.useColors = n, t.storage = o(), t.destroy = /* @__PURE__ */ (() => {
      let s = !1;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      return () => {
        s || (s = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), t.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function n() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let s;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (s = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(s[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function r(s) {
      if (s[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + s[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
        return;
      const u = "color: " + this.color;
      s.splice(1, 0, u, "color: inherit");
      let l = 0, p = 0;
      s[0].replace(/%[a-zA-Z%]/g, (d) => {
        d !== "%%" && (l++, d === "%c" && (p = l));
      }), s.splice(p, 0, u);
    }
    t.log = console.debug || console.log || (() => {
    });
    function i(s) {
      try {
        s ? t.storage.setItem("debug", s) : t.storage.removeItem("debug");
      } catch {
      }
    }
    function a() {
      let s;
      try {
        s = t.storage.getItem("debug") || t.storage.getItem("DEBUG");
      } catch {
      }
      return !s && typeof process < "u" && "env" in process && (s = process.env.DEBUG), s;
    }
    function o() {
      try {
        return localStorage;
      } catch {
      }
    }
    e.exports = Fm()(t);
    const { formatters: c } = e.exports;
    c.j = function(s) {
      try {
        return JSON.stringify(s);
      } catch (u) {
        return "[UnexpectedJSONParseError]: " + u.message;
      }
    };
  }(ua, ua.exports)), ua.exports;
}
<<<<<<< HEAD
var node$1 = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os2 = require$$2$2;
  const tty = require$$1$5;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
=======
var pa = { exports: {} }, Xs, Wp;
function Gw() {
  return Wp || (Wp = 1, Xs = (e, t = process.argv) => {
    const n = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", r = t.indexOf(n + e), i = t.indexOf("--");
    return r !== -1 && (i === -1 || r < i);
  }), Xs;
}
var Ks, Vp;
function Ww() {
  if (Vp) return Ks;
  Vp = 1;
  const e = Eo, t = Kh, n = Gw(), { env: r } = process;
  let i;
  n("no-color") || n("no-colors") || n("color=false") || n("color=never") ? i = 0 : (n("color") || n("colors") || n("color=true") || n("color=always")) && (i = 1), "FORCE_COLOR" in r && (r.FORCE_COLOR === "true" ? i = 1 : r.FORCE_COLOR === "false" ? i = 0 : i = r.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(r.FORCE_COLOR, 10), 3));
  function a(s) {
    return s === 0 ? !1 : {
      level: s,
      hasBasic: !0,
      has256: s >= 2,
      has16m: s >= 3
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    };
  }
  function o(s, u) {
    if (i === 0)
      return 0;
    if (n("color=16m") || n("color=full") || n("color=truecolor"))
      return 3;
    if (n("color=256"))
      return 2;
    if (s && !u && i === void 0)
      return 0;
    const l = i || 0;
    if (r.TERM === "dumb")
      return l;
    if (process.platform === "win32") {
      const p = e.release().split(".");
      return Number(p[0]) >= 10 && Number(p[2]) >= 10586 ? Number(p[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in r)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((p) => p in r) || r.CI_NAME === "codeship" ? 1 : l;
    if ("TEAMCITY_VERSION" in r)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(r.TEAMCITY_VERSION) ? 1 : 0;
    if (r.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in r) {
      const p = parseInt((r.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (r.TERM_PROGRAM) {
        case "iTerm.app":
          return p >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(r.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(r.TERM) || "COLORTERM" in r ? 1 : l;
  }
  function c(s) {
    const u = o(s, s && s.isTTY);
    return a(u);
  }
  return Ks = {
    supportsColor: c,
    stdout: a(o(!0, t.isatty(1))),
    stderr: a(o(!0, t.isatty(2)))
  }, Ks;
}
<<<<<<< HEAD
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1) return node$1.exports;
  hasRequiredNode$1 = 1;
  (function(module, exports) {
    const tty = require$$1$5;
    const util2 = require$$1$3;
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
=======
var Yp;
function Vw() {
  return Yp || (Yp = 1, function(e, t) {
    const n = Kh, r = Pe;
    t.init = l, t.log = c, t.formatArgs = a, t.save = s, t.load = u, t.useColors = i, t.destroy = r.deprecate(
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    ), t.colors = [6, 2, 3, 4, 5, 1];
    try {
<<<<<<< HEAD
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key2) => {
      return /^debug_/i.test(key2);
    }).reduce((obj, key2) => {
      const prop = key2.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key2];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
=======
      const d = Ww();
      d && (d.stderr || d).level >= 2 && (t.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ]);
    } catch {
    }
    t.inspectOpts = Object.keys(process.env).filter((d) => /^debug_/i.test(d)).reduce((d, m) => {
      const g = m.substring(6).toLowerCase().replace(/_([a-z])/g, (y, x) => x.toUpperCase());
      let v = process.env[m];
      return /^(yes|on|true|enabled)$/i.test(v) ? v = !0 : /^(no|off|false|disabled)$/i.test(v) ? v = !1 : v === "null" ? v = null : v = Number(v), d[g] = v, d;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }, {});
    function i() {
      return "colors" in t.inspectOpts ? !!t.inspectOpts.colors : n.isatty(process.stderr.fd);
    }
    function a(d) {
      const { namespace: m, useColors: g } = this;
      if (g) {
        const v = this.color, y = "\x1B[3" + (v < 8 ? v : "8;5;" + v), x = `  ${y};1m${m} \x1B[0m`;
        d[0] = x + d[0].split(`
`).join(`
` + x), d.push(y + "m+" + e.exports.humanize(this.diff) + "\x1B[0m");
      } else
        d[0] = o() + m + " " + d[0];
    }
    function o() {
      return t.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function c(...d) {
      return process.stderr.write(r.formatWithOptions(t.inspectOpts, ...d) + `
`);
    }
    function s(d) {
      d ? process.env.DEBUG = d : delete process.env.DEBUG;
    }
    function u() {
      return process.env.DEBUG;
    }
    function l(d) {
      d.inspectOpts = {};
      const m = Object.keys(t.inspectOpts);
      for (let g = 0; g < m.length; g++)
        d.inspectOpts[m[g]] = t.inspectOpts[m[g]];
    }
    e.exports = Fm()(t);
    const { formatters: p } = e.exports;
    p.o = function(d) {
      return this.inspectOpts.colors = this.useColors, r.inspect(d, this.inspectOpts).split(`
`).map((m) => m.trim()).join(" ");
    }, p.O = function(d) {
      return this.inspectOpts.colors = this.useColors, r.inspect(d, this.inspectOpts);
    };
  }(pa, pa.exports)), pa.exports;
}
<<<<<<< HEAD
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src.exports = requireBrowser();
} else {
  src.exports = requireNode$1();
}
var srcExports = src.exports;
var debug$5;
var debug_1$2 = function() {
  if (!debug$5) {
=======
typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? rl.exports = Hw() : rl.exports = Vw();
var Nm = rl.exports, Gr, Yw = function() {
  if (!Gr) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    try {
      Gr = Nm("follow-redirects");
    } catch {
    }
    typeof Gr != "function" && (Gr = function() {
    });
  }
<<<<<<< HEAD
  debug$5.apply(null, arguments);
};
var url = require$$0$3;
var URL$1 = url.URL;
var http = require$$3$2;
var https = require$$4$2;
var Writable$5 = require$$1$2.Writable;
var assert$2 = require$$2$3;
var debug$4 = debug_1$2;
(function detectUnsupportedEnvironment() {
  var looksLikeNode = typeof process !== "undefined";
  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var looksLikeV8 = isFunction(Error.captureStackTrace);
  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
    console.warn("The follow-redirects package should be excluded from browser builds.");
  }
=======
  Gr.apply(null, arguments);
}, Fi = At, pi = Fi.URL, Xw = bo, Kw = Nl, Yl = ie.Writable, Xl = wo, km = Yw;
(function() {
  var t = typeof process < "u", n = typeof window < "u" && typeof document < "u", r = jn(Error.captureStackTrace);
  !t && (n || !r) && console.warn("The follow-redirects package should be excluded from browser builds.");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
})();
var Kl = !1;
try {
  Xl(new pi(""));
} catch (e) {
  Kl = e.code === "ERR_INVALID_URL";
}
<<<<<<< HEAD
var preservedUrlFields = [
=======
var Jw = [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash"
], Jl = ["abort", "aborted", "connect", "error", "socket", "timeout"], Zl = /* @__PURE__ */ Object.create(null);
Jl.forEach(function(e) {
  Zl[e] = function(t, n, r) {
    this._redirectable.emit(e, t, n, r);
  };
});
var il = Ni(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
), al = Ni(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
<<<<<<< HEAD
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);
var destroy = Writable$5.prototype.destroy || noop$5;
function RedirectableRequest(options, responseCallback) {
  Writable$5.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];
  if (responseCallback) {
    this.on("response", responseCallback);
  }
  var self2 = this;
  this._onNativeResponse = function(response) {
=======
), Zw = Ni(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  al
), Qw = Ni(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
), eE = Ni(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
), tE = Yl.prototype.destroy || Um;
function tt(e, t) {
  Yl.call(this), this._sanitizeOptions(e), this._options = e, this._ended = !1, this._ending = !1, this._redirectCount = 0, this._redirects = [], this._requestBodyLength = 0, this._requestBodyBuffers = [], t && this.on("response", t);
  var n = this;
  this._onNativeResponse = function(r) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    try {
      n._processResponse(r);
    } catch (i) {
      n.emit("error", i instanceof al ? i : new al({ cause: i }));
    }
  }, this._performRequest();
}
tt.prototype = Object.create(Yl.prototype);
tt.prototype.abort = function() {
  eu(this._currentRequest), this._currentRequest.abort(), this.emit("abort");
};
<<<<<<< HEAD
RedirectableRequest.prototype.destroy = function(error2) {
  destroyRequest(this._currentRequest, error2);
  destroy.call(this, error2);
  return this;
};
RedirectableRequest.prototype.write = function(data, encoding, callback) {
  if (this._ending) {
    throw new WriteAfterEndError();
  }
  if (!isString(data) && !isBuffer(data)) {
=======
tt.prototype.destroy = function(e) {
  return eu(this._currentRequest, e), tE.call(this, e), this;
};
tt.prototype.write = function(e, t, n) {
  if (this._ending)
    throw new eE();
  if (!Fn(e) && !iE(e))
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  if (jn(t) && (n = t, t = null), e.length === 0) {
    n && n();
    return;
  }
<<<<<<< HEAD
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data, encoding });
    this._currentRequest.write(data, encoding, callback);
  } else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
=======
  this._requestBodyLength + e.length <= this._options.maxBodyLength ? (this._requestBodyLength += e.length, this._requestBodyBuffers.push({ data: e, encoding: t }), this._currentRequest.write(e, t, n)) : (this.emit("error", new Qw()), this.abort());
};
tt.prototype.end = function(e, t, n) {
  if (jn(e) ? (n = e, e = t = null) : jn(t) && (n = t, t = null), !e)
    this._ended = this._ending = !0, this._currentRequest.end(null, null, n);
  else {
    var r = this, i = this._currentRequest;
    this.write(e, t, function() {
      r._ended = !0, i.end(null, null, n);
    }), this._ending = !0;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
};
tt.prototype.setHeader = function(e, t) {
  this._options.headers[e] = t, this._currentRequest.setHeader(e, t);
};
tt.prototype.removeHeader = function(e) {
  delete this._options.headers[e], this._currentRequest.removeHeader(e);
};
tt.prototype.setTimeout = function(e, t) {
  var n = this;
  function r(o) {
    o.setTimeout(e), o.removeListener("timeout", o.destroy), o.addListener("timeout", o.destroy);
  }
  function i(o) {
    n._timeout && clearTimeout(n._timeout), n._timeout = setTimeout(function() {
      n.emit("timeout"), a();
    }, e), r(o);
  }
  function a() {
    n._timeout && (clearTimeout(n._timeout), n._timeout = null), n.removeListener("abort", a), n.removeListener("error", a), n.removeListener("response", a), n.removeListener("close", a), t && n.removeListener("timeout", t), n.socket || n._currentRequest.removeListener("socket", i);
  }
  return t && this.on("timeout", t), this.socket ? i(this.socket) : this._currentRequest.once("socket", i), this.on("socket", r), this.on("abort", a), this.on("error", a), this.on("response", a), this.on("close", a), this;
};
[
  "flushHeaders",
  "getHeader",
  "setNoDelay",
  "setSocketKeepAlive"
].forEach(function(e) {
  tt.prototype[e] = function(t, n) {
    return this._currentRequest[e](t, n);
  };
});
["aborted", "connection", "socket"].forEach(function(e) {
  Object.defineProperty(tt.prototype, e, {
    get: function() {
      return this._currentRequest[e];
    }
  });
});
tt.prototype._sanitizeOptions = function(e) {
  if (e.headers || (e.headers = {}), e.host && (e.hostname || (e.hostname = e.host), delete e.host), !e.pathname && e.path) {
    var t = e.path.indexOf("?");
    t < 0 ? e.pathname = e.path : (e.pathname = e.path.substring(0, t), e.search = e.path.substring(t));
  }
};
tt.prototype._performRequest = function() {
  var e = this._options.protocol, t = this._options.nativeProtocols[e];
  if (!t)
    throw new TypeError("Unsupported protocol " + e);
  if (this._options.agents) {
    var n = e.slice(0, -1);
    this._options.agent = this._options.agents[n];
  }
  var r = this._currentRequest = t.request(this._options, this._onNativeResponse);
  r._redirectable = this;
  for (var i of Jl)
    r.on(i, Zl[i]);
  if (this._currentUrl = /^\//.test(this._options.path) ? Fi.format(this._options) : (
    // When making a request to a proxy, []
    // a client MUST send the target URI in absolute-form [].
    this._options.path
<<<<<<< HEAD
  );
  if (this._isRedirect) {
    var i = 0;
    var self2 = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error2) {
      if (request === self2._currentRequest) {
        if (error2) {
          self2.emit("error", error2);
        } else if (i < buffers.length) {
          var buffer2 = buffers[i++];
          if (!request.finished) {
            request.write(buffer2.data, buffer2.encoding, writeNext);
          }
        } else if (self2._ended) {
          request.end();
        }
      }
=======
  ), this._isRedirect) {
    var a = 0, o = this, c = this._requestBodyBuffers;
    (function s(u) {
      if (r === o._currentRequest)
        if (u)
          o.emit("error", u);
        else if (a < c.length) {
          var l = c[a++];
          r.finished || r.write(l.data, l.encoding, s);
        } else o._ended && r.end();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    })();
  }
};
tt.prototype._processResponse = function(e) {
  var t = e.statusCode;
  this._options.trackRedirects && this._redirects.push({
    url: this._currentUrl,
    headers: e.headers,
    statusCode: t
  });
  var n = e.headers.location;
  if (!n || this._options.followRedirects === !1 || t < 300 || t >= 400) {
    e.responseUrl = this._currentUrl, e.redirects = this._redirects, this.emit("response", e), this._requestBodyBuffers = [];
    return;
  }
<<<<<<< HEAD
  destroyRequest(this._currentRequest);
  response.destroy();
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host")
    }, this._options.headers);
  }
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource []
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) []
  statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
  var redirectUrl = resolveUrl(location, currentUrl);
  debug$4("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);
  if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response.headers,
      statusCode
=======
  if (eu(this._currentRequest), e.destroy(), ++this._redirectCount > this._options.maxRedirects)
    throw new Zw();
  var r, i = this._options.beforeRedirect;
  i && (r = Object.assign({
    // The Host header was set by nativeProtocol.request
    Host: e.req.getHeader("host")
  }, this._options.headers));
  var a = this._options.method;
  ((t === 301 || t === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource []
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) []
  t === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) && (this._options.method = "GET", this._requestBodyBuffers = [], Js(/^content-/i, this._options.headers));
  var o = Js(/^host$/i, this._options.headers), c = Ql(this._currentUrl), s = o || c.host, u = /^\w+:/.test(n) ? this._currentUrl : Fi.format(Object.assign(c, { host: s })), l = nE(n, u);
  if (km("redirecting to", l.href), this._isRedirect = !0, ol(l, this._options), (l.protocol !== c.protocol && l.protocol !== "https:" || l.host !== s && !rE(l.host, s)) && Js(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers), jn(i)) {
    var p = {
      headers: e.headers,
      statusCode: t
    }, d = {
      url: u,
      method: a,
      headers: r
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    };
    i(this._options, p, d), this._sanitizeOptions(this._options);
  }
  this._performRequest();
};
function Lm(e) {
  var t = {
    maxRedirects: 21,
<<<<<<< HEAD
    maxBodyLength: 10 * 1024 * 1024
  };
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function(scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
    function request(input, options, callback) {
      if (isURL(input)) {
        input = spreadUrlObject(input);
      } else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      } else {
        callback = options;
        options = validateUrl(input);
        input = { protocol };
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }
      assert$2.equal(options.protocol, protocol, "protocol mismatch");
      debug$4("options", options);
      return new RedirectableRequest(options, callback);
=======
    maxBodyLength: 10485760
  }, n = {};
  return Object.keys(e).forEach(function(r) {
    var i = r + ":", a = n[i] = e[r], o = t[r] = Object.create(a);
    function c(u, l, p) {
      return aE(u) ? u = ol(u) : Fn(u) ? u = ol(Ql(u)) : (p = l, l = Bm(u), u = { protocol: i }), jn(l) && (p = l, l = null), l = Object.assign({
        maxRedirects: t.maxRedirects,
        maxBodyLength: t.maxBodyLength
      }, u, l), l.nativeProtocols = n, !Fn(l.host) && !Fn(l.hostname) && (l.hostname = "::1"), Xl.equal(l.protocol, i, "protocol mismatch"), km("options", l), new tt(l, p);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    function s(u, l, p) {
      var d = o.request(u, l, p);
      return d.end(), d;
    }
    Object.defineProperties(o, {
      request: { value: c, configurable: !0, enumerable: !0, writable: !0 },
      get: { value: s, configurable: !0, enumerable: !0, writable: !0 }
    });
  }), t;
}
function Um() {
}
<<<<<<< HEAD
function parseUrl(input) {
  var parsed;
  if (useNativeURL) {
    parsed = new URL$1(input);
  } else {
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}
function resolveUrl(relative, base) {
  return useNativeURL ? new URL$1(relative, base) : parseUrl(url.resolve(base, relative));
}
function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}
function spreadUrlObject(urlObject, target) {
  var spread2 = target || {};
  for (var key2 of preservedUrlFields) {
    spread2[key2] = urlObject[key2];
  }
  if (spread2.hostname.startsWith("[")) {
    spread2.hostname = spread2.hostname.slice(1, -1);
  }
  if (spread2.port !== "") {
    spread2.port = Number(spread2.port);
  }
  spread2.path = spread2.search ? spread2.pathname + spread2.search : spread2.pathname;
  return spread2;
}
function removeMatchingHeaders(regex, headers2) {
  var lastValue;
  for (var header in headers2) {
    if (regex.test(header)) {
      lastValue = headers2[header];
      delete headers2[header];
    }
  }
  return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
}
function createErrorType(code, message, baseClass) {
  function CustomError(properties) {
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    }
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
=======
function Ql(e) {
  var t;
  if (Kl)
    t = new pi(e);
  else if (t = Bm(Fi.parse(e)), !Fn(t.protocol))
    throw new il({ input: e });
  return t;
}
function nE(e, t) {
  return Kl ? new pi(e, t) : Ql(Fi.resolve(t, e));
}
function Bm(e) {
  if (/^\[/.test(e.hostname) && !/^\[[:0-9a-f]+\]$/i.test(e.hostname))
    throw new il({ input: e.href || e });
  if (/^\[/.test(e.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(e.host))
    throw new il({ input: e.href || e });
  return e;
}
function ol(e, t) {
  var n = t || {};
  for (var r of Jw)
    n[r] = e[r];
  return n.hostname.startsWith("[") && (n.hostname = n.hostname.slice(1, -1)), n.port !== "" && (n.port = Number(n.port)), n.path = n.search ? n.pathname + n.search : n.pathname, n;
}
function Js(e, t) {
  var n;
  for (var r in t)
    e.test(r) && (n = t[r], delete t[r]);
  return n === null || typeof n > "u" ? void 0 : String(n).trim();
}
function Ni(e, t, n) {
  function r(i) {
    jn(Error.captureStackTrace) && Error.captureStackTrace(this, this.constructor), Object.assign(this, i || {}), this.code = e, this.message = this.cause ? t + ": " + this.cause.message : t;
  }
  return r.prototype = new (n || Error)(), Object.defineProperties(r.prototype, {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    constructor: {
      value: r,
      enumerable: !1
    },
    name: {
      value: "Error [" + e + "]",
      enumerable: !1
    }
  }), r;
}
<<<<<<< HEAD
function destroyRequest(request, error2) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
=======
function eu(e, t) {
  for (var n of Jl)
    e.removeListener(n, Zl[n]);
  e.on("error", Um), e.destroy(t);
}
function rE(e, t) {
  Xl(Fn(e) && Fn(t));
  var n = e.length - t.length - 1;
  return n > 0 && e[n] === "." && e.endsWith(t);
}
function Fn(e) {
  return typeof e == "string" || e instanceof String;
}
function jn(e) {
  return typeof e == "function";
}
function iE(e) {
  return typeof e == "object" && "length" in e;
}
function aE(e) {
  return pi && e instanceof pi;
}
Vl.exports = Lm({ http: Xw, https: Kw });
Vl.exports.wrap = Lm;
var oE = Vl.exports;
const sE = /* @__PURE__ */ Ul(oE), eo = "1.10.0";
function jm(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
const cE = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function lE(e, t, n) {
  const r = n && n.Blob || be.classes.Blob, i = jm(e);
  if (t === void 0 && r && (t = !0), i === "data") {
    e = i.length ? e.slice(i.length + 1) : e;
    const a = cE.exec(e);
    if (!a)
      throw new V("Invalid URL", V.ERR_INVALID_URL);
    const o = a[1], c = a[2], s = a[3], u = Buffer.from(decodeURIComponent(s), c ? "base64" : "utf8");
    if (t) {
      if (!r)
        throw new V("Blob is not supported", V.ERR_NOT_SUPPORT);
      return new r([u], { type: o });
    }
    return u;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  throw new V("Unsupported protocol " + i, V.ERR_NOT_SUPPORT);
}
<<<<<<< HEAD
function isSubdomain(subdomain, domain) {
  assert$2(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isFunction(value) {
  return typeof value === "function";
}
function isBuffer(value) {
  return typeof value === "object" && "length" in value;
}
function isURL(value) {
  return URL$1 && value instanceof URL$1;
}
followRedirects$1.exports = wrap({ http, https });
followRedirects$1.exports.wrap = wrap;
var followRedirectsExports = followRedirects$1.exports;
const followRedirects = /* @__PURE__ */ getDefaultExportFromCjs(followRedirectsExports);
const VERSION$1 = "1.10.0";
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}
const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri2, asBlob, options) {
  const _Blob = options && options.Blob || platform$1.classes.Blob;
  const protocol = parseProtocol(uri2);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri2 = protocol.length ? uri2.slice(protocol.length + 1) : uri2;
    const match = DATA_URL_PATTERN.exec(uri2);
    if (!match) {
      throw new AxiosError$1("Invalid URL", AxiosError$1.ERR_INVALID_URL);
    }
    const mime2 = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer2 = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError$1("Blob is not supported", AxiosError$1.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer2], { type: mime2 });
    }
    return buffer2;
  }
  throw new AxiosError$1("Unsupported protocol " + protocol, AxiosError$1.ERR_NOT_SUPPORT);
}
const kInternals = Symbol("internals");
class AxiosTransformStream extends require$$1$2.Transform {
  constructor(options) {
    options = utils$h.toFlatObject(options, {
=======
const Zs = Symbol("internals");
class Xp extends ie.Transform {
  constructor(t) {
    t = P.toFlatObject(t, {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (r, i) => !P.isUndefined(i[r])), super({
      readableHighWaterMark: t.chunkSize
    });
    const n = this[Zs] = {
      timeWindow: t.timeWindow,
      chunkSize: t.chunkSize,
      maxRate: t.maxRate,
      minChunkSize: t.minChunkSize,
      bytesSeen: 0,
      isCaptured: !1,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (r) => {
      r === "progress" && (n.isCaptured || (n.isCaptured = !0));
    });
  }
  _read(t) {
    const n = this[Zs];
    return n.onReadCallback && n.onReadCallback(), super._read(t);
  }
  _transform(t, n, r) {
    const i = this[Zs], a = i.maxRate, o = this.readableHighWaterMark, c = i.timeWindow, s = 1e3 / c, u = a / s, l = i.minChunkSize !== !1 ? Math.max(i.minChunkSize, u * 0.01) : 0, p = (m, g) => {
      const v = Buffer.byteLength(m);
      i.bytesSeen += v, i.bytes += v, i.isCaptured && this.emit("progress", i.bytesSeen), this.push(m) ? process.nextTick(g) : i.onReadCallback = () => {
        i.onReadCallback = null, process.nextTick(g);
      };
    }, d = (m, g) => {
      const v = Buffer.byteLength(m);
      let y = null, x = o, w, A = 0;
      if (a) {
        const O = Date.now();
        (!i.ts || (A = O - i.ts) >= c) && (i.ts = O, w = u - i.bytes, i.bytes = w < 0 ? -w : 0, A = 0), w = u - i.bytes;
      }
      if (a) {
        if (w <= 0)
          return setTimeout(() => {
            g(null, m);
          }, c - A);
        w < x && (x = w);
      }
      x && v > x && v - x > l && (y = m.subarray(x), m = m.subarray(0, x)), p(m, y ? () => {
        process.nextTick(g, null, y);
      } : g);
    };
    d(t, function m(g, v) {
      if (g)
        return r(g);
      v ? d(v, m) : r(null);
    });
  }
}
<<<<<<< HEAD
const { asyncIterator } = Symbol;
const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
const BOUNDARY_ALPHABET = platform$1.ALPHABET.ALPHA_DIGIT + "-_";
const textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new require$$1$3.TextEncoder();
const CRLF = "\r\n";
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;
class FormDataPart {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils$h.isString(value);
    let headers2 = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers2 += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers2 + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils$h.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob(value);
    }
    yield CRLF_BYTES;
=======
const { asyncIterator: Kp } = Symbol, Mm = async function* (e) {
  e.stream ? yield* e.stream() : e.arrayBuffer ? yield await e.arrayBuffer() : e[Kp] ? yield* e[Kp]() : yield e;
}, uE = be.ALPHABET.ALPHA_DIGIT + "-_", fi = typeof TextEncoder == "function" ? new TextEncoder() : new Pe.TextEncoder(), In = `\r
`, pE = fi.encode(In), fE = 2;
class dE {
  constructor(t, n) {
    const { escapeName: r } = this.constructor, i = P.isString(n);
    let a = `Content-Disposition: form-data; name="${r(t)}"${!i && n.name ? `; filename="${r(n.name)}"` : ""}${In}`;
    i ? n = fi.encode(String(n).replace(/\r?\n|\r\n?/g, In)) : a += `Content-Type: ${n.type || "application/octet-stream"}${In}`, this.headers = fi.encode(a + In), this.contentLength = i ? n.byteLength : n.size, this.size = this.headers.byteLength + this.contentLength + fE, this.name = t, this.value = n;
  }
  async *encode() {
    yield this.headers;
    const { value: t } = this;
    P.isTypedArray(t) ? yield t : yield* Mm(t), yield pE;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  static escapeName(t) {
    return String(t).replace(/[\r\n"]/g, (n) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[n]);
  }
}
<<<<<<< HEAD
const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + platform$1.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils$h.isFormData(form)) {
=======
const hE = (e, t, n) => {
  const {
    tag: r = "form-data-boundary",
    size: i = 25,
    boundary: a = r + "-" + be.generateString(i, uE)
  } = n || {};
  if (!P.isFormData(e))
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    throw TypeError("FormData instance required");
  if (a.length < 1 || a.length > 70)
    throw Error("boundary must be 10-70 characters long");
<<<<<<< HEAD
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
=======
  const o = fi.encode("--" + a + In), c = fi.encode("--" + a + "--" + In);
  let s = c.byteLength;
  const u = Array.from(e.entries()).map(([p, d]) => {
    const m = new dE(p, d);
    return s += m.size, m;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  });
  s += o.byteLength * u.length, s = P.toFiniteNumber(s);
  const l = {
    "Content-Type": `multipart/form-data; boundary=${a}`
  };
<<<<<<< HEAD
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return Readable$2.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
class ZlibHeaderTransformStream extends require$$1$2.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
=======
  return Number.isFinite(s) && (l["Content-Length"] = s), t && t(l), Cy.from(async function* () {
    for (const p of u)
      yield o, yield* p.encode();
    yield c;
  }());
};
class mE extends ie.Transform {
  __transform(t, n, r) {
    this.push(t), r();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  _transform(t, n, r) {
    if (t.length !== 0 && (this._transform = this.__transform, t[0] !== 120)) {
      const i = Buffer.alloc(2);
      i[0] = 120, i[1] = 156, this.push(i, n);
    }
    this.__transform(t, n, r);
  }
}
<<<<<<< HEAD
const callbackify = (fn, reducer) => {
  return utils$h.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min2) {
      return;
=======
const vE = (e, t) => P.isAsyncFn(e) ? function(...n) {
  const r = n.pop();
  e.apply(this, n).then((i) => {
    try {
      t ? r(null, ...t(i)) : r(null, i);
    } catch (a) {
      r(a);
    }
  }, r);
} : e;
function gE(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, a = 0, o;
  return t = t !== void 0 ? t : 1e3, function(s) {
    const u = Date.now(), l = r[a];
    o || (o = u), n[i] = s, r[i] = u;
    let p = a, d = 0;
    for (; p !== i; )
      d += n[p++], p = p % e;
    if (i = (i + 1) % e, i === a && (a = (a + 1) % e), u - o < t)
      return;
    const m = l && u - l;
    return m ? Math.round(d * 1e3 / m) : void 0;
  };
}
function xE(e, t) {
  let n = 0, r = 1e3 / t, i, a;
  const o = (u, l = Date.now()) => {
    n = l, i = null, a && (clearTimeout(a), a = null), e.apply(null, u);
  };
  return [(...u) => {
    const l = Date.now(), p = l - n;
    p >= r ? o(u, l) : (i = u, a || (a = setTimeout(() => {
      a = null, o(i);
    }, r - p)));
  }, () => i && o(i)];
}
const Rr = (e, t, n = 3) => {
  let r = 0;
  const i = gE(50, 250);
  return xE((a) => {
    const o = a.loaded, c = a.lengthComputable ? a.total : void 0, s = o - r, u = i(s), l = o <= c;
    r = o;
    const p = {
      loaded: o,
      total: c,
      progress: c ? o / c : void 0,
      bytes: s,
      rate: u || void 0,
      estimated: u && c && l ? (c - o) / u : void 0,
      event: a,
      lengthComputable: c != null,
      [t ? "download" : "upload"]: !0
    };
    e(p);
  }, n);
}, to = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, no = (e) => (...t) => P.asap(() => e(...t)), Jp = {
  flush: Qe.constants.Z_SYNC_FLUSH,
  finishFlush: Qe.constants.Z_SYNC_FLUSH
}, yE = {
  flush: Qe.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: Qe.constants.BROTLI_OPERATION_FLUSH
}, Zp = P.isFunction(Qe.createBrotliDecompress), { http: bE, https: wE } = sE, EE = /https:?/, Qp = be.protocols.map((e) => e + ":"), ef = (e, [t, n]) => (e.on("end", n).on("error", n), t);
function _E(e, t) {
  e.beforeRedirects.proxy && e.beforeRedirects.proxy(e), e.beforeRedirects.config && e.beforeRedirects.config(e, t);
}
function qm(e, t, n) {
  let r = t;
  if (!r && r !== !1) {
    const i = Dm.getProxyForUrl(n);
    i && (r = new URL(i));
  }
  if (r) {
    if (r.username && (r.auth = (r.username || "") + ":" + (r.password || "")), r.auth) {
      (r.auth.username || r.auth.password) && (r.auth = (r.auth.username || "") + ":" + (r.auth.password || ""));
      const a = Buffer.from(r.auth, "utf8").toString("base64");
      e.headers["Proxy-Authorization"] = "Basic " + a;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    e.headers.host = e.hostname + (e.port ? ":" + e.port : "");
    const i = r.hostname || r.host;
    e.hostname = i, e.host = i, e.port = r.port, e.path = n, r.protocol && (e.protocol = r.protocol.includes(":") ? r.protocol : `${r.protocol}:`);
  }
  e.beforeRedirects.proxy = function(a) {
    qm(a, t, a.href);
  };
}
<<<<<<< HEAD
function throttle(fn, freq) {
  let timestamp2 = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp2 = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp2;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$h.asap(() => fn(...args));
const zlibOptions = {
  flush: zlib$4.constants.Z_SYNC_FLUSH,
  finishFlush: zlib$4.constants.Z_SYNC_FLUSH
};
const brotliOptions = {
  flush: zlib$4.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib$4.constants.BROTLI_OPERATION_FLUSH
};
const isBrotliSupported = utils$h.isFunction(zlib$4.createBrotliDecompress);
const { http: httpFollow, https: httpsFollow } = followRedirects;
const isHttps = /https:?/;
const supportedProtocols = platform$1.protocols.map((protocol) => {
  return protocol + ":";
});
const flushOnFinish = (stream2, [throttled, flush]) => {
  stream2.on("end", flush).on("error", flush);
  return throttled;
};
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnv.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
const isHttpAdapterSupported = typeof process !== "undefined" && utils$h.kindOf(process) === "process";
const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
const resolveFamily = ({ address, family }) => {
  if (!utils$h.isString(address)) {
=======
const SE = typeof process < "u" && P.kindOf(process) === "process", TE = (e) => new Promise((t, n) => {
  let r, i;
  const a = (s, u) => {
    i || (i = !0, r && r(s, u));
  }, o = (s) => {
    a(s), t(s);
  }, c = (s) => {
    a(s, !0), n(s);
  };
  e(o, c, (s) => r = s).catch(c);
}), AE = ({ address: e, family: t }) => {
  if (!P.isString(e))
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    throw TypeError("address must be a string");
  return {
    address: e,
    family: t || (e.indexOf(".") < 0 ? 6 : 4)
  };
<<<<<<< HEAD
};
const buildAddressEntry = (address, family) => resolveFamily(utils$h.isObject(address) ? address : { address, family });
const httpAdapter = isHttpAdapterSupported && function httpAdapter2(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let { data, lookup, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup) {
      const _lookup = callbackify(lookup, (value) => utils$h.isArray(value) ? value : [value]);
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils$h.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new EventEmitter$4();
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort2);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort2);
      }
      emitter.removeAllListeners();
=======
}, tf = (e, t) => AE(P.isObject(e) ? e : { address: e, family: t }), RE = SE && function(t) {
  return TE(async function(r, i, a) {
    let { data: o, lookup: c, family: s } = t;
    const { responseType: u, responseEncoding: l } = t, p = t.method.toUpperCase();
    let d, m = !1, g;
    if (c) {
      const b = vE(c, (E) => P.isArray(E) ? E : [E]);
      c = (E, R, N) => {
        b(E, R, (L, B, K) => {
          if (L)
            return N(L);
          const Z = P.isArray(B) ? B.map((M) => tf(M)) : [tf(B, K)];
          R.all ? N(L, Z) : N(L, Z[0].address, Z[0].family);
        });
      };
    }
    const v = new Oy(), y = () => {
      t.cancelToken && t.cancelToken.unsubscribe(x), t.signal && t.signal.removeEventListener("abort", x), v.removeAllListeners();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    };
    a((b, E) => {
      d = !0, E && (m = !0, y());
    });
    function x(b) {
      v.emit("abort", !b || b.type ? new an(null, t, g) : b);
    }
    v.once("abort", i), (t.cancelToken || t.signal) && (t.cancelToken && t.cancelToken.subscribe(x), t.signal && (t.signal.aborted ? x() : t.signal.addEventListener("abort", x)));
    const w = Wl(t.baseURL, t.url, t.allowAbsoluteUrls), A = new URL(w, be.hasBrowserEnv ? be.origin : void 0), O = A.protocol || Qp[0];
    if (O === "data:") {
      let b;
      if (p !== "GET")
        return fr(r, i, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config: t
        });
<<<<<<< HEAD
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError$1.from(err, AxiosError$1.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils$h.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = require$$1$2.Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
=======
      try {
        b = lE(t.url, u === "blob", {
          Blob: t.env && t.env.Blob
        });
      } catch (E) {
        throw V.from(E, V.ERR_BAD_REQUEST, t);
      }
      return u === "text" ? (b = b.toString(l), (!l || l === "utf8") && (b = P.stripBOM(b))) : u === "stream" && (b = ie.Readable.from(b)), fr(r, i, {
        data: b,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        status: 200,
        statusText: "OK",
        headers: new Le(),
        config: t
      });
    }
    if (Qp.indexOf(O) === -1)
      return i(new V(
        "Unsupported protocol " + O,
        V.ERR_BAD_REQUEST,
        t
      ));
<<<<<<< HEAD
    }
    const headers2 = AxiosHeaders$1.from(config.headers).normalize();
    headers2.set("User-Agent", "axios/" + VERSION$1, false);
    const { onUploadProgress, onDownloadProgress } = config;
    const maxRate = config.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils$h.isSpecCompliantForm(data)) {
      const userBoundary = headers2.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream(data, (formHeaders) => {
        headers2.set(formHeaders);
=======
    const k = Le.from(t.headers).normalize();
    k.set("User-Agent", "axios/" + eo, !1);
    const { onUploadProgress: q, onDownloadProgress: W } = t, te = t.maxRate;
    let T, H;
    if (P.isSpecCompliantForm(o)) {
      const b = k.getContentType(/boundary=([-_\w\d]{10,70})/i);
      o = hE(o, (E) => {
        k.set(E);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }, {
        tag: `axios-${eo}-boundary`,
        boundary: b && b[1] || void 0
      });
    } else if (P.isFormData(o) && P.isFunction(o.getHeaders)) {
      if (k.set(o.getHeaders()), !k.hasContentLength())
        try {
<<<<<<< HEAD
          const knownLength = await require$$1$3.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers2.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils$h.isBlob(data) || utils$h.isFile(data)) {
      data.size && headers2.setContentType(data.type || "application/octet-stream");
      headers2.setContentLength(data.size || 0);
      data = require$$1$2.Readable.from(readBlob(data));
    } else if (data && !utils$h.isStream(data)) {
      if (Buffer.isBuffer(data)) ;
      else if (utils$h.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils$h.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError$1(
=======
          const b = await Pe.promisify(o.getLength).call(o);
          Number.isFinite(b) && b >= 0 && k.setContentLength(b);
        } catch {
        }
    } else if (P.isBlob(o) || P.isFile(o))
      o.size && k.setContentType(o.type || "application/octet-stream"), k.setContentLength(o.size || 0), o = ie.Readable.from(Mm(o));
    else if (o && !P.isStream(o)) {
      if (!Buffer.isBuffer(o)) if (P.isArrayBuffer(o))
        o = Buffer.from(new Uint8Array(o));
      else if (P.isString(o))
        o = Buffer.from(o, "utf-8");
      else
        return i(new V(
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          V.ERR_BAD_REQUEST,
          t
        ));
      if (k.setContentLength(o.length, !1), t.maxBodyLength > -1 && o.length > t.maxBodyLength)
        return i(new V(
          "Request body larger than maxBodyLength limit",
          V.ERR_BAD_REQUEST,
          t
        ));
    }
    const j = P.toFiniteNumber(k.getContentLength());
    P.isArray(te) ? (T = te[0], H = te[1]) : T = H = te, o && (q || T) && (P.isStream(o) || (o = ie.Readable.from(o, { objectMode: !1 })), o = ie.pipeline([o, new Xp({
      maxRate: P.toFiniteNumber(T)
    })], P.noop), q && o.on("progress", ef(
      o,
      to(
        j,
        Rr(no(q), !1, 3)
      )
    )));
    let J;
    if (t.auth) {
      const b = t.auth.username || "", E = t.auth.password || "";
      J = b + ":" + E;
    }
<<<<<<< HEAD
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils$h.isStream(data)) {
        data = require$$1$2.Readable.from(data, { objectMode: false });
      }
      data = require$$1$2.pipeline([data, new AxiosTransformStream({
        maxRate: utils$h.toFiniteNumber(maxUploadRate)
      })], utils$h.noop);
      onUploadProgress && data.on("progress", flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
=======
    if (!J && A.username) {
      const b = A.username, E = A.password;
      J = b + ":" + E;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    J && k.delete("authorization");
    let ne;
    try {
      ne = zl(
        A.pathname + A.search,
        t.params,
        t.paramsSerializer
      ).replace(/^\?/, "");
    } catch (b) {
      const E = new Error(b.message);
      return E.config = t, E.url = t.url, E.exists = !0, i(E);
    }
    k.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (Zp ? ", br" : ""),
      !1
    );
<<<<<<< HEAD
    const options = {
      path: path2,
      method,
      headers: headers2.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils$h.isUndefined(lookup) && (options.lookup = lookup);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? require$$4$2 : require$$3$2;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
=======
    const F = {
      path: ne,
      method: p,
      headers: k.toJSON(),
      agents: { http: t.httpAgent, https: t.httpsAgent },
      auth: J,
      protocol: O,
      family: s,
      beforeRedirect: _E,
      beforeRedirects: {}
    };
    !P.isUndefined(c) && (F.lookup = c), t.socketPath ? F.socketPath = t.socketPath : (F.hostname = A.hostname.startsWith("[") ? A.hostname.slice(1, -1) : A.hostname, F.port = A.port, qm(F, t.proxy, O + "//" + A.hostname + (A.port ? ":" + A.port : "") + F.path));
    let $;
    const D = EE.test(F.protocol);
    if (F.agent = D ? t.httpsAgent : t.httpAgent, t.transport ? $ = t.transport : t.maxRedirects === 0 ? $ = D ? Nl : bo : (t.maxRedirects && (F.maxRedirects = t.maxRedirects), t.beforeRedirect && (F.beforeRedirects.config = t.beforeRedirect), $ = D ? wE : bE), t.maxBodyLength > -1 ? F.maxBodyLength = t.maxBodyLength : F.maxBodyLength = 1 / 0, t.insecureHTTPParser && (F.insecureHTTPParser = t.insecureHTTPParser), g = $.request(F, function(E) {
      if (g.destroyed) return;
      const R = [E], N = +E.headers["content-length"];
      if (W || H) {
        const M = new Xp({
          maxRate: P.toFiniteNumber(H)
        });
        W && M.on("progress", ef(
          M,
          to(
            N,
            Rr(no(W), !0, 3)
          )
        )), R.push(M);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
      let L = E;
      const B = E.req || g;
      if (t.decompress !== !1 && E.headers["content-encoding"])
        switch ((p === "HEAD" || E.statusCode === 204) && delete E.headers["content-encoding"], (E.headers["content-encoding"] || "").toLowerCase()) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            R.push(Qe.createUnzip(Jp)), delete E.headers["content-encoding"];
            break;
          case "deflate":
<<<<<<< HEAD
            streams2.push(new ZlibHeaderTransformStream());
            streams2.push(zlib$4.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams2.push(zlib$4.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams2.length > 1 ? require$$1$2.pipeline(streams2, utils$h.noop) : streams2[0];
      const offListeners = require$$1$2.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders$1(res.headers),
        config,
        request: lastRequest
=======
            R.push(new mE()), R.push(Qe.createUnzip(Jp)), delete E.headers["content-encoding"];
            break;
          case "br":
            Zp && (R.push(Qe.createBrotliDecompress(yE)), delete E.headers["content-encoding"]);
        }
      L = R.length > 1 ? ie.pipeline(R, P.noop) : R[0];
      const K = ie.finished(L, () => {
        K(), y();
      }), Z = {
        status: E.statusCode,
        statusText: E.statusMessage,
        headers: new Le(E.headers),
        config: t,
        request: B
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      };
      if (u === "stream")
        Z.data = L, fr(r, i, Z);
      else {
        const M = [];
        let le = 0;
        L.on("data", function(f) {
          M.push(f), le += f.length, t.maxContentLength > -1 && le > t.maxContentLength && (m = !0, L.destroy(), i(new V(
            "maxContentLength size of " + t.maxContentLength + " exceeded",
            V.ERR_BAD_RESPONSE,
            t,
            B
          )));
        }), L.on("aborted", function() {
          if (m)
            return;
          const f = new V(
            "stream has been aborted",
            V.ERR_BAD_RESPONSE,
            t,
            B
          );
          L.destroy(f), i(f);
        }), L.on("error", function(f) {
          g.destroyed || i(V.from(f, null, t, B));
        }), L.on("end", function() {
          try {
            let f = M.length === 1 ? M[0] : Buffer.concat(M);
            u !== "arraybuffer" && (f = f.toString(l), (!l || l === "utf8") && (f = P.stripBOM(f))), Z.data = f;
          } catch (f) {
            return i(V.from(f, null, t, Z.request, Z));
          }
          fr(r, i, Z);
        });
      }
      v.once("abort", (M) => {
        L.destroyed || (L.emit("error", M), L.destroy());
      });
    }), v.once("abort", (b) => {
      i(b), g.destroy(b);
    }), g.on("error", function(E) {
      i(V.from(E, null, t, g));
    }), g.on("socket", function(E) {
      E.setKeepAlive(!0, 1e3 * 60);
    }), t.timeout) {
      const b = parseInt(t.timeout, 10);
      if (Number.isNaN(b)) {
        i(new V(
          "error trying to parse `config.timeout` to int",
          V.ERR_BAD_OPTION_VALUE,
          t,
          g
        ));
        return;
      }
      g.setTimeout(b, function() {
        if (d) return;
        let R = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
        const N = t.transitional || Hl;
        t.timeoutErrorMessage && (R = t.timeoutErrorMessage), i(new V(
          R,
          N.clarifyTimeoutError ? V.ETIMEDOUT : V.ECONNABORTED,
          t,
          g
        )), x();
      });
    }
    if (P.isStream(o)) {
      let b = !1, E = !1;
      o.on("end", () => {
        b = !0;
      }), o.once("error", (R) => {
        E = !0, g.destroy(R);
      }), o.on("close", () => {
        !b && !E && x(new an("Request stream has been aborted", t, g));
      }), o.pipe(g);
    } else
      g.end(o);
  });
<<<<<<< HEAD
};
const isURLSameOrigin = platform$1.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
  url2 = new URL(url2, platform$1.origin);
  return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
})(
  new URL(platform$1.origin),
  platform$1.navigator && /(msie|trident)/i.test(platform$1.navigator.userAgent)
) : () => true;
const cookies = platform$1.hasStandardBrowserEnv ? (
=======
}, CE = be.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, be.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(be.origin),
  be.navigator && /(msie|trident)/i.test(be.navigator.userAgent)
) : () => !0, OE = be.hasStandardBrowserEnv ? (
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, i, a) {
      const o = [e + "=" + encodeURIComponent(t)];
      P.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), P.isString(r) && o.push("path=" + r), P.isString(i) && o.push("domain=" + i), a === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
), nf = (e) => e instanceof Le ? { ...e } : e;
function Mn(e, t) {
  t = t || {};
  const n = {};
  function r(u, l, p, d) {
    return P.isPlainObject(u) && P.isPlainObject(l) ? P.merge.call({ caseless: d }, u, l) : P.isPlainObject(l) ? P.merge({}, l) : P.isArray(l) ? l.slice() : l;
  }
  function i(u, l, p, d) {
    if (P.isUndefined(l)) {
      if (!P.isUndefined(u))
        return r(void 0, u, p, d);
    } else return r(u, l, p, d);
  }
  function a(u, l) {
    if (!P.isUndefined(l))
      return r(void 0, l);
  }
  function o(u, l) {
    if (P.isUndefined(l)) {
      if (!P.isUndefined(u))
        return r(void 0, u);
    } else return r(void 0, l);
  }
  function c(u, l, p) {
    if (p in t)
      return r(u, l);
    if (p in e)
      return r(void 0, u);
  }
  const s = {
    url: a,
    method: a,
    data: a,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: c,
    headers: (u, l, p) => i(nf(u), nf(l), p, !0)
  };
<<<<<<< HEAD
  utils$h.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$h.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = (config) => {
  const newConfig = mergeConfig$1({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers: headers2, auth } = newConfig;
  newConfig.headers = headers2 = AxiosHeaders$1.from(headers2);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers2.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$h.isFormData(data)) {
    if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv) {
      headers2.setContentType(void 0);
    } else if ((contentType = headers2.getContentType()) !== false) {
      const [type2, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers2.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform$1.hasStandardBrowserEnv) {
    withXSRFToken && utils$h.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers2.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
=======
  return P.forEach(Object.keys(Object.assign({}, e, t)), function(l) {
    const p = s[l] || i, d = p(e[l], t[l], l);
    P.isUndefined(d) && p !== c || (n[l] = d);
  }), n;
}
const zm = (e) => {
  const t = Mn({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: a, headers: o, auth: c } = t;
  t.headers = o = Le.from(o), t.url = zl(Wl(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), c && o.set(
    "Authorization",
    "Basic " + btoa((c.username || "") + ":" + (c.password ? unescape(encodeURIComponent(c.password)) : ""))
  );
  let s;
  if (P.isFormData(n)) {
    if (be.hasStandardBrowserEnv || be.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((s = o.getContentType()) !== !1) {
      const [u, ...l] = s ? s.split(";").map((p) => p.trim()).filter(Boolean) : [];
      o.setContentType([u || "multipart/form-data", ...l].join("; "));
    }
  }
  if (be.hasStandardBrowserEnv && (r && P.isFunction(r) && (r = r(t)), r || r !== !1 && CE(t.url))) {
    const u = i && a && OE.read(a);
    u && o.set(i, u);
  }
  return t;
}, $E = typeof XMLHttpRequest < "u", IE = $E && function(e) {
  return new Promise(function(n, r) {
    const i = zm(e);
    let a = i.data;
    const o = Le.from(i.headers).normalize();
    let { responseType: c, onUploadProgress: s, onDownloadProgress: u } = i, l, p, d, m, g;
    function v() {
      m && m(), g && g(), i.cancelToken && i.cancelToken.unsubscribe(l), i.signal && i.signal.removeEventListener("abort", l);
    }
    let y = new XMLHttpRequest();
    y.open(i.method.toUpperCase(), i.url, !0), y.timeout = i.timeout;
    function x() {
      if (!y)
        return;
      const A = Le.from(
        "getAllResponseHeaders" in y && y.getAllResponseHeaders()
      ), k = {
        data: !c || c === "text" || c === "json" ? y.responseText : y.response,
        status: y.status,
        statusText: y.statusText,
        headers: A,
        config: e,
        request: y
      };
      fr(function(W) {
        n(W), v();
      }, function(W) {
        r(W), v();
      }, k), y = null;
    }
    "onloadend" in y ? y.onloadend = x : y.onreadystatechange = function() {
      !y || y.readyState !== 4 || y.status === 0 && !(y.responseURL && y.responseURL.indexOf("file:") === 0) || setTimeout(x);
    }, y.onabort = function() {
      y && (r(new V("Request aborted", V.ECONNABORTED, e, y)), y = null);
    }, y.onerror = function() {
      r(new V("Network Error", V.ERR_NETWORK, e, y)), y = null;
    }, y.ontimeout = function() {
      let O = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const k = i.transitional || Hl;
      i.timeoutErrorMessage && (O = i.timeoutErrorMessage), r(new V(
        O,
        k.clarifyTimeoutError ? V.ETIMEDOUT : V.ECONNABORTED,
        e,
        y
      )), y = null;
    }, a === void 0 && o.setContentType(null), "setRequestHeader" in y && P.forEach(o.toJSON(), function(O, k) {
      y.setRequestHeader(k, O);
    }), P.isUndefined(i.withCredentials) || (y.withCredentials = !!i.withCredentials), c && c !== "json" && (y.responseType = i.responseType), u && ([d, g] = Rr(u, !0), y.addEventListener("progress", d)), s && y.upload && ([p, m] = Rr(s), y.upload.addEventListener("progress", p), y.upload.addEventListener("loadend", m)), (i.cancelToken || i.signal) && (l = (A) => {
      y && (r(!A || A.type ? new an(null, e, y) : A), y.abort(), y = null);
    }, i.cancelToken && i.cancelToken.subscribe(l), i.signal && (i.signal.aborted ? l() : i.signal.addEventListener("abort", l)));
    const w = jm(i.url);
    if (w && be.protocols.indexOf(w) === -1) {
      r(new V("Unsupported protocol " + w + ":", V.ERR_BAD_REQUEST, e));
      return;
    }
    y.send(a || null);
  });
}, PE = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), i;
    const a = function(u) {
      if (!i) {
        i = !0, c();
        const l = u instanceof Error ? u : this.reason;
        r.abort(l instanceof V ? l : new an(l instanceof Error ? l.message : l));
      }
    };
    let o = t && setTimeout(() => {
      o = null, a(new V(`timeout ${t} of ms exceeded`, V.ETIMEDOUT));
    }, t);
    const c = () => {
      e && (o && clearTimeout(o), o = null, e.forEach((u) => {
        u.unsubscribe ? u.unsubscribe(a) : u.removeEventListener("abort", a);
      }), e = null);
    };
    e.forEach((u) => u.addEventListener("abort", a));
    const { signal: s } = r;
    return s.unsubscribe = () => P.asap(c), s;
  }
}, DE = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let r = 0, i;
  for (; r < n; )
    i = r + t, yield e.slice(r, i), r = i;
}, FE = async function* (e, t) {
  for await (const n of NE(e))
    yield* DE(n, t);
}, NE = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, rf = (e, t, n, r) => {
  const i = FE(e, t);
  let a = 0, o, c = (s) => {
    o || (o = !0, r && r(s));
  };
  return new ReadableStream({
    async pull(s) {
      try {
        const { done: u, value: l } = await i.next();
        if (u) {
          c(), s.close();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
          return;
        }
        let p = l.byteLength;
        if (n) {
          let d = a += p;
          n(d);
        }
<<<<<<< HEAD
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError2() {
      reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$h.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
        request.setRequestHeader(key2, val);
      });
    }
    if (!utils$h.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform$1.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$h.asap(unsubscribe);
    return signal;
  }
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end2;
  while (pos < len) {
    end2 = pos + chunkSize;
    yield chunk.slice(pos, end2);
    pos = end2;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream2) {
  if (stream2[Symbol.asyncIterator]) {
    yield* stream2;
    return;
  }
  const reader = stream2.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream2, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream2, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
=======
        s.enqueue(new Uint8Array(l));
      } catch (u) {
        throw c(u), u;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
    },
    cancel(s) {
      return c(s), i.return();
    }
  }, {
    highWaterMark: 2
  });
<<<<<<< HEAD
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str2) => encoder.encode(str2))(new TextEncoder()) : async (str2) => new Uint8Array(await new Response(str2).arrayBuffer()));
const test = (fn, ...args) => {
=======
}, Io = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", Hm = Io && typeof ReadableStream == "function", kE = Io && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), Gm = (e, ...t) => {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
<<<<<<< HEAD
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform$1.origin, {
=======
}, LE = Hm && Gm(() => {
  let e = !1;
  const t = new Request(be.origin, {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), af = 64 * 1024, sl = Hm && Gm(() => P.isReadableStream(new Response("").body)), ro = {
  stream: sl && ((e) => e.body)
};
Io && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !ro[t] && (ro[t] = P.isFunction(e[t]) ? (n) => n[t]() : (n, r) => {
      throw new V(`Response type '${t}' is not supported`, V.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
<<<<<<< HEAD
const getBodyLength = async (body) => {
  if (body == null) {
=======
const UE = async (e) => {
  if (e == null)
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return 0;
  if (P.isBlob(e))
    return e.size;
  if (P.isSpecCompliantForm(e))
    return (await new Request(be.origin, {
      method: "POST",
<<<<<<< HEAD
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$h.isArrayBufferView(body) || utils$h.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$h.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$h.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers2, body) => {
  const length = utils$h.toFiniteNumber(headers2.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url: url2,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers: headers2,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
=======
      body: e
    }).arrayBuffer()).byteLength;
  if (P.isArrayBufferView(e) || P.isArrayBuffer(e))
    return e.byteLength;
  if (P.isURLSearchParams(e) && (e = e + ""), P.isString(e))
    return (await kE(e)).byteLength;
}, BE = async (e, t) => {
  const n = P.toFiniteNumber(e.getContentLength());
  return n ?? UE(t);
}, jE = Io && (async (e) => {
  let {
    url: t,
    method: n,
    data: r,
    signal: i,
    cancelToken: a,
    timeout: o,
    onDownloadProgress: c,
    onUploadProgress: s,
    responseType: u,
    headers: l,
    withCredentials: p = "same-origin",
    fetchOptions: d
  } = zm(e);
  u = u ? (u + "").toLowerCase() : "text";
  let m = PE([i, a && a.toAbortSignal()], o), g;
  const v = m && m.unsubscribe && (() => {
    m.unsubscribe();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  });
  let y;
  try {
<<<<<<< HEAD
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers2, data)) !== 0) {
      let _request = new Request(url2, {
=======
    if (s && LE && n !== "get" && n !== "head" && (y = await BE(l, r)) !== 0) {
      let k = new Request(t, {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        method: "POST",
        body: r,
        duplex: "half"
      }), q;
      if (P.isFormData(r) && (q = k.headers.get("content-type")) && l.setContentType(q), k.body) {
        const [W, te] = to(
          y,
          Rr(no(s))
        );
        r = rf(k.body, af, W, te);
      }
    }
    P.isString(p) || (p = p ? "include" : "omit");
    const x = "credentials" in Request.prototype;
    g = new Request(t, {
      ...d,
      signal: m,
      method: n.toUpperCase(),
      headers: l.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: x ? p : void 0
    });
    let w = await fetch(g, d);
    const A = sl && (u === "stream" || u === "response");
    if (sl && (c || A && v)) {
      const k = {};
      ["status", "statusText", "headers"].forEach((T) => {
        k[T] = w[T];
      });
      const q = P.toFiniteNumber(w.headers.get("content-length")), [W, te] = c && to(
        q,
        Rr(no(c), !0)
      ) || [];
      w = new Response(
        rf(w.body, af, W, () => {
          te && te(), v && v();
        }),
        k
      );
    }
    u = u || "text";
    let O = await ro[P.findKey(ro, u) || "text"](w, e);
    return !A && v && v(), await new Promise((k, q) => {
      fr(k, q, {
        data: O,
        headers: Le.from(w.headers),
        status: w.status,
        statusText: w.statusText,
        config: e,
        request: g
      });
    });
<<<<<<< HEAD
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
=======
  } catch (x) {
    throw v && v(), x && x.name === "TypeError" && /Load failed|fetch/i.test(x.message) ? Object.assign(
      new V("Network Error", V.ERR_NETWORK, e, g),
      {
        cause: x.cause || x
      }
    ) : V.from(x, x && x.code, e, g);
  }
}), cl = {
  http: RE,
  xhr: IE,
  fetch: jE
};
P.forEach(cl, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
<<<<<<< HEAD
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$h.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
=======
const of = (e) => `- ${e}`, ME = (e) => P.isFunction(e) || e === null || e === !1, Wm = {
  getAdapter: (e) => {
    e = P.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const i = {};
    for (let a = 0; a < t; a++) {
      n = e[a];
      let o;
      if (r = n, !ME(n) && (r = cl[(o = String(n)).toLowerCase()], r === void 0))
        throw new V(`Unknown adapter '${o}'`);
      if (r)
        break;
      i[o || "#" + a] = r;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    if (!r) {
      const a = Object.entries(i).map(
        ([c, s]) => `adapter ${c} ` + (s === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = t ? a.length > 1 ? `since :
` + a.map(of).join(`
`) : " " + of(a[0]) : "as no adapter specified";
      throw new V(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: cl
};
function Qs(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new an(null, e);
}
function sf(e) {
  return Qs(e), e.headers = Le.from(e.headers), e.data = Ws.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), Wm.getAdapter(e.adapter || Di.adapter)(e).then(function(r) {
    return Qs(e), r.data = Ws.call(
      e,
      e.transformResponse,
      r
    ), r.headers = Le.from(r.headers), r;
  }, function(r) {
    return Pm(r) || (Qs(e), r && r.response && (r.response.data = Ws.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = Le.from(r.response.headers))), Promise.reject(r);
  });
}
const Po = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Po[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const cf = {};
Po.transitional = function(t, n, r) {
  function i(a, o) {
    return "[Axios v" + eo + "] Transitional option '" + a + "'" + o + (r ? ". " + r : "");
  }
  return (a, o, c) => {
    if (t === !1)
      throw new V(
        i(o, " has been removed" + (n ? " in " + n : "")),
        V.ERR_DEPRECATED
      );
    return n && !cf[o] && (cf[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(a, o, c) : !0;
  };
};
Po.spelling = function(t) {
  return (n, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0);
};
<<<<<<< HEAD
function assertOptions(options, schema2, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema2[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
=======
function qE(e, t, n) {
  if (typeof e != "object")
    throw new V("options must be an object", V.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const a = r[i], o = t[a];
    if (o) {
      const c = e[a], s = c === void 0 || o(c, a, e);
      if (s !== !0)
        throw new V("option " + a + " must be " + s, V.ERR_BAD_OPTION_VALUE);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      continue;
    }
    if (n !== !0)
      throw new V("Unknown option " + a, V.ERR_BAD_OPTION);
  }
}
<<<<<<< HEAD
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
=======
const za = {
  assertOptions: qE,
  validators: Po
}, bt = za.validators;
let Nn = class {
  constructor(t) {
    this.defaults = t || {}, this.interceptors = {
      request: new jp(),
      response: new jp()
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (r) {
      if (r instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const a = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? a && !String(r.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + a) : r.stack = a;
        } catch {
        }
      }
      throw r;
    }
  }
<<<<<<< HEAD
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
=======
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Mn(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: a } = n;
    r !== void 0 && za.assertOptions(r, {
      silentJSONParsing: bt.transitional(bt.boolean),
      forcedJSONParsing: bt.transitional(bt.boolean),
      clarifyTimeoutError: bt.transitional(bt.boolean)
    }, !1), i != null && (P.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : za.assertOptions(i, {
      encode: bt.function,
      serialize: bt.function
    }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), za.assertOptions(n, {
      baseUrl: bt.spelling("baseURL"),
      withXsrfToken: bt.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let o = a && P.merge(
      a.common,
      a[n.method]
    );
    a && P.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (g) => {
        delete a[g];
      }
    ), n.headers = Le.concat(o, a);
    const c = [];
    let s = !0;
    this.interceptors.request.forEach(function(v) {
      typeof v.runWhen == "function" && v.runWhen(n) === !1 || (s = s && v.synchronous, c.unshift(v.fulfilled, v.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(v) {
      u.push(v.fulfilled, v.rejected);
    });
    let l, p = 0, d;
    if (!s) {
      const g = [sf.bind(this), void 0];
      for (g.unshift.apply(g, c), g.push.apply(g, u), d = g.length, l = Promise.resolve(n); p < d; )
        l = l.then(g[p++], g[p++]);
      return l;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    d = c.length;
    let m = n;
    for (p = 0; p < d; ) {
      const g = c[p++], v = c[p++];
      try {
        m = g(m);
      } catch (y) {
        v.call(this, y);
        break;
      }
    }
    try {
      l = sf.call(this, m);
    } catch (g) {
      return Promise.reject(g);
    }
    for (p = 0, d = u.length; p < d; )
      l = l.then(u[p++], u[p++]);
    return l;
  }
  getUri(t) {
    t = Mn(this.defaults, t);
    const n = Wl(t.baseURL, t.url, t.allowAbsoluteUrls);
    return zl(n, t.params, t.paramsSerializer);
  }
};
P.forEach(["delete", "get", "head", "options"], function(t) {
  Nn.prototype[t] = function(n, r) {
    return this.request(Mn(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
P.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(a, o, c) {
      return this.request(Mn(c || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: o
      }));
    };
  }
  Nn.prototype[t] = n(), Nn.prototype[t + "Form"] = n(!0);
});
<<<<<<< HEAD
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
=======
let zE = class Vm {
  constructor(t) {
    if (typeof t != "function")
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let a;
      const o = new Promise((c) => {
        r.subscribe(c), a = c;
      }).then(i);
      return o.cancel = function() {
        r.unsubscribe(a);
      }, o;
    }, t(function(a, o, c) {
      r.reason || (r.reason = new an(a, o, c), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (r) => {
      t.abort(r);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new Vm(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
};
<<<<<<< HEAD
function spread$1(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$h.isObject(payload) && payload.isAxiosError === true;
=======
function HE(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function GE(e) {
  return P.isObject(e) && e.isAxiosError === !0;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
const ll = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
<<<<<<< HEAD
Object.entries(HttpStatusCode$1).forEach(([key2, value]) => {
  HttpStatusCode$1[value] = key2;
=======
Object.entries(ll).forEach(([e, t]) => {
  ll[t] = e;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
});
function Ym(e) {
  const t = new Nn(e), n = Zh(Nn.prototype.request, t);
  return P.extend(n, Nn.prototype, t, { allOwnKeys: !0 }), P.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return Ym(Mn(e, i));
  }, n;
}
<<<<<<< HEAD
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$h.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios: Axios2,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken: CancelToken2,
  VERSION,
  all: all2,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u2 = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t3 % 100;
      return "[" + t3 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m = function(t3, e2, n2) {
      var r2 = String(t3);
      return !r2 || r2.length >= e2 ? t3 : "" + Array(e2 + 1 - r2.length).join(n2) + t3;
    }, v = { s: m, z: function(t3) {
      var e2 = -t3.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t3(e2, n2) {
      if (e2.date() < n2.date()) return -t3(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u3 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c, y: h, w: o, d: a, D: d, h: u2, m: s, s: i, ms: r, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g = "en", D = {};
    D[g] = M;
    var p = "$isDayjsObject", S = function(t3) {
      return t3 instanceof _ || !(!t3 || !t3[p]);
    }, w = function t3(e2, n2, r2) {
      var i2;
      if (!e2) return g;
      if ("string" == typeof e2) {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u3 = e2.split("-");
        if (!i2 && u3.length > 1) return t3(u3[0]);
=======
const Ee = Ym(Di);
Ee.Axios = Nn;
Ee.CanceledError = an;
Ee.CancelToken = zE;
Ee.isCancel = Pm;
Ee.VERSION = eo;
Ee.toFormData = $o;
Ee.AxiosError = V;
Ee.Cancel = Ee.CanceledError;
Ee.all = function(t) {
  return Promise.all(t);
};
Ee.spread = HE;
Ee.isAxiosError = GE;
Ee.mergeConfig = Mn;
Ee.AxiosHeaders = Le;
Ee.formToJSON = (e) => Im(P.isHTMLForm(e) ? new FormData(e) : e);
Ee.getAdapter = Wm.getAdapter;
Ee.HttpStatusCode = ll;
Ee.default = Ee;
const {
  Axios: ZI,
  AxiosError: QI,
  CanceledError: eP,
  isCancel: tP,
  CancelToken: nP,
  VERSION: rP,
  all: iP,
  Cancel: aP,
  isAxiosError: oP,
  spread: sP,
  toFormData: cP,
  AxiosHeaders: lP,
  HttpStatusCode: uP,
  formToJSON: pP,
  getAdapter: fP,
  mergeConfig: dP
} = Ee;
var Xm = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(Te, function() {
    var n = 1e3, r = 6e4, i = 36e5, a = "millisecond", o = "second", c = "minute", s = "hour", u = "day", l = "week", p = "month", d = "quarter", m = "year", g = "date", v = "Invalid Date", y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, x = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, w = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(F) {
      var $ = ["th", "st", "nd", "rd"], D = F % 100;
      return "[" + F + ($[(D - 20) % 10] || $[D] || $[0]) + "]";
    } }, A = function(F, $, D) {
      var b = String(F);
      return !b || b.length >= $ ? F : "" + Array($ + 1 - b.length).join(D) + F;
    }, O = { s: A, z: function(F) {
      var $ = -F.utcOffset(), D = Math.abs($), b = Math.floor(D / 60), E = D % 60;
      return ($ <= 0 ? "+" : "-") + A(b, 2, "0") + ":" + A(E, 2, "0");
    }, m: function F($, D) {
      if ($.date() < D.date()) return -F(D, $);
      var b = 12 * (D.year() - $.year()) + (D.month() - $.month()), E = $.clone().add(b, p), R = D - E < 0, N = $.clone().add(b + (R ? -1 : 1), p);
      return +(-(b + (D - E) / (R ? E - N : N - E)) || 0);
    }, a: function(F) {
      return F < 0 ? Math.ceil(F) || 0 : Math.floor(F);
    }, p: function(F) {
      return { M: p, y: m, w: l, d: u, D: g, h: s, m: c, s: o, ms: a, Q: d }[F] || String(F || "").toLowerCase().replace(/s$/, "");
    }, u: function(F) {
      return F === void 0;
    } }, k = "en", q = {};
    q[k] = w;
    var W = "$isDayjsObject", te = function(F) {
      return F instanceof J || !(!F || !F[W]);
    }, T = function F($, D, b) {
      var E;
      if (!$) return k;
      if (typeof $ == "string") {
        var R = $.toLowerCase();
        q[R] && (E = R), D && (q[R] = D, E = R);
        var N = $.split("-");
        if (!E && N.length > 1) return F(N[0]);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      } else {
        var L = $.name;
        q[L] = $, E = L;
      }
      return !b && E && (k = E), E || !b && k;
    }, H = function(F, $) {
      if (te(F)) return F.clone();
      var D = typeof $ == "object" ? $ : {};
      return D.date = F, D.args = arguments, new J(D);
    }, j = O;
    j.l = T, j.i = te, j.w = function(F, $) {
      return H(F, { locale: $.$L, utc: $.$u, x: $.$x, $offset: $.$offset });
    };
    var J = function() {
      function F(D) {
        this.$L = T(D.locale, null, !0), this.parse(D), this.$x = this.$x || D.x || {}, this[W] = !0;
      }
      var $ = F.prototype;
      return $.parse = function(D) {
        this.$d = function(b) {
          var E = b.date, R = b.utc;
          if (E === null) return /* @__PURE__ */ new Date(NaN);
          if (j.u(E)) return /* @__PURE__ */ new Date();
          if (E instanceof Date) return new Date(E);
          if (typeof E == "string" && !/Z$/i.test(E)) {
            var N = E.match(y);
            if (N) {
              var L = N[2] - 1 || 0, B = (N[7] || "0").substring(0, 3);
              return R ? new Date(Date.UTC(N[1], L, N[3] || 1, N[4] || 0, N[5] || 0, N[6] || 0, B)) : new Date(N[1], L, N[3] || 1, N[4] || 0, N[5] || 0, N[6] || 0, B);
            }
          }
          return new Date(E);
        }(D), this.init();
      }, $.init = function() {
        var D = this.$d;
        this.$y = D.getFullYear(), this.$M = D.getMonth(), this.$D = D.getDate(), this.$W = D.getDay(), this.$H = D.getHours(), this.$m = D.getMinutes(), this.$s = D.getSeconds(), this.$ms = D.getMilliseconds();
      }, $.$utils = function() {
        return j;
      }, $.isValid = function() {
        return this.$d.toString() !== v;
      }, $.isSame = function(D, b) {
        var E = H(D);
        return this.startOf(b) <= E && E <= this.endOf(b);
      }, $.isAfter = function(D, b) {
        return H(D) < this.startOf(b);
      }, $.isBefore = function(D, b) {
        return this.endOf(b) < H(D);
      }, $.$g = function(D, b, E) {
        return j.u(D) ? this[b] : this.set(E, D);
      }, $.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, $.valueOf = function() {
        return this.$d.getTime();
      }, $.startOf = function(D, b) {
        var E = this, R = !!j.u(b) || b, N = j.p(D), L = function(C, S) {
          var G = j.w(E.$u ? Date.UTC(E.$y, S, C) : new Date(E.$y, S, C), E);
          return R ? G : G.endOf(u);
        }, B = function(C, S) {
          return j.w(E.toDate()[C].apply(E.toDate("s"), (R ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(S)), E);
        }, K = this.$W, Z = this.$M, M = this.$D, le = "set" + (this.$u ? "UTC" : "");
        switch (N) {
          case m:
            return R ? L(1, 0) : L(31, 11);
          case p:
            return R ? L(1, Z) : L(0, Z + 1);
          case l:
            var h = this.$locale().weekStart || 0, f = (K < h ? K + 7 : K) - h;
            return L(R ? M - f : M + (6 - f), Z);
          case u:
          case g:
            return B(le + "Hours", 0);
          case s:
            return B(le + "Minutes", 1);
          case c:
            return B(le + "Seconds", 2);
          case o:
            return B(le + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, $.endOf = function(D) {
        return this.startOf(D, !1);
      }, $.$set = function(D, b) {
        var E, R = j.p(D), N = "set" + (this.$u ? "UTC" : ""), L = (E = {}, E[u] = N + "Date", E[g] = N + "Date", E[p] = N + "Month", E[m] = N + "FullYear", E[s] = N + "Hours", E[c] = N + "Minutes", E[o] = N + "Seconds", E[a] = N + "Milliseconds", E)[R], B = R === u ? this.$D + (b - this.$W) : b;
        if (R === p || R === m) {
          var K = this.clone().set(g, 1);
          K.$d[L](B), K.init(), this.$d = K.set(g, Math.min(this.$D, K.daysInMonth())).$d;
        } else L && this.$d[L](B);
        return this.init(), this;
      }, $.set = function(D, b) {
        return this.clone().$set(D, b);
      }, $.get = function(D) {
        return this[j.p(D)]();
      }, $.add = function(D, b) {
        var E, R = this;
        D = Number(D);
        var N = j.p(b), L = function(Z) {
          var M = H(R);
          return j.w(M.date(M.date() + Math.round(Z * D)), R);
        };
        if (N === p) return this.set(p, this.$M + D);
        if (N === m) return this.set(m, this.$y + D);
        if (N === u) return L(1);
        if (N === l) return L(7);
        var B = (E = {}, E[c] = r, E[s] = i, E[o] = n, E)[N] || 1, K = this.$d.getTime() + D * B;
        return j.w(K, this);
      }, $.subtract = function(D, b) {
        return this.add(-1 * D, b);
      }, $.format = function(D) {
        var b = this, E = this.$locale();
        if (!this.isValid()) return E.invalidDate || v;
        var R = D || "YYYY-MM-DDTHH:mm:ssZ", N = j.z(this), L = this.$H, B = this.$m, K = this.$M, Z = E.weekdays, M = E.months, le = E.meridiem, h = function(S, G, z, X) {
          return S && (S[G] || S(b, R)) || z[G].slice(0, X);
        }, f = function(S) {
          return j.s(L % 12 || 12, S, "0");
        }, C = le || function(S, G, z) {
          var X = S < 12 ? "AM" : "PM";
          return z ? X.toLowerCase() : X;
        };
        return R.replace(x, function(S, G) {
          return G || function(z) {
            switch (z) {
              case "YY":
                return String(b.$y).slice(-2);
              case "YYYY":
                return j.s(b.$y, 4, "0");
              case "M":
                return K + 1;
              case "MM":
                return j.s(K + 1, 2, "0");
              case "MMM":
                return h(E.monthsShort, K, M, 3);
              case "MMMM":
                return h(M, K);
              case "D":
                return b.$D;
              case "DD":
                return j.s(b.$D, 2, "0");
              case "d":
                return String(b.$W);
              case "dd":
                return h(E.weekdaysMin, b.$W, Z, 2);
              case "ddd":
                return h(E.weekdaysShort, b.$W, Z, 3);
              case "dddd":
                return Z[b.$W];
              case "H":
                return String(L);
              case "HH":
                return j.s(L, 2, "0");
              case "h":
                return f(1);
              case "hh":
                return f(2);
              case "a":
                return C(L, B, !0);
              case "A":
                return C(L, B, !1);
              case "m":
                return String(B);
              case "mm":
                return j.s(B, 2, "0");
              case "s":
                return String(b.$s);
              case "ss":
                return j.s(b.$s, 2, "0");
              case "SSS":
                return j.s(b.$ms, 3, "0");
              case "Z":
                return N;
            }
            return null;
          }(S) || N.replace(":", "");
        });
      }, $.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, $.diff = function(D, b, E) {
        var R, N = this, L = j.p(b), B = H(D), K = (B.utcOffset() - this.utcOffset()) * r, Z = this - B, M = function() {
          return j.m(N, B);
        };
        switch (L) {
          case m:
            R = M() / 12;
            break;
          case p:
            R = M();
            break;
          case d:
            R = M() / 3;
            break;
          case l:
            R = (Z - K) / 6048e5;
            break;
          case u:
            R = (Z - K) / 864e5;
            break;
          case s:
            R = Z / i;
            break;
          case c:
            R = Z / r;
            break;
          case o:
            R = Z / n;
            break;
          default:
            R = Z;
        }
        return E ? R : j.a(R);
      }, $.daysInMonth = function() {
        return this.endOf(p).$D;
      }, $.$locale = function() {
        return q[this.$L];
      }, $.locale = function(D, b) {
        if (!D) return this.$L;
        var E = this.clone(), R = T(D, b, !0);
        return R && (E.$L = R), E;
      }, $.clone = function() {
        return j.w(this.$d, this);
      }, $.toDate = function() {
        return new Date(this.valueOf());
      }, $.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, $.toISOString = function() {
        return this.$d.toISOString();
      }, $.toString = function() {
        return this.$d.toUTCString();
      }, F;
    }(), ne = J.prototype;
    return H.prototype = ne, [["$ms", a], ["$s", o], ["$m", c], ["$H", s], ["$W", u], ["$M", p], ["$y", m], ["$D", g]].forEach(function(F) {
      ne[F[1]] = function($) {
        return this.$g($, F[0], F[1]);
      };
    }), H.extend = function(F, $) {
      return F.$i || (F($, J, H), F.$i = !0), H;
    }, H.locale = T, H.isDayjs = te, H.unix = function(F) {
      return H(1e3 * F);
    }, H.en = q[k], H.Ls = q, H.p = {}, H;
  });
<<<<<<< HEAD
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
var compressing = {};
var zip = {};
var utils$f = {};
var path$r = require$$1$4;
var fs$u = fs$w;
var _0777 = parseInt("0777", 8);
var mkdirp$2 = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
function mkdirP(p, opts, f, made) {
  if (typeof opts === "function") {
    f = opts;
    opts = {};
  } else if (!opts || typeof opts !== "object") {
    opts = { mode: opts };
  }
  var mode = opts.mode;
  var xfs = opts.fs || fs$u;
  if (mode === void 0) {
    mode = _0777;
  }
  if (!made) made = null;
  var cb = f || /* istanbul ignore next */
=======
})(Xm);
var WE = Xm.exports;
const lf = /* @__PURE__ */ Ul(WE);
var ki = {}, dn = {}, me = {}, ri = oe, Km = ae, Jm = parseInt("0777", 8), VE = wr.mkdirp = wr.mkdirP = wr;
function wr(e, t, n, r) {
  typeof t == "function" ? (n = t, t = {}) : (!t || typeof t != "object") && (t = { mode: t });
  var i = t.mode, a = t.fs || Km;
  i === void 0 && (i = Jm), r || (r = null);
  var o = n || /* istanbul ignore next */
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  function() {
  };
  e = ri.resolve(e), a.mkdir(e, i, function(c) {
    if (!c)
      return r = r || e, o(null, r);
    switch (c.code) {
      case "ENOENT":
        if (ri.dirname(e) === e) return o(c);
        wr(ri.dirname(e), t, function(s, u) {
          s ? o(s, u) : wr(e, t, o, u);
        });
        break;
      default:
        a.stat(e, function(s, u) {
          s || !u.isDirectory() ? o(c, r) : o(null, r);
        });
        break;
    }
  });
}
wr.sync = function e(t, n, r) {
  (!n || typeof n != "object") && (n = { mode: n });
  var i = n.mode, a = n.fs || Km;
  i === void 0 && (i = Jm), r || (r = null), t = ri.resolve(t);
  try {
    a.mkdirSync(t, i), r = r || t;
  } catch (c) {
    switch (c.code) {
      case "ENOENT":
        r = e(ri.dirname(t), n, r), e(t, n, r);
        break;
      default:
        var o;
        try {
          o = a.statSync(t);
        } catch {
          throw c;
        }
        if (!o.isDirectory()) throw c;
        break;
    }
  }
  return r;
};
<<<<<<< HEAD
var once$3 = { exports: {} };
var wrappy_1 = wrappy$1;
function wrappy$1(fn, cb) {
  if (fn && cb) return wrappy$1(fn)(cb);
  if (typeof fn !== "function")
=======
var tu = { exports: {} }, YE = Zm;
function Zm(e, t) {
  if (e && t) return Zm(e)(t);
  if (typeof e != "function")
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    throw new TypeError("need wrapper function");
  return Object.keys(e).forEach(function(r) {
    n[r] = e[r];
  }), n;
  function n() {
    for (var r = new Array(arguments.length), i = 0; i < r.length; i++)
      r[i] = arguments[i];
    var a = e.apply(this, r), o = r[r.length - 1];
    return typeof a == "function" && a !== o && Object.keys(o).forEach(function(c) {
      a[c] = o[c];
    }), a;
  }
}
<<<<<<< HEAD
var wrappy = wrappy_1;
once$3.exports = wrappy(once$2);
once$3.exports.strict = wrappy(onceStrict);
once$2.proto = once$2(function() {
=======
var Qm = YE;
tu.exports = Qm(Ha);
tu.exports.strict = Qm(e0);
Ha.proto = Ha(function() {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return Ha(this);
    },
    configurable: !0
  }), Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return e0(this);
    },
    configurable: !0
  });
});
function Ha(e) {
  var t = function() {
    return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments));
  };
  return t.called = !1, t;
}
function e0(e) {
  var t = function() {
    if (t.called)
      throw new Error(t.onceError);
    return t.called = !0, t.value = e.apply(this, arguments);
  }, n = e.name || "Function wrapped with `once`";
  return t.onceError = n + " shouldn't be called more than once", t.called = !1, t;
}
<<<<<<< HEAD
var onceExports = once$3.exports;
var once$1 = onceExports;
var noop$4 = function() {
};
var qnt = commonjsGlobal.Bare ? queueMicrotask : process.nextTick.bind(process);
var isRequest$1 = function(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
};
var isChildProcess = function(stream2) {
  return stream2.stdio && Array.isArray(stream2.stdio) && stream2.stdio.length === 3;
};
var eos$2 = function(stream2, opts, callback) {
  if (typeof opts === "function") return eos$2(stream2, null, opts);
  if (!opts) opts = {};
  callback = once$1(callback || noop$4);
  var ws = stream2._writableState;
  var rs = stream2._readableState;
  var readable2 = opts.readable || opts.readable !== false && stream2.readable;
  var writable = opts.writable || opts.writable !== false && stream2.writable;
  var cancelled = false;
  var onlegacyfinish = function() {
    if (!stream2.writable) onfinish();
  };
  var onfinish = function() {
    writable = false;
    if (!readable2) callback.call(stream2);
  };
  var onend = function() {
    readable2 = false;
    if (!writable) callback.call(stream2);
  };
  var onexit = function(exitCode) {
    callback.call(stream2, exitCode ? new Error("exited with error code: " + exitCode) : null);
  };
  var onerror = function(err) {
    callback.call(stream2, err);
  };
  var onclose = function() {
    qnt(onclosenexttick);
  };
  var onclosenexttick = function() {
    if (cancelled) return;
    if (readable2 && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream2, new Error("premature close"));
    if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream2, new Error("premature close"));
  };
  var onrequest = function() {
    stream2.req.on("finish", onfinish);
  };
  if (isRequest$1(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req) onrequest();
    else stream2.on("request", onrequest);
  } else if (writable && !ws) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  if (isChildProcess(stream2)) stream2.on("exit", onexit);
  stream2.on("end", onend);
  stream2.on("finish", onfinish);
  if (opts.error !== false) stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    cancelled = true;
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req) stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("exit", onexit);
    stream2.removeListener("end", onend);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
};
var endOfStream = eos$2;
var once = onceExports;
var eos$1 = endOfStream;
var fs$t;
=======
var t0 = tu.exports, XE = t0, KE = function() {
}, JE = Te.Bare ? queueMicrotask : process.nextTick.bind(process), ZE = function(e) {
  return e.setHeader && typeof e.abort == "function";
}, QE = function(e) {
  return e.stdio && Array.isArray(e.stdio) && e.stdio.length === 3;
}, n0 = function(e, t, n) {
  if (typeof t == "function") return n0(e, null, t);
  t || (t = {}), n = XE(n || KE);
  var r = e._writableState, i = e._readableState, a = t.readable || t.readable !== !1 && e.readable, o = t.writable || t.writable !== !1 && e.writable, c = !1, s = function() {
    e.writable || u();
  }, u = function() {
    o = !1, a || n.call(e);
  }, l = function() {
    a = !1, o || n.call(e);
  }, p = function(y) {
    n.call(e, y ? new Error("exited with error code: " + y) : null);
  }, d = function(y) {
    n.call(e, y);
  }, m = function() {
    JE(g);
  }, g = function() {
    if (!c) {
      if (a && !(i && i.ended && !i.destroyed)) return n.call(e, new Error("premature close"));
      if (o && !(r && r.ended && !r.destroyed)) return n.call(e, new Error("premature close"));
    }
  }, v = function() {
    e.req.on("finish", u);
  };
  return ZE(e) ? (e.on("complete", u), e.on("abort", m), e.req ? v() : e.on("request", v)) : o && !r && (e.on("end", s), e.on("close", s)), QE(e) && e.on("exit", p), e.on("end", l), e.on("finish", u), t.error !== !1 && e.on("error", d), e.on("close", m), function() {
    c = !0, e.removeListener("complete", u), e.removeListener("abort", m), e.removeListener("request", v), e.req && e.req.removeListener("finish", u), e.removeListener("end", s), e.removeListener("close", s), e.removeListener("finish", u), e.removeListener("exit", p), e.removeListener("end", l), e.removeListener("error", d), e.removeListener("close", m);
  };
}, r0 = n0, e_ = t0, t_ = r0, Ga;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
try {
  Ga = require("fs");
} catch {
}
<<<<<<< HEAD
var noop$3 = function() {
};
var ancient = typeof process === "undefined" ? false : /^v?\.0/.test(process.version);
var isFn = function(fn) {
  return typeof fn === "function";
};
var isFS = function(stream2) {
  if (!ancient) return false;
  if (!fs$t) return false;
  return (stream2 instanceof (fs$t.ReadStream || noop$3) || stream2 instanceof (fs$t.WriteStream || noop$3)) && isFn(stream2.close);
};
var isRequest = function(stream2) {
  return stream2.setHeader && isFn(stream2.abort);
};
var destroyer = function(stream2, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream2.on("close", function() {
    closed = true;
  });
  eos$1(stream2, { readable: reading, writable: writing }, function(err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;
    if (isFS(stream2)) return stream2.close(noop$3);
    if (isRequest(stream2)) return stream2.abort();
    if (isFn(stream2.destroy)) return stream2.destroy();
    callback(err || new Error("stream was destroyed"));
  };
};
var call = function(fn) {
  fn();
};
var pipe = function(from, to) {
  return from.pipe(to);
};
var pump$2 = function() {
  var streams2 = Array.prototype.slice.call(arguments);
  var callback = isFn(streams2[streams2.length - 1] || noop$3) && streams2.pop() || noop$3;
  if (Array.isArray(streams2[0])) streams2 = streams2[0];
  if (streams2.length < 2) throw new Error("pump requires two streams per minimum");
  var error2;
  var destroys = streams2.map(function(stream2, i) {
    var reading = i < streams2.length - 1;
    var writing = i > 0;
    return destroyer(stream2, reading, writing, function(err) {
      if (!error2) error2 = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error2);
    });
  });
  return streams2.reduce(pipe);
};
var pump_1 = pump$2;
const fs$s = fs$w;
const path$q = require$$1$4;
const mkdirp$1 = mkdirp$2;
const pump$1 = pump_1;
utils$f.sourceType = (source) => {
  if (!source) return void 0;
  if (source instanceof Buffer) return "buffer";
  if (typeof source._read === "function" || typeof source._transform === "function") return "stream";
  if (typeof source !== "string") {
    const err = new Error("Type is not supported, must be a file path, file buffer, or a readable stream");
    err.name = "IlligalSourceError";
    throw err;
  }
  return "file";
};
function destType(dest) {
  if (typeof dest._write === "function" || typeof dest._transform === "function") return "stream";
  if (typeof dest !== "string") {
    const err = new Error("Type is not supported, must be a file path, or a writable stream");
    err.name = "IlligalDestinationError";
    throw err;
=======
var di = function() {
}, n_ = typeof process > "u" ? !1 : /^v?\.0/.test(process.version), Do = function(e) {
  return typeof e == "function";
}, r_ = function(e) {
  return !n_ || !Ga ? !1 : (e instanceof (Ga.ReadStream || di) || e instanceof (Ga.WriteStream || di)) && Do(e.close);
}, i_ = function(e) {
  return e.setHeader && Do(e.abort);
}, a_ = function(e, t, n, r) {
  r = e_(r);
  var i = !1;
  e.on("close", function() {
    i = !0;
  }), t_(e, { readable: t, writable: n }, function(o) {
    if (o) return r(o);
    i = !0, r();
  });
  var a = !1;
  return function(o) {
    if (!i && !a) {
      if (a = !0, r_(e)) return e.close(di);
      if (i_(e)) return e.abort();
      if (Do(e.destroy)) return e.destroy();
      r(o || new Error("stream was destroyed"));
    }
  };
}, uf = function(e) {
  e();
}, o_ = function(e, t) {
  return e.pipe(t);
}, s_ = function() {
  var e = Array.prototype.slice.call(arguments), t = Do(e[e.length - 1] || di) && e.pop() || di;
  if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new Error("pump requires two streams per minimum");
  var n, r = e.map(function(i, a) {
    var o = a < e.length - 1, c = a > 0;
    return a_(i, o, c, function(s) {
      n || (n = s), s && r.forEach(uf), !o && (r.forEach(uf), t(n));
    });
  });
  return e.reduce(o_);
}, i0 = s_;
const io = ae, lr = oe, fa = VE, a0 = i0;
me.sourceType = (e) => {
  if (e) {
    if (e instanceof Buffer) return "buffer";
    if (typeof e._read == "function" || typeof e._transform == "function") return "stream";
    if (typeof e != "string") {
      const t = new Error("Type is not supported, must be a file path, file buffer, or a readable stream");
      throw t.name = "IlligalSourceError", t;
    }
    return "file";
  }
};
function Fo(e) {
  if (typeof e._write == "function" || typeof e._transform == "function") return "stream";
  if (typeof e != "string") {
    const t = new Error("Type is not supported, must be a file path, or a writable stream");
    throw t.name = "IlligalDestinationError", t;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return "path";
}
me.destType = Fo;
const o0 = new Error("Type is not supported, must be a file path, directory path, file buffer, or a readable stream");
o0.name = "IlligalEntryError";
me.entryType = (e) => {
  if (e) {
    if (e instanceof Buffer) return "buffer";
    if (typeof e._read == "function" || typeof e._transform == "function") return "stream";
    if (typeof e != "string") throw o0;
    return "fileOrDir";
  }
};
me.clone = (e) => {
  const t = {};
  for (const n in e)
    t[n] = e[n];
  return t;
};
me.makeFileProcessFn = (e) => (t, n, r) => {
  r = r || {}, r.source = t;
  const i = Fo(n) === "path" ? io.createWriteStream(n) : n, a = new e(r);
  return nu([a, i]);
};
me.makeCompressDirFn = (e) => (t, n, r) => {
  const i = Fo(n) === "path" ? io.createWriteStream(n) : n, a = new e();
  return a.addEntry(t, r), nu([a, i]);
};
me.makeUncompressFn = (e) => (t, n, r) => {
  if (r = r || {}, r.source = t, !t) {
    const i = new Error("Type is not supported, must be a file path, file buffer, or a readable stream");
    throw i.name = "IlligalSourceError", i;
  }
  if (Fo(n) !== "path") {
    const i = new Error("uncompress destination must be a directory");
    throw i.name = "IlligalDestError", i;
  }
  return new Promise((i, a) => {
    fa(n, (o) => {
      if (o) return a(o);
      let c = 0, s = 0, u = !1;
      function l() {
        u && c === s && i();
      }
      new e(r).on("finish", () => {
        u = !0, l();
      }).on("error", a).on("entry", (p, d, m) => {
        d.on("end", m);
        const g = lr.join(n, p.name);
        if (p.type === "file") {
          const v = lr.dirname(g);
          fa(v, (y) => {
            if (y) return a(y);
            c++, a0(d, io.createWriteStream(g, { mode: r.mode || p.mode }), (x) => {
              if (x) return a(x);
              s++, l();
            });
          });
        } else if (p.type === "symlink") {
          const v = lr.dirname(g), y = lr.resolve(v, p.linkname);
          c++, fa(v, (x) => {
            if (x) return a(x);
            const w = lr.relative(v, y);
            io.symlink(w, g, (A) => {
              if (A) return a(A);
              s++, d.resume();
            });
          });
        } else
          fa(g, (v) => {
            if (v) return a(v);
            d.resume();
          });
      });
    });
  });
};
me.streamToBuffer = (e) => new Promise((t, n) => {
  const r = [];
  e.on("readable", () => {
    let i;
    for (; i = e.read(); ) r.push(i);
  }).on("end", () => t(Buffer.concat(r))).on("error", (i) => n(i));
});
function nu(e) {
  return new Promise((t, n) => {
    a0(e[0], e[1], (r) => {
      if (r) return n(r);
      t();
    });
  });
}
<<<<<<< HEAD
utils$f.safePipe = safePipe;
function normalizePath(fileName) {
  fileName = path$q.normalize(fileName);
  if (process.platform === "win32") fileName = fileName.replace(/\\+/g, "/");
  return fileName;
}
function stripFileName(strip, fileName, type2) {
  if (Buffer.isBuffer(fileName)) fileName = fileName.toString();
  if (fileName.indexOf("\\") !== -1) fileName = fileName.replace(/\\+/g, "/");
  if (fileName[0] === "/") fileName = fileName.replace(/^\/+/, "");
  if (fileName) {
    fileName = normalizePath(fileName);
  }
  let s = fileName.split("/");
  if (s.indexOf("..") !== -1) {
    fileName = fileName.replace(/(\.\.\/)+/, "");
    if (type2 === "directory" && fileName && fileName[fileName.length - 1] !== "/") {
      fileName += "/";
    }
    s = fileName.split("/");
  }
  strip = Math.min(strip, s.length - 1);
  return s.slice(strip).join("/") || "/";
}
utils$f.stripFileName = stripFileName;
var yazl$2 = {};
var Buffer$4 = require$$0$5.Buffer;
var CRC_TABLE = [
=======
me.safePipe = nu;
function c_(e) {
  return e = lr.normalize(e), process.platform === "win32" && (e = e.replace(/\\+/g, "/")), e;
}
function l_(e, t, n) {
  Buffer.isBuffer(t) && (t = t.toString()), t.indexOf("\\") !== -1 && (t = t.replace(/\\+/g, "/")), t[0] === "/" && (t = t.replace(/^\/+/, "")), t && (t = c_(t));
  let r = t.split("/");
  return r.indexOf("..") !== -1 && (t = t.replace(/(\.\.\/)+/, ""), n === "directory" && t && t[t.length - 1] !== "/" && (t += "/"), r = t.split("/")), e = Math.min(e, r.length - 1), r.slice(e).join("/") || "/";
}
me.stripFileName = l_;
var No = {}, Xt = Nt.Buffer, ul = [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
typeof Int32Array < "u" && (ul = new Int32Array(ul));
function s0(e) {
  if (Xt.isBuffer(e))
    return e;
  var t = typeof Xt.alloc == "function" && typeof Xt.from == "function";
  if (typeof e == "number")
    return t ? Xt.alloc(e) : new Xt(e);
  if (typeof e == "string")
    return t ? Xt.from(e) : new Xt(e);
  throw new Error("input must be buffer, number, or string, received " + typeof e);
}
<<<<<<< HEAD
function ensureBuffer(input) {
  if (Buffer$4.isBuffer(input)) {
    return input;
  }
  var hasNewBufferAPI = typeof Buffer$4.alloc === "function" && typeof Buffer$4.from === "function";
  if (typeof input === "number") {
    return hasNewBufferAPI ? Buffer$4.alloc(input) : new Buffer$4(input);
  } else if (typeof input === "string") {
    return hasNewBufferAPI ? Buffer$4.from(input) : new Buffer$4(input);
  } else {
    throw new Error("input must be buffer, number, or string, received " + typeof input);
  }
=======
function u_(e) {
  var t = s0(4);
  return t.writeInt32BE(e, 0), t;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function ru(e, t) {
  e = s0(e), Xt.isBuffer(t) && (t = t.readUInt32BE(0));
  for (var n = ~~t ^ -1, r = 0; r < e.length; r++)
    n = ul[(n ^ e[r]) & 255] ^ n >>> 8;
  return n ^ -1;
}
<<<<<<< HEAD
function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if (Buffer$4.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  var crc = ~~previous ^ -1;
  for (var n = 0; n < buf.length; n++) {
    crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
  }
  return crc ^ -1;
=======
function iu() {
  return u_(ru.apply(null, arguments));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
iu.signed = function() {
  return ru.apply(null, arguments);
};
iu.unsigned = function() {
  return ru.apply(null, arguments) >>> 0;
};
<<<<<<< HEAD
var bufferCrc32 = crc32$2;
var fs$r = fs$w;
var Transform$1 = require$$1$2.Transform;
var PassThrough$3 = require$$1$2.PassThrough;
var zlib$3 = zlib$4;
var util$a = require$$1$3;
var EventEmitter$3 = require$$0$6.EventEmitter;
var crc32$1 = bufferCrc32;
yazl$2.ZipFile = ZipFile$1;
yazl$2.dateToDosDateTime = dateToDosDateTime;
util$a.inherits(ZipFile$1, EventEmitter$3);
function ZipFile$1() {
  this.outputStream = new PassThrough$3();
  this.entries = [];
  this.outputStreamCursor = 0;
  this.ended = false;
  this.allDone = false;
  this.forceZip64Eocd = false;
=======
var c0 = iu, pf = ae, ko = ie.Transform, l0 = ie.PassThrough, u0 = Qe, au = Pe, p_ = Hn.EventEmitter, p0 = c0;
No.ZipFile = Gn;
No.dateToDosDateTime = S0;
au.inherits(Gn, p_);
function Gn() {
  this.outputStream = new l0(), this.entries = [], this.outputStreamCursor = 0, this.ended = !1, this.allDone = !1, this.forceZip64Eocd = !1;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
Gn.prototype.addFile = function(e, t, n) {
  var r = this;
  t = Lo(t, !1), n == null && (n = {});
  var i = new pe(t, !1, n);
  r.entries.push(i), pf.stat(e, function(a, o) {
    if (a) return r.emit("error", a);
    if (!o.isFile()) return r.emit("error", new Error("not a file: " + e));
    i.uncompressedSize = o.size, n.mtime == null && i.setLastModDate(o.mtime), n.mode == null && i.setFileAttributesMode(o.mode), i.setFileDataPumpFunction(function() {
      var c = pf.createReadStream(e);
      i.state = pe.FILE_DATA_IN_PROGRESS, c.on("error", function(s) {
        r.emit("error", s);
      }), f0(r, i, c);
    }), on(r);
  });
};
Gn.prototype.addReadStream = function(e, t, n) {
  var r = this;
  t = Lo(t, !1), n == null && (n = {});
  var i = new pe(t, !1, n);
  r.entries.push(i), i.setFileDataPumpFunction(function() {
    i.state = pe.FILE_DATA_IN_PROGRESS, f0(r, i, e);
  }), on(r);
};
<<<<<<< HEAD
ZipFile$1.prototype.addBuffer = function(buffer2, metadataPath, options) {
  var self2 = this;
  metadataPath = validateMetadataPath(metadataPath, false);
  if (buffer2.length > 1073741823) throw new Error("buffer too large: " + buffer2.length + " > 1073741823");
  if (options == null) options = {};
  if (options.size != null) throw new Error("options.size not allowed");
  var entry = new Entry$1(metadataPath, false, options);
  entry.uncompressedSize = buffer2.length;
  entry.crc32 = crc32$1.unsigned(buffer2);
  entry.crcAndFileSizeKnown = true;
  self2.entries.push(entry);
  if (!entry.compress) {
    setCompressedBuffer(buffer2);
  } else {
    zlib$3.deflateRaw(buffer2, function(err, compressedBuffer) {
      setCompressedBuffer(compressedBuffer);
    });
  }
  function setCompressedBuffer(compressedBuffer) {
    entry.compressedSize = compressedBuffer.length;
    entry.setFileDataPumpFunction(function() {
      writeToOutputStream(self2, compressedBuffer);
      writeToOutputStream(self2, entry.getDataDescriptor());
      entry.state = Entry$1.FILE_DATA_DONE;
      setImmediate(function() {
        pumpEntries(self2);
=======
Gn.prototype.addBuffer = function(e, t, n) {
  var r = this;
  if (t = Lo(t, !1), e.length > 1073741823) throw new Error("buffer too large: " + e.length + " > 1073741823");
  if (n == null && (n = {}), n.size != null) throw new Error("options.size not allowed");
  var i = new pe(t, !1, n);
  i.uncompressedSize = e.length, i.crc32 = p0.unsigned(e), i.crcAndFileSizeKnown = !0, r.entries.push(i), i.compress ? u0.deflateRaw(e, function(o, c) {
    a(c);
  }) : a(e);
  function a(o) {
    i.compressedSize = o.length, i.setFileDataPumpFunction(function() {
      kn(r, o), kn(r, i.getDataDescriptor()), i.state = pe.FILE_DATA_DONE, setImmediate(function() {
        on(r);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      });
    }), on(r);
  }
};
Gn.prototype.addEmptyDirectory = function(e, t) {
  var n = this;
  if (e = Lo(e, !0), t == null && (t = {}), t.size != null) throw new Error("options.size not allowed");
  if (t.compress != null) throw new Error("options.compress not allowed");
  var r = new pe(e, !0, t);
  n.entries.push(r), r.setFileDataPumpFunction(function() {
    kn(n, r.getDataDescriptor()), r.state = pe.FILE_DATA_DONE, on(n);
  }), on(n);
};
<<<<<<< HEAD
var eocdrSignatureBuffer = bufferFrom([80, 75, 5, 6]);
ZipFile$1.prototype.end = function(options, finalSizeCallback) {
  if (typeof options === "function") {
    finalSizeCallback = options;
    options = null;
=======
var f_ = Zt([80, 75, 5, 6]);
Gn.prototype.end = function(e, t) {
  if (typeof e == "function" && (t = e, e = null), e == null && (e = {}), !this.ended) {
    if (this.ended = !0, this.finalSizeCallback = t, this.forceZip64Eocd = !!e.forceZip64Format, e.comment) {
      if (typeof e.comment == "string" ? this.comment = m_(e.comment) : this.comment = e.comment, this.comment.length > 65535) throw new Error("comment is too large");
      if (ei(this.comment, f_)) throw new Error("comment contains end of central directory record signature");
    } else
      this.comment = Uo;
    on(this);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
};
<<<<<<< HEAD
function writeToOutputStream(self2, buffer2) {
  self2.outputStream.write(buffer2);
  self2.outputStreamCursor += buffer2.length;
=======
function kn(e, t) {
  e.outputStream.write(t), e.outputStreamCursor += t.length;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function f0(e, t, n) {
  var r = new ou(), i = new ao(), a = t.compress ? new u0.DeflateRaw() : new l0(), o = new ao();
  n.pipe(r).pipe(i).pipe(a).pipe(o).pipe(e.outputStream, { end: !1 }), o.on("end", function() {
    if (t.crc32 = r.crc32, t.uncompressedSize == null)
      t.uncompressedSize = i.byteCount;
    else if (t.uncompressedSize !== i.byteCount) return e.emit("error", new Error("file data stream has unexpected number of bytes"));
    t.compressedSize = o.byteCount, e.outputStreamCursor += t.compressedSize, kn(e, t.getDataDescriptor()), t.state = pe.FILE_DATA_DONE, on(e);
  });
}
<<<<<<< HEAD
function pumpEntries(self2) {
  if (self2.allDone) return;
  if (self2.ended && self2.finalSizeCallback != null) {
    var finalSize = calculateFinalSize(self2);
    if (finalSize != null) {
      self2.finalSizeCallback(finalSize);
      self2.finalSizeCallback = null;
    }
=======
function on(e) {
  if (e.allDone) return;
  if (e.ended && e.finalSizeCallback != null) {
    var t = d_(e);
    t != null && (e.finalSizeCallback(t), e.finalSizeCallback = null);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  var n = r();
  function r() {
    for (var a = 0; a < e.entries.length; a++) {
      var o = e.entries[a];
      if (o.state < pe.FILE_DATA_DONE) return o;
    }
    return null;
  }
<<<<<<< HEAD
  if (entry != null) {
    if (entry.state < Entry$1.READY_TO_PUMP_FILE_DATA) return;
    if (entry.state === Entry$1.FILE_DATA_IN_PROGRESS) return;
    entry.relativeOffsetOfLocalHeader = self2.outputStreamCursor;
    var localFileHeader = entry.getLocalFileHeader();
    writeToOutputStream(self2, localFileHeader);
    entry.doFileDataPump();
  } else {
    if (self2.ended) {
      self2.offsetOfStartOfCentralDirectory = self2.outputStreamCursor;
      self2.entries.forEach(function(entry2) {
        var centralDirectoryRecord = entry2.getCentralDirectoryRecord();
        writeToOutputStream(self2, centralDirectoryRecord);
      });
      writeToOutputStream(self2, getEndOfCentralDirectoryRecord(self2));
      self2.outputStream.end();
      self2.allDone = true;
    }
=======
  if (n != null) {
    if (n.state < pe.READY_TO_PUMP_FILE_DATA || n.state === pe.FILE_DATA_IN_PROGRESS) return;
    n.relativeOffsetOfLocalHeader = e.outputStreamCursor;
    var i = n.getLocalFileHeader();
    kn(e, i), n.doFileDataPump();
  } else
    e.ended && (e.offsetOfStartOfCentralDirectory = e.outputStreamCursor, e.entries.forEach(function(a) {
      var o = a.getCentralDirectoryRecord();
      kn(e, o);
    }), kn(e, h_(e)), e.outputStream.end(), e.allDone = !0);
}
function d_(e) {
  for (var t = 0, n = 0, r = 0; r < e.entries.length; r++) {
    var i = e.entries[r];
    if (i.compress) return -1;
    if (i.state >= pe.READY_TO_PUMP_FILE_DATA) {
      if (i.uncompressedSize == null) return -1;
    } else if (i.uncompressedSize == null) return null;
    i.relativeOffsetOfLocalHeader = t;
    var a = i.useZip64Format();
    t += m0 + i.utf8FileName.length, t += i.uncompressedSize, i.crcAndFileSizeKnown || (a ? t += E0 : t += w0), n += _0 + i.utf8FileName.length + i.fileComment.length, a && (n += fl);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  var o = 0;
  return (e.forceZip64Eocd || e.entries.length >= 65535 || n >= 65535 || t >= 4294967295) && (o += pl + d0), o += h0 + e.comment.length, t + n + o;
}
<<<<<<< HEAD
function calculateFinalSize(self2) {
  var pretendOutputCursor = 0;
  var centralDirectorySize = 0;
  for (var i = 0; i < self2.entries.length; i++) {
    var entry = self2.entries[i];
    if (entry.compress) return -1;
    if (entry.state >= Entry$1.READY_TO_PUMP_FILE_DATA) {
      if (entry.uncompressedSize == null) return -1;
    } else {
      if (entry.uncompressedSize == null) return null;
    }
    entry.relativeOffsetOfLocalHeader = pretendOutputCursor;
    var useZip64Format = entry.useZip64Format();
    pretendOutputCursor += LOCAL_FILE_HEADER_FIXED_SIZE + entry.utf8FileName.length;
    pretendOutputCursor += entry.uncompressedSize;
    if (!entry.crcAndFileSizeKnown) {
      if (useZip64Format) {
        pretendOutputCursor += ZIP64_DATA_DESCRIPTOR_SIZE;
      } else {
        pretendOutputCursor += DATA_DESCRIPTOR_SIZE;
      }
    }
    centralDirectorySize += CENTRAL_DIRECTORY_RECORD_FIXED_SIZE + entry.utf8FileName.length + entry.fileComment.length;
    if (useZip64Format) {
      centralDirectorySize += ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE;
    }
  }
  var endOfCentralDirectorySize = 0;
  if (self2.forceZip64Eocd || self2.entries.length >= 65535 || centralDirectorySize >= 65535 || pretendOutputCursor >= 4294967295) {
    endOfCentralDirectorySize += ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE;
  }
  endOfCentralDirectorySize += END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length;
  return pretendOutputCursor + centralDirectorySize + endOfCentralDirectorySize;
}
var ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 56;
var ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE = 20;
var END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 22;
function getEndOfCentralDirectoryRecord(self2, actuallyJustTellMeHowLongItWouldBe) {
  var needZip64Format = false;
  var normalEntriesLength = self2.entries.length;
  if (self2.forceZip64Eocd || self2.entries.length >= 65535) {
    normalEntriesLength = 65535;
    needZip64Format = true;
  }
  var sizeOfCentralDirectory = self2.outputStreamCursor - self2.offsetOfStartOfCentralDirectory;
  var normalSizeOfCentralDirectory = sizeOfCentralDirectory;
  if (self2.forceZip64Eocd || sizeOfCentralDirectory >= 4294967295) {
    normalSizeOfCentralDirectory = 4294967295;
    needZip64Format = true;
  }
  var normalOffsetOfStartOfCentralDirectory = self2.offsetOfStartOfCentralDirectory;
  if (self2.forceZip64Eocd || self2.offsetOfStartOfCentralDirectory >= 4294967295) {
    normalOffsetOfStartOfCentralDirectory = 4294967295;
    needZip64Format = true;
  }
  var eocdrBuffer = bufferAlloc$1(END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length);
  eocdrBuffer.writeUInt32LE(101010256, 0);
  eocdrBuffer.writeUInt16LE(0, 4);
  eocdrBuffer.writeUInt16LE(0, 6);
  eocdrBuffer.writeUInt16LE(normalEntriesLength, 8);
  eocdrBuffer.writeUInt16LE(normalEntriesLength, 10);
  eocdrBuffer.writeUInt32LE(normalSizeOfCentralDirectory, 12);
  eocdrBuffer.writeUInt32LE(normalOffsetOfStartOfCentralDirectory, 16);
  eocdrBuffer.writeUInt16LE(self2.comment.length, 20);
  self2.comment.copy(eocdrBuffer, 22);
  if (!needZip64Format) return eocdrBuffer;
  var zip64EocdrBuffer = bufferAlloc$1(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE);
  zip64EocdrBuffer.writeUInt32LE(101075792, 0);
  writeUInt64LE(zip64EocdrBuffer, ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE - 12, 4);
  zip64EocdrBuffer.writeUInt16LE(VERSION_MADE_BY, 12);
  zip64EocdrBuffer.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_ZIP64, 14);
  zip64EocdrBuffer.writeUInt32LE(0, 16);
  zip64EocdrBuffer.writeUInt32LE(0, 20);
  writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 24);
  writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 32);
  writeUInt64LE(zip64EocdrBuffer, sizeOfCentralDirectory, 40);
  writeUInt64LE(zip64EocdrBuffer, self2.offsetOfStartOfCentralDirectory, 48);
  var zip64EocdlBuffer = bufferAlloc$1(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE);
  zip64EocdlBuffer.writeUInt32LE(117853008, 0);
  zip64EocdlBuffer.writeUInt32LE(0, 4);
  writeUInt64LE(zip64EocdlBuffer, self2.outputStreamCursor, 8);
  zip64EocdlBuffer.writeUInt32LE(1, 16);
  return Buffer.concat([
    zip64EocdrBuffer,
    zip64EocdlBuffer,
    eocdrBuffer
=======
var pl = 56, d0 = 20, h0 = 22;
function h_(e, t) {
  var n = !1, r = e.entries.length;
  (e.forceZip64Eocd || e.entries.length >= 65535) && (r = 65535, n = !0);
  var i = e.outputStreamCursor - e.offsetOfStartOfCentralDirectory, a = i;
  (e.forceZip64Eocd || i >= 4294967295) && (a = 4294967295, n = !0);
  var o = e.offsetOfStartOfCentralDirectory;
  (e.forceZip64Eocd || e.offsetOfStartOfCentralDirectory >= 4294967295) && (o = 4294967295, n = !0);
  var c = Ke(h0 + e.comment.length);
  if (c.writeUInt32LE(101010256, 0), c.writeUInt16LE(0, 4), c.writeUInt16LE(0, 6), c.writeUInt16LE(r, 8), c.writeUInt16LE(r, 10), c.writeUInt32LE(a, 12), c.writeUInt32LE(o, 16), c.writeUInt16LE(e.comment.length, 20), e.comment.copy(c, 22), !n) return c;
  var s = Ke(pl);
  s.writeUInt32LE(101075792, 0), pt(s, pl - 12, 4), s.writeUInt16LE(x0, 12), s.writeUInt16LE(g0, 14), s.writeUInt32LE(0, 16), s.writeUInt32LE(0, 20), pt(s, e.entries.length, 24), pt(s, e.entries.length, 32), pt(s, i, 40), pt(s, e.offsetOfStartOfCentralDirectory, 48);
  var u = Ke(d0);
  return u.writeUInt32LE(117853008, 0), u.writeUInt32LE(0, 4), pt(u, e.outputStreamCursor, 8), u.writeUInt32LE(1, 16), Buffer.concat([
    s,
    u,
    c
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  ]);
}
function Lo(e, t) {
  if (e === "") throw new Error("empty metadataPath");
  if (e = e.replace(/\\/g, "/"), /^[a-zA-Z]:/.test(e) || /^\//.test(e)) throw new Error("absolute path: " + e);
  if (e.split("/").indexOf("..") !== -1) throw new Error("invalid relative path: " + e);
  var n = /\/$/.test(e);
  if (t)
    n || (e += "/");
  else if (n) throw new Error("file path cannot end with '/': " + e);
  return e;
}
var Uo = Ke(0);
function pe(e, t, n) {
  if (this.utf8FileName = Zt(e), this.utf8FileName.length > 65535) throw new Error("utf8 file name too long. " + utf8FileName.length + " > 65535");
  if (this.isDirectory = t, this.state = pe.WAITING_FOR_METADATA, this.setLastModDate(n.mtime != null ? n.mtime : /* @__PURE__ */ new Date()), n.mode != null ? this.setFileAttributesMode(n.mode) : this.setFileAttributesMode(t ? 16893 : 33204), t ? (this.crcAndFileSizeKnown = !0, this.crc32 = 0, this.uncompressedSize = 0, this.compressedSize = 0) : (this.crcAndFileSizeKnown = !1, this.crc32 = null, this.uncompressedSize = null, this.compressedSize = null, n.size != null && (this.uncompressedSize = n.size)), t ? this.compress = !1 : (this.compress = !0, n.compress != null && (this.compress = !!n.compress)), this.forceZip64Format = !!n.forceZip64Format, n.fileComment) {
    if (typeof n.fileComment == "string" ? this.fileComment = Zt(n.fileComment, "utf-8") : this.fileComment = n.fileComment, this.fileComment.length > 65535) throw new Error("fileComment is too large");
  } else
    this.fileComment = Uo;
}
pe.WAITING_FOR_METADATA = 0;
pe.READY_TO_PUMP_FILE_DATA = 1;
pe.FILE_DATA_IN_PROGRESS = 2;
pe.FILE_DATA_DONE = 3;
pe.prototype.setLastModDate = function(e) {
  var t = S0(e);
  this.lastModFileTime = t.time, this.lastModFileDate = t.date;
};
pe.prototype.setFileAttributesMode = function(e) {
  if ((e & 65535) !== e) throw new Error("invalid mode. expected: 0 <= " + e + " <= 65535");
  this.externalFileAttributes = e << 16 >>> 0;
};
pe.prototype.setFileDataPumpFunction = function(e) {
  this.doFileDataPump = e, this.state = pe.READY_TO_PUMP_FILE_DATA;
};
pe.prototype.useZip64Format = function() {
  return this.forceZip64Format || this.uncompressedSize != null && this.uncompressedSize > 4294967294 || this.compressedSize != null && this.compressedSize > 4294967294 || this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 4294967294;
};
var m0 = 30, v0 = 20, g0 = 45, x0 = 831, y0 = 2048, b0 = 8;
pe.prototype.getLocalFileHeader = function() {
  var e = 0, t = 0, n = 0;
  this.crcAndFileSizeKnown && (e = this.crc32, t = this.compressedSize, n = this.uncompressedSize);
  var r = Ke(m0), i = y0;
  return this.crcAndFileSizeKnown || (i |= b0), r.writeUInt32LE(67324752, 0), r.writeUInt16LE(v0, 4), r.writeUInt16LE(i, 6), r.writeUInt16LE(this.getCompressionMethod(), 8), r.writeUInt16LE(this.lastModFileTime, 10), r.writeUInt16LE(this.lastModFileDate, 12), r.writeUInt32LE(e, 14), r.writeUInt32LE(t, 18), r.writeUInt32LE(n, 22), r.writeUInt16LE(this.utf8FileName.length, 26), r.writeUInt16LE(0, 28), Buffer.concat([
    r,
    // file name (variable size)
    this.utf8FileName
    // extra field (variable size)
    // no extra fields
  ]);
};
<<<<<<< HEAD
var DATA_DESCRIPTOR_SIZE = 16;
var ZIP64_DATA_DESCRIPTOR_SIZE = 24;
Entry$1.prototype.getDataDescriptor = function() {
  if (this.crcAndFileSizeKnown) {
    return EMPTY_BUFFER;
  }
  if (!this.useZip64Format()) {
    var buffer2 = bufferAlloc$1(DATA_DESCRIPTOR_SIZE);
    buffer2.writeUInt32LE(134695760, 0);
    buffer2.writeUInt32LE(this.crc32, 4);
    buffer2.writeUInt32LE(this.compressedSize, 8);
    buffer2.writeUInt32LE(this.uncompressedSize, 12);
    return buffer2;
  } else {
    var buffer2 = bufferAlloc$1(ZIP64_DATA_DESCRIPTOR_SIZE);
    buffer2.writeUInt32LE(134695760, 0);
    buffer2.writeUInt32LE(this.crc32, 4);
    writeUInt64LE(buffer2, this.compressedSize, 8);
    writeUInt64LE(buffer2, this.uncompressedSize, 16);
    return buffer2;
  }
};
var CENTRAL_DIRECTORY_RECORD_FIXED_SIZE = 46;
var ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE = 28;
Entry$1.prototype.getCentralDirectoryRecord = function() {
  var fixedSizeStuff = bufferAlloc$1(CENTRAL_DIRECTORY_RECORD_FIXED_SIZE);
  var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
  if (!this.crcAndFileSizeKnown) generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
  var normalCompressedSize = this.compressedSize;
  var normalUncompressedSize = this.uncompressedSize;
  var normalRelativeOffsetOfLocalHeader = this.relativeOffsetOfLocalHeader;
  var versionNeededToExtract;
  var zeiefBuffer;
  if (this.useZip64Format()) {
    normalCompressedSize = 4294967295;
    normalUncompressedSize = 4294967295;
    normalRelativeOffsetOfLocalHeader = 4294967295;
    versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_ZIP64;
    zeiefBuffer = bufferAlloc$1(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE);
    zeiefBuffer.writeUInt16LE(1, 0);
    zeiefBuffer.writeUInt16LE(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE - 4, 2);
    writeUInt64LE(zeiefBuffer, this.uncompressedSize, 4);
    writeUInt64LE(zeiefBuffer, this.compressedSize, 12);
    writeUInt64LE(zeiefBuffer, this.relativeOffsetOfLocalHeader, 20);
  } else {
    versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_UTF8;
    zeiefBuffer = EMPTY_BUFFER;
  }
  fixedSizeStuff.writeUInt32LE(33639248, 0);
  fixedSizeStuff.writeUInt16LE(VERSION_MADE_BY, 4);
  fixedSizeStuff.writeUInt16LE(versionNeededToExtract, 6);
  fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 8);
  fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 10);
  fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 12);
  fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 14);
  fixedSizeStuff.writeUInt32LE(this.crc32, 16);
  fixedSizeStuff.writeUInt32LE(normalCompressedSize, 20);
  fixedSizeStuff.writeUInt32LE(normalUncompressedSize, 24);
  fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 28);
  fixedSizeStuff.writeUInt16LE(zeiefBuffer.length, 30);
  fixedSizeStuff.writeUInt16LE(this.fileComment.length, 32);
  fixedSizeStuff.writeUInt16LE(0, 34);
  fixedSizeStuff.writeUInt16LE(0, 36);
  fixedSizeStuff.writeUInt32LE(this.externalFileAttributes, 38);
  fixedSizeStuff.writeUInt32LE(normalRelativeOffsetOfLocalHeader, 42);
  return Buffer.concat([
    fixedSizeStuff,
=======
var w0 = 16, E0 = 24;
pe.prototype.getDataDescriptor = function() {
  if (this.crcAndFileSizeKnown)
    return Uo;
  if (this.useZip64Format()) {
    var e = Ke(E0);
    return e.writeUInt32LE(134695760, 0), e.writeUInt32LE(this.crc32, 4), pt(e, this.compressedSize, 8), pt(e, this.uncompressedSize, 16), e;
  } else {
    var e = Ke(w0);
    return e.writeUInt32LE(134695760, 0), e.writeUInt32LE(this.crc32, 4), e.writeUInt32LE(this.compressedSize, 8), e.writeUInt32LE(this.uncompressedSize, 12), e;
  }
};
var _0 = 46, fl = 28;
pe.prototype.getCentralDirectoryRecord = function() {
  var e = Ke(_0), t = y0;
  this.crcAndFileSizeKnown || (t |= b0);
  var n = this.compressedSize, r = this.uncompressedSize, i = this.relativeOffsetOfLocalHeader, a, o;
  return this.useZip64Format() ? (n = 4294967295, r = 4294967295, i = 4294967295, a = g0, o = Ke(fl), o.writeUInt16LE(1, 0), o.writeUInt16LE(fl - 4, 2), pt(o, this.uncompressedSize, 4), pt(o, this.compressedSize, 12), pt(o, this.relativeOffsetOfLocalHeader, 20)) : (a = v0, o = Uo), e.writeUInt32LE(33639248, 0), e.writeUInt16LE(x0, 4), e.writeUInt16LE(a, 6), e.writeUInt16LE(t, 8), e.writeUInt16LE(this.getCompressionMethod(), 10), e.writeUInt16LE(this.lastModFileTime, 12), e.writeUInt16LE(this.lastModFileDate, 14), e.writeUInt32LE(this.crc32, 16), e.writeUInt32LE(n, 20), e.writeUInt32LE(r, 24), e.writeUInt16LE(this.utf8FileName.length, 28), e.writeUInt16LE(o.length, 30), e.writeUInt16LE(this.fileComment.length, 32), e.writeUInt16LE(0, 34), e.writeUInt16LE(0, 36), e.writeUInt32LE(this.externalFileAttributes, 38), e.writeUInt32LE(i, 42), Buffer.concat([
    e,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    // file name (variable size)
    this.utf8FileName,
    // extra field (variable size)
    o,
    // file comment (variable size)
    this.fileComment
  ]);
};
pe.prototype.getCompressionMethod = function() {
  var e = 0, t = 8;
  return this.compress ? t : e;
};
function S0(e) {
  var t = 0;
  t |= e.getDate() & 31, t |= (e.getMonth() + 1 & 15) << 5, t |= (e.getFullYear() - 1980 & 127) << 9;
  var n = 0;
  return n |= Math.floor(e.getSeconds() / 2), n |= (e.getMinutes() & 63) << 5, n |= (e.getHours() & 31) << 11, { date: t, time: n };
}
<<<<<<< HEAD
function writeUInt64LE(buffer2, n, offset) {
  var high = Math.floor(n / 4294967296);
  var low = n % 4294967296;
  buffer2.writeUInt32LE(low, offset);
  buffer2.writeUInt32LE(high, offset + 4);
=======
function pt(e, t, n) {
  var r = Math.floor(t / 4294967296), i = t % 4294967296;
  e.writeUInt32LE(i, n), e.writeUInt32LE(r, n + 4);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
au.inherits(ao, ko);
function ao(e) {
  ko.call(this, e), this.byteCount = 0;
}
ao.prototype._transform = function(e, t, n) {
  this.byteCount += e.length, n(null, e);
};
au.inherits(ou, ko);
function ou(e) {
  ko.call(this, e), this.crc32 = 0;
}
ou.prototype._transform = function(e, t, n) {
  this.crc32 = p0.unsigned(e, this.crc32), n(null, e);
};
<<<<<<< HEAD
var cp437$1 = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
if (cp437$1.length !== 256) throw new Error("assertion failure");
var reverseCp437 = null;
function encodeCp437(string) {
  if (/^[\x20-\x7e]*$/.test(string)) {
    return bufferFrom(string, "utf-8");
=======
var dl = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
if (dl.length !== 256) throw new Error("assertion failure");
var da = null;
function m_(e) {
  if (/^[\x20-\x7e]*$/.test(e))
    return Zt(e, "utf-8");
  if (da == null) {
    da = {};
    for (var t = 0; t < dl.length; t++)
      da[dl[t]] = t;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  for (var n = Ke(e.length), t = 0; t < e.length; t++) {
    var r = da[e[t]];
    if (r == null) throw new Error("character not encodable in CP437: " + JSON.stringify(e[t]));
    n[t] = r;
  }
  return n;
}
function Ke(e) {
  Ke = t;
  try {
    return Ke(e);
  } catch {
    return Ke = n, Ke(e);
  }
  function t(r) {
    return Buffer.allocUnsafe(r);
  }
  function n(r) {
    return new Buffer(r);
  }
}
function Zt(e, t) {
  Zt = n;
  try {
    return Zt(e, t);
  } catch {
    return Zt = r, Zt(e, t);
  }
  function n(i, a) {
    return Buffer.from(i, a);
  }
  function r(i, a) {
    return new Buffer(i, a);
  }
}
<<<<<<< HEAD
function bufferIncludes(buffer2, content) {
  bufferIncludes = modern;
  try {
    return bufferIncludes(buffer2, content);
  } catch (e) {
    bufferIncludes = legacy2;
    return bufferIncludes(buffer2, content);
  }
  function modern(buffer3, content2) {
    return buffer3.includes(content2);
  }
  function legacy2(buffer3, content2) {
    for (var i = 0; i <= buffer3.length - content2.length; i++) {
      for (var j = 0; ; j++) {
        if (j === content2.length) return true;
        if (buffer3[i + j] !== content2[j]) break;
=======
function ei(e, t) {
  ei = n;
  try {
    return ei(e, t);
  } catch {
    return ei = r, ei(e, t);
  }
  function n(i, a) {
    return i.includes(a);
  }
  function r(i, a) {
    for (var o = 0; o <= i.length - a.length; o++)
      for (var c = 0; ; c++) {
        if (c === a.length) return !0;
        if (i[o + c] !== a[c]) break;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
    return !1;
  }
}
var Li = {}, hl = { exports: {} }, ha = { exports: {} }, ff;
function Bo() {
  if (ff) return ha.exports;
  ff = 1, typeof process > "u" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0 ? ha.exports = { nextTick: e } : ha.exports = process;
  function e(t, n, r, i) {
    if (typeof t != "function")
      throw new TypeError('"callback" argument must be a function');
    var a = arguments.length, o, c;
    switch (a) {
      case 0:
      case 1:
        return process.nextTick(t);
      case 2:
        return process.nextTick(function() {
          t.call(null, n);
        });
      case 3:
        return process.nextTick(function() {
          t.call(null, n, r);
        });
      case 4:
        return process.nextTick(function() {
          t.call(null, n, r, i);
        });
      default:
        for (o = new Array(a - 1), c = 0; c < o.length; )
          o[c++] = arguments[c];
        return process.nextTick(function() {
          t.apply(null, o);
        });
    }
  }
  return ha.exports;
}
<<<<<<< HEAD
var isarray$1;
var hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray$1;
  hasRequiredIsarray = 1;
  var toString5 = {}.toString;
  isarray$1 = Array.isArray || function(arr) {
    return toString5.call(arr) == "[object Array]";
  };
  return isarray$1;
}
var stream$a;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream$a;
  hasRequiredStream = 1;
  stream$a = require$$1$2;
  return stream$a;
}
var safeBuffer$1 = { exports: {} };
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer$1.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer2 = require$$0$5;
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key2 in src2) {
        dst[key2] = src2[key2];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill2, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill2 !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill2, encoding);
        } else {
          buf.fill(fill2);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer$1, safeBuffer$1.exports);
  return safeBuffer$1.exports;
}
var util$9 = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util$9;
  hasRequiredUtil = 1;
  function isArray2(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString2(arg) === "[object Array]";
=======
var ec, df;
function v_() {
  if (df) return ec;
  df = 1;
  var e = {}.toString;
  return ec = Array.isArray || function(t) {
    return e.call(t) == "[object Array]";
  }, ec;
}
var tc, hf;
function T0() {
  return hf || (hf = 1, tc = ie), tc;
}
var ma = { exports: {} }, mf;
function jo() {
  return mf || (mf = 1, function(e, t) {
    var n = Nt, r = n.Buffer;
    function i(o, c) {
      for (var s in o)
        c[s] = o[s];
    }
    r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? e.exports = n : (i(n, t), t.Buffer = a);
    function a(o, c, s) {
      return r(o, c, s);
    }
    i(r, a), a.from = function(o, c, s) {
      if (typeof o == "number")
        throw new TypeError("Argument must not be a number");
      return r(o, c, s);
    }, a.alloc = function(o, c, s) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      var u = r(o);
      return c !== void 0 ? typeof s == "string" ? u.fill(c, s) : u.fill(c) : u.fill(0), u;
    }, a.allocUnsafe = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return r(o);
    }, a.allocUnsafeSlow = function(o) {
      if (typeof o != "number")
        throw new TypeError("Argument must be a number");
      return n.SlowBuffer(o);
    };
  }(ma, ma.exports)), ma.exports;
}
var Ne = {}, vf;
function Ui() {
  if (vf) return Ne;
  vf = 1;
  function e(v) {
    return Array.isArray ? Array.isArray(v) : g(v) === "[object Array]";
  }
  Ne.isArray = e;
  function t(v) {
    return typeof v == "boolean";
  }
  Ne.isBoolean = t;
  function n(v) {
    return v === null;
  }
  Ne.isNull = n;
  function r(v) {
    return v == null;
  }
  Ne.isNullOrUndefined = r;
  function i(v) {
    return typeof v == "number";
  }
  Ne.isNumber = i;
  function a(v) {
    return typeof v == "string";
  }
  Ne.isString = a;
  function o(v) {
    return typeof v == "symbol";
  }
  Ne.isSymbol = o;
  function c(v) {
    return v === void 0;
  }
  Ne.isUndefined = c;
  function s(v) {
    return g(v) === "[object RegExp]";
  }
  Ne.isRegExp = s;
  function u(v) {
    return typeof v == "object" && v !== null;
  }
  Ne.isObject = u;
  function l(v) {
    return g(v) === "[object Date]";
  }
  Ne.isDate = l;
  function p(v) {
    return g(v) === "[object Error]" || v instanceof Error;
  }
  Ne.isError = p;
  function d(v) {
    return typeof v == "function";
  }
  Ne.isFunction = d;
  function m(v) {
    return v === null || typeof v == "boolean" || typeof v == "number" || typeof v == "string" || typeof v == "symbol" || // ES6 symbol
    typeof v > "u";
  }
  Ne.isPrimitive = m, Ne.isBuffer = Nt.Buffer.isBuffer;
  function g(v) {
    return Object.prototype.toString.call(v);
  }
  return Ne;
}
var va = { exports: {} }, ga = { exports: {} }, gf;
function g_() {
  return gf || (gf = 1, typeof Object.create == "function" ? ga.exports = function(t, n) {
    n && (t.super_ = n, t.prototype = Object.create(n.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : ga.exports = function(t, n) {
    if (n) {
      t.super_ = n;
      var r = function() {
      };
      r.prototype = n.prototype, t.prototype = new r(), t.prototype.constructor = t;
    }
  }), ga.exports;
}
var xf;
function Bi() {
  if (xf) return va.exports;
  xf = 1;
  try {
    var e = require("util");
    if (typeof e.inherits != "function") throw "";
    va.exports = e.inherits;
  } catch {
    va.exports = g_();
  }
  return va.exports;
}
var nc = { exports: {} }, yf;
function x_() {
  return yf || (yf = 1, function(e) {
    function t(a, o) {
      if (!(a instanceof o))
        throw new TypeError("Cannot call a class as a function");
    }
    var n = jo().Buffer, r = Pe;
    function i(a, o, c) {
      a.copy(o, c);
    }
    e.exports = function() {
      function a() {
        t(this, a), this.head = null, this.tail = null, this.length = 0;
      }
      return a.prototype.push = function(c) {
        var s = { data: c, next: null };
        this.length > 0 ? this.tail.next = s : this.head = s, this.tail = s, ++this.length;
      }, a.prototype.unshift = function(c) {
        var s = { data: c, next: this.head };
        this.length === 0 && (this.tail = s), this.head = s, ++this.length;
      }, a.prototype.shift = function() {
        if (this.length !== 0) {
          var c = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, c;
        }
      }, a.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, a.prototype.join = function(c) {
        if (this.length === 0) return "";
        for (var s = this.head, u = "" + s.data; s = s.next; )
          u += c + s.data;
        return u;
      }, a.prototype.concat = function(c) {
        if (this.length === 0) return n.alloc(0);
        for (var s = n.allocUnsafe(c >>> 0), u = this.head, l = 0; u; )
          i(u.data, s, l), l += u.data.length, u = u.next;
        return s;
      }, a;
    }(), r && r.inspect && r.inspect.custom && (e.exports.prototype[r.inspect.custom] = function() {
      var a = r.inspect({ length: this.length });
      return this.constructor.name + " " + a;
    });
  }(nc)), nc.exports;
}
var rc, bf;
function A0() {
  if (bf) return rc;
  bf = 1;
  var e = Bo();
  function t(i, a) {
    var o = this, c = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return c || s ? (a ? a(i) : i && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(r, this, i)) : e.nextTick(r, this, i)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(i || null, function(u) {
      !a && u ? o._writableState ? o._writableState.errorEmitted || (o._writableState.errorEmitted = !0, e.nextTick(r, o, u)) : e.nextTick(r, o, u) : a && a(u);
    }), this);
  }
  function n() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function r(i, a) {
    i.emit("error", a);
  }
  return rc = {
    destroy: t,
    undestroy: n
  }, rc;
}
var ic, wf;
function y_() {
  return wf || (wf = 1, ic = Pe.deprecate), ic;
}
var ac, Ef;
function R0() {
  if (Ef) return ac;
  Ef = 1;
  var e = Bo();
  ac = v;
  function t(b) {
    var E = this;
    this.next = null, this.entry = null, this.finish = function() {
      D(E, b);
    };
  }
  var n = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, r;
  v.WritableState = m;
  var i = Object.create(Ui());
  i.inherits = Bi();
  var a = {
    deprecate: y_()
  }, o = T0(), c = jo().Buffer, s = (typeof Te < "u" ? Te : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function u(b) {
    return c.from(b);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  function l(b) {
    return c.isBuffer(b) || b instanceof s;
  }
  var p = A0();
  i.inherits(v, o);
  function d() {
  }
  function m(b, E) {
    r = r || Cr(), b = b || {};
    var R = E instanceof r;
    this.objectMode = !!b.objectMode, R && (this.objectMode = this.objectMode || !!b.writableObjectMode);
    var N = b.highWaterMark, L = b.writableHighWaterMark, B = this.objectMode ? 16 : 16 * 1024;
    N || N === 0 ? this.highWaterMark = N : R && (L || L === 0) ? this.highWaterMark = L : this.highWaterMark = B, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var K = b.decodeStrings === !1;
    this.decodeStrings = !K, this.defaultEncoding = b.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Z) {
      W(E, Z);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
<<<<<<< HEAD
  util$9.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  util$9.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  util$9.isString = isString2;
  function isSymbol2(arg) {
    return typeof arg === "symbol";
  }
  util$9.isSymbol = isSymbol2;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  util$9.isUndefined = isUndefined2;
  function isRegExp2(re2) {
    return objectToString2(re2) === "[object RegExp]";
  }
  util$9.isRegExp = isRegExp2;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util$9.isObject = isObject2;
  function isDate2(d) {
    return objectToString2(d) === "[object Date]";
  }
  util$9.isDate = isDate2;
  function isError(e) {
    return objectToString2(e) === "[object Error]" || e instanceof Error;
  }
  util$9.isError = isError;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  util$9.isFunction = isFunction2;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util$9.isPrimitive = isPrimitive;
  util$9.isBuffer = require$$0$5.Buffer.isBuffer;
  function objectToString2(o) {
    return Object.prototype.toString.call(o);
  }
  return util$9;
}
var inherits = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits.exports;
  hasRequiredInherits = 1;
  try {
    var util2 = require("util");
    if (typeof util2.inherits !== "function") throw "";
    inherits.exports = util2.inherits;
  } catch (e) {
    inherits.exports = requireInherits_browser();
  }
  return inherits.exports;
}
var BufferList$1 = { exports: {} };
var hasRequiredBufferList;
function requireBufferList() {
  if (hasRequiredBufferList) return BufferList$1.exports;
  hasRequiredBufferList = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer().Buffer;
    var util2 = require$$1$3;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList$1);
  return BufferList$1.exports;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var pna = requireProcessNextickArgs();
  function destroy3(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  destroy_1 = {
    destroy: destroy3,
    undestroy
  };
  return destroy_1;
}
var node;
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  node = require$$1$3.deprecate;
  return node;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable = Writable2;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable2.WritableState = WritableState;
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream2 = requireStream();
  var Buffer2 = requireSafeBuffer().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  util2.inherits(Writable2, Stream2);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out2 = [];
    while (current) {
      out2.push(current);
      current = current.next;
    }
    return out2;
  };
  (function() {
=======
  m.prototype.getBuffer = function() {
    for (var E = this.bufferedRequest, R = []; E; )
      R.push(E), E = E.next;
    return R;
  }, function() {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    try {
      Object.defineProperty(m.prototype, "buffer", {
        get: a.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var g;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (g = Function.prototype[Symbol.hasInstance], Object.defineProperty(v, Symbol.hasInstance, {
    value: function(b) {
      return g.call(this, b) ? !0 : this !== v ? !1 : b && b._writableState instanceof m;
    }
  })) : g = function(b) {
    return b instanceof this;
  };
  function v(b) {
    if (r = r || Cr(), !g.call(v, this) && !(this instanceof r))
      return new v(b);
    this._writableState = new m(b, this), this.writable = !0, b && (typeof b.write == "function" && (this._write = b.write), typeof b.writev == "function" && (this._writev = b.writev), typeof b.destroy == "function" && (this._destroy = b.destroy), typeof b.final == "function" && (this._final = b.final)), o.call(this);
  }
  v.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function y(b, E) {
    var R = new Error("write after end");
    b.emit("error", R), e.nextTick(E, R);
  }
  function x(b, E, R, N) {
    var L = !0, B = !1;
    return R === null ? B = new TypeError("May not write null values to stream") : typeof R != "string" && R !== void 0 && !E.objectMode && (B = new TypeError("Invalid non-string/buffer chunk")), B && (b.emit("error", B), e.nextTick(N, B), L = !1), L;
  }
  v.prototype.write = function(b, E, R) {
    var N = this._writableState, L = !1, B = !N.objectMode && l(b);
    return B && !c.isBuffer(b) && (b = u(b)), typeof E == "function" && (R = E, E = null), B ? E = "buffer" : E || (E = N.defaultEncoding), typeof R != "function" && (R = d), N.ended ? y(this, R) : (B || x(this, N, b, R)) && (N.pendingcb++, L = A(this, N, B, b, E, R)), L;
  }, v.prototype.cork = function() {
    var b = this._writableState;
    b.corked++;
  }, v.prototype.uncork = function() {
    var b = this._writableState;
    b.corked && (b.corked--, !b.writing && !b.corked && !b.bufferProcessing && b.bufferedRequest && H(this, b));
  }, v.prototype.setDefaultEncoding = function(E) {
    if (typeof E == "string" && (E = E.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((E + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + E);
    return this._writableState.defaultEncoding = E, this;
  };
  function w(b, E, R) {
    return !b.objectMode && b.decodeStrings !== !1 && typeof E == "string" && (E = c.from(E, R)), E;
  }
  Object.defineProperty(v.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function A(b, E, R, N, L, B) {
    if (!R) {
      var K = w(E, N, L);
      N !== K && (R = !0, L = "buffer", N = K);
    }
    var Z = E.objectMode ? 1 : N.length;
    E.length += Z;
    var M = E.length < E.highWaterMark;
    if (M || (E.needDrain = !0), E.writing || E.corked) {
      var le = E.lastBufferedRequest;
      E.lastBufferedRequest = {
        chunk: N,
        encoding: L,
        isBuf: R,
        callback: B,
        next: null
      }, le ? le.next = E.lastBufferedRequest : E.bufferedRequest = E.lastBufferedRequest, E.bufferedRequestCount += 1;
    } else
      O(b, E, !1, Z, N, L, B);
    return M;
  }
  function O(b, E, R, N, L, B, K) {
    E.writelen = N, E.writecb = K, E.writing = !0, E.sync = !0, R ? b._writev(L, E.onwrite) : b._write(L, B, E.onwrite), E.sync = !1;
  }
  function k(b, E, R, N, L) {
    --E.pendingcb, R ? (e.nextTick(L, N), e.nextTick(F, b, E), b._writableState.errorEmitted = !0, b.emit("error", N)) : (L(N), b._writableState.errorEmitted = !0, b.emit("error", N), F(b, E));
  }
  function q(b) {
    b.writing = !1, b.writecb = null, b.length -= b.writelen, b.writelen = 0;
  }
  function W(b, E) {
    var R = b._writableState, N = R.sync, L = R.writecb;
    if (q(R), E) k(b, R, N, E, L);
    else {
      var B = j(R);
      !B && !R.corked && !R.bufferProcessing && R.bufferedRequest && H(b, R), N ? n(te, b, R, B, L) : te(b, R, B, L);
    }
  }
  function te(b, E, R, N) {
    R || T(b, E), E.pendingcb--, N(), F(b, E);
  }
  function T(b, E) {
    E.length === 0 && E.needDrain && (E.needDrain = !1, b.emit("drain"));
  }
<<<<<<< HEAD
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer2 = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
=======
  function H(b, E) {
    E.bufferProcessing = !0;
    var R = E.bufferedRequest;
    if (b._writev && R && R.next) {
      var N = E.bufferedRequestCount, L = new Array(N), B = E.corkedRequestsFree;
      B.entry = R;
      for (var K = 0, Z = !0; R; )
        L[K] = R, R.isBuf || (Z = !1), R = R.next, K += 1;
      L.allBuffers = Z, O(b, E, !0, E.length, L, "", B.finish), E.pendingcb++, E.lastBufferedRequest = null, B.next ? (E.corkedRequestsFree = B.next, B.next = null) : E.corkedRequestsFree = new t(E), E.bufferedRequestCount = 0;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    } else {
      for (; R; ) {
        var M = R.chunk, le = R.encoding, h = R.callback, f = E.objectMode ? 1 : M.length;
        if (O(b, E, !1, f, M, le, h), R = R.next, E.bufferedRequestCount--, E.writing)
          break;
      }
      R === null && (E.lastBufferedRequest = null);
    }
    E.bufferedRequest = R, E.bufferProcessing = !1;
  }
  v.prototype._write = function(b, E, R) {
    R(new Error("_write() is not implemented"));
  }, v.prototype._writev = null, v.prototype.end = function(b, E, R) {
    var N = this._writableState;
    typeof b == "function" ? (R = b, b = null, E = null) : typeof E == "function" && (R = E, E = null), b != null && this.write(b, E), N.corked && (N.corked = 1, this.uncork()), N.ending || $(this, N, R);
  };
  function j(b) {
    return b.ending && b.length === 0 && b.bufferedRequest === null && !b.finished && !b.writing;
  }
  function J(b, E) {
    b._final(function(R) {
      E.pendingcb--, R && b.emit("error", R), E.prefinished = !0, b.emit("prefinish"), F(b, E);
    });
  }
  function ne(b, E) {
    !E.prefinished && !E.finalCalled && (typeof b._final == "function" ? (E.pendingcb++, E.finalCalled = !0, e.nextTick(J, b, E)) : (E.prefinished = !0, b.emit("prefinish")));
  }
  function F(b, E) {
    var R = j(E);
    return R && (ne(b, E), E.pendingcb === 0 && (E.finished = !0, b.emit("finish"))), R;
  }
  function $(b, E, R) {
    E.ending = !0, F(b, E), R && (E.finished ? e.nextTick(R) : b.once("finish", R)), E.ended = !0, b.writable = !1;
  }
  function D(b, E, R) {
    var N = b.entry;
    for (b.entry = null; N; ) {
      var L = N.callback;
      E.pendingcb--, L(R), N = N.next;
    }
    E.corkedRequestsFree.next = b;
  }
  return Object.defineProperty(v.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(b) {
      this._writableState && (this._writableState.destroyed = b);
    }
  }), v.prototype.destroy = p.destroy, v.prototype._undestroy = p.undestroy, v.prototype._destroy = function(b, E) {
    this.end(), E(b);
  }, ac;
}
<<<<<<< HEAD
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key2 in obj) {
      keys2.push(key2);
    }
    return keys2;
=======
var oc, _f;
function Cr() {
  if (_f) return oc;
  _f = 1;
  var e = Bo(), t = Object.keys || function(p) {
    var d = [];
    for (var m in p)
      d.push(m);
    return d;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  };
  oc = s;
  var n = Object.create(Ui());
  n.inherits = Bi();
  var r = C0(), i = R0();
  n.inherits(s, r);
  for (var a = t(i.prototype), o = 0; o < a.length; o++) {
    var c = a[o];
    s.prototype[c] || (s.prototype[c] = i.prototype[c]);
  }
  function s(p) {
    if (!(this instanceof s)) return new s(p);
    r.call(this, p), i.call(this, p), p && p.readable === !1 && (this.readable = !1), p && p.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, p && p.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", u);
  }
  Object.defineProperty(s.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function u() {
    this.allowHalfOpen || this._writableState.ended || e.nextTick(l, this);
  }
  function l(p) {
    p.end();
  }
  return Object.defineProperty(s.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(p) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = p, this._writableState.destroyed = p);
    }
  }), s.prototype._destroy = function(p, d) {
    this.push(null), this.end(), e.nextTick(d, p);
  }, oc;
}
var sc = {}, Sf;
function Tf() {
  if (Sf) return sc;
  Sf = 1;
  var e = jo().Buffer, t = e.isEncoding || function(x) {
    switch (x = "" + x, x && x.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function n(x) {
    if (!x) return "utf8";
    for (var w; ; )
      switch (x) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return x;
        default:
          if (w) return;
          x = ("" + x).toLowerCase(), w = !0;
      }
  }
  function r(x) {
    var w = n(x);
    if (typeof w != "string" && (e.isEncoding === t || !t(x))) throw new Error("Unknown encoding: " + x);
    return w || x;
  }
  sc.StringDecoder = i;
  function i(x) {
    this.encoding = r(x);
    var w;
    switch (this.encoding) {
      case "utf16le":
        this.text = p, this.end = d, w = 4;
        break;
      case "utf8":
        this.fillLast = s, w = 4;
        break;
      case "base64":
        this.text = m, this.end = g, w = 3;
        break;
      default:
        this.write = v, this.end = y;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(w);
  }
  i.prototype.write = function(x) {
    if (x.length === 0) return "";
    var w, A;
    if (this.lastNeed) {
      if (w = this.fillLast(x), w === void 0) return "";
      A = this.lastNeed, this.lastNeed = 0;
    } else
      A = 0;
    return A < x.length ? w ? w + this.text(x, A) : this.text(x, A) : w || "";
  }, i.prototype.end = l, i.prototype.text = u, i.prototype.fillLast = function(x) {
    if (this.lastNeed <= x.length)
      return x.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    x.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, x.length), this.lastNeed -= x.length;
  };
  function a(x) {
    return x <= 127 ? 0 : x >> 5 === 6 ? 2 : x >> 4 === 14 ? 3 : x >> 3 === 30 ? 4 : x >> 6 === 2 ? -1 : -2;
  }
  function o(x, w, A) {
    var O = w.length - 1;
    if (O < A) return 0;
    var k = a(w[O]);
    return k >= 0 ? (k > 0 && (x.lastNeed = k - 1), k) : --O < A || k === -2 ? 0 : (k = a(w[O]), k >= 0 ? (k > 0 && (x.lastNeed = k - 2), k) : --O < A || k === -2 ? 0 : (k = a(w[O]), k >= 0 ? (k > 0 && (k === 2 ? k = 0 : x.lastNeed = k - 3), k) : 0));
  }
  function c(x, w, A) {
    if ((w[0] & 192) !== 128)
      return x.lastNeed = 0, "";
    if (x.lastNeed > 1 && w.length > 1) {
      if ((w[1] & 192) !== 128)
        return x.lastNeed = 1, "";
      if (x.lastNeed > 2 && w.length > 2 && (w[2] & 192) !== 128)
        return x.lastNeed = 2, "";
    }
  }
  function s(x) {
    var w = this.lastTotal - this.lastNeed, A = c(this, x);
    if (A !== void 0) return A;
    if (this.lastNeed <= x.length)
      return x.copy(this.lastChar, w, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    x.copy(this.lastChar, w, 0, x.length), this.lastNeed -= x.length;
  }
  function u(x, w) {
    var A = o(this, x, w);
    if (!this.lastNeed) return x.toString("utf8", w);
    this.lastTotal = A;
    var O = x.length - (A - this.lastNeed);
    return x.copy(this.lastChar, 0, O), x.toString("utf8", w, O);
  }
  function l(x) {
    var w = x && x.length ? this.write(x) : "";
    return this.lastNeed ? w + "" : w;
  }
  function p(x, w) {
    if ((x.length - w) % 2 === 0) {
      var A = x.toString("utf16le", w);
      if (A) {
        var O = A.charCodeAt(A.length - 1);
        if (O >= 55296 && O <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = x[x.length - 2], this.lastChar[1] = x[x.length - 1], A.slice(0, -1);
      }
      return A;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = x[x.length - 1], x.toString("utf16le", w, x.length - 1);
  }
  function d(x) {
    var w = x && x.length ? this.write(x) : "";
    if (this.lastNeed) {
      var A = this.lastTotal - this.lastNeed;
      return w + this.lastChar.toString("utf16le", 0, A);
    }
    return w;
  }
  function m(x, w) {
    var A = (x.length - w) % 3;
    return A === 0 ? x.toString("base64", w) : (this.lastNeed = 3 - A, this.lastTotal = 3, A === 1 ? this.lastChar[0] = x[x.length - 1] : (this.lastChar[0] = x[x.length - 2], this.lastChar[1] = x[x.length - 1]), x.toString("base64", w, x.length - A));
  }
  function g(x) {
    var w = x && x.length ? this.write(x) : "";
    return this.lastNeed ? w + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : w;
  }
  function v(x) {
    return x.toString(this.encoding);
  }
  function y(x) {
    return x && x.length ? this.write(x) : "";
  }
  return sc;
}
<<<<<<< HEAD
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable = Readable2;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$0$6.EventEmitter;
  var EElistenerCount = function(emitter, type2) {
    return emitter.listeners(type2).length;
=======
var cc, Af;
function C0() {
  if (Af) return cc;
  Af = 1;
  var e = Bo();
  cc = w;
  var t = v_(), n;
  w.ReadableState = x, Hn.EventEmitter;
  var r = function(h, f) {
    return h.listeners(f).length;
  }, i = T0(), a = jo().Buffer, o = (typeof Te < "u" ? Te : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  };
  function c(h) {
    return a.from(h);
  }
  function s(h) {
    return a.isBuffer(h) || h instanceof o;
  }
  var u = Object.create(Ui());
  u.inherits = Bi();
  var l = Pe, p = void 0;
  l && l.debuglog ? p = l.debuglog("stream") : p = function() {
  };
<<<<<<< HEAD
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
=======
  var d = x_(), m = A0(), g;
  u.inherits(w, i);
  var v = ["error", "close", "destroy", "pause", "resume"];
  function y(h, f, C) {
    if (typeof h.prependListener == "function") return h.prependListener(f, C);
    !h._events || !h._events[f] ? h.on(f, C) : t(h._events[f]) ? h._events[f].unshift(C) : h._events[f] = [C, h._events[f]];
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  function x(h, f) {
    n = n || Cr(), h = h || {};
    var C = f instanceof n;
    this.objectMode = !!h.objectMode, C && (this.objectMode = this.objectMode || !!h.readableObjectMode);
    var S = h.highWaterMark, G = h.readableHighWaterMark, z = this.objectMode ? 16 : 16 * 1024;
    S || S === 0 ? this.highWaterMark = S : C && (G || G === 0) ? this.highWaterMark = G : this.highWaterMark = z, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new d(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = h.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, h.encoding && (g || (g = Tf().StringDecoder), this.decoder = new g(h.encoding), this.encoding = h.encoding);
  }
<<<<<<< HEAD
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  var debugUtil = require$$1$3;
  var debug2 = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug2 = debugUtil.debuglog("stream");
  } else {
    debug2 = function() {
=======
  function w(h) {
    if (n = n || Cr(), !(this instanceof w)) return new w(h);
    this._readableState = new x(h, this), this.readable = !0, h && (typeof h.read == "function" && (this._read = h.read), typeof h.destroy == "function" && (this._destroy = h.destroy)), i.call(this);
  }
  Object.defineProperty(w.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(h) {
      this._readableState && (this._readableState.destroyed = h);
    }
  }), w.prototype.destroy = m.destroy, w.prototype._undestroy = m.undestroy, w.prototype._destroy = function(h, f) {
    this.push(null), f(h);
  }, w.prototype.push = function(h, f) {
    var C = this._readableState, S;
    return C.objectMode ? S = !0 : typeof h == "string" && (f = f || C.defaultEncoding, f !== C.encoding && (h = a.from(h, f), f = ""), S = !0), A(this, h, f, !1, S);
  }, w.prototype.unshift = function(h) {
    return A(this, h, null, !0, !1);
  };
  function A(h, f, C, S, G) {
    var z = h._readableState;
    if (f === null)
      z.reading = !1, H(h, z);
    else {
      var X;
      G || (X = k(z, f)), X ? h.emit("error", X) : z.objectMode || f && f.length > 0 ? (typeof f != "string" && !z.objectMode && Object.getPrototypeOf(f) !== a.prototype && (f = c(f)), S ? z.endEmitted ? h.emit("error", new Error("stream.unshift() after end event")) : O(h, z, f, !0) : z.ended ? h.emit("error", new Error("stream.push() after EOF")) : (z.reading = !1, z.decoder && !C ? (f = z.decoder.write(f), z.objectMode || f.length !== 0 ? O(h, z, f, !1) : ne(h, z)) : O(h, z, f, !1))) : S || (z.reading = !1);
    }
    return q(z);
  }
  function O(h, f, C, S) {
    f.flowing && f.length === 0 && !f.sync ? (h.emit("data", C), h.read(0)) : (f.length += f.objectMode ? 1 : C.length, S ? f.buffer.unshift(C) : f.buffer.push(C), f.needReadable && j(h)), ne(h, f);
  }
  function k(h, f) {
    var C;
    return !s(f) && typeof f != "string" && f !== void 0 && !h.objectMode && (C = new TypeError("Invalid non-string/buffer chunk")), C;
  }
  function q(h) {
    return !h.ended && (h.needReadable || h.length < h.highWaterMark || h.length === 0);
  }
  w.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, w.prototype.setEncoding = function(h) {
    return g || (g = Tf().StringDecoder), this._readableState.decoder = new g(h), this._readableState.encoding = h, this;
  };
  var W = 8388608;
  function te(h) {
    return h >= W ? h = W : (h--, h |= h >>> 1, h |= h >>> 2, h |= h >>> 4, h |= h >>> 8, h |= h >>> 16, h++), h;
  }
  function T(h, f) {
    return h <= 0 || f.length === 0 && f.ended ? 0 : f.objectMode ? 1 : h !== h ? f.flowing && f.length ? f.buffer.head.data.length : f.length : (h > f.highWaterMark && (f.highWaterMark = te(h)), h <= f.length ? h : f.ended ? f.length : (f.needReadable = !0, 0));
  }
  w.prototype.read = function(h) {
    p("read", h), h = parseInt(h, 10);
    var f = this._readableState, C = h;
    if (h !== 0 && (f.emittedReadable = !1), h === 0 && f.needReadable && (f.length >= f.highWaterMark || f.ended))
      return p("read: emitReadable", f.length, f.ended), f.length === 0 && f.ended ? Z(this) : j(this), null;
    if (h = T(h, f), h === 0 && f.ended)
      return f.length === 0 && Z(this), null;
    var S = f.needReadable;
    p("need readable", S), (f.length === 0 || f.length - h < f.highWaterMark) && (S = !0, p("length less than watermark", S)), f.ended || f.reading ? (S = !1, p("reading or ended", S)) : S && (p("do read"), f.reading = !0, f.sync = !0, f.length === 0 && (f.needReadable = !0), this._read(f.highWaterMark), f.sync = !1, f.reading || (h = T(C, f)));
    var G;
    return h > 0 ? G = N(h, f) : G = null, G === null ? (f.needReadable = !0, h = 0) : f.length -= h, f.length === 0 && (f.ended || (f.needReadable = !0), C !== h && f.ended && Z(this)), G !== null && this.emit("data", G), G;
  };
  function H(h, f) {
    if (!f.ended) {
      if (f.decoder) {
        var C = f.decoder.end();
        C && C.length && (f.buffer.push(C), f.length += f.objectMode ? 1 : C.length);
      }
      f.ended = !0, j(h);
    }
  }
  function j(h) {
    var f = h._readableState;
    f.needReadable = !1, f.emittedReadable || (p("emitReadable", f.flowing), f.emittedReadable = !0, f.sync ? e.nextTick(J, h) : J(h));
  }
  function J(h) {
    p("emit readable"), h.emit("readable"), R(h);
  }
  function ne(h, f) {
    f.readingMore || (f.readingMore = !0, e.nextTick(F, h, f));
  }
  function F(h, f) {
    for (var C = f.length; !f.reading && !f.flowing && !f.ended && f.length < f.highWaterMark && (p("maybeReadMore read 0"), h.read(0), C !== f.length); )
      C = f.length;
    f.readingMore = !1;
  }
  w.prototype._read = function(h) {
    this.emit("error", new Error("_read() is not implemented"));
  }, w.prototype.pipe = function(h, f) {
    var C = this, S = this._readableState;
    switch (S.pipesCount) {
      case 0:
        S.pipes = h;
        break;
      case 1:
        S.pipes = [S.pipes, h];
        break;
      default:
        S.pipes.push(h);
        break;
    }
    S.pipesCount += 1, p("pipe count=%d opts=%j", S.pipesCount, f);
    var G = (!f || f.end !== !1) && h !== process.stdout && h !== process.stderr, z = G ? ve : xn;
    S.endEmitted ? e.nextTick(z) : C.once("end", z), h.on("unpipe", X);
    function X(qt, yn) {
      p("onunpipe"), qt === C && yn && yn.hasUnpiped === !1 && (yn.hasUnpiped = !0, Se());
    }
    function ve() {
      p("onend"), h.end();
    }
    var Ae = $(C);
    h.on("drain", Ae);
    var ct = !1;
    function Se() {
      p("cleanup"), h.removeListener("close", Ot), h.removeListener("finish", Mt), h.removeListener("drain", Ae), h.removeListener("error", jt), h.removeListener("unpipe", X), C.removeListener("end", ve), C.removeListener("end", xn), C.removeListener("data", Jn), ct = !0, S.awaitDrain && (!h._writableState || h._writableState.needDrain) && Ae();
    }
    var qe = !1;
    C.on("data", Jn);
    function Jn(qt) {
      p("ondata"), qe = !1;
      var yn = h.write(qt);
      yn === !1 && !qe && ((S.pipesCount === 1 && S.pipes === h || S.pipesCount > 1 && le(S.pipes, h) !== -1) && !ct && (p("false write response, pause", S.awaitDrain), S.awaitDrain++, qe = !0), C.pause());
    }
    function jt(qt) {
      p("onerror", qt), xn(), h.removeListener("error", jt), r(h, "error") === 0 && h.emit("error", qt);
    }
    y(h, "error", jt);
    function Ot() {
      h.removeListener("finish", Mt), xn();
    }
    h.once("close", Ot);
    function Mt() {
      p("onfinish"), h.removeListener("close", Ot), xn();
    }
    h.once("finish", Mt);
    function xn() {
      p("unpipe"), C.unpipe(h);
    }
    return h.emit("pipe", C), S.flowing || (p("pipe resume"), C.resume()), h;
  };
  function $(h) {
    return function() {
      var f = h._readableState;
      p("pipeOnDrain", f.awaitDrain), f.awaitDrain && f.awaitDrain--, f.awaitDrain === 0 && r(h, "data") && (f.flowing = !0, R(h));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    };
  }
  w.prototype.unpipe = function(h) {
    var f = this._readableState, C = { hasUnpiped: !1 };
    if (f.pipesCount === 0) return this;
    if (f.pipesCount === 1)
      return h && h !== f.pipes ? this : (h || (h = f.pipes), f.pipes = null, f.pipesCount = 0, f.flowing = !1, h && h.emit("unpipe", this, C), this);
    if (!h) {
      var S = f.pipes, G = f.pipesCount;
      f.pipes = null, f.pipesCount = 0, f.flowing = !1;
      for (var z = 0; z < G; z++)
        S[z].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var X = le(f.pipes, h);
    return X === -1 ? this : (f.pipes.splice(X, 1), f.pipesCount -= 1, f.pipesCount === 1 && (f.pipes = f.pipes[0]), h.emit("unpipe", this, C), this);
  }, w.prototype.on = function(h, f) {
    var C = i.prototype.on.call(this, h, f);
    if (h === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (h === "readable") {
      var S = this._readableState;
      !S.endEmitted && !S.readableListening && (S.readableListening = S.needReadable = !0, S.emittedReadable = !1, S.reading ? S.length && j(this) : e.nextTick(D, this));
    }
    return C;
  }, w.prototype.addListener = w.prototype.on;
  function D(h) {
    p("readable nexttick read 0"), h.read(0);
  }
  w.prototype.resume = function() {
    var h = this._readableState;
    return h.flowing || (p("resume"), h.flowing = !0, b(this, h)), this;
  };
  function b(h, f) {
    f.resumeScheduled || (f.resumeScheduled = !0, e.nextTick(E, h, f));
  }
  function E(h, f) {
    f.reading || (p("resume read 0"), h.read(0)), f.resumeScheduled = !1, f.awaitDrain = 0, h.emit("resume"), R(h), f.flowing && !f.reading && h.read(0);
  }
  w.prototype.pause = function() {
    return p("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (p("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function R(h) {
    var f = h._readableState;
    for (p("flow", f.flowing); f.flowing && h.read() !== null; )
      ;
  }
  w.prototype.wrap = function(h) {
    var f = this, C = this._readableState, S = !1;
    h.on("end", function() {
      if (p("wrapped end"), C.decoder && !C.ended) {
        var X = C.decoder.end();
        X && X.length && f.push(X);
      }
      f.push(null);
    }), h.on("data", function(X) {
      if (p("wrapped data"), C.decoder && (X = C.decoder.write(X)), !(C.objectMode && X == null) && !(!C.objectMode && (!X || !X.length))) {
        var ve = f.push(X);
        ve || (S = !0, h.pause());
      }
    });
    for (var G in h)
      this[G] === void 0 && typeof h[G] == "function" && (this[G] = /* @__PURE__ */ function(X) {
        return function() {
          return h[X].apply(h, arguments);
        };
      }(G));
    for (var z = 0; z < v.length; z++)
      h.on(v[z], this.emit.bind(this, v[z]));
    return this._read = function(X) {
      p("wrapped _read", X), S && (S = !1, h.resume());
    }, this;
  }, Object.defineProperty(w.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), w._fromList = N;
  function N(h, f) {
    if (f.length === 0) return null;
    var C;
    return f.objectMode ? C = f.buffer.shift() : !h || h >= f.length ? (f.decoder ? C = f.buffer.join("") : f.buffer.length === 1 ? C = f.buffer.head.data : C = f.buffer.concat(f.length), f.buffer.clear()) : C = L(h, f.buffer, f.decoder), C;
  }
  function L(h, f, C) {
    var S;
    return h < f.head.data.length ? (S = f.head.data.slice(0, h), f.head.data = f.head.data.slice(h)) : h === f.head.data.length ? S = f.shift() : S = C ? B(h, f) : K(h, f), S;
  }
  function B(h, f) {
    var C = f.head, S = 1, G = C.data;
    for (h -= G.length; C = C.next; ) {
      var z = C.data, X = h > z.length ? z.length : h;
      if (X === z.length ? G += z : G += z.slice(0, h), h -= X, h === 0) {
        X === z.length ? (++S, C.next ? f.head = C.next : f.head = f.tail = null) : (f.head = C, C.data = z.slice(X));
        break;
      }
      ++S;
    }
    return f.length -= S, G;
  }
  function K(h, f) {
    var C = a.allocUnsafe(h), S = f.head, G = 1;
    for (S.data.copy(C), h -= S.data.length; S = S.next; ) {
      var z = S.data, X = h > z.length ? z.length : h;
      if (z.copy(C, C.length - h, 0, X), h -= X, h === 0) {
        X === z.length ? (++G, S.next ? f.head = S.next : f.head = f.tail = null) : (f.head = S, S.data = z.slice(X));
        break;
      }
      ++G;
    }
    return f.length -= G, C;
  }
  function Z(h) {
    var f = h._readableState;
    if (f.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    f.endEmitted || (f.ended = !0, e.nextTick(M, f, h));
  }
  function M(h, f) {
    !h.endEmitted && h.length === 0 && (h.endEmitted = !0, f.readable = !1, f.emit("end"));
  }
  function le(h, f) {
    for (var C = 0, S = h.length; C < S; C++)
      if (h[C] === f) return C;
    return -1;
  }
  return cc;
}
var lc, Rf;
function O0() {
  if (Rf) return lc;
  Rf = 1, lc = r;
  var e = Cr(), t = Object.create(Ui());
  t.inherits = Bi(), t.inherits(r, e);
  function n(o, c) {
    var s = this._transformState;
    s.transforming = !1;
    var u = s.writecb;
    if (!u)
      return this.emit("error", new Error("write callback called multiple times"));
    s.writechunk = null, s.writecb = null, c != null && this.push(c), u(o);
    var l = this._readableState;
    l.reading = !1, (l.needReadable || l.length < l.highWaterMark) && this._read(l.highWaterMark);
  }
  function r(o) {
    if (!(this instanceof r)) return new r(o);
    e.call(this, o), this._transformState = {
      afterTransform: n.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, o && (typeof o.transform == "function" && (this._transform = o.transform), typeof o.flush == "function" && (this._flush = o.flush)), this.on("prefinish", i);
  }
  function i() {
    var o = this;
    typeof this._flush == "function" ? this._flush(function(c, s) {
      a(o, c, s);
    }) : a(this, null, null);
  }
  r.prototype.push = function(o, c) {
    return this._transformState.needTransform = !1, e.prototype.push.call(this, o, c);
  }, r.prototype._transform = function(o, c, s) {
    throw new Error("_transform() is not implemented");
  }, r.prototype._write = function(o, c, s) {
    var u = this._transformState;
    if (u.writecb = s, u.writechunk = o, u.writeencoding = c, !u.transforming) {
      var l = this._readableState;
      (u.needTransform || l.needReadable || l.length < l.highWaterMark) && this._read(l.highWaterMark);
    }
  }, r.prototype._read = function(o) {
    var c = this._transformState;
    c.writechunk !== null && c.writecb && !c.transforming ? (c.transforming = !0, this._transform(c.writechunk, c.writeencoding, c.afterTransform)) : c.needTransform = !0;
  }, r.prototype._destroy = function(o, c) {
    var s = this;
    e.prototype._destroy.call(this, o, function(u) {
      c(u), s.emit("close");
    });
  };
  function a(o, c, s) {
    if (c) return o.emit("error", c);
    if (s != null && o.push(s), o._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (o._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return o.push(null);
  }
  return lc;
}
<<<<<<< HEAD
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough2;
  var Transform2 = require_stream_transform();
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough2, Transform2);
  function PassThrough2(options) {
    if (!(this instanceof PassThrough2)) return new PassThrough2(options);
    Transform2.call(this, options);
=======
var uc, Cf;
function b_() {
  if (Cf) return uc;
  Cf = 1, uc = n;
  var e = O0(), t = Object.create(Ui());
  t.inherits = Bi(), t.inherits(n, e);
  function n(r) {
    if (!(this instanceof n)) return new n(r);
    e.call(this, r);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return n.prototype._transform = function(r, i, a) {
    a(null, r);
  }, uc;
}
<<<<<<< HEAD
(function(module, exports) {
  var Stream2 = require$$1$2;
  if (process.env.READABLE_STREAM === "disable" && Stream2) {
    module.exports = Stream2;
    exports = module.exports = Stream2.Readable;
    exports.Readable = Stream2.Readable;
    exports.Writable = Stream2.Writable;
    exports.Duplex = Stream2.Duplex;
    exports.Transform = Stream2.Transform;
    exports.PassThrough = Stream2.PassThrough;
    exports.Stream = Stream2;
  } else {
    exports = module.exports = require_stream_readable();
    exports.Stream = Stream2 || exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
  }
})(readable, readable.exports);
var readableExports = readable.exports;
var duplex = readableExports.Duplex;
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module, exports) {
  var buffer2 = require$$0$5;
  var Buffer2 = buffer2.Buffer;
  function copyProps(src2, dst) {
    for (var key2 in src2) {
      dst[key2] = src2[key2];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer2;
  } else {
    copyProps(buffer2, exports);
    exports.Buffer = SafeBuffer;
=======
(function(e, t) {
  var n = ie;
  process.env.READABLE_STREAM === "disable" && n ? (e.exports = n, t = e.exports = n.Readable, t.Readable = n.Readable, t.Writable = n.Writable, t.Duplex = n.Duplex, t.Transform = n.Transform, t.PassThrough = n.PassThrough, t.Stream = n) : (t = e.exports = C0(), t.Stream = n || t, t.Readable = t, t.Writable = R0(), t.Duplex = Cr(), t.Transform = O0(), t.PassThrough = b_());
})(hl, hl.exports);
var ji = hl.exports, w_ = ji.Duplex, ml = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
  var n = Nt, r = n.Buffer;
  function i(o, c) {
    for (var s in o)
      c[s] = o[s];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? e.exports = n : (i(n, t), t.Buffer = a);
  function a(o, c, s) {
    return r(o, c, s);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  a.prototype = Object.create(r.prototype), i(r, a), a.from = function(o, c, s) {
    if (typeof o == "number")
      throw new TypeError("Argument must not be a number");
<<<<<<< HEAD
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill2, encoding) {
    if (typeof size !== "number") {
=======
    return r(o, c, s);
  }, a.alloc = function(o, c, s) {
    if (typeof o != "number")
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      throw new TypeError("Argument must be a number");
    var u = r(o);
    return c !== void 0 ? typeof s == "string" ? u.fill(c, s) : u.fill(c) : u.fill(0), u;
  }, a.allocUnsafe = function(o) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    return r(o);
  }, a.allocUnsafeSlow = function(o) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
<<<<<<< HEAD
    }
    return buffer2.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports;
var DuplexStream = duplex, util$8 = require$$1$3, Buffer$3 = safeBufferExports.Buffer;
function BufferList(callback) {
  if (!(this instanceof BufferList))
    return new BufferList(callback);
  this._bufs = [];
  this.length = 0;
  if (typeof callback == "function") {
    this._callback = callback;
    var piper = (function piper2(err) {
      if (this._callback) {
        this._callback(err);
        this._callback = null;
      }
=======
    return n.SlowBuffer(o);
  };
})(ml, ml.exports);
var $0 = ml.exports, su = w_, E_ = Pe, hr = $0.Buffer;
function _e(e) {
  if (!(this instanceof _e))
    return new _e(e);
  if (this._bufs = [], this.length = 0, typeof e == "function") {
    this._callback = e;
    var t = (function(r) {
      this._callback && (this._callback(r), this._callback = null);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }).bind(this);
    this.on("pipe", function(r) {
      r.on("error", t);
    }), this.on("unpipe", function(r) {
      r.removeListener("error", t);
    });
  } else
    this.append(e);
  su.call(this);
}
<<<<<<< HEAD
util$8.inherits(BufferList, DuplexStream);
BufferList.prototype._offset = function _offset(offset) {
  var tot = 0, i = 0, _t;
  if (offset === 0) return [0, 0];
  for (; i < this._bufs.length; i++) {
    _t = tot + this._bufs[i].length;
    if (offset < _t || i == this._bufs.length - 1)
      return [i, offset - tot];
    tot = _t;
  }
};
BufferList.prototype.append = function append2(buf) {
  var i = 0;
  if (Buffer$3.isBuffer(buf)) {
    this._appendBuffer(buf);
  } else if (Array.isArray(buf)) {
    for (; i < buf.length; i++)
      this.append(buf[i]);
  } else if (buf instanceof BufferList) {
    for (; i < buf._bufs.length; i++)
      this.append(buf._bufs[i]);
  } else if (buf != null) {
    if (typeof buf == "number")
      buf = buf.toString();
    this._appendBuffer(Buffer$3.from(buf));
  }
=======
E_.inherits(_e, su);
_e.prototype._offset = function(t) {
  var n = 0, r = 0, i;
  if (t === 0) return [0, 0];
  for (; r < this._bufs.length; r++) {
    if (i = n + this._bufs[r].length, t < i || r == this._bufs.length - 1)
      return [r, t - n];
    n = i;
  }
};
_e.prototype.append = function(t) {
  var n = 0;
  if (hr.isBuffer(t))
    this._appendBuffer(t);
  else if (Array.isArray(t))
    for (; n < t.length; n++)
      this.append(t[n]);
  else if (t instanceof _e)
    for (; n < t._bufs.length; n++)
      this.append(t._bufs[n]);
  else t != null && (typeof t == "number" && (t = t.toString()), this._appendBuffer(hr.from(t)));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  return this;
};
_e.prototype._appendBuffer = function(t) {
  this._bufs.push(t), this.length += t.length;
};
_e.prototype._write = function(t, n, r) {
  this._appendBuffer(t), typeof r == "function" && r();
};
_e.prototype._read = function(t) {
  if (!this.length)
    return this.push(null);
  t = Math.min(t, this.length), this.push(this.slice(0, t)), this.consume(t);
};
_e.prototype.end = function(t) {
  su.prototype.end.call(this, t), this._callback && (this._callback(null, this.slice()), this._callback = null);
};
_e.prototype.get = function(t) {
  return this.slice(t, t + 1)[0];
};
_e.prototype.slice = function(t, n) {
  return typeof t == "number" && t < 0 && (t += this.length), typeof n == "number" && n < 0 && (n += this.length), this.copy(null, 0, t, n);
};
_e.prototype.copy = function(t, n, r, i) {
  if ((typeof r != "number" || r < 0) && (r = 0), (typeof i != "number" || i > this.length) && (i = this.length), r >= this.length || i <= 0)
    return t || hr.alloc(0);
  var a = !!t, o = this._offset(r), c = i - r, s = c, u = a && n || 0, l = o[1], p, d;
  if (r === 0 && i == this.length) {
    if (!a)
      return this._bufs.length === 1 ? this._bufs[0] : hr.concat(this._bufs, this.length);
    for (d = 0; d < this._bufs.length; d++)
      this._bufs[d].copy(t, u), u += this._bufs[d].length;
    return t;
  }
<<<<<<< HEAD
};
BufferList.prototype.get = function get2(index) {
  return this.slice(index, index + 1)[0];
};
BufferList.prototype.slice = function slice(start, end2) {
  if (typeof start == "number" && start < 0)
    start += this.length;
  if (typeof end2 == "number" && end2 < 0)
    end2 += this.length;
  return this.copy(null, 0, start, end2);
};
BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
  if (typeof srcStart != "number" || srcStart < 0)
    srcStart = 0;
  if (typeof srcEnd != "number" || srcEnd > this.length)
    srcEnd = this.length;
  if (srcStart >= this.length)
    return dst || Buffer$3.alloc(0);
  if (srcEnd <= 0)
    return dst || Buffer$3.alloc(0);
  var copy3 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy3 && dstStart || 0, start = off[1], l, i;
  if (srcStart === 0 && srcEnd == this.length) {
    if (!copy3) {
      return this._bufs.length === 1 ? this._bufs[0] : Buffer$3.concat(this._bufs, this.length);
    }
    for (i = 0; i < this._bufs.length; i++) {
      this._bufs[i].copy(dst, bufoff);
      bufoff += this._bufs[i].length;
    }
    return dst;
  }
  if (bytes <= this._bufs[off[0]].length - start) {
    return copy3 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
  }
  if (!copy3)
    dst = Buffer$3.allocUnsafe(len);
  for (i = off[0]; i < this._bufs.length; i++) {
    l = this._bufs[i].length - start;
    if (bytes > l) {
      this._bufs[i].copy(dst, bufoff, start);
      bufoff += l;
    } else {
      this._bufs[i].copy(dst, bufoff, start, start + bytes);
      bufoff += l;
=======
  if (s <= this._bufs[o[0]].length - l)
    return a ? this._bufs[o[0]].copy(t, n, l, l + s) : this._bufs[o[0]].slice(l, l + s);
  for (a || (t = hr.allocUnsafe(c)), d = o[0]; d < this._bufs.length; d++) {
    if (p = this._bufs[d].length - l, s > p)
      this._bufs[d].copy(t, u, l), u += p;
    else {
      this._bufs[d].copy(t, u, l, l + s), u += p;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      break;
    }
    s -= p, l && (l = 0);
  }
  return t.length > u ? t.slice(0, u) : t;
};
_e.prototype.shallowSlice = function(t, n) {
  t = t || 0, n = n || this.length, t < 0 && (t += this.length), n < 0 && (n += this.length);
  var r = this._offset(t), i = this._offset(n), a = this._bufs.slice(r[0], i[0] + 1);
  return i[1] == 0 ? a.pop() : a[a.length - 1] = a[a.length - 1].slice(0, i[1]), r[1] != 0 && (a[0] = a[0].slice(r[1])), new _e(a);
};
_e.prototype.toString = function(t, n, r) {
  return this.slice(n, r).toString(t);
};
_e.prototype.consume = function(t) {
  if (t = Math.trunc(t), Number.isNaN(t) || t <= 0) return this;
  for (; this._bufs.length; )
    if (t >= this._bufs[0].length)
      t -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
    else {
      this._bufs[0] = this._bufs[0].slice(t), this.length -= t;
      break;
    }
  return this;
};
_e.prototype.duplicate = function() {
  for (var t = 0, n = new _e(); t < this._bufs.length; t++)
    n.append(this._bufs[t]);
  return n;
};
_e.prototype.destroy = function() {
  this._bufs.length = 0, this.length = 0, this.push(null);
};
(function() {
  var e = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1
  };
  for (var t in e)
    (function(n) {
      _e.prototype[n] = function(r) {
        return this.slice(r, r + e[n])[n](0);
      };
    })(t);
})();
<<<<<<< HEAD
var bl$1 = BufferList;
var immutable = extend$1;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function extend$1() {
  var target = {};
  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key2 in source) {
      if (hasOwnProperty.call(source, key2)) {
        target[key2] = source[key2];
      }
    }
  }
  return target;
}
var headers$2 = {};
var toString$1 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$1.call(arr) == "[object Array]";
};
var Buffer$2 = safeBufferExports.Buffer;
var isArray = isarray;
var useUint8Array = typeof Uint8Array !== "undefined";
var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && ArrayBuffer.isView && (Buffer$2.prototype instanceof Uint8Array || Buffer$2.TYPED_ARRAY_SUPPORT);
var toBuffer$2 = function toBuffer(data, encoding) {
  if (data instanceof Buffer$2) {
    return data;
  }
  if (typeof data === "string") {
    return Buffer$2.from(data, encoding);
  }
  if (useArrayBuffer && ArrayBuffer.isView(data)) {
    if (data.byteLength === 0) {
      return Buffer$2.alloc(0);
    }
    var res = Buffer$2.from(data.buffer, data.byteOffset, data.byteLength);
    if (res.byteLength === data.byteLength) {
      return res;
    }
  }
  if (useUint8Array && data instanceof Uint8Array) {
    return Buffer$2.from(data);
  }
  var isArr = isArray(data);
  if (isArr) {
    for (var i = 0; i < data.length; i += 1) {
      var x = data[i];
      if (typeof x !== "number" || x < 0 || x > 255 || ~~x !== x) {
        throw new RangeError("Array items must be numbers in the range 0-255.");
      }
    }
  }
  if (isArr || Buffer$2.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data)) {
    return Buffer$2.from(data);
  }
  throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a TypedArray, or a DataView.');
};
var hasFullSupport = function() {
=======
var __ = _e, S_ = A_, T_ = Object.prototype.hasOwnProperty;
function A_() {
  for (var e = {}, t = 0; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      T_.call(n, r) && (e[r] = n[r]);
  }
  return e;
}
var Wn = {}, R_ = {}.toString, C_ = Array.isArray || function(e) {
  return R_.call(e) == "[object Array]";
}, Dt = $0.Buffer, O_ = C_, $_ = typeof Uint8Array < "u", I_ = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (Dt.prototype instanceof Uint8Array || Dt.TYPED_ARRAY_SUPPORT), I0 = function(t, n) {
  if (t instanceof Dt)
    return t;
  if (typeof t == "string")
    return Dt.from(t, n);
  if (I_ && ArrayBuffer.isView(t)) {
    if (t.byteLength === 0)
      return Dt.alloc(0);
    var r = Dt.from(t.buffer, t.byteOffset, t.byteLength);
    if (r.byteLength === t.byteLength)
      return r;
  }
  if ($_ && t instanceof Uint8Array)
    return Dt.from(t);
  var i = O_(t);
  if (i)
    for (var a = 0; a < t.length; a += 1) {
      var o = t[a];
      if (typeof o != "number" || o < 0 || o > 255 || ~~o !== o)
        throw new RangeError("Array items must be numbers in the range 0-255.");
    }
  if (i || Dt.isBuffer(t) && t.constructor && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t))
    return Dt.from(t);
  throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a TypedArray, or a DataView.');
}, P_ = function() {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    if (!Buffer.isEncoding("latin1"))
      return !1;
    var e = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
    return e.fill("ab", "ucs2"), e.toString("hex") === "61006200";
  } catch {
    return !1;
  }
}();
<<<<<<< HEAD
function isSingleByte(val) {
  return val.length === 1 && val.charCodeAt(0) < 256;
}
function fillWithNumber(buffer2, val, start, end2) {
  if (start < 0 || end2 > buffer2.length) {
    throw new RangeError("Out of range index");
  }
  start = start >>> 0;
  end2 = end2 === void 0 ? buffer2.length : end2 >>> 0;
  if (end2 > start) {
    buffer2.fill(val, start, end2);
  }
  return buffer2;
}
function fillWithBuffer(buffer2, val, start, end2) {
  if (start < 0 || end2 > buffer2.length) {
    throw new RangeError("Out of range index");
  }
  if (end2 <= start) {
    return buffer2;
  }
  start = start >>> 0;
  end2 = end2 === void 0 ? buffer2.length : end2 >>> 0;
  var pos = start;
  var len = val.length;
  while (pos <= end2 - len) {
    val.copy(buffer2, pos);
    pos += len;
  }
  if (pos !== end2) {
    val.copy(buffer2, pos, 0, end2 - pos);
  }
  return buffer2;
}
function fill(buffer2, val, start, end2, encoding) {
  if (hasFullSupport) {
    return buffer2.fill(val, start, end2, encoding);
  }
  if (typeof val === "number") {
    return fillWithNumber(buffer2, val, start, end2);
  }
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end2 = buffer2.length;
    } else if (typeof end2 === "string") {
      encoding = end2;
      end2 = buffer2.length;
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (encoding === "latin1") {
      encoding = "binary";
    }
    if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    if (val === "") {
      return fillWithNumber(buffer2, 0, start, end2);
    }
    if (isSingleByte(val)) {
      return fillWithNumber(buffer2, val.charCodeAt(0), start, end2);
    }
    val = new Buffer(val, encoding);
  }
  if (Buffer.isBuffer(val)) {
    return fillWithBuffer(buffer2, val, start, end2);
  }
  return fillWithNumber(buffer2, 0, start, end2);
}
var bufferFill$1 = fill;
function allocUnsafe$1(size) {
  if (typeof size !== "number") {
=======
function D_(e) {
  return e.length === 1 && e.charCodeAt(0) < 256;
}
function xa(e, t, n, r) {
  if (n < 0 || r > e.length)
    throw new RangeError("Out of range index");
  return n = n >>> 0, r = r === void 0 ? e.length : r >>> 0, r > n && e.fill(t, n, r), e;
}
function F_(e, t, n, r) {
  if (n < 0 || r > e.length)
    throw new RangeError("Out of range index");
  if (r <= n)
    return e;
  n = n >>> 0, r = r === void 0 ? e.length : r >>> 0;
  for (var i = n, a = t.length; i <= r - a; )
    t.copy(e, i), i += a;
  return i !== r && t.copy(e, i, 0, r - i), e;
}
function N_(e, t, n, r, i) {
  if (P_)
    return e.fill(t, n, r, i);
  if (typeof t == "number")
    return xa(e, t, n, r);
  if (typeof t == "string") {
    if (typeof n == "string" ? (i = n, n = 0, r = e.length) : typeof r == "string" && (i = r, r = e.length), i !== void 0 && typeof i != "string")
      throw new TypeError("encoding must be a string");
    if (i === "latin1" && (i = "binary"), typeof i == "string" && !Buffer.isEncoding(i))
      throw new TypeError("Unknown encoding: " + i);
    if (t === "")
      return xa(e, 0, n, r);
    if (D_(t))
      return xa(e, t.charCodeAt(0), n, r);
    t = new Buffer(t, i);
  }
  return Buffer.isBuffer(t) ? F_(e, t, n, r) : xa(e, 0, n, r);
}
var k_ = N_;
function L_(e) {
  if (typeof e != "number")
    throw new TypeError('"size" argument must be a number');
  if (e < 0)
    throw new RangeError('"size" argument must not be negative');
  return Buffer.allocUnsafe ? Buffer.allocUnsafe(e) : new Buffer(e);
}
var U_ = L_, Of = k_, B_ = U_, P0 = function(t, n, r) {
  if (typeof t != "number")
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    throw new TypeError('"size" argument must be a number');
  if (t < 0)
    throw new RangeError('"size" argument must not be negative');
<<<<<<< HEAD
  }
  if (Buffer.allocUnsafe) {
    return Buffer.allocUnsafe(size);
  } else {
    return new Buffer(size);
  }
}
var bufferAllocUnsafe = allocUnsafe$1;
var bufferFill = bufferFill$1;
var allocUnsafe = bufferAllocUnsafe;
var bufferAlloc = function alloc(size, fill2, encoding) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  }
  if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
  if (Buffer.alloc) {
    return Buffer.alloc(size, fill2, encoding);
  }
  var buffer2 = allocUnsafe(size);
  if (size === 0) {
    return buffer2;
  }
  if (fill2 === void 0) {
    return bufferFill(buffer2, 0);
  }
  if (typeof encoding !== "string") {
    encoding = void 0;
  }
  return bufferFill(buffer2, fill2, encoding);
};
var toBuffer$1 = toBuffer$2;
var alloc$1 = bufferAlloc;
var ZEROS = "0000000000000000000";
var SEVENS = "7777777777777777777";
var ZERO_OFFSET = "0".charCodeAt(0);
var USTAR = "ustar\x0000";
var MASK = parseInt("7777", 8);
var clamp = function(index, len, defaultValue) {
  if (typeof index !== "number") return defaultValue;
  index = ~~index;
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
};
var toType = function(flag) {
  switch (flag) {
=======
  if (Buffer.alloc)
    return Buffer.alloc(t, n, r);
  var i = B_(t);
  return t === 0 ? i : n === void 0 ? Of(i, 0) : (typeof r != "string" && (r = void 0), Of(i, n, r));
}, j_ = I0, M_ = P0, q_ = "0000000000000000000", z_ = "7777777777777777777", D0 = 48, H_ = "ustar\x0000", G_ = parseInt("7777", 8), W_ = function(e, t, n) {
  return typeof e != "number" ? n : (e = ~~e, e >= t ? t : e >= 0 || (e += t, e >= 0) ? e : 0);
}, V_ = function(e) {
  switch (e) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    case 0:
      return "file";
    case 1:
      return "link";
    case 2:
      return "symlink";
    case 3:
      return "character-device";
    case 4:
      return "block-device";
    case 5:
      return "directory";
    case 6:
      return "fifo";
    case 7:
      return "contiguous-file";
    case 72:
      return "pax-header";
    case 55:
      return "pax-global-header";
    case 27:
      return "gnu-long-link-path";
    case 28:
    case 30:
      return "gnu-long-path";
  }
  return null;
<<<<<<< HEAD
};
var toTypeflag = function(flag) {
  switch (flag) {
=======
}, Y_ = function(e) {
  switch (e) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    case "file":
      return 0;
    case "link":
      return 1;
    case "symlink":
      return 2;
    case "character-device":
      return 3;
    case "block-device":
      return 4;
    case "directory":
      return 5;
    case "fifo":
      return 6;
    case "contiguous-file":
      return 7;
    case "pax-header":
      return 72;
  }
  return 0;
<<<<<<< HEAD
};
var indexOf = function(block, num, offset, end2) {
  for (; offset < end2; offset++) {
    if (block[offset] === num) return offset;
  }
  return end2;
};
var cksum = function(block) {
  var sum = 8 * 32;
  for (var i = 0; i < 148; i++) sum += block[i];
  for (var j = 156; j < 512; j++) sum += block[j];
  return sum;
};
var encodeOct = function(val, n) {
  val = val.toString(8);
  if (val.length > n) return SEVENS.slice(0, n) + " ";
  else return ZEROS.slice(0, n - val.length) + val + " ";
};
function parse256(buf) {
  var positive;
  if (buf[0] === 128) positive = true;
  else if (buf[0] === 255) positive = false;
=======
}, F0 = function(e, t, n, r) {
  for (; n < r; n++)
    if (e[n] === t) return n;
  return r;
}, N0 = function(e) {
  for (var t = 256, n = 0; n < 148; n++) t += e[n];
  for (var r = 156; r < 512; r++) t += e[r];
  return t;
}, Wt = function(e, t) {
  return e = e.toString(8), e.length > t ? z_.slice(0, t) + " " : q_.slice(0, t - e.length) + e + " ";
};
function X_(e) {
  var t;
  if (e[0] === 128) t = !0;
  else if (e[0] === 255) t = !1;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  else return null;
  for (var n = [], r = e.length - 1; r > 0; r--) {
    var i = e[r];
    t ? n.push(i) : n.push(255 - i);
  }
  var a = 0, o = n.length;
  for (r = 0; r < o; r++)
    a += n[r] * Math.pow(256, r);
  return t ? a : -1 * a;
}
<<<<<<< HEAD
var decodeOct = function(val, offset, length) {
  val = val.slice(offset, offset + length);
  offset = 0;
  if (val[offset] & 128) {
    return parse256(val);
  } else {
    while (offset < val.length && val[offset] === 32) offset++;
    var end2 = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
    while (offset < end2 && val[offset] === 0) offset++;
    if (end2 === offset) return 0;
    return parseInt(val.slice(offset, end2).toString(), 8);
=======
var Vt = function(e, t, n) {
  if (e = e.slice(t, t + n), t = 0, e[t] & 128)
    return X_(e);
  for (; t < e.length && e[t] === 32; ) t++;
  for (var r = W_(F0(e, 32, t, e.length), e.length, e.length); t < r && e[t] === 0; ) t++;
  return r === t ? 0 : parseInt(e.slice(t, r).toString(), 8);
}, ur = function(e, t, n, r) {
  return e.slice(t, F0(e, 0, t, t + n)).toString(r);
}, pc = function(e) {
  var t = Buffer.byteLength(e), n = Math.floor(Math.log(t) / Math.log(10)) + 1;
  return t + n >= Math.pow(10, n) && n++, t + n + e;
};
Wn.decodeLongPath = function(e, t) {
  return ur(e, 0, e.length, t);
};
Wn.encodePax = function(e) {
  var t = "";
  e.name && (t += pc(" path=" + e.name + `
`)), e.linkname && (t += pc(" linkpath=" + e.linkname + `
`));
  var n = e.pax;
  if (n)
    for (var r in n)
      t += pc(" " + r + "=" + n[r] + `
`);
  return j_(t);
};
Wn.decodePax = function(e) {
  for (var t = {}; e.length; ) {
    for (var n = 0; n < e.length && e[n] !== 32; ) n++;
    var r = parseInt(e.slice(0, n).toString(), 10);
    if (!r) return t;
    var i = e.slice(n + 1, r - 1).toString(), a = i.indexOf("=");
    if (a === -1) return t;
    t[i.slice(0, a)] = i.slice(a + 1), e = e.slice(r);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return t;
};
<<<<<<< HEAD
var decodeStr = function(val, offset, length, encoding) {
  return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
};
var addLength = function(str2) {
  var len = Buffer.byteLength(str2);
  var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
  if (len + digits >= Math.pow(10, digits)) digits++;
  return len + digits + str2;
};
headers$2.decodeLongPath = function(buf, encoding) {
  return decodeStr(buf, 0, buf.length, encoding);
};
headers$2.encodePax = function(opts) {
  var result = "";
  if (opts.name) result += addLength(" path=" + opts.name + "\n");
  if (opts.linkname) result += addLength(" linkpath=" + opts.linkname + "\n");
  var pax = opts.pax;
  if (pax) {
    for (var key2 in pax) {
      result += addLength(" " + key2 + "=" + pax[key2] + "\n");
    }
  }
  return toBuffer$1(result);
};
headers$2.decodePax = function(buf) {
  var result = {};
  while (buf.length) {
    var i = 0;
    while (i < buf.length && buf[i] !== 32) i++;
    var len = parseInt(buf.slice(0, i).toString(), 10);
    if (!len) return result;
    var b = buf.slice(i + 1, len - 1).toString();
    var keyIndex = b.indexOf("=");
    if (keyIndex === -1) return result;
    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
    buf = buf.slice(len);
  }
  return result;
};
headers$2.encode = function(opts) {
  var buf = alloc$1(512);
  var name = opts.name;
  var prefix = "";
  if (opts.typeflag === 5 && name[name.length - 1] !== "/") name += "/";
  if (Buffer.byteLength(name) !== name.length) return null;
  while (Buffer.byteLength(name) > 100) {
    var i = name.indexOf("/");
=======
Wn.encode = function(e) {
  var t = M_(512), n = e.name, r = "";
  if (e.typeflag === 5 && n[n.length - 1] !== "/" && (n += "/"), Buffer.byteLength(n) !== n.length) return null;
  for (; Buffer.byteLength(n) > 100; ) {
    var i = n.indexOf("/");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    if (i === -1) return null;
    r += r ? "/" + n.slice(0, i) : n.slice(0, i), n = n.slice(i + 1);
  }
<<<<<<< HEAD
  if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null;
  if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null;
  buf.write(name);
  buf.write(encodeOct(opts.mode & MASK, 6), 100);
  buf.write(encodeOct(opts.uid, 6), 108);
  buf.write(encodeOct(opts.gid, 6), 116);
  buf.write(encodeOct(opts.size, 11), 124);
  buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
  buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
  if (opts.linkname) buf.write(opts.linkname, 157);
  buf.write(USTAR, 257);
  if (opts.uname) buf.write(opts.uname, 265);
  if (opts.gname) buf.write(opts.gname, 297);
  buf.write(encodeOct(opts.devmajor || 0, 6), 329);
  buf.write(encodeOct(opts.devminor || 0, 6), 337);
  if (prefix) buf.write(prefix, 345);
  buf.write(encodeOct(cksum(buf), 6), 148);
  return buf;
};
headers$2.decode = function(buf, filenameEncoding) {
  var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
  var name = decodeStr(buf, 0, 100, filenameEncoding);
  var mode = decodeOct(buf, 100, 8);
  var uid = decodeOct(buf, 108, 8);
  var gid = decodeOct(buf, 116, 8);
  var size = decodeOct(buf, 124, 12);
  var mtime = decodeOct(buf, 136, 12);
  var type2 = toType(typeflag);
  var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
  var uname = decodeStr(buf, 265, 32);
  var gname = decodeStr(buf, 297, 32);
  var devmajor = decodeOct(buf, 329, 8);
  var devminor = decodeOct(buf, 337, 8);
  if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
  if (typeflag === 0 && name && name[name.length - 1] === "/") typeflag = 5;
  var c = cksum(buf);
  if (c === 8 * 32) return null;
  if (c !== decodeOct(buf, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
=======
  return Buffer.byteLength(n) > 100 || Buffer.byteLength(r) > 155 || e.linkname && Buffer.byteLength(e.linkname) > 100 ? null : (t.write(n), t.write(Wt(e.mode & G_, 6), 100), t.write(Wt(e.uid, 6), 108), t.write(Wt(e.gid, 6), 116), t.write(Wt(e.size, 11), 124), t.write(Wt(e.mtime.getTime() / 1e3 | 0, 11), 136), t[156] = D0 + Y_(e.type), e.linkname && t.write(e.linkname, 157), t.write(H_, 257), e.uname && t.write(e.uname, 265), e.gname && t.write(e.gname, 297), t.write(Wt(e.devmajor || 0, 6), 329), t.write(Wt(e.devminor || 0, 6), 337), r && t.write(r, 345), t.write(Wt(N0(t), 6), 148), t);
};
Wn.decode = function(e, t) {
  var n = e[156] === 0 ? 0 : e[156] - D0, r = ur(e, 0, 100, t), i = Vt(e, 100, 8), a = Vt(e, 108, 8), o = Vt(e, 116, 8), c = Vt(e, 124, 12), s = Vt(e, 136, 12), u = V_(n), l = e[157] === 0 ? null : ur(e, 157, 100, t), p = ur(e, 265, 32), d = ur(e, 297, 32), m = Vt(e, 329, 8), g = Vt(e, 337, 8);
  e[345] && (r = ur(e, 345, 155, t) + "/" + r), n === 0 && r && r[r.length - 1] === "/" && (n = 5);
  var v = N0(e);
  if (v === 8 * 32) return null;
  if (v !== Vt(e, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  return {
    name: r,
    mode: i,
    uid: a,
    gid: o,
    size: c,
    mtime: new Date(1e3 * s),
    type: u,
    linkname: l,
    uname: p,
    gname: d,
    devmajor: m,
    devminor: g
  };
};
<<<<<<< HEAD
var util$7 = require$$1$3;
var bl = bl$1;
var xtend = immutable;
var headers$1 = headers$2;
var Writable$4 = readableExports.Writable;
var PassThrough$2 = readableExports.PassThrough;
var noop$2 = function() {
=======
var k0 = Pe, K_ = __, J_ = S_, Wr = Wn, L0 = ji.Writable, U0 = ji.PassThrough, B0 = function() {
}, $f = function(e) {
  return e &= 511, e && 512 - e;
}, Z_ = function(e, t) {
  var n = new Mo(e, t);
  return n.end(), n;
}, Q_ = function(e, t) {
  return t.path && (e.name = t.path), t.linkpath && (e.linkname = t.linkpath), t.size && (e.size = parseInt(t.size, 10)), e.pax = t, e;
}, Mo = function(e, t) {
  this._parent = e, this.offset = t, U0.call(this);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
};
k0.inherits(Mo, U0);
Mo.prototype.destroy = function(e) {
  this._parent.destroy(e);
};
<<<<<<< HEAD
var emptyStream = function(self2, offset) {
  var s = new Source(self2, offset);
  s.end();
  return s;
};
var mixinPax = function(header, pax) {
  if (pax.path) header.name = pax.path;
  if (pax.linkpath) header.linkname = pax.linkpath;
  if (pax.size) header.size = parseInt(pax.size, 10);
  header.pax = pax;
  return header;
};
var Source = function(self2, offset) {
  this._parent = self2;
  this.offset = offset;
  PassThrough$2.call(this);
};
util$7.inherits(Source, PassThrough$2);
Source.prototype.destroy = function(err) {
  this._parent.destroy(err);
};
var Extract = function(opts) {
  if (!(this instanceof Extract)) return new Extract(opts);
  Writable$4.call(this, opts);
  opts = opts || {};
  this._offset = 0;
  this._buffer = bl();
  this._missing = 0;
  this._partial = false;
  this._onparse = noop$2;
  this._header = null;
  this._stream = null;
  this._overflow = null;
  this._cb = null;
  this._locked = false;
  this._destroyed = false;
  this._pax = null;
  this._paxGlobal = null;
  this._gnuLongPath = null;
  this._gnuLongLinkPath = null;
  var self2 = this;
  var b = self2._buffer;
  var oncontinue = function() {
    self2._continue();
  };
  var onunlock = function(err) {
    self2._locked = false;
    if (err) return self2.destroy(err);
    if (!self2._stream) oncontinue();
  };
  var onstreamend = function() {
    self2._stream = null;
    var drain = overflow$1(self2._header.size);
    if (drain) self2._parse(drain, ondrain);
    else self2._parse(512, onheader);
    if (!self2._locked) oncontinue();
  };
  var ondrain = function() {
    self2._buffer.consume(overflow$1(self2._header.size));
    self2._parse(512, onheader);
    oncontinue();
  };
  var onpaxglobalheader = function() {
    var size = self2._header.size;
    self2._paxGlobal = headers$1.decodePax(b.slice(0, size));
    b.consume(size);
    onstreamend();
  };
  var onpaxheader = function() {
    var size = self2._header.size;
    self2._pax = headers$1.decodePax(b.slice(0, size));
    if (self2._paxGlobal) self2._pax = xtend(self2._paxGlobal, self2._pax);
    b.consume(size);
    onstreamend();
  };
  var ongnulongpath = function() {
    var size = self2._header.size;
    this._gnuLongPath = headers$1.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
    b.consume(size);
    onstreamend();
  };
  var ongnulonglinkpath = function() {
    var size = self2._header.size;
    this._gnuLongLinkPath = headers$1.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
    b.consume(size);
    onstreamend();
  };
  var onheader = function() {
    var offset = self2._offset;
    var header;
=======
var kt = function(e) {
  if (!(this instanceof kt)) return new kt(e);
  L0.call(this, e), e = e || {}, this._offset = 0, this._buffer = K_(), this._missing = 0, this._partial = !1, this._onparse = B0, this._header = null, this._stream = null, this._overflow = null, this._cb = null, this._locked = !1, this._destroyed = !1, this._pax = null, this._paxGlobal = null, this._gnuLongPath = null, this._gnuLongLinkPath = null;
  var t = this, n = t._buffer, r = function() {
    t._continue();
  }, i = function(d) {
    if (t._locked = !1, d) return t.destroy(d);
    t._stream || r();
  }, a = function() {
    t._stream = null;
    var d = $f(t._header.size);
    d ? t._parse(d, o) : t._parse(512, p), t._locked || r();
  }, o = function() {
    t._buffer.consume($f(t._header.size)), t._parse(512, p), r();
  }, c = function() {
    var d = t._header.size;
    t._paxGlobal = Wr.decodePax(n.slice(0, d)), n.consume(d), a();
  }, s = function() {
    var d = t._header.size;
    t._pax = Wr.decodePax(n.slice(0, d)), t._paxGlobal && (t._pax = J_(t._paxGlobal, t._pax)), n.consume(d), a();
  }, u = function() {
    var d = t._header.size;
    this._gnuLongPath = Wr.decodeLongPath(n.slice(0, d), e.filenameEncoding), n.consume(d), a();
  }, l = function() {
    var d = t._header.size;
    this._gnuLongLinkPath = Wr.decodeLongPath(n.slice(0, d), e.filenameEncoding), n.consume(d), a();
  }, p = function() {
    var d = t._offset, m;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    try {
      m = t._header = Wr.decode(n.slice(0, 512), e.filenameEncoding);
    } catch (g) {
      t.emit("error", g);
    }
    if (n.consume(512), !m) {
      t._parse(512, p), r();
      return;
    }
    if (m.type === "gnu-long-path") {
      t._parse(m.size, u), r();
      return;
    }
    if (m.type === "gnu-long-link-path") {
      t._parse(m.size, l), r();
      return;
    }
    if (m.type === "pax-global-header") {
      t._parse(m.size, c), r();
      return;
    }
    if (m.type === "pax-header") {
      t._parse(m.size, s), r();
      return;
    }
<<<<<<< HEAD
    if (self2._gnuLongPath) {
      header.name = self2._gnuLongPath;
      self2._gnuLongPath = null;
    }
    if (self2._gnuLongLinkPath) {
      header.linkname = self2._gnuLongLinkPath;
      self2._gnuLongLinkPath = null;
    }
    if (self2._pax) {
      self2._header = header = mixinPax(header, self2._pax);
      self2._pax = null;
    }
    self2._locked = true;
    if (!header.size || header.type === "directory") {
      self2._parse(512, onheader);
      self2.emit("entry", header, emptyStream(self2, offset), onunlock);
=======
    if (t._gnuLongPath && (m.name = t._gnuLongPath, t._gnuLongPath = null), t._gnuLongLinkPath && (m.linkname = t._gnuLongLinkPath, t._gnuLongLinkPath = null), t._pax && (t._header = m = Q_(m, t._pax), t._pax = null), t._locked = !0, !m.size || m.type === "directory") {
      t._parse(512, p), t.emit("entry", m, Z_(t, d), i);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      return;
    }
    t._stream = new Mo(t, d), t.emit("entry", m, t._stream, i), t._parse(m.size, a), r();
  };
  this._onheader = p, this._parse(512, p);
};
k0.inherits(kt, L0);
kt.prototype.destroy = function(e) {
  this._destroyed || (this._destroyed = !0, e && this.emit("error", e), this.emit("close"), this._stream && this._stream.emit("close"));
};
kt.prototype._parse = function(e, t) {
  this._destroyed || (this._offset += e, this._missing = e, t === this._onheader && (this._partial = !1), this._onparse = t);
};
kt.prototype._continue = function() {
  if (!this._destroyed) {
    var e = this._cb;
    this._cb = B0, this._overflow ? this._write(this._overflow, void 0, e) : e();
  }
};
kt.prototype._write = function(e, t, n) {
  if (!this._destroyed) {
    var r = this._stream, i = this._buffer, a = this._missing;
    if (e.length && (this._partial = !0), e.length < a)
      return this._missing -= e.length, this._overflow = null, r ? r.write(e, n) : (i.append(e), n());
    this._cb = n, this._missing = 0;
    var o = null;
    e.length > a && (o = e.slice(a), e = e.slice(0, a)), r ? r.end(e) : i.append(e), this._overflow = o, this._onparse();
  }
};
kt.prototype._final = function(e) {
  if (this._partial) return this.destroy(new Error("Unexpected end of data"));
  e();
};
<<<<<<< HEAD
var extract = Extract;
var fsConstants = fs$w.constants || require$$1$6;
var constants$3 = fsConstants;
var eos = endOfStream;
var util$6 = require$$1$3;
var alloc2 = bufferAlloc;
var toBuffer2 = toBuffer$2;
var Readable$1 = readableExports.Readable;
var Writable$3 = readableExports.Writable;
var StringDecoder = require$$1$7.StringDecoder;
var headers = headers$2;
var DMODE = parseInt("755", 8);
var FMODE = parseInt("644", 8);
var END_OF_TAR = alloc2(1024);
var noop$1 = function() {
};
var overflow = function(self2, size) {
  size &= 511;
  if (size) self2.push(END_OF_TAR.slice(0, 512 - size));
};
function modeToType(mode) {
  switch (mode & constants$3.S_IFMT) {
    case constants$3.S_IFBLK:
=======
var eS = kt, tS = ae.constants || Jh, er = tS, If = r0, qo = Pe, nS = P0, rS = I0, j0 = ji.Readable, Nr = ji.Writable, iS = kl.StringDecoder, Wa = Wn, aS = parseInt("755", 8), oS = parseInt("644", 8), M0 = nS(1024), cu = function() {
}, vl = function(e, t) {
  t &= 511, t && e.push(M0.slice(0, 512 - t));
};
function sS(e) {
  switch (e & er.S_IFMT) {
    case er.S_IFBLK:
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      return "block-device";
    case er.S_IFCHR:
      return "character-device";
    case er.S_IFDIR:
      return "directory";
    case er.S_IFIFO:
      return "fifo";
    case er.S_IFLNK:
      return "symlink";
  }
  return "file";
}
var zo = function(e) {
  Nr.call(this), this.written = 0, this._to = e, this._destroyed = !1;
};
qo.inherits(zo, Nr);
zo.prototype._write = function(e, t, n) {
  if (this.written += e.length, this._to.push(e)) return n();
  this._to._drain = n;
};
zo.prototype.destroy = function() {
  this._destroyed || (this._destroyed = !0, this.emit("close"));
};
<<<<<<< HEAD
var LinkSink = function() {
  Writable$3.call(this);
  this.linkname = "";
  this._decoder = new StringDecoder("utf-8");
  this._destroyed = false;
=======
var Ho = function() {
  Nr.call(this), this.linkname = "", this._decoder = new iS("utf-8"), this._destroyed = !1;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
};
qo.inherits(Ho, Nr);
Ho.prototype._write = function(e, t, n) {
  this.linkname += this._decoder.write(e), n();
};
Ho.prototype.destroy = function() {
  this._destroyed || (this._destroyed = !0, this.emit("close"));
};
var hi = function() {
  Nr.call(this), this._destroyed = !1;
};
qo.inherits(hi, Nr);
hi.prototype._write = function(e, t, n) {
  n(new Error("No body allowed for this entry"));
};
hi.prototype.destroy = function() {
  this._destroyed || (this._destroyed = !0, this.emit("close"));
};
<<<<<<< HEAD
var Pack = function(opts) {
  if (!(this instanceof Pack)) return new Pack(opts);
  Readable$1.call(this, opts);
  this._drain = noop$1;
  this._finalized = false;
  this._finalizing = false;
  this._destroyed = false;
  this._stream = null;
};
util$6.inherits(Pack, Readable$1);
Pack.prototype.entry = function(header, buffer2, callback) {
  if (this._stream) throw new Error("already piping an entry");
  if (this._finalized || this._destroyed) return;
  if (typeof buffer2 === "function") {
    callback = buffer2;
    buffer2 = null;
  }
  if (!callback) callback = noop$1;
  var self2 = this;
  if (!header.size || header.type === "symlink") header.size = 0;
  if (!header.type) header.type = modeToType(header.mode);
  if (!header.mode) header.mode = header.type === "directory" ? DMODE : FMODE;
  if (!header.uid) header.uid = 0;
  if (!header.gid) header.gid = 0;
  if (!header.mtime) header.mtime = /* @__PURE__ */ new Date();
  if (typeof buffer2 === "string") buffer2 = toBuffer2(buffer2);
  if (Buffer.isBuffer(buffer2)) {
    header.size = buffer2.length;
    this._encode(header);
    this.push(buffer2);
    overflow(self2, header.size);
    process.nextTick(callback);
    return new Void();
  }
  if (header.type === "symlink" && !header.linkname) {
    var linkSink = new LinkSink();
    eos(linkSink, function(err) {
      if (err) {
        self2.destroy();
        return callback(err);
      }
      header.linkname = linkSink.linkname;
      self2._encode(header);
      callback();
    });
    return linkSink;
  }
  this._encode(header);
  if (header.type !== "file" && header.type !== "contiguous-file") {
    process.nextTick(callback);
    return new Void();
  }
  var sink = new Sink(this);
  this._stream = sink;
  eos(sink, function(err) {
    self2._stream = null;
    if (err) {
      self2.destroy();
      return callback(err);
    }
    if (sink.written !== header.size) {
      self2.destroy();
      return callback(new Error("size mismatch"));
    }
    overflow(self2, header.size);
    if (self2._finalizing) self2.finalize();
    callback();
  });
  return sink;
};
Pack.prototype.finalize = function() {
=======
var Tt = function(e) {
  if (!(this instanceof Tt)) return new Tt(e);
  j0.call(this, e), this._drain = cu, this._finalized = !1, this._finalizing = !1, this._destroyed = !1, this._stream = null;
};
qo.inherits(Tt, j0);
Tt.prototype.entry = function(e, t, n) {
  if (this._stream) throw new Error("already piping an entry");
  if (!(this._finalized || this._destroyed)) {
    typeof t == "function" && (n = t, t = null), n || (n = cu);
    var r = this;
    if ((!e.size || e.type === "symlink") && (e.size = 0), e.type || (e.type = sS(e.mode)), e.mode || (e.mode = e.type === "directory" ? aS : oS), e.uid || (e.uid = 0), e.gid || (e.gid = 0), e.mtime || (e.mtime = /* @__PURE__ */ new Date()), typeof t == "string" && (t = rS(t)), Buffer.isBuffer(t))
      return e.size = t.length, this._encode(e), this.push(t), vl(r, e.size), process.nextTick(n), new hi();
    if (e.type === "symlink" && !e.linkname) {
      var i = new Ho();
      return If(i, function(o) {
        if (o)
          return r.destroy(), n(o);
        e.linkname = i.linkname, r._encode(e), n();
      }), i;
    }
    if (this._encode(e), e.type !== "file" && e.type !== "contiguous-file")
      return process.nextTick(n), new hi();
    var a = new zo(this);
    return this._stream = a, If(a, function(o) {
      if (r._stream = null, o)
        return r.destroy(), n(o);
      if (a.written !== e.size)
        return r.destroy(), n(new Error("size mismatch"));
      vl(r, e.size), r._finalizing && r.finalize(), n();
    }), a;
  }
};
Tt.prototype.finalize = function() {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  if (this._stream) {
    this._finalizing = !0;
    return;
  }
  this._finalized || (this._finalized = !0, this.push(M0), this.push(null));
};
<<<<<<< HEAD
Pack.prototype.destroy = function(err) {
  if (this._destroyed) return;
  this._destroyed = true;
  if (err) this.emit("error", err);
  this.emit("close");
  if (this._stream && this._stream.destroy) this._stream.destroy();
};
Pack.prototype._encode = function(header) {
  if (!header.pax) {
    var buf = headers.encode(header);
    if (buf) {
      this.push(buf);
=======
Tt.prototype.destroy = function(e) {
  this._destroyed || (this._destroyed = !0, e && this.emit("error", e), this.emit("close"), this._stream && this._stream.destroy && this._stream.destroy());
};
Tt.prototype._encode = function(e) {
  if (!e.pax) {
    var t = Wa.encode(e);
    if (t) {
      this.push(t);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      return;
    }
  }
  this._encodePax(e);
};
<<<<<<< HEAD
Pack.prototype._encodePax = function(header) {
  var paxHeader = headers.encodePax({
    name: header.name,
    linkname: header.linkname,
    pax: header.pax
  });
  var newHeader = {
=======
Tt.prototype._encodePax = function(e) {
  var t = Wa.encodePax({
    name: e.name,
    linkname: e.linkname,
    pax: e.pax
  }), n = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    name: "PaxHeader",
    mode: e.mode,
    uid: e.uid,
    gid: e.gid,
    size: t.length,
    mtime: e.mtime,
    type: "pax-header",
    linkname: e.linkname && "PaxHeader",
    uname: e.uname,
    gname: e.gname,
    devmajor: e.devmajor,
    devminor: e.devminor
  };
  this.push(Wa.encode(n)), this.push(t), vl(this, t.length), n.size = e.size, n.type = e.type, this.push(Wa.encode(n));
};
<<<<<<< HEAD
Pack.prototype._read = function(n) {
  var drain = this._drain;
  this._drain = noop$1;
  drain();
};
var pack = Pack;
tarStream.extract = extract;
tarStream.pack = pack;
const stream$9 = require$$1$2;
let BaseStream$2 = class BaseStream extends stream$9.Readable {
=======
Tt.prototype._read = function(e) {
  var t = this._drain;
  this._drain = cu, t();
};
var cS = Tt;
Li.extract = eS;
Li.pack = cS;
const lS = ie;
let uS = class extends lS.Readable {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  addEntry() {
    throw new Error(".addEntry not implemented in sub class!");
  }
  _read() {
  }
  emit(t, n) {
    if (t === "error") {
      const r = n;
      r.name === "Error" && (r.name = this.constructor.name + "Error");
    }
    super.emit(t, n);
  }
};
<<<<<<< HEAD
var base_stream = BaseStream$2;
const fs$q = fs$w;
const path$p = require$$1$4;
const stream$8 = require$$1$2;
const tar$5 = tarStream;
const utils$e = utils$f;
const BaseStream$1 = base_stream;
let TarStream$2 = class TarStream extends BaseStream$1 {
  constructor(opts) {
    super(opts);
    this._waitingEntries = [];
    this._processing = false;
    this._init(opts);
  }
  _init() {
    const pack2 = this._pack = tar$5.pack();
    pack2.on("end", () => this.push(null));
    pack2.on("data", (chunk) => this.push(chunk));
    pack2.on("error", (err) => this.emit("error", err));
=======
var q0 = uS;
const ya = ae, Vr = oe, pS = ie, fS = Li, Pf = me, dS = q0;
let hS = class extends dS {
  constructor(t) {
    super(t), this._waitingEntries = [], this._processing = !1, this._init(t);
  }
  _init() {
    const t = this._pack = fS.pack();
    t.on("end", () => this.push(null)), t.on("data", (n) => this.push(n)), t.on("error", (n) => this.emit("error", n));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  addEntry(t, n) {
    if (this._processing)
      return this._waitingEntries.push([t, n]);
    n = n || {}, this._processing = !0;
    const r = Pf.entryType(t);
    r && (r === "fileOrDir" ? this._addFileOrDirEntry(t, n) : r === "buffer" ? this._addBufferEntry(t, n) : this._addStreamEntry(t, n));
  }
  _addFileOrDirEntry(t, n) {
    ya.stat(t, (r, i) => {
      if (r) return this.emit("error", r);
      if (i.isDirectory()) return this._addDirEntry(t, n);
      if (i.isFile()) return this._addFileEntry(t, n);
      const a = new Error("Type is not supported, must be a file path, directory path, file buffer, or a readable stream");
      a.name = "IlligalEntryError", this.emit("error", a);
    });
  }
  _addFileEntry(t, n) {
    ya.stat(t, (r, i) => {
      if (r) return this.emit("error", r);
      const a = this._pack.entry({ name: n.relativePath || Vr.basename(t), size: i.size, mode: i.mode & 511 }, this._onEntryFinish.bind(this)), o = ya.createReadStream(t, n.fs);
      o.on("error", (c) => this.emit("error", c)), o.pipe(a);
    });
  }
  _addDirEntry(t, n) {
    ya.readdir(t, (r, i) => {
      if (r) return this.emit("error", r);
      const a = n.relativePath || "";
      i.forEach((o) => {
        const c = Pf.clone(n);
        n.ignoreBase ? c.relativePath = Vr.posix.join(a, o) : c.relativePath = Vr.posix.join(a, Vr.basename(t), o), c.ignoreBase = !0, this.addEntry(Vr.posix.join(t, o), c);
      }), this._onEntryFinish();
    });
  }
  _addBufferEntry(t, n) {
    if (!n.relativePath) return this.emit("error", "opts.relativePath is required if entry is a buffer");
    this._pack.entry({ name: n.relativePath }, t, this._onEntryFinish.bind(this));
  }
  _addStreamEntry(t, n) {
    if (t.on("error", (r) => this.emit("error", r)), !n.relativePath) return this.emit("error", new Error("opts.relativePath is required"));
    if (n.size) {
      const r = this._pack.entry({ name: n.relativePath, size: n.size }, this._onEntryFinish.bind(this));
      t.pipe(r);
    } else {
<<<<<<< HEAD
      this._addStreamEntry(entry, opts);
    }
  }
  _addFileOrDirEntry(entry, opts) {
    fs$q.stat(entry, (err, stat2) => {
      if (err) return this.emit("error", err);
      if (stat2.isDirectory()) return this._addDirEntry(entry, opts);
      if (stat2.isFile()) return this._addFileEntry(entry, opts);
      const illigalEntryError2 = new Error("Type is not supported, must be a file path, directory path, file buffer, or a readable stream");
      illigalEntryError2.name = "IlligalEntryError";
      this.emit("error", illigalEntryError2);
    });
  }
  _addFileEntry(entry, opts) {
    fs$q.stat(entry, (err, stat2) => {
      if (err) return this.emit("error", err);
      const entryStream = this._pack.entry({ name: opts.relativePath || path$p.basename(entry), size: stat2.size, mode: stat2.mode & 511 }, this._onEntryFinish.bind(this));
      const stream2 = fs$q.createReadStream(entry, opts.fs);
      stream2.on("error", (err2) => this.emit("error", err2));
      stream2.pipe(entryStream);
    });
  }
  _addDirEntry(entry, opts) {
    fs$q.readdir(entry, (err, files) => {
      if (err) return this.emit("error", err);
      const relativePath = opts.relativePath || "";
      files.forEach((fileOrDir) => {
        const newOpts = utils$e.clone(opts);
        if (opts.ignoreBase) {
          newOpts.relativePath = path$p.posix.join(relativePath, fileOrDir);
        } else {
          newOpts.relativePath = path$p.posix.join(relativePath, path$p.basename(entry), fileOrDir);
        }
        newOpts.ignoreBase = true;
        this.addEntry(path$p.posix.join(entry, fileOrDir), newOpts);
      });
      this._onEntryFinish();
    });
  }
  _addBufferEntry(entry, opts) {
    if (!opts.relativePath) return this.emit("error", "opts.relativePath is required if entry is a buffer");
    this._pack.entry({ name: opts.relativePath }, entry, this._onEntryFinish.bind(this));
  }
  _addStreamEntry(entry, opts) {
    entry.on("error", (err) => this.emit("error", err));
    if (!opts.relativePath) return this.emit("error", new Error("opts.relativePath is required"));
    if (opts.size) {
      const entryStream = this._pack.entry({ name: opts.relativePath, size: opts.size }, this._onEntryFinish.bind(this));
      entry.pipe(entryStream);
    } else {
      if (!opts.suppressSizeWarning) {
        console.warn("You should specify the size of streamming data by opts.size to prevent all streaming data from loading into memory. If you are sure about memory cost, pass opts.suppressSizeWarning: true to suppress this warning");
      }
      const buf = [];
      const collectStream = new stream$8.Writable({
        write(chunk, _, callback) {
          buf.push(chunk);
          callback();
=======
      n.suppressSizeWarning || console.warn("You should specify the size of streamming data by opts.size to prevent all streaming data from loading into memory. If you are sure about memory cost, pass opts.suppressSizeWarning: true to suppress this warning");
      const r = [], i = new pS.Writable({
        write(a, o, c) {
          r.push(a), c();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        }
      });
      i.on("error", (a) => this.emit("error", a)), i.on("finish", () => {
        this._pack.entry({ name: n.relativePath }, Buffer.concat(r), this._onEntryFinish.bind(this));
      }), t.pipe(i);
    }
  }
  _read() {
  }
  _onEntryFinish(t) {
    if (t) return this.emit("error", t);
    this._processing = !1;
    const n = this._waitingEntries.shift();
    n ? this.addEntry.apply(this, n) : this._finalize();
  }
  _finalize() {
    this._pack.finalize();
  }
};
<<<<<<< HEAD
var stream_1$4 = TarStream$2;
const path$o = require$$1$4;
const yazl$1 = yazl$2;
const TarStream$1 = stream_1$4;
let ZipStream$1 = class ZipStream extends TarStream$1 {
  _init() {
    const zipfile = this._zipfile = new yazl$1.ZipFile();
    const stream2 = zipfile.outputStream;
    stream2.on("end", () => this.push(null));
    stream2.on("data", (chunk) => this.push(chunk));
    stream2.on("error", (err) => this.emit("error", err));
  }
  _addFileEntry(entry, opts) {
    this._zipfile.addFile(entry, opts.relativePath || path$o.basename(entry), opts);
    this._onEntryFinish();
=======
var z0 = hS;
const mS = oe, vS = No, gS = z0;
let xS = class extends gS {
  _init() {
    const n = (this._zipfile = new vS.ZipFile()).outputStream;
    n.on("end", () => this.push(null)), n.on("data", (r) => this.push(r)), n.on("error", (r) => this.emit("error", r));
  }
  _addFileEntry(t, n) {
    this._zipfile.addFile(t, n.relativePath || mS.basename(t), n), this._onEntryFinish();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  _addBufferEntry(t, n) {
    if (!n.relativePath) return this.emit("error", new Error("opts.relativePath is required if entry is a buffer"));
    this._zipfile.addBuffer(t, n.relativePath, n), this._onEntryFinish();
  }
  _addStreamEntry(t, n) {
    if (!n.relativePath) return this.emit("error", new Error("opts.relativePath is required if entry is a stream"));
    t.on("error", (r) => this.emit("error", r)), this._zipfile.addReadStream(t, n.relativePath, n), this._onEntryFinish();
  }
  _finalize() {
    this._zipfile.end();
  }
};
<<<<<<< HEAD
var stream$7 = ZipStream$1;
var getReady = { exports: {} };
function ready$4(flagOrFunction) {
  this._ready = !!this._ready;
  this._readyCallbacks = this._readyCallbacks || [];
  if (arguments.length === 0) {
    return new Promise((function(resolve) {
      if (this._ready) {
        return resolve();
      }
      this._readyCallbacks.push(resolve);
=======
var yS = xS, lu = { exports: {} };
function bS(e) {
  if (this._ready = !!this._ready, this._readyCallbacks = this._readyCallbacks || [], arguments.length === 0)
    return new Promise((function(t) {
      if (this._ready)
        return t();
      this._readyCallbacks.push(t);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }).bind(this));
  typeof e == "function" ? this._readyCallbacks.push(e) : this._ready = !!e, this._ready && this._readyCallbacks.splice(0, 1 / 0).forEach(function(t) {
    process.nextTick(t);
  });
}
<<<<<<< HEAD
function mixin(object) {
  object.ready = ready$4;
}
getReady.exports = mixin;
getReady.exports.mixin = mixin;
var getReadyExports = getReady.exports;
const path$n = require$$1$4;
const yazl = yazl$2;
const assert$1 = require$$2$3;
const stream$6 = require$$1$2;
const utils$d = utils$f;
const ready$3 = getReadyExports;
let ZipFileStream$1 = class ZipFileStream extends stream$6.Transform {
  constructor(opts) {
    super(opts);
    const sourceType = utils$d.sourceType(opts.source);
    const zipfile = new yazl.ZipFile();
    const zipStream = zipfile.outputStream;
    zipStream.on("data", (data) => this.push(data));
    zipStream.on("end", () => this.ready(true));
    zipfile.on("error", (err) => this.emit("error", err));
    if (sourceType !== "file") {
      assert$1(opts.relativePath, "opts.relativePath is required when compressing a buffer, or a stream");
=======
function H0(e) {
  e.ready = bS;
}
lu.exports = H0;
lu.exports.mixin = H0;
var Go = lu.exports;
const wS = oe, ES = No, _S = wo, Df = ie, SS = me, TS = Go;
let G0 = class extends Df.Transform {
  constructor(t) {
    super(t);
    const n = SS.sourceType(t.source), r = new ES.ZipFile(), i = r.outputStream;
    if (i.on("data", (a) => this.push(a)), i.on("end", () => this.ready(!0)), r.on("error", (a) => this.emit("error", a)), n !== "file" && _S(t.relativePath, "opts.relativePath is required when compressing a buffer, or a stream"), n && this.end(), n === "file")
      r.addFile(t.source, t.relativePath || wS.basename(t.source), t.yazl);
    else if (n === "buffer")
      r.addBuffer(t.source, t.relativePath, t.yazl);
    else if (n === "stream")
      r.addReadStream(t.source, t.relativePath, t.yazl);
    else {
      const a = this._passThrough = new Df.PassThrough();
      this.on("finish", () => a.end()), r.addReadStream(a, t.relativePath, t.yazl);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    r.end(t.yazl);
  }
<<<<<<< HEAD
  _transform(chunk, encoding, callback) {
    if (this._passThrough) {
      this._passThrough.write(chunk, encoding, callback);
=======
  _transform(t, n, r) {
    this._passThrough && this._passThrough.write(t, n, r);
  }
  _flush(t) {
    this.ready(t);
  }
};
TS.mixin(G0.prototype);
var AS = G0, Rt = {}, Mi = {}, RS = Wo;
function Wo() {
  this.pending = 0, this.max = 1 / 0, this.listeners = [], this.waiting = [], this.error = null;
}
Wo.prototype.go = function(e) {
  this.pending < this.max ? V0(this, e) : this.waiting.push(e);
};
Wo.prototype.wait = function(e) {
  this.pending === 0 ? e(this.error) : this.listeners.push(e);
};
Wo.prototype.hold = function() {
  return W0(this);
};
function W0(e) {
  e.pending += 1;
  var t = !1;
  return n;
  function n(i) {
    if (t) throw new Error("callback called twice");
    if (t = !0, e.error = e.error || i, e.pending -= 1, e.waiting.length > 0 && e.pending < e.max)
      V0(e, e.waiting.shift());
    else if (e.pending === 0) {
      var a = e.listeners;
      e.listeners = [], a.forEach(r);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
  }
  function r(i) {
    i(e.error);
  }
}
function V0(e, t) {
  t(W0(e));
}
<<<<<<< HEAD
const fs$p = fs$w;
const { Readable, Writable: Writable$2, PassThrough: PassThrough$1 } = require$$1$2;
const Pend = pend;
const { EventEmitter: EventEmitter$2 } = require$$0$6;
class FdSlicer extends EventEmitter$2 {
  constructor(fd, options = {}) {
    super();
    this.fd = fd;
    this.pend = new Pend();
    this.pend.max = 1;
    this.refCount = 0;
    this.autoClose = !!options.autoClose;
  }
  read(buffer2, offset, length, position, callback) {
    this.pend.go((cb) => {
      fs$p.read(this.fd, buffer2, offset, length, position, (err, bytesRead, buffer3) => {
        cb();
        callback(err, bytesRead, buffer3);
      });
    });
  }
  write(buffer2, offset, length, position, callback) {
    this.pend.go((cb) => {
      fs$p.write(this.fd, buffer2, offset, length, position, (err, written, buffer3) => {
        cb();
        callback(err, written, buffer3);
      });
    });
  }
  createReadStream(options) {
    return new ReadStream(this, options);
  }
  createWriteStream(options) {
    return new WriteStream(this, options);
=======
const ii = ae, { Readable: CS, Writable: Y0, PassThrough: OS } = ie, $S = RS, { EventEmitter: X0 } = Hn;
class K0 extends X0 {
  constructor(t, n = {}) {
    super(), this.fd = t, this.pend = new $S(), this.pend.max = 1, this.refCount = 0, this.autoClose = !!n.autoClose;
  }
  read(t, n, r, i, a) {
    this.pend.go((o) => {
      ii.read(this.fd, t, n, r, i, (c, s, u) => {
        o(), a(c, s, u);
      });
    });
  }
  write(t, n, r, i, a) {
    this.pend.go((o) => {
      ii.write(this.fd, t, n, r, i, (c, s, u) => {
        o(), a(c, s, u);
      });
    });
  }
  createReadStream(t) {
    return new IS(this, t);
  }
  createWriteStream(t) {
    return new PS(this, t);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  ref() {
    this.refCount += 1;
  }
  unref() {
    if (this.refCount -= 1, !(this.refCount > 0)) {
      if (this.refCount < 0) throw new Error("invalid unref");
      this.autoClose && ii.close(this.fd, (t) => {
        t ? this.emit("error", t) : this.emit("close");
      });
    }
  }
}
<<<<<<< HEAD
class ReadStream extends Readable {
  constructor(context, options = {}) {
    super(options);
    this.context = context;
    this.context.ref();
    this.start = options.start || 0;
    this.endOffset = options.end;
    this.pos = this.start;
    this.destroyed = false;
=======
class IS extends CS {
  constructor(t, n = {}) {
    super(n), this.context = t, this.context.ref(), this.start = n.start || 0, this.endOffset = n.end, this.pos = this.start, this.destroyed = !1;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  _read(t) {
    if (this.destroyed) return;
    let n = Math.min(this._readableState.highWaterMark, t);
    if (this.endOffset != null && (n = Math.min(n, this.endOffset - this.pos)), n <= 0) {
      this.destroyed = !0, this.push(null), this.context.unref();
      return;
    }
<<<<<<< HEAD
    this.context.pend.go((cb) => {
      if (this.destroyed) return cb();
      const buffer2 = Buffer.alloc(toRead);
      fs$p.read(this.context.fd, buffer2, 0, toRead, this.pos, (err, bytesRead) => {
        if (err) {
          this.destroy(err);
        } else if (bytesRead === 0) {
          this.destroyed = true;
          this.push(null);
          this.context.unref();
        } else {
          this.pos += bytesRead;
          this.push(buffer2.slice(0, bytesRead));
        }
        cb();
=======
    this.context.pend.go((r) => {
      if (this.destroyed) return r();
      const i = Buffer.alloc(n);
      ii.read(this.context.fd, i, 0, n, this.pos, (a, o) => {
        a ? this.destroy(a) : o === 0 ? (this.destroyed = !0, this.push(null), this.context.unref()) : (this.pos += o, this.push(i.slice(0, o))), r();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      });
    });
  }
  destroy(t) {
    this.destroyed || (t = t || new Error("stream destroyed"), this.destroyed = !0, this.emit("error", t), this.context.unref());
  }
}
<<<<<<< HEAD
class WriteStream extends Writable$2 {
  constructor(context, options = {}) {
    super(options);
    this.context = context;
    this.context.ref();
    this.start = options.start || 0;
    this.endOffset = options.end == null ? Infinity : +options.end;
    this.bytesWritten = 0;
    this.pos = this.start;
    this.destroyed = false;
    this.on("finish", this.destroy.bind(this));
  }
  _write(buffer2, _encoding, callback) {
    if (this.destroyed) return;
    if (this.pos + buffer2.length > this.endOffset) {
      const err = new Error("maximum file length exceeded");
      err.code = "ETOOBIG";
      this.destroy();
      callback(err);
      return;
    }
    this.context.pend.go((cb) => {
      if (this.destroyed) return cb();
      fs$p.write(this.context.fd, buffer2, 0, buffer2.length, this.pos, (err, bytes) => {
        if (err) {
          this.destroy();
          cb();
          callback(err);
        } else {
          this.bytesWritten += bytes;
          this.pos += bytes;
          this.emit("progress");
          cb();
          callback();
        }
=======
class PS extends Y0 {
  constructor(t, n = {}) {
    super(n), this.context = t, this.context.ref(), this.start = n.start || 0, this.endOffset = n.end == null ? 1 / 0 : +n.end, this.bytesWritten = 0, this.pos = this.start, this.destroyed = !1, this.on("finish", this.destroy.bind(this));
  }
  _write(t, n, r) {
    if (!this.destroyed) {
      if (this.pos + t.length > this.endOffset) {
        const i = new Error("maximum file length exceeded");
        i.code = "ETOOBIG", this.destroy(), r(i);
        return;
      }
      this.context.pend.go((i) => {
        if (this.destroyed) return i();
        ii.write(this.context.fd, t, 0, t.length, this.pos, (a, o) => {
          a ? (this.destroy(), i(), r(a)) : (this.bytesWritten += o, this.pos += o, this.emit("progress"), i(), r());
        });
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      });
    }
  }
  destroy() {
    this.destroyed || (this.destroyed = !0, this.context.unref());
  }
}
<<<<<<< HEAD
const { MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2 } = Number;
class BufferSlicer extends EventEmitter$2 {
  constructor(buffer2, options) {
    super();
    options = options || {};
    this.refCount = 0;
    this.buffer = buffer2;
    this.maxChunkSize = options.maxChunkSize || MAX_SAFE_INTEGER$2;
  }
  read(buffer2, offset, length, position, callback) {
    const end2 = position + length;
    const delta = end2 - this.buffer.length;
    const written = delta > 0 ? delta : length;
    this.buffer.copy(buffer2, offset, position, end2);
    setImmediate(() => {
      callback(null, written);
    });
  }
  write(buffer2, offset, length, position, callback) {
    buffer2.copy(this.buffer, position, offset, offset + length);
    setImmediate(() => {
      callback(null, length, buffer2);
    });
  }
  createReadStream(options = {}) {
    const readStream2 = new PassThrough$1(options);
    readStream2.destroyed = false;
    readStream2.start = options.start || 0;
    readStream2.endOffset = options.end;
    readStream2.pos = readStream2.endOffset || this.buffer.length;
    const entireSlice = this.buffer.slice(readStream2.start, readStream2.pos);
    let offset = 0;
    while (true) {
      const nextOffset = offset + this.maxChunkSize;
      if (nextOffset >= entireSlice.length) {
        if (offset < entireSlice.length) {
          readStream2.write(entireSlice.slice(offset, entireSlice.length));
        }
=======
const { MAX_SAFE_INTEGER: DS } = Number;
class J0 extends X0 {
  constructor(t, n) {
    super(), n = n || {}, this.refCount = 0, this.buffer = t, this.maxChunkSize = n.maxChunkSize || DS;
  }
  read(t, n, r, i, a) {
    const o = i + r, c = o - this.buffer.length, s = c > 0 ? c : r;
    this.buffer.copy(t, n, i, o), setImmediate(() => {
      a(null, s);
    });
  }
  write(t, n, r, i, a) {
    t.copy(this.buffer, i, n, n + r), setImmediate(() => {
      a(null, r, t);
    });
  }
  createReadStream(t = {}) {
    const n = new OS(t);
    n.destroyed = !1, n.start = t.start || 0, n.endOffset = t.end, n.pos = n.endOffset || this.buffer.length;
    const r = this.buffer.slice(n.start, n.pos);
    let i = 0;
    for (; ; ) {
      const a = i + this.maxChunkSize;
      if (a >= r.length) {
        i < r.length && n.write(r.slice(i, r.length));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        break;
      }
      n.write(r.slice(i, a)), i = a;
    }
    return n.end(), n.destroy = () => {
      n.destroyed = !0;
    }, n;
  }
<<<<<<< HEAD
  createWriteStream(options) {
    const bufferSlicer = this;
    options = options || {};
    const writeStream = new Writable$2(options);
    writeStream.start = options.start || 0;
    writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
    writeStream.bytesWritten = 0;
    writeStream.pos = writeStream.start;
    writeStream.destroyed = false;
    writeStream._write = (buffer2, encoding, callback) => {
      if (writeStream.destroyed) return;
      const end2 = writeStream.pos + buffer2.length;
      if (end2 > writeStream.endOffset) {
        const err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        writeStream.destroyed = true;
        callback(err);
        return;
      }
      buffer2.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer2.length);
      writeStream.bytesWritten += buffer2.length;
      writeStream.pos = end2;
      writeStream.emit("progress");
      callback();
    };
    writeStream.destroy = () => {
      writeStream.destroyed = true;
    };
    return writeStream;
=======
  createWriteStream(t) {
    const n = this;
    t = t || {};
    const r = new Y0(t);
    return r.start = t.start || 0, r.endOffset = t.end == null ? this.buffer.length : +t.end, r.bytesWritten = 0, r.pos = r.start, r.destroyed = !1, r._write = (i, a, o) => {
      if (r.destroyed) return;
      const c = r.pos + i.length;
      if (c > r.endOffset) {
        const s = new Error("maximum file length exceeded");
        s.code = "ETOOBIG", r.destroyed = !0, o(s);
        return;
      }
      i.copy(n.buffer, r.pos, 0, i.length), r.bytesWritten += i.length, r.pos = c, r.emit("progress"), o();
    }, r.destroy = () => {
      r.destroyed = !0;
    }, r;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  ref() {
    this.refCount += 1;
  }
  unref() {
    if (this.refCount -= 1, this.refCount < 0)
      throw new Error("invalid unref");
  }
}
<<<<<<< HEAD
function createFromBuffer(buffer2, options) {
  return new BufferSlicer(buffer2, options);
}
function createFromFd(fd, options) {
  return new FdSlicer(fd, options);
}
fdSlicer2.createFromBuffer = createFromBuffer;
fdSlicer2.createFromFd = createFromFd;
fdSlicer2.BufferSlicer = BufferSlicer;
fdSlicer2.FdSlicer = FdSlicer;
var fs$o = fs$w;
var zlib$2 = zlib$4;
var fd_slicer = fdSlicer2;
var crc32 = bufferCrc32;
var util$5 = require$$1$3;
var EventEmitter$1 = require$$0$6.EventEmitter;
var Transform = require$$1$2.Transform;
var PassThrough = require$$1$2.PassThrough;
var Writable$1 = require$$1$2.Writable;
yauzl$1.open = open;
yauzl$1.fromFd = fromFd;
yauzl$1.fromBuffer = fromBuffer;
yauzl$1.fromRandomAccessReader = fromRandomAccessReader;
yauzl$1.dosDateTimeToDate = dosDateTimeToDate;
yauzl$1.validateFileName = validateFileName;
yauzl$1.ZipFile = ZipFile;
yauzl$1.Entry = Entry;
yauzl$1.RandomAccessReader = RandomAccessReader;
function open(path2, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  if (options.autoClose == null) options.autoClose = true;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  if (callback == null) callback = defaultCallback;
  fs$o.open(path2, "r", function(err, fd) {
    if (err) return callback(err);
    fromFd(fd, options, function(err2, zipfile) {
      if (err2) fs$o.close(fd, defaultCallback);
      callback(err2, zipfile);
=======
function FS(e, t) {
  return new J0(e, t);
}
function NS(e, t) {
  return new K0(e, t);
}
Mi.createFromBuffer = FS;
Mi.createFromFd = NS;
Mi.BufferSlicer = J0;
Mi.FdSlicer = K0;
var gl = ae, kS = Qe, Z0 = Mi, LS = c0, Vo = Pe, Yo = Hn.EventEmitter, Q0 = ie.Transform, uu = ie.PassThrough, US = ie.Writable;
Rt.open = BS;
Rt.fromFd = ev;
Rt.fromBuffer = jS;
Rt.fromRandomAccessReader = pu;
Rt.dosDateTimeToDate = nv;
Rt.validateFileName = rv;
Rt.ZipFile = sn;
Rt.Entry = qi;
Rt.RandomAccessReader = hn;
function BS(e, t, n) {
  typeof t == "function" && (n = t, t = null), t == null && (t = {}), t.autoClose == null && (t.autoClose = !0), t.lazyEntries == null && (t.lazyEntries = !1), t.decodeStrings == null && (t.decodeStrings = !0), t.validateEntrySizes == null && (t.validateEntrySizes = !0), t.strictFileNames == null && (t.strictFileNames = !1), n == null && (n = oo), gl.open(e, "r", function(r, i) {
    if (r) return n(r);
    ev(i, t, function(a, o) {
      a && gl.close(i, oo), n(a, o);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    });
  });
}
function ev(e, t, n) {
  typeof t == "function" && (n = t, t = null), t == null && (t = {}), t.autoClose == null && (t.autoClose = !1), t.lazyEntries == null && (t.lazyEntries = !1), t.decodeStrings == null && (t.decodeStrings = !0), t.validateEntrySizes == null && (t.validateEntrySizes = !0), t.strictFileNames == null && (t.strictFileNames = !1), n == null && (n = oo), gl.fstat(e, function(r, i) {
    if (r) return n(r);
    var a = Z0.createFromFd(e, { autoClose: !0 });
    pu(a, i.size, t, n);
  });
}
<<<<<<< HEAD
function fromBuffer(buffer2, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = null;
  }
  if (options == null) options = {};
  options.autoClose = false;
  if (options.lazyEntries == null) options.lazyEntries = false;
  if (options.decodeStrings == null) options.decodeStrings = true;
  if (options.validateEntrySizes == null) options.validateEntrySizes = true;
  if (options.strictFileNames == null) options.strictFileNames = false;
  var reader = fd_slicer.createFromBuffer(buffer2, { maxChunkSize: 65536 });
  fromRandomAccessReader(reader, buffer2.length, options, callback);
=======
function jS(e, t, n) {
  typeof t == "function" && (n = t, t = null), t == null && (t = {}), t.autoClose = !1, t.lazyEntries == null && (t.lazyEntries = !1), t.decodeStrings == null && (t.decodeStrings = !0), t.validateEntrySizes == null && (t.validateEntrySizes = !0), t.strictFileNames == null && (t.strictFileNames = !1);
  var r = Z0.createFromBuffer(e, { maxChunkSize: 65536 });
  pu(r, e.length, t, n);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function pu(e, t, n, r) {
  typeof n == "function" && (r = n, n = null), n == null && (n = {}), n.autoClose == null && (n.autoClose = !0), n.lazyEntries == null && (n.lazyEntries = !1), n.decodeStrings == null && (n.decodeStrings = !0);
  var i = !!n.decodeStrings;
  if (n.validateEntrySizes == null && (n.validateEntrySizes = !0), n.strictFileNames == null && (n.strictFileNames = !1), r == null && (r = oo), typeof t != "number") throw new Error("expected totalSize parameter to be a number");
  if (t > Number.MAX_SAFE_INTEGER)
    throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
<<<<<<< HEAD
  }
  reader.ref();
  var eocdrWithoutCommentSize = 22;
  var maxCommentSize = 65535;
  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
  var buffer2 = newBuffer(bufferSize);
  var bufferReadStart = totalSize - buffer2.length;
  readAndAssertNoEof(reader, buffer2, 0, bufferSize, bufferReadStart, function(err) {
    if (err) return callback(err);
    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
      if (buffer2.readUInt32LE(i) !== 101010256) continue;
      var eocdrBuffer = buffer2.slice(i);
      var diskNumber = eocdrBuffer.readUInt16LE(4);
      if (diskNumber !== 0) {
        return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
=======
  e.ref();
  var a = 22, o = 65535, c = Math.min(a + o, t), s = _t(c), u = t - s.length;
  Er(e, s, 0, c, u, function(l) {
    if (l) return r(l);
    for (var p = c - a; p >= 0; p -= 1)
      if (s.readUInt32LE(p) === 101010256) {
        var d = s.slice(p), m = d.readUInt16LE(4);
        if (m !== 0)
          return r(new Error("multi-disk zip files are not supported: found disk number: " + m));
        var g = d.readUInt16LE(10), v = d.readUInt32LE(16), y = d.readUInt16LE(20), x = d.length - a;
        if (y !== x)
          return r(new Error("invalid comment length. expected: " + x + ". found: " + y));
        var w = i ? Va(d, 22, d.length, !1) : d.slice(22);
        if (!(g === 65535 || v === 4294967295))
          return r(null, new sn(e, v, t, g, w, n.autoClose, n.lazyEntries, i, n.validateEntrySizes, n.strictFileNames));
        var A = _t(20), O = u + p - A.length;
        Er(e, A, 0, A.length, O, function(k) {
          if (k) return r(k);
          if (A.readUInt32LE(0) !== 117853008)
            return r(new Error("invalid zip64 end of central directory locator signature"));
          var q = _r(A, 8), W = _t(56);
          Er(e, W, 0, W.length, q, function(te) {
            return te ? r(te) : W.readUInt32LE(0) !== 101075792 ? r(new Error("invalid zip64 end of central directory record signature")) : (g = _r(W, 32), v = _r(W, 48), r(null, new sn(e, v, t, g, w, n.autoClose, n.lazyEntries, i, n.validateEntrySizes, n.strictFileNames)));
          });
        });
        return;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
    r(new Error("end of central directory record signature not found"));
  });
}
Vo.inherits(sn, Yo);
function sn(e, t, n, r, i, a, o, c, s, u) {
  var l = this;
  Yo.call(l), l.reader = e, l.reader.on("error", function(p) {
    tv(l, p);
  }), l.reader.once("close", function() {
    l.emit("close");
  }), l.readEntryCursor = t, l.fileSize = n, l.entryCount = r, l.comment = i, l.entriesRead = 0, l.autoClose = !!a, l.lazyEntries = !!o, l.decodeStrings = !!c, l.validateEntrySizes = !!s, l.strictFileNames = !!u, l.isOpen = !0, l.emittedError = !1, l.lazyEntries || l._readEntry();
}
sn.prototype.close = function() {
  this.isOpen && (this.isOpen = !1, this.reader.unref());
};
<<<<<<< HEAD
function emitErrorAndAutoClose(self2, err) {
  if (self2.autoClose) self2.close();
  emitError(self2, err);
=======
function ut(e, t) {
  e.autoClose && e.close(), tv(e, t);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function tv(e, t) {
  e.emittedError || (e.emittedError = !0, e.emit("error", t));
}
sn.prototype.readEntry = function() {
  if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
  this._readEntry();
};
sn.prototype._readEntry = function() {
  var e = this;
  if (e.entryCount === e.entriesRead) {
    setImmediate(function() {
      e.autoClose && e.close(), !e.emittedError && e.emit("end");
    });
    return;
  }
<<<<<<< HEAD
  if (self2.emittedError) return;
  var buffer2 = newBuffer(46);
  readAndAssertNoEof(self2.reader, buffer2, 0, buffer2.length, self2.readEntryCursor, function(err) {
    if (err) return emitErrorAndAutoClose(self2, err);
    if (self2.emittedError) return;
    var entry = new Entry();
    var signature = buffer2.readUInt32LE(0);
    if (signature !== 33639248) return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
    entry.versionMadeBy = buffer2.readUInt16LE(4);
    entry.versionNeededToExtract = buffer2.readUInt16LE(6);
    entry.generalPurposeBitFlag = buffer2.readUInt16LE(8);
    entry.compressionMethod = buffer2.readUInt16LE(10);
    entry.lastModFileTime = buffer2.readUInt16LE(12);
    entry.lastModFileDate = buffer2.readUInt16LE(14);
    entry.crc32 = buffer2.readUInt32LE(16);
    entry.compressedSize = buffer2.readUInt32LE(20);
    entry.uncompressedSize = buffer2.readUInt32LE(24);
    entry.fileNameLength = buffer2.readUInt16LE(28);
    entry.extraFieldLength = buffer2.readUInt16LE(30);
    entry.fileCommentLength = buffer2.readUInt16LE(32);
    entry.internalFileAttributes = buffer2.readUInt16LE(36);
    entry.externalFileAttributes = buffer2.readUInt32LE(38);
    entry.relativeOffsetOfLocalHeader = buffer2.readUInt32LE(42);
    if (entry.generalPurposeBitFlag & 64) return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
    self2.readEntryCursor += 46;
    buffer2 = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
    readAndAssertNoEof(self2.reader, buffer2, 0, buffer2.length, self2.readEntryCursor, function(err2) {
      if (err2) return emitErrorAndAutoClose(self2, err2);
      if (self2.emittedError) return;
      var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
      entry.fileName = self2.decodeStrings ? decodeBuffer(buffer2, 0, entry.fileNameLength, isUtf8) : buffer2.slice(0, entry.fileNameLength);
      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
      var extraFieldBuffer = buffer2.slice(entry.fileNameLength, fileCommentStart);
      entry.extraFields = [];
      var i = 0;
      while (i < extraFieldBuffer.length - 3) {
        var headerId = extraFieldBuffer.readUInt16LE(i + 0);
        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
        var dataStart = i + 4;
        var dataEnd = dataStart + dataSize;
        if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
        var dataBuffer = newBuffer(dataSize);
        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
        entry.extraFields.push({
          id: headerId,
          data: dataBuffer
=======
  if (!e.emittedError) {
    var t = _t(46);
    Er(e.reader, t, 0, t.length, e.readEntryCursor, function(n) {
      if (n) return ut(e, n);
      if (!e.emittedError) {
        var r = new qi(), i = t.readUInt32LE(0);
        if (i !== 33639248) return ut(e, new Error("invalid central directory file header signature: 0x" + i.toString(16)));
        if (r.versionMadeBy = t.readUInt16LE(4), r.versionNeededToExtract = t.readUInt16LE(6), r.generalPurposeBitFlag = t.readUInt16LE(8), r.compressionMethod = t.readUInt16LE(10), r.lastModFileTime = t.readUInt16LE(12), r.lastModFileDate = t.readUInt16LE(14), r.crc32 = t.readUInt32LE(16), r.compressedSize = t.readUInt32LE(20), r.uncompressedSize = t.readUInt32LE(24), r.fileNameLength = t.readUInt16LE(28), r.extraFieldLength = t.readUInt16LE(30), r.fileCommentLength = t.readUInt16LE(32), r.internalFileAttributes = t.readUInt16LE(36), r.externalFileAttributes = t.readUInt32LE(38), r.relativeOffsetOfLocalHeader = t.readUInt32LE(42), r.generalPurposeBitFlag & 64) return ut(e, new Error("strong encryption is not supported"));
        e.readEntryCursor += 46, t = _t(r.fileNameLength + r.extraFieldLength + r.fileCommentLength), Er(e.reader, t, 0, t.length, e.readEntryCursor, function(a) {
          if (a) return ut(e, a);
          if (!e.emittedError) {
            var o = (r.generalPurposeBitFlag & 2048) !== 0;
            r.fileName = e.decodeStrings ? Va(t, 0, r.fileNameLength, o) : t.slice(0, r.fileNameLength);
            var c = r.fileNameLength + r.extraFieldLength, s = t.slice(r.fileNameLength, c);
            r.extraFields = [];
            for (var u = 0; u < s.length - 3; ) {
              var l = s.readUInt16LE(u + 0), p = s.readUInt16LE(u + 2), d = u + 4, m = d + p;
              if (m > s.length) return ut(e, new Error("extra field length exceeds extra field buffer size"));
              var g = _t(p);
              s.copy(g, 0, d, m), r.extraFields.push({
                id: l,
                data: g
              }), u = m;
            }
            if (r.fileComment = e.decodeStrings ? Va(t, c, c + r.fileCommentLength, o) : t.slice(c, c + r.fileCommentLength), r.comment = r.fileComment, e.readEntryCursor += t.length, e.entriesRead += 1, r.uncompressedSize === 4294967295 || r.compressedSize === 4294967295 || r.relativeOffsetOfLocalHeader === 4294967295) {
              for (var v = null, u = 0; u < r.extraFields.length; u++) {
                var y = r.extraFields[u];
                if (y.id === 1) {
                  v = y.data;
                  break;
                }
              }
              if (v == null)
                return ut(e, new Error("expected zip64 extended information extra field"));
              var x = 0;
              if (r.uncompressedSize === 4294967295) {
                if (x + 8 > v.length)
                  return ut(e, new Error("zip64 extended information extra field does not include uncompressed size"));
                r.uncompressedSize = _r(v, x), x += 8;
              }
              if (r.compressedSize === 4294967295) {
                if (x + 8 > v.length)
                  return ut(e, new Error("zip64 extended information extra field does not include compressed size"));
                r.compressedSize = _r(v, x), x += 8;
              }
              if (r.relativeOffsetOfLocalHeader === 4294967295) {
                if (x + 8 > v.length)
                  return ut(e, new Error("zip64 extended information extra field does not include relative header offset"));
                r.relativeOffsetOfLocalHeader = _r(v, x), x += 8;
              }
            }
            if (e.decodeStrings)
              for (var u = 0; u < r.extraFields.length; u++) {
                var y = r.extraFields[u];
                if (y.id === 28789) {
                  if (y.data.length < 6 || y.data.readUInt8(0) !== 1)
                    continue;
                  var w = y.data.readUInt32LE(1);
                  if (LS.unsigned(t.slice(0, r.fileNameLength)) !== w)
                    continue;
                  r.fileName = Va(y.data, 5, y.data.length, !0);
                  break;
                }
              }
            if (e.validateEntrySizes && r.compressionMethod === 0) {
              var A = r.uncompressedSize;
              if (r.isEncrypted() && (A += 12), r.compressedSize !== A) {
                var O = "compressed/uncompressed size mismatch for stored file: " + r.compressedSize + " != " + r.uncompressedSize;
                return ut(e, new Error(O));
              }
            }
            if (e.decodeStrings) {
              e.strictFileNames || (r.fileName = r.fileName.replace(/\\/g, "/"));
              var k = rv(r.fileName, e.validateFileNameOptions);
              if (k != null) return ut(e, new Error(k));
            }
            e.emit("entry", r), e.lazyEntries || e._readEntry();
          }
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        });
      }
<<<<<<< HEAD
      entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer2, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer2.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
      entry.comment = entry.fileComment;
      self2.readEntryCursor += buffer2.length;
      self2.entriesRead += 1;
      if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
        var zip64EiefBuffer = null;
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id === 1) {
            zip64EiefBuffer = extraField.data;
            break;
          }
        }
        if (zip64EiefBuffer == null) {
          return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
        }
        var index = 0;
        if (entry.uncompressedSize === 4294967295) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
          }
          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        if (entry.compressedSize === 4294967295) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
          }
          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
        if (entry.relativeOffsetOfLocalHeader === 4294967295) {
          if (index + 8 > zip64EiefBuffer.length) {
            return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
          }
          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
          index += 8;
        }
      }
      if (self2.decodeStrings) {
        for (var i = 0; i < entry.extraFields.length; i++) {
          var extraField = entry.extraFields[i];
          if (extraField.id === 28789) {
            if (extraField.data.length < 6) {
              continue;
            }
            if (extraField.data.readUInt8(0) !== 1) {
              continue;
            }
            var oldNameCrc32 = extraField.data.readUInt32LE(1);
            if (crc32.unsigned(buffer2.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
              continue;
            }
            entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
            break;
          }
        }
      }
      if (self2.validateEntrySizes && entry.compressionMethod === 0) {
        var expectedCompressedSize = entry.uncompressedSize;
        if (entry.isEncrypted()) {
          expectedCompressedSize += 12;
        }
        if (entry.compressedSize !== expectedCompressedSize) {
          var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
          return emitErrorAndAutoClose(self2, new Error(msg));
        }
      }
      if (self2.decodeStrings) {
        if (!self2.strictFileNames) {
          entry.fileName = entry.fileName.replace(/\\/g, "/");
        }
        var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
        if (errorMessage != null) return emitErrorAndAutoClose(self2, new Error(errorMessage));
      }
      self2.emit("entry", entry);
      if (!self2.lazyEntries) self2._readEntry();
=======
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    });
  }
};
sn.prototype.openReadStream = function(e, t, n) {
  var r = this, i = 0, a = e.compressedSize;
  if (n == null)
    n = t, t = {};
  else {
    if (t.decrypt != null) {
      if (!e.isEncrypted())
        throw new Error("options.decrypt can only be specified for encrypted entries");
      if (t.decrypt !== !1) throw new Error("invalid options.decrypt value: " + t.decrypt);
      if (e.isCompressed() && t.decompress !== !1)
        throw new Error("entry is encrypted and compressed, and options.decompress !== false");
    }
    if (t.decompress != null) {
      if (!e.isCompressed())
        throw new Error("options.decompress can only be specified for compressed entries");
      if (!(t.decompress === !1 || t.decompress === !0))
        throw new Error("invalid options.decompress value: " + t.decompress);
    }
    if (t.start != null || t.end != null) {
      if (e.isCompressed() && t.decompress !== !1)
        throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
      if (e.isEncrypted() && t.decrypt !== !1)
        throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
    }
    if (t.start != null) {
      if (i = t.start, i < 0) throw new Error("options.start < 0");
      if (i > e.compressedSize) throw new Error("options.start > entry.compressedSize");
    }
    if (t.end != null) {
      if (a = t.end, a < 0) throw new Error("options.end < 0");
      if (a > e.compressedSize) throw new Error("options.end > entry.compressedSize");
      if (a < i) throw new Error("options.end < options.start");
    }
  }
<<<<<<< HEAD
  if (!self2.isOpen) return callback(new Error("closed"));
  if (entry.isEncrypted()) {
    if (options.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
  }
  self2.reader.ref();
  var buffer2 = newBuffer(30);
  readAndAssertNoEof(self2.reader, buffer2, 0, buffer2.length, entry.relativeOffsetOfLocalHeader, function(err) {
    try {
      if (err) return callback(err);
      var signature = buffer2.readUInt32LE(0);
      if (signature !== 67324752) {
        return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
      }
      var fileNameLength = buffer2.readUInt16LE(26);
      var extraFieldLength = buffer2.readUInt16LE(28);
      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer2.length + fileNameLength + extraFieldLength;
      var decompress;
      if (entry.compressionMethod === 0) {
        decompress = false;
      } else if (entry.compressionMethod === 8) {
        decompress = options.decompress != null ? options.decompress : true;
      } else {
        return callback(new Error("unsupported compression method: " + entry.compressionMethod));
      }
      var fileDataStart = localFileHeaderEnd;
      var fileDataEnd = fileDataStart + entry.compressedSize;
      if (entry.compressedSize !== 0) {
        if (fileDataEnd > self2.fileSize) {
          return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
        }
      }
      var readStream2 = self2.reader.createReadStream({
        start: fileDataStart + relativeStart,
        end: fileDataStart + relativeEnd
      });
      var endpointStream = readStream2;
      if (decompress) {
        var destroyed = false;
        var inflateFilter = zlib$2.createInflateRaw();
        readStream2.on("error", function(err2) {
=======
  if (!r.isOpen) return n(new Error("closed"));
  if (e.isEncrypted() && t.decrypt !== !1)
    return n(new Error("entry is encrypted, and options.decrypt !== false"));
  r.reader.ref();
  var o = _t(30);
  Er(r.reader, o, 0, o.length, e.relativeOffsetOfLocalHeader, function(c) {
    try {
      if (c) return n(c);
      var s = o.readUInt32LE(0);
      if (s !== 67324752)
        return n(new Error("invalid local file header signature: 0x" + s.toString(16)));
      var u = o.readUInt16LE(26), l = o.readUInt16LE(28), p = e.relativeOffsetOfLocalHeader + o.length + u + l, d;
      if (e.compressionMethod === 0)
        d = !1;
      else if (e.compressionMethod === 8)
        d = t.decompress != null ? t.decompress : !0;
      else
        return n(new Error("unsupported compression method: " + e.compressionMethod));
      var m = p, g = m + e.compressedSize;
      if (e.compressedSize !== 0 && g > r.fileSize)
        return n(new Error("file data overflows file bounds: " + m + " + " + e.compressedSize + " > " + r.fileSize));
      var v = r.reader.createReadStream({
        start: m + i,
        end: m + a
      }), y = v;
      if (d) {
        var x = !1, w = kS.createInflateRaw();
        v.on("error", function(A) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
          setImmediate(function() {
            x || w.emit("error", A);
          });
        }), v.pipe(w), r.validateEntrySizes ? (y = new zi(e.uncompressedSize), w.on("error", function(A) {
          setImmediate(function() {
            x || y.emit("error", A);
          });
        }), w.pipe(y)) : y = w, y.destroy = function() {
          x = !0, w !== y && w.unpipe(y), v.unpipe(w), v.destroy();
        };
      }
      n(null, y);
    } finally {
      r.reader.unref();
    }
  });
};
function qi() {
}
qi.prototype.getLastModDate = function() {
  return nv(this.lastModFileDate, this.lastModFileTime);
};
qi.prototype.isEncrypted = function() {
  return (this.generalPurposeBitFlag & 1) !== 0;
};
qi.prototype.isCompressed = function() {
  return this.compressionMethod === 8;
};
function nv(e, t) {
  var n = e & 31, r = (e >> 5 & 15) - 1, i = (e >> 9 & 127) + 1980, a = 0, o = (t & 31) * 2, c = t >> 5 & 63, s = t >> 11 & 31;
  return new Date(i, r, n, s, c, o, a);
}
function rv(e) {
  return e.indexOf("\\") !== -1 ? "invalid characters in fileName: " + e : /^[a-zA-Z]:/.test(e) || /^\//.test(e) ? "absolute path: " + e : e.split("/").indexOf("..") !== -1 ? "invalid relative path: " + e : null;
}
<<<<<<< HEAD
function readAndAssertNoEof(reader, buffer2, offset, length, position, callback) {
  if (length === 0) {
    return setImmediate(function() {
      callback(null, newBuffer(0));
    });
  }
  reader.read(buffer2, offset, length, position, function(err, bytesRead) {
    if (err) return callback(err);
    if (bytesRead < length) {
      return callback(new Error("unexpected EOF"));
    }
    callback();
=======
function Er(e, t, n, r, i, a) {
  if (r === 0)
    return setImmediate(function() {
      a(null, _t(0));
    });
  e.read(t, n, r, i, function(o, c) {
    if (o) return a(o);
    if (c < r)
      return a(new Error("unexpected EOF"));
    a();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  });
}
Vo.inherits(zi, Q0);
function zi(e) {
  Q0.call(this), this.actualByteCount = 0, this.expectedByteCount = e;
}
zi.prototype._transform = function(e, t, n) {
  if (this.actualByteCount += e.length, this.actualByteCount > this.expectedByteCount) {
    var r = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
    return n(new Error(r));
  }
  n(null, e);
};
zi.prototype._flush = function(e) {
  if (this.actualByteCount < this.expectedByteCount) {
    var t = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
    return e(new Error(t));
  }
  e();
};
Vo.inherits(hn, Yo);
function hn() {
  Yo.call(this), this.refCount = 0;
}
hn.prototype.ref = function() {
  this.refCount += 1;
};
hn.prototype.unref = function() {
  var e = this;
  if (e.refCount -= 1, e.refCount > 0) return;
  if (e.refCount < 0) throw new Error("invalid unref");
  e.close(t);
  function t(n) {
    if (n) return e.emit("error", n);
    e.emit("close");
  }
};
hn.prototype.createReadStream = function(e) {
  var t = e.start, n = e.end;
  if (t === n) {
    var r = new uu();
    return setImmediate(function() {
      r.end();
    }), r;
  }
  var i = this._readStreamForRange(t, n), a = !1, o = new Xo(this);
  i.on("error", function(s) {
    setImmediate(function() {
      a || o.emit("error", s);
    });
  }), o.destroy = function() {
    i.unpipe(o), o.unref(), i.destroy();
  };
  var c = new zi(n - t);
  return o.on("error", function(s) {
    setImmediate(function() {
      a || c.emit("error", s);
    });
  }), c.destroy = function() {
    a = !0, o.unpipe(c), o.destroy();
  }, i.pipe(o).pipe(c);
};
hn.prototype._readStreamForRange = function(e, t) {
  throw new Error("not implemented");
};
<<<<<<< HEAD
RandomAccessReader.prototype.read = function(buffer2, offset, length, position, callback) {
  var readStream2 = this.createReadStream({ start: position, end: position + length });
  var writeStream = new Writable$1();
  var written = 0;
  writeStream._write = function(chunk, encoding, cb) {
    chunk.copy(buffer2, offset + written, 0, chunk.length);
    written += chunk.length;
    cb();
  };
  writeStream.on("finish", callback);
  readStream2.on("error", function(error2) {
    callback(error2);
  });
  readStream2.pipe(writeStream);
=======
hn.prototype.read = function(e, t, n, r, i) {
  var a = this.createReadStream({ start: r, end: r + n }), o = new US(), c = 0;
  o._write = function(s, u, l) {
    s.copy(e, t + c, 0, s.length), c += s.length, l();
  }, o.on("finish", i), a.on("error", function(s) {
    i(s);
  }), a.pipe(o);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
};
hn.prototype.close = function(e) {
  setImmediate(e);
};
Vo.inherits(Xo, uu);
function Xo(e) {
  uu.call(this), this.context = e, this.context.ref(), this.unreffedYet = !1;
}
Xo.prototype._flush = function(e) {
  this.unref(), e();
};
Xo.prototype.unref = function(e) {
  this.unreffedYet || (this.unreffedYet = !0, this.context.unref());
};
<<<<<<< HEAD
var cp437 = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
function decodeBuffer(buffer2, start, end2, isUtf8) {
  if (isUtf8) {
    return buffer2.toString("utf8", start, end2);
  } else {
    var result = "";
    for (var i = start; i < end2; i++) {
      result += cp437[buffer2[i]];
    }
    return result;
  }
}
function readUInt64LE(buffer2, offset) {
  var lower32 = buffer2.readUInt32LE(offset);
  var upper32 = buffer2.readUInt32LE(offset + 4);
  return upper32 * 4294967296 + lower32;
}
var newBuffer;
if (typeof Buffer.allocUnsafe === "function") {
  newBuffer = function(len) {
    return Buffer.allocUnsafe(len);
  };
} else {
  newBuffer = function(len) {
    return new Buffer(len);
  };
}
function defaultCallback(err) {
  if (err) throw err;
}
const stream$5 = require$$1$2;
let UncompressBaseStream$1 = class UncompressBaseStream extends stream$5.Writable {
  emit(event, data) {
    if (event === "error") {
      const error2 = data;
      if (error2.name === "Error") {
        error2.name = this.constructor.name + "Error";
      }
=======
var MS = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
function Va(e, t, n, r) {
  if (r)
    return e.toString("utf8", t, n);
  for (var i = "", a = t; a < n; a++)
    i += MS[e[a]];
  return i;
}
function _r(e, t) {
  var n = e.readUInt32LE(t), r = e.readUInt32LE(t + 4);
  return r * 4294967296 + n;
}
var _t;
typeof Buffer.allocUnsafe == "function" ? _t = function(e) {
  return Buffer.allocUnsafe(e);
} : _t = function(e) {
  return new Buffer(e);
};
function oo(e) {
  if (e) throw e;
}
const qS = ie;
let zS = class extends qS.Writable {
  emit(t, n) {
    if (t === "error") {
      const r = n;
      r.name === "Error" && (r.name = this.constructor.name + "Error");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    super.emit.apply(this, arguments);
  }
};
<<<<<<< HEAD
var base_write_stream = UncompressBaseStream$1;
var lib$3 = { exports: {} };
var buffer = require$$0$5;
var Buffer$1 = buffer.Buffer;
var safer = {};
var key;
for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue;
  if (key === "SlowBuffer" || key === "Buffer") continue;
  safer[key] = buffer[key];
}
var Safer = safer.Buffer = {};
for (key in Buffer$1) {
  if (!Buffer$1.hasOwnProperty(key)) continue;
  if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
  Safer[key] = Buffer$1[key];
}
safer.Buffer.prototype = Buffer$1.prototype;
if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function(value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
    }
    if (value && typeof value.length === "undefined") {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    return Buffer$1(value, encodingOrOffset, length);
  };
}
if (!Safer.alloc) {
  Safer.alloc = function(size, fill2, encoding) {
    if (typeof size !== "number") {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
    var buf = Buffer$1(size);
    if (!fill2 || fill2.length === 0) {
      buf.fill(0);
    } else if (typeof encoding === "string") {
      buf.fill(fill2, encoding);
    } else {
      buf.fill(fill2);
    }
    return buf;
  };
}
if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
  } catch (e) {
  }
}
if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  };
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
  }
}
var safer_1 = safer;
var bomHandling$1 = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling$1;
  hasRequiredBomHandling = 1;
  var BOMChar2 = "\uFEFF";
  bomHandling$1.PrependBOM = PrependBOMWrapper2;
  function PrependBOMWrapper2(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper2.prototype.write = function(str2) {
    if (this.addBOM) {
      str2 = BOMChar2 + str2;
      this.addBOM = false;
    }
    return this.encoder.write(str2);
  };
  PrependBOMWrapper2.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling$1.StripBOM = StripBOMWrapper2;
  function StripBOMWrapper2(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper2.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
      return res;
    if (res[0] === BOMChar2) {
      res = res.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res;
  };
  StripBOMWrapper2.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling$1;
}
var encodings$1 = {};
var internal$1;
var hasRequiredInternal$1;
function requireInternal$1() {
  if (hasRequiredInternal$1) return internal$1;
  hasRequiredInternal$1 = 1;
  var Buffer2 = safer_1.Buffer;
  internal$1 = {
=======
var HS = zS, fc = { exports: {} }, dc, Ff;
function Vn() {
  if (Ff) return dc;
  Ff = 1;
  var e = Nt, t = e.Buffer, n = {}, r;
  for (r in e)
    e.hasOwnProperty(r) && (r === "SlowBuffer" || r === "Buffer" || (n[r] = e[r]));
  var i = n.Buffer = {};
  for (r in t)
    t.hasOwnProperty(r) && (r === "allocUnsafe" || r === "allocUnsafeSlow" || (i[r] = t[r]));
  if (n.Buffer.prototype = t.prototype, (!i.from || i.from === Uint8Array.from) && (i.from = function(a, o, c) {
    if (typeof a == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof a);
    if (a && typeof a.length > "u")
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof a);
    return t(a, o, c);
  }), i.alloc || (i.alloc = function(a, o, c) {
    if (typeof a != "number")
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof a);
    if (a < 0 || a >= 2 * (1 << 30))
      throw new RangeError('The value "' + a + '" is invalid for option "size"');
    var s = t(a);
    return !o || o.length === 0 ? s.fill(0) : typeof c == "string" ? s.fill(o, c) : s.fill(o), s;
  }), !n.kStringMaxLength)
    try {
      n.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch {
    }
  return n.constants || (n.constants = {
    MAX_LENGTH: n.kMaxLength
  }, n.kStringMaxLength && (n.constants.MAX_STRING_LENGTH = n.kStringMaxLength)), dc = n, dc;
}
var ba = {}, Nf;
function GS() {
  if (Nf) return ba;
  Nf = 1;
  var e = "\uFEFF";
  ba.PrependBOM = t;
  function t(r, i) {
    this.encoder = r, this.addBOM = !0;
  }
  t.prototype.write = function(r) {
    return this.addBOM && (r = e + r, this.addBOM = !1), this.encoder.write(r);
  }, t.prototype.end = function() {
    return this.encoder.end();
  }, ba.StripBOM = n;
  function n(r, i) {
    this.decoder = r, this.pass = !1, this.options = i || {};
  }
  return n.prototype.write = function(r) {
    var i = this.decoder.write(r);
    return this.pass || !i || (i[0] === e && (i = i.slice(1), typeof this.options.stripBOM == "function" && this.options.stripBOM()), this.pass = !0), i;
  }, n.prototype.end = function() {
    return this.decoder.end();
  }, ba;
}
var hc = {}, mc, kf;
function WS() {
  if (kf) return mc;
  kf = 1;
  var e = Vn().Buffer;
  mc = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    // Encodings
    utf8: { type: "_internal", bomAware: !0 },
    cesu8: { type: "_internal", bomAware: !0 },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: !0 },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: t
  };
  function t(s, u) {
    this.enc = s.encodingName, this.bomAware = s.bomAware, this.enc === "base64" ? this.encoder = a : this.enc === "cesu8" && (this.enc = "utf8", this.encoder = o, e.from("eda0bdedb2a9", "hex").toString() !== "" && (this.decoder = c, this.defaultCharUnicode = u.defaultCharUnicode));
  }
<<<<<<< HEAD
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder2 = require$$1$7.StringDecoder;
  if (!StringDecoder2.prototype.end)
    StringDecoder2.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    StringDecoder2.call(this, codec.enc);
=======
  t.prototype.encoder = i, t.prototype.decoder = r;
  var n = kl.StringDecoder;
  n.prototype.end || (n.prototype.end = function() {
  });
  function r(s, u) {
    n.call(this, u.enc);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  r.prototype = n.prototype;
  function i(s, u) {
    this.enc = u.enc;
  }
  i.prototype.write = function(s) {
    return e.from(s, this.enc);
  }, i.prototype.end = function() {
  };
  function a(s, u) {
    this.prevStr = "";
  }
  a.prototype.write = function(s) {
    s = this.prevStr + s;
    var u = s.length - s.length % 4;
    return this.prevStr = s.slice(u), s = s.slice(0, u), e.from(s, "base64");
  }, a.prototype.end = function() {
    return e.from(this.prevStr, "base64");
  };
  function o(s, u) {
  }
  o.prototype.write = function(s) {
    for (var u = e.alloc(s.length * 3), l = 0, p = 0; p < s.length; p++) {
      var d = s.charCodeAt(p);
      d < 128 ? u[l++] = d : d < 2048 ? (u[l++] = 192 + (d >>> 6), u[l++] = 128 + (d & 63)) : (u[l++] = 224 + (d >>> 12), u[l++] = 128 + (d >>> 6 & 63), u[l++] = 128 + (d & 63));
    }
    return u.slice(0, l);
  }, o.prototype.end = function() {
  };
  function c(s, u) {
    this.acc = 0, this.contBytes = 0, this.accBytes = 0, this.defaultCharUnicode = u.defaultCharUnicode;
  }
<<<<<<< HEAD
  InternalEncoderCesu8.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length * 3), bufIdx = 0;
    for (var i = 0; i < str2.length; i++) {
      var charCode = str2.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
  return internal$1;
}
var utf32$1 = {};
var hasRequiredUtf32$1;
function requireUtf32$1() {
  if (hasRequiredUtf32$1) return utf32$1;
  hasRequiredUtf32$1 = 1;
  var Buffer2 = safer_1.Buffer;
  utf32$1._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv2) {
    this.iconv = iconv2;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32$1.utf32le = { type: "_utf32", isLE: true };
  utf32$1.utf32be = { type: "_utf32", isLE: false };
  utf32$1.ucs4le = "utf32le";
  utf32$1.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str2) {
    var src2 = Buffer2.from(str2, "ucs2");
    var dst = Buffer2.alloc(src2.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src2.length; i += 2) {
      var code = src2.readUInt16LE(i);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer2.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = null;
  }
  Utf32Decoder.prototype.write = function(src2) {
    if (src2.length === 0)
      return "";
    if (this.overflow)
      src2 = Buffer2.concat([this.overflow, src2]);
    var goodLength = src2.length - src2.length % 4;
    if (src2.length !== goodLength) {
      this.overflow = src2.slice(goodLength);
      src2 = src2.slice(0, goodLength);
    } else
      this.overflow = null;
    var dst = Buffer2.alloc(goodLength);
    var offset = 0;
    for (var i = 0; i < goodLength; i += 4) {
      var codepoint = this.isLE ? src2.readUInt32LE(i) : src2.readUInt32BE(i);
      if (codepoint < 65536) {
        dst.writeUInt16LE(codepoint, offset);
        offset += 2;
      } else {
        if (codepoint > 1114111) {
          dst.writeUInt16LE(this.badChar, offset);
          offset += 2;
        } else {
          codepoint -= 65536;
          var high = 55296 | codepoint >> 10;
          var low = 56320 + (codepoint & 1023);
          dst.writeUInt16LE(high, offset);
          offset += 2;
          dst.writeUInt16LE(low, offset);
          offset += 2;
        }
      }
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  Utf32Decoder.prototype.end = function() {
    this.overflow = null;
  };
  utf32$1.utf32 = Utf32AutoCodec;
  utf32$1.ucs4 = Utf32AutoCodec;
  function Utf32AutoCodec(options, iconv2) {
    this.iconv = iconv2;
=======
  return c.prototype.write = function(s) {
    for (var u = this.acc, l = this.contBytes, p = this.accBytes, d = "", m = 0; m < s.length; m++) {
      var g = s[m];
      (g & 192) !== 128 ? (l > 0 && (d += this.defaultCharUnicode, l = 0), g < 128 ? d += String.fromCharCode(g) : g < 224 ? (u = g & 31, l = 1, p = 1) : g < 240 ? (u = g & 15, l = 2, p = 1) : d += this.defaultCharUnicode) : l > 0 ? (u = u << 6 | g & 63, l--, p++, l === 0 && (p === 2 && u < 128 && u > 0 ? d += this.defaultCharUnicode : p === 3 && u < 2048 ? d += this.defaultCharUnicode : d += String.fromCharCode(u))) : d += this.defaultCharUnicode;
    }
    return this.acc = u, this.contBytes = l, this.accBytes = p, d;
  }, c.prototype.end = function() {
    var s = 0;
    return this.contBytes > 0 && (s += this.defaultCharUnicode), s;
  }, mc;
}
var Pt = {}, Lf;
function VS() {
  if (Lf) return Pt;
  Lf = 1;
  var e = Vn().Buffer;
  Pt._utf32 = t;
  function t(s, u) {
    this.iconv = u, this.bomAware = !0, this.isLE = s.isLE;
  }
  Pt.utf32le = { type: "_utf32", isLE: !0 }, Pt.utf32be = { type: "_utf32", isLE: !1 }, Pt.ucs4le = "utf32le", Pt.ucs4be = "utf32be", t.prototype.encoder = n, t.prototype.decoder = r;
  function n(s, u) {
    this.isLE = u.isLE, this.highSurrogate = 0;
  }
  n.prototype.write = function(s) {
    for (var u = e.from(s, "ucs2"), l = e.alloc(u.length * 2), p = this.isLE ? l.writeUInt32LE : l.writeUInt32BE, d = 0, m = 0; m < u.length; m += 2) {
      var g = u.readUInt16LE(m), v = 55296 <= g && g < 56320, y = 56320 <= g && g < 57344;
      if (this.highSurrogate)
        if (v || !y)
          p.call(l, this.highSurrogate, d), d += 4;
        else {
          var x = (this.highSurrogate - 55296 << 10 | g - 56320) + 65536;
          p.call(l, x, d), d += 4, this.highSurrogate = 0;
          continue;
        }
      v ? this.highSurrogate = g : (p.call(l, g, d), d += 4, this.highSurrogate = 0);
    }
    return d < l.length && (l = l.slice(0, d)), l;
  }, n.prototype.end = function() {
    if (this.highSurrogate) {
      var s = e.alloc(4);
      return this.isLE ? s.writeUInt32LE(this.highSurrogate, 0) : s.writeUInt32BE(this.highSurrogate, 0), this.highSurrogate = 0, s;
    }
  };
  function r(s, u) {
    this.isLE = u.isLE, this.badChar = u.iconv.defaultCharUnicode.charCodeAt(0), this.overflow = null;
  }
  r.prototype.write = function(s) {
    if (s.length === 0)
      return "";
    this.overflow && (s = e.concat([this.overflow, s]));
    var u = s.length - s.length % 4;
    s.length !== u ? (this.overflow = s.slice(u), s = s.slice(0, u)) : this.overflow = null;
    for (var l = e.alloc(u), p = 0, d = 0; d < u; d += 4) {
      var m = this.isLE ? s.readUInt32LE(d) : s.readUInt32BE(d);
      if (m < 65536)
        l.writeUInt16LE(m, p), p += 2;
      else if (m > 1114111)
        l.writeUInt16LE(this.badChar, p), p += 2;
      else {
        m -= 65536;
        var g = 55296 | m >> 10, v = 56320 + (m & 1023);
        l.writeUInt16LE(g, p), p += 2, l.writeUInt16LE(v, p), p += 2;
      }
    }
    return l.slice(0, p).toString("ucs2");
  }, r.prototype.end = function() {
    this.overflow = null;
  }, Pt.utf32 = i, Pt.ucs4 = i;
  function i(s, u) {
    this.iconv = u;
  }
  i.prototype.encoder = a, i.prototype.decoder = o;
  function a(s, u) {
    s = s || {}, s.addBOM === void 0 && (s.addBOM = !0), this.encoder = u.iconv.getEncoder(s.defaultEncoding || "utf-32le", s);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  a.prototype.write = function(s) {
    return this.encoder.write(s);
  }, a.prototype.end = function() {
    return this.encoder.end();
  };
  function o(s, u) {
    this.decoder = null, this.initialBytes = [], this.initialBytesLen = 0, this.options = s || {}, this.iconv = u.iconv;
  }
  o.prototype.write = function(s) {
    if (!this.decoder) {
      if (this.initialBytes.push(s), this.initialBytesLen += s.length, this.initialBytesLen < 32)
        return "";
      var u = e.concat(this.initialBytes), l = c(u, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(l, this.options), this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(s);
  }, o.prototype.end = function() {
    if (!this.decoder) {
      var s = e.concat(this.initialBytes), u = c(s, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(u, this.options);
      var l = this.decoder.write(s), p = this.decoder.end();
      return p ? l + p : l;
    }
    return this.decoder.end();
  };
  function c(s, u) {
    var l = u || "utf-32le";
    if (s.length >= 4)
      if (s.readUInt32BE(0) === 65279)
        l = "utf-32be";
      else if (s.readUInt32LE(0) === 65279)
        l = "utf-32le";
      else {
        for (var p = 0, d = 0, m = 0, g = 0, v = Math.min(s.length - s.length % 4, 128), y = 0; y < v; y += 4) {
          var x = s[y], w = s[y + 1], A = s[y + 2], O = s[y + 3];
          (x !== 0 || w > 16) && ++d, (O !== 0 || A > 16) && ++p, x === 0 && w === 0 && A === 0 && O !== 0 && g++, x !== 0 && w === 0 && A === 0 && O === 0 && m++;
        }
        d < p ? l = "utf-32be" : p < d && (l = "utf-32le"), g > m ? l = "utf-32be" : g < m && (l = "utf-32le");
      }
<<<<<<< HEAD
    }
    return enc;
  }
  return utf32$1;
}
var utf16$1 = {};
var hasRequiredUtf16$1;
function requireUtf16$1() {
  if (hasRequiredUtf16$1) return utf16$1;
  hasRequiredUtf16$1 = 1;
  var Buffer2 = safer_1.Buffer;
  utf16$1.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str2) {
    var buf = Buffer2.from(str2, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
=======
    return l;
  }
  return Pt;
}
var wa = {}, Uf;
function YS() {
  if (Uf) return wa;
  Uf = 1;
  var e = Vn().Buffer;
  wa.utf16be = t;
  function t() {
  }
  t.prototype.encoder = n, t.prototype.decoder = r, t.prototype.bomAware = !0;
  function n() {
  }
  n.prototype.write = function(s) {
    for (var u = e.from(s, "ucs2"), l = 0; l < u.length; l += 2) {
      var p = u[l];
      u[l] = u[l + 1], u[l + 1] = p;
    }
    return u;
  }, n.prototype.end = function() {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  };
  function r() {
    this.overflowByte = -1;
  }
  r.prototype.write = function(s) {
    if (s.length == 0)
      return "";
<<<<<<< HEAD
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
  };
  utf16$1.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv2) {
    this.iconv = iconv2;
=======
    var u = e.alloc(s.length + 1), l = 0, p = 0;
    for (this.overflowByte !== -1 && (u[0] = s[0], u[1] = this.overflowByte, l = 1, p = 2); l < s.length - 1; l += 2, p += 2)
      u[p] = s[l + 1], u[p + 1] = s[l];
    return this.overflowByte = l == s.length - 1 ? s[s.length - 1] : -1, u.slice(0, p).toString("ucs2");
  }, r.prototype.end = function() {
  }, wa.utf16 = i;
  function i(s, u) {
    this.iconv = u;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  i.prototype.encoder = a, i.prototype.decoder = o;
  function a(s, u) {
    s = s || {}, s.addBOM === void 0 && (s.addBOM = !0), this.encoder = u.iconv.getEncoder("utf-16le", s);
  }
  a.prototype.write = function(s) {
    return this.encoder.write(s);
  }, a.prototype.end = function() {
    return this.encoder.end();
  };
  function o(s, u) {
    this.decoder = null, this.initialBytes = [], this.initialBytesLen = 0, this.options = s || {}, this.iconv = u.iconv;
  }
  o.prototype.write = function(s) {
    if (!this.decoder) {
      if (this.initialBytes.push(s), this.initialBytesLen += s.length, this.initialBytesLen < 16)
        return "";
      var s = e.concat(this.initialBytes), u = c(s, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(u, this.options), this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(s);
  }, o.prototype.end = function() {
    if (!this.decoder) {
      var s = e.concat(this.initialBytes), u = c(s, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(u, this.options);
      var l = this.decoder.write(s), p = this.decoder.end();
      return p ? l + p : l;
    }
    return this.decoder.end();
  };
  function c(s, u) {
    var l = u || "utf-16le";
    if (s.length >= 2)
      if (s[0] == 254 && s[1] == 255)
        l = "utf-16be";
      else if (s[0] == 255 && s[1] == 254)
        l = "utf-16le";
      else {
        for (var p = 0, d = 0, m = Math.min(s.length - s.length % 2, 64), g = 0; g < m; g += 2)
          s[g] === 0 && s[g + 1] !== 0 && d++, s[g] !== 0 && s[g + 1] === 0 && p++;
        d > p ? l = "utf-16be" : d < p && (l = "utf-16le");
      }
    return l;
  }
<<<<<<< HEAD
  return utf16$1;
}
var utf7$1 = {};
var hasRequiredUtf7$1;
function requireUtf7$1() {
  if (hasRequiredUtf7$1) return utf7$1;
  hasRequiredUtf7$1 = 1;
  var Buffer2 = safer_1.Buffer;
  utf7$1.utf7 = Utf7Codec;
  utf7$1.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv2) {
    this.iconv = iconv2;
=======
  return wa;
}
var Yr = {}, Bf;
function XS() {
  if (Bf) return Yr;
  Bf = 1;
  var e = Vn().Buffer;
  Yr.utf7 = t, Yr.unicode11utf7 = "utf7";
  function t(v, y) {
    this.iconv = y;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  t.prototype.encoder = r, t.prototype.decoder = i, t.prototype.bomAware = !0;
  var n = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function r(v, y) {
    this.iconv = y.iconv;
  }
  r.prototype.write = function(v) {
    return e.from(v.replace(n, (function(y) {
      return "+" + (y === "+" ? "" : this.iconv.encode(y, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
  }, r.prototype.end = function() {
  };
  function i(v, y) {
    this.iconv = y.iconv, this.inBase64 = !1, this.base64Accum = "";
  }
  for (var a = /[A-Za-z0-9\/+]/, o = [], c = 0; c < 256; c++)
    o[c] = a.test(String.fromCharCode(c));
  var s = 43, u = 45, l = 38;
  i.prototype.write = function(v) {
    for (var y = "", x = 0, w = this.inBase64, A = this.base64Accum, O = 0; O < v.length; O++)
      if (!w)
        v[O] == s && (y += this.iconv.decode(v.slice(x, O), "ascii"), x = O + 1, w = !0);
      else if (!o[v[O]]) {
        if (O == x && v[O] == u)
          y += "+";
        else {
          var k = A + v.slice(x, O).toString();
          y += this.iconv.decode(e.from(k, "base64"), "utf16-be");
        }
        v[O] != u && O--, x = O + 1, w = !1, A = "";
      }
    if (!w)
      y += this.iconv.decode(v.slice(x), "ascii");
    else {
      var k = A + v.slice(x).toString(), q = k.length - k.length % 8;
      A = k.slice(q), k = k.slice(0, q), y += this.iconv.decode(e.from(k, "base64"), "utf16-be");
    }
<<<<<<< HEAD
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  utf7$1.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv2) {
    this.iconv = iconv2;
=======
    return this.inBase64 = w, this.base64Accum = A, y;
  }, i.prototype.end = function() {
    var v = "";
    return this.inBase64 && this.base64Accum.length > 0 && (v = this.iconv.decode(e.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", v;
  }, Yr.utf7imap = p;
  function p(v, y) {
    this.iconv = y;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  p.prototype.encoder = d, p.prototype.decoder = m, p.prototype.bomAware = !0;
  function d(v, y) {
    this.iconv = y.iconv, this.inBase64 = !1, this.base64Accum = e.alloc(6), this.base64AccumIdx = 0;
  }
  d.prototype.write = function(v) {
    for (var y = this.inBase64, x = this.base64Accum, w = this.base64AccumIdx, A = e.alloc(v.length * 5 + 10), O = 0, k = 0; k < v.length; k++) {
      var q = v.charCodeAt(k);
      32 <= q && q <= 126 ? (y && (w > 0 && (O += A.write(x.slice(0, w).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), O), w = 0), A[O++] = u, y = !1), y || (A[O++] = q, q === l && (A[O++] = u))) : (y || (A[O++] = l, y = !0), y && (x[w++] = q >> 8, x[w++] = q & 255, w == x.length && (O += A.write(x.toString("base64").replace(/\//g, ","), O), w = 0)));
    }
    return this.inBase64 = y, this.base64AccumIdx = w, A.slice(0, O);
  }, d.prototype.end = function() {
    var v = e.alloc(10), y = 0;
    return this.inBase64 && (this.base64AccumIdx > 0 && (y += v.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), y), this.base64AccumIdx = 0), v[y++] = u, this.inBase64 = !1), v.slice(0, y);
  };
  function m(v, y) {
    this.iconv = y.iconv, this.inBase64 = !1, this.base64Accum = "";
  }
  var g = o.slice();
  return g[44] = !0, m.prototype.write = function(v) {
    for (var y = "", x = 0, w = this.inBase64, A = this.base64Accum, O = 0; O < v.length; O++)
      if (!w)
        v[O] == l && (y += this.iconv.decode(v.slice(x, O), "ascii"), x = O + 1, w = !0);
      else if (!g[v[O]]) {
        if (O == x && v[O] == u)
          y += "&";
        else {
          var k = A + v.slice(x, O).toString().replace(/,/g, "/");
          y += this.iconv.decode(e.from(k, "base64"), "utf16-be");
        }
        v[O] != u && O--, x = O + 1, w = !1, A = "";
      }
    if (!w)
      y += this.iconv.decode(v.slice(x), "ascii");
    else {
      var k = A + v.slice(x).toString().replace(/,/g, "/"), q = k.length - k.length % 8;
      A = k.slice(q), k = k.slice(0, q), y += this.iconv.decode(e.from(k, "base64"), "utf16-be");
    }
<<<<<<< HEAD
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  return utf7$1;
}
var sbcsCodec$1 = {};
var hasRequiredSbcsCodec$1;
function requireSbcsCodec$1() {
  if (hasRequiredSbcsCodec$1) return sbcsCodec$1;
  hasRequiredSbcsCodec$1 = 1;
  var Buffer2 = safer_1.Buffer;
  sbcsCodec$1._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv2) {
    if (!codecOptions)
=======
    return this.inBase64 = w, this.base64Accum = A, y;
  }, m.prototype.end = function() {
    var v = "";
    return this.inBase64 && this.base64Accum.length > 0 && (v = this.iconv.decode(e.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = !1, this.base64Accum = "", v;
  }, Yr;
}
var vc = {}, jf;
function KS() {
  if (jf) return vc;
  jf = 1;
  var e = Vn().Buffer;
  vc._sbcs = t;
  function t(i, a) {
    if (!i)
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      throw new Error("SBCS codec is called without the data.");
    if (!i.chars || i.chars.length !== 128 && i.chars.length !== 256)
      throw new Error("Encoding '" + i.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (i.chars.length === 128) {
      for (var o = "", c = 0; c < 128; c++)
        o += String.fromCharCode(c);
      i.chars = o + i.chars;
    }
    this.decodeBuf = e.from(i.chars, "ucs2");
    for (var s = e.alloc(65536, a.defaultCharSingleByte.charCodeAt(0)), c = 0; c < i.chars.length; c++)
      s[i.chars.charCodeAt(c)] = c;
    this.encodeBuf = s;
  }
  t.prototype.encoder = n, t.prototype.decoder = r;
  function n(i, a) {
    this.encodeBuf = a.encodeBuf;
  }
  n.prototype.write = function(i) {
    for (var a = e.alloc(i.length), o = 0; o < i.length; o++)
      a[o] = this.encodeBuf[i.charCodeAt(o)];
    return a;
  }, n.prototype.end = function() {
  };
  function r(i, a) {
    this.decodeBuf = a.decodeBuf;
  }
<<<<<<< HEAD
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec$1;
}
var sbcsData$1;
var hasRequiredSbcsData$1;
function requireSbcsData$1() {
  if (hasRequiredSbcsData$1) return sbcsData$1;
  hasRequiredSbcsData$1 = 1;
  sbcsData$1 = {
=======
  return r.prototype.write = function(i) {
    for (var a = this.decodeBuf, o = e.alloc(i.length * 2), c = 0, s = 0, u = 0; u < i.length; u++)
      c = i[u] * 2, s = u * 2, o[s] = a[c], o[s + 1] = a[c + 1];
    return o.toString("ucs2");
  }, r.prototype.end = function() {
  }, vc;
}
var gc, Mf;
function JS() {
  return Mf || (Mf = 1, gc = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    // Not supported by iconv, not sure why.
    10029: "maccenteuro",
    maccenteuro: {
      type: "_sbcs",
      chars: ""
    },
    808: "cp808",
    ibm808: "cp808",
    cp808: {
      type: "_sbcs",
      chars: ""
    },
    mik: {
      type: "_sbcs",
      chars: ""
    },
    cp720: {
      type: "_sbcs",
      chars: ""
    },
    // Aliases of generated encodings.
<<<<<<< HEAD
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData$1;
}
var sbcsDataGenerated$1;
var hasRequiredSbcsDataGenerated$1;
function requireSbcsDataGenerated$1() {
  if (hasRequiredSbcsDataGenerated$1) return sbcsDataGenerated$1;
  hasRequiredSbcsDataGenerated$1 = 1;
  sbcsDataGenerated$1 = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "\uFEFF"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated$1;
}
var dbcsCodec$1 = {};
var hasRequiredDbcsCodec$1;
function requireDbcsCodec$1() {
  if (hasRequiredDbcsCodec$1) return dbcsCodec$1;
  hasRequiredDbcsCodec$1 = 1;
  var Buffer2 = safer_1.Buffer;
  dbcsCodec$1._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv2) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv2.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv2.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j = 48; j <= 57; j++)
          secondByteNode[j] = NODE_START - thirdByteNodeIdx;
      }
      for (var i2 = 129; i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48; i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
=======
    ascii8bit: "ascii",
    usascii: "ascii",
    ansix34: "ascii",
    ansix341968: "ascii",
    ansix341986: "ascii",
    csascii: "ascii",
    cp367: "ascii",
    ibm367: "ascii",
    isoir6: "ascii",
    iso646us: "ascii",
    iso646irv: "ascii",
    us: "ascii",
    latin1: "iso88591",
    latin2: "iso88592",
    latin3: "iso88593",
    latin4: "iso88594",
    latin5: "iso88599",
    latin6: "iso885910",
    latin7: "iso885913",
    latin8: "iso885914",
    latin9: "iso885915",
    latin10: "iso885916",
    csisolatin1: "iso88591",
    csisolatin2: "iso88592",
    csisolatin3: "iso88593",
    csisolatin4: "iso88594",
    csisolatincyrillic: "iso88595",
    csisolatinarabic: "iso88596",
    csisolatingreek: "iso88597",
    csisolatinhebrew: "iso88598",
    csisolatin5: "iso88599",
    csisolatin6: "iso885910",
    l1: "iso88591",
    l2: "iso88592",
    l3: "iso88593",
    l4: "iso88594",
    l5: "iso88599",
    l6: "iso885910",
    l7: "iso885913",
    l8: "iso885914",
    l9: "iso885915",
    l10: "iso885916",
    isoir14: "iso646jp",
    isoir57: "iso646cn",
    isoir100: "iso88591",
    isoir101: "iso88592",
    isoir109: "iso88593",
    isoir110: "iso88594",
    isoir144: "iso88595",
    isoir127: "iso88596",
    isoir126: "iso88597",
    isoir138: "iso88598",
    isoir148: "iso88599",
    isoir157: "iso885910",
    isoir166: "tis620",
    isoir179: "iso885913",
    isoir199: "iso885914",
    isoir203: "iso885915",
    isoir226: "iso885916",
    cp819: "iso88591",
    ibm819: "iso88591",
    cyrillic: "iso88595",
    arabic: "iso88596",
    arabic8: "iso88596",
    ecma114: "iso88596",
    asmo708: "iso88596",
    greek: "iso88597",
    greek8: "iso88597",
    ecma118: "iso88597",
    elot928: "iso88597",
    hebrew: "iso88598",
    hebrew8: "iso88598",
    turkish: "iso88599",
    turkish8: "iso88599",
    thai: "iso885911",
    thai8: "iso885911",
    celtic: "iso885914",
    celtic8: "iso885914",
    isoceltic: "iso885914",
    tis6200: "tis620",
    tis62025291: "tis620",
    tis62025330: "tis620",
    1e4: "macroman",
    10006: "macgreek",
    10007: "maccyrillic",
    10079: "maciceland",
    10081: "macturkish",
    cspc8codepage437: "cp437",
    cspc775baltic: "cp775",
    cspc850multilingual: "cp850",
    cspcp852: "cp852",
    cspc862latinhebrew: "cp862",
    cpgr: "cp869",
    msee: "cp1250",
    mscyrl: "cp1251",
    msansi: "cp1252",
    msgreek: "cp1253",
    msturk: "cp1254",
    mshebr: "cp1255",
    msarab: "cp1256",
    winbaltrim: "cp1257",
    cp20866: "koi8r",
    20866: "koi8r",
    ibm878: "koi8r",
    cskoi8r: "koi8r",
    cp21866: "koi8u",
    21866: "koi8u",
    ibm1168: "koi8u",
    strk10482002: "rk1048",
    tcvn5712: "tcvn",
    tcvn57121: "tcvn",
    gb198880: "iso646cn",
    cn: "iso646cn",
    csiso14jisc6220ro: "iso646jp",
    jisc62201969ro: "iso646jp",
    jp: "iso646jp",
    cshproman8: "hproman8",
    r8: "hproman8",
    roman8: "hproman8",
    xroman8: "hproman8",
    ibm1051: "hproman8",
    mac: "macintosh",
    csmacintosh: "macintosh"
  }), gc;
}
var xc, qf;
function ZS() {
  return qf || (qf = 1, xc = {
    437: "cp437",
    737: "cp737",
    775: "cp775",
    850: "cp850",
    852: "cp852",
    855: "cp855",
    856: "cp856",
    857: "cp857",
    858: "cp858",
    860: "cp860",
    861: "cp861",
    862: "cp862",
    863: "cp863",
    864: "cp864",
    865: "cp865",
    866: "cp866",
    869: "cp869",
    874: "windows874",
    922: "cp922",
    1046: "cp1046",
    1124: "cp1124",
    1125: "cp1125",
    1129: "cp1129",
    1133: "cp1133",
    1161: "cp1161",
    1162: "cp1162",
    1163: "cp1163",
    1250: "windows1250",
    1251: "windows1251",
    1252: "windows1252",
    1253: "windows1253",
    1254: "windows1254",
    1255: "windows1255",
    1256: "windows1256",
    1257: "windows1257",
    1258: "windows1258",
    28591: "iso88591",
    28592: "iso88592",
    28593: "iso88593",
    28594: "iso88594",
    28595: "iso88595",
    28596: "iso88596",
    28597: "iso88597",
    28598: "iso88598",
    28599: "iso88599",
    28600: "iso885910",
    28601: "iso885911",
    28603: "iso885913",
    28604: "iso885914",
    28605: "iso885915",
    28606: "iso885916",
    windows874: {
      type: "_sbcs",
      chars: ""
    },
    win874: "windows874",
    cp874: "windows874",
    windows1250: {
      type: "_sbcs",
      chars: ""
    },
    win1250: "windows1250",
    cp1250: "windows1250",
    windows1251: {
      type: "_sbcs",
      chars: ""
    },
    win1251: "windows1251",
    cp1251: "windows1251",
    windows1252: {
      type: "_sbcs",
      chars: ""
    },
    win1252: "windows1252",
    cp1252: "windows1252",
    windows1253: {
      type: "_sbcs",
      chars: ""
    },
    win1253: "windows1253",
    cp1253: "windows1253",
    windows1254: {
      type: "_sbcs",
      chars: ""
    },
    win1254: "windows1254",
    cp1254: "windows1254",
    windows1255: {
      type: "_sbcs",
      chars: ""
    },
    win1255: "windows1255",
    cp1255: "windows1255",
    windows1256: {
      type: "_sbcs",
      chars: ""
    },
    win1256: "windows1256",
    cp1256: "windows1256",
    windows1257: {
      type: "_sbcs",
      chars: ""
    },
    win1257: "windows1257",
    cp1257: "windows1257",
    windows1258: {
      type: "_sbcs",
      chars: ""
    },
    win1258: "windows1258",
    cp1258: "windows1258",
    iso88591: {
      type: "_sbcs",
      chars: ""
    },
    cp28591: "iso88591",
    iso88592: {
      type: "_sbcs",
      chars: ""
    },
    cp28592: "iso88592",
    iso88593: {
      type: "_sbcs",
      chars: ""
    },
    cp28593: "iso88593",
    iso88594: {
      type: "_sbcs",
      chars: ""
    },
    cp28594: "iso88594",
    iso88595: {
      type: "_sbcs",
      chars: ""
    },
    cp28595: "iso88595",
    iso88596: {
      type: "_sbcs",
      chars: ""
    },
    cp28596: "iso88596",
    iso88597: {
      type: "_sbcs",
      chars: ""
    },
    cp28597: "iso88597",
    iso88598: {
      type: "_sbcs",
      chars: ""
    },
    cp28598: "iso88598",
    iso88599: {
      type: "_sbcs",
      chars: ""
    },
    cp28599: "iso88599",
    iso885910: {
      type: "_sbcs",
      chars: ""
    },
    cp28600: "iso885910",
    iso885911: {
      type: "_sbcs",
      chars: ""
    },
    cp28601: "iso885911",
    iso885913: {
      type: "_sbcs",
      chars: ""
    },
    cp28603: "iso885913",
    iso885914: {
      type: "_sbcs",
      chars: ""
    },
    cp28604: "iso885914",
    iso885915: {
      type: "_sbcs",
      chars: ""
    },
    cp28605: "iso885915",
    iso885916: {
      type: "_sbcs",
      chars: ""
    },
    cp28606: "iso885916",
    cp437: {
      type: "_sbcs",
      chars: ""
    },
    ibm437: "cp437",
    csibm437: "cp437",
    cp737: {
      type: "_sbcs",
      chars: ""
    },
    ibm737: "cp737",
    csibm737: "cp737",
    cp775: {
      type: "_sbcs",
      chars: ""
    },
    ibm775: "cp775",
    csibm775: "cp775",
    cp850: {
      type: "_sbcs",
      chars: ""
    },
    ibm850: "cp850",
    csibm850: "cp850",
    cp852: {
      type: "_sbcs",
      chars: ""
    },
    ibm852: "cp852",
    csibm852: "cp852",
    cp855: {
      type: "_sbcs",
      chars: ""
    },
    ibm855: "cp855",
    csibm855: "cp855",
    cp856: {
      type: "_sbcs",
      chars: ""
    },
    ibm856: "cp856",
    csibm856: "cp856",
    cp857: {
      type: "_sbcs",
      chars: ""
    },
    ibm857: "cp857",
    csibm857: "cp857",
    cp858: {
      type: "_sbcs",
      chars: ""
    },
    ibm858: "cp858",
    csibm858: "cp858",
    cp860: {
      type: "_sbcs",
      chars: ""
    },
    ibm860: "cp860",
    csibm860: "cp860",
    cp861: {
      type: "_sbcs",
      chars: ""
    },
    ibm861: "cp861",
    csibm861: "cp861",
    cp862: {
      type: "_sbcs",
      chars: ""
    },
    ibm862: "cp862",
    csibm862: "cp862",
    cp863: {
      type: "_sbcs",
      chars: ""
    },
    ibm863: "cp863",
    csibm863: "cp863",
    cp864: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    ibm864: "cp864",
    csibm864: "cp864",
    cp865: {
      type: "_sbcs",
      chars: ""
    },
    ibm865: "cp865",
    csibm865: "cp865",
    cp866: {
      type: "_sbcs",
      chars: ""
    },
    ibm866: "cp866",
    csibm866: "cp866",
    cp869: {
      type: "_sbcs",
      chars: ""
    },
    ibm869: "cp869",
    csibm869: "cp869",
    cp922: {
      type: "_sbcs",
      chars: ""
    },
    ibm922: "cp922",
    csibm922: "cp922",
    cp1046: {
      type: "_sbcs",
      chars: ""
    },
    ibm1046: "cp1046",
    csibm1046: "cp1046",
    cp1124: {
      type: "_sbcs",
      chars: ""
    },
    ibm1124: "cp1124",
    csibm1124: "cp1124",
    cp1125: {
      type: "_sbcs",
      chars: ""
    },
    ibm1125: "cp1125",
    csibm1125: "cp1125",
    cp1129: {
      type: "_sbcs",
      chars: ""
    },
    ibm1129: "cp1129",
    csibm1129: "cp1129",
    cp1133: {
      type: "_sbcs",
      chars: ""
    },
    ibm1133: "cp1133",
    csibm1133: "cp1133",
    cp1161: {
      type: "_sbcs",
      chars: ""
    },
    ibm1161: "cp1161",
    csibm1161: "cp1161",
    cp1162: {
      type: "_sbcs",
      chars: ""
    },
    ibm1162: "cp1162",
    csibm1162: "cp1162",
    cp1163: {
      type: "_sbcs",
      chars: ""
    },
    ibm1163: "cp1163",
    csibm1163: "cp1163",
    maccroatian: {
      type: "_sbcs",
      chars: ""
    },
    maccyrillic: {
      type: "_sbcs",
      chars: ""
    },
    macgreek: {
      type: "_sbcs",
      chars: ""
    },
    maciceland: {
      type: "_sbcs",
      chars: ""
    },
    macroman: {
      type: "_sbcs",
      chars: ""
    },
    macromania: {
      type: "_sbcs",
      chars: ""
    },
    macthai: {
      type: "_sbcs",
      chars: "\uFEFF"
    },
    macturkish: {
      type: "_sbcs",
      chars: ""
    },
    macukraine: {
      type: "_sbcs",
      chars: ""
    },
    koi8r: {
      type: "_sbcs",
      chars: ""
    },
    koi8u: {
      type: "_sbcs",
      chars: ""
    },
    koi8ru: {
      type: "_sbcs",
      chars: ""
    },
    koi8t: {
      type: "_sbcs",
      chars: ""
    },
    armscii8: {
      type: "_sbcs",
      chars: ")(.,-"
    },
    rk1048: {
      type: "_sbcs",
      chars: ""
    },
    tcvn: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    georgianacademy: {
      type: "_sbcs",
      chars: ""
    },
    georgianps: {
      type: "_sbcs",
      chars: ""
    },
    pt154: {
      type: "_sbcs",
      chars: ""
    },
    viscii: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~`
    },
    iso646cn: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    iso646jp: {
      type: "_sbcs",
      chars: `\0\x07\b	
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_\`abcdefghijklmnopqrstuvwxyz{|}`
    },
    hproman8: {
      type: "_sbcs",
      chars: ""
    },
    macintosh: {
      type: "_sbcs",
      chars: ""
    },
    ascii: {
      type: "_sbcs",
      chars: ""
    },
    tis620: {
      type: "_sbcs",
      chars: ""
    }
  }), xc;
}
var yc = {}, zf;
function QS() {
  if (zf) return yc;
  zf = 1;
  var e = Vn().Buffer;
  yc._dbcs = s;
  for (var t = -1, n = -2, r = -10, i = -1e3, a = new Array(256), o = -1, c = 0; c < 256; c++)
    a[c] = t;
  function s(d, m) {
    if (this.encodingName = d.encodingName, !d)
      throw new Error("DBCS codec is called without the data.");
    if (!d.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var g = d.table();
    this.decodeTables = [], this.decodeTables[0] = a.slice(0), this.decodeTableSeq = [];
    for (var v = 0; v < g.length; v++)
      this._addDecodeChunk(g[v]);
    this.defaultCharUnicode = m.defaultCharUnicode, this.encodeTable = [], this.encodeTableSeq = [];
    var y = {};
    if (d.encodeSkipVals)
      for (var v = 0; v < d.encodeSkipVals.length; v++) {
        var x = d.encodeSkipVals[v];
        if (typeof x == "number")
          y[x] = !0;
        else
          for (var w = x.from; w <= x.to; w++)
            y[w] = !0;
      }
    if (this._fillEncodeTable(0, 0, y), d.encodeAdd)
      for (var A in d.encodeAdd)
        Object.prototype.hasOwnProperty.call(d.encodeAdd, A) && this._setEncodeChar(A.charCodeAt(0), d.encodeAdd[A]);
    if (this.defCharSB = this.encodeTable[0][m.defaultCharSingleByte.charCodeAt(0)], this.defCharSB === t && (this.defCharSB = this.encodeTable[0]["?"]), this.defCharSB === t && (this.defCharSB = 63), typeof d.gb18030 == "function") {
      this.gb18030 = d.gb18030();
      for (var O = this.decodeTables.length, k = this.decodeTables[O] = a.slice(0), q = this.decodeTables.length, W = this.decodeTables[q] = a.slice(0), v = 129; v <= 254; v++)
        for (var te = i - this.decodeTables[0][v], T = this.decodeTables[te], w = 48; w <= 57; w++)
          T[w] = i - O;
      for (var v = 129; v <= 254; v++)
        k[v] = i - q;
      for (var v = 48; v <= 57; v++)
        W[v] = n;
    }
  }
  s.prototype.encoder = u, s.prototype.decoder = l, s.prototype._getDecodeTrieNode = function(d) {
    for (var m = []; d > 0; d >>= 8)
      m.push(d & 255);
    m.length == 0 && m.push(0);
    for (var g = this.decodeTables[0], v = m.length - 1; v > 0; v--) {
      var y = g[m[v]];
      if (y == t)
        g[m[v]] = i - this.decodeTables.length, this.decodeTables.push(g = a.slice(0));
      else if (y <= i)
        g = this.decodeTables[i - y];
      else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + d.toString(16));
    }
    return g;
  }, s.prototype._addDecodeChunk = function(d) {
    var m = parseInt(d[0], 16), g = this._getDecodeTrieNode(m);
    m = m & 255;
    for (var v = 1; v < d.length; v++) {
      var y = d[v];
      if (typeof y == "string")
        for (var x = 0; x < y.length; ) {
          var w = y.charCodeAt(x++);
          if (55296 <= w && w < 56320) {
            var A = y.charCodeAt(x++);
            if (56320 <= A && A < 57344)
              g[m++] = 65536 + (w - 55296) * 1024 + (A - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + d[0]);
          } else if (4080 < w && w <= 4095) {
            for (var O = 4095 - w + 2, k = [], q = 0; q < O; q++)
              k.push(y.charCodeAt(x++));
            g[m++] = r - this.decodeTableSeq.length, this.decodeTableSeq.push(k);
          } else
            g[m++] = w;
        }
      else if (typeof y == "number")
        for (var W = g[m - 1] + 1, x = 0; x < y; x++)
          g[m++] = W++;
      else
        throw new Error("Incorrect type '" + typeof y + "' given in " + this.encodingName + " at chunk " + d[0]);
    }
    if (m > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + d[0] + ": too long" + m);
  }, s.prototype._getEncodeBucket = function(d) {
    var m = d >> 8;
    return this.encodeTable[m] === void 0 && (this.encodeTable[m] = a.slice(0)), this.encodeTable[m];
  }, s.prototype._setEncodeChar = function(d, m) {
    var g = this._getEncodeBucket(d), v = d & 255;
    g[v] <= r ? this.encodeTableSeq[r - g[v]][o] = m : g[v] == t && (g[v] = m);
  }, s.prototype._setEncodeSequence = function(d, m) {
    var g = d[0], v = this._getEncodeBucket(g), y = g & 255, x;
    v[y] <= r ? x = this.encodeTableSeq[r - v[y]] : (x = {}, v[y] !== t && (x[o] = v[y]), v[y] = r - this.encodeTableSeq.length, this.encodeTableSeq.push(x));
    for (var w = 1; w < d.length - 1; w++) {
      var A = x[g];
      typeof A == "object" ? x = A : (x = x[g] = {}, A !== void 0 && (x[o] = A));
    }
    g = d[d.length - 1], x[g] = m;
  }, s.prototype._fillEncodeTable = function(d, m, g) {
    for (var v = this.decodeTables[d], y = 0; y < 256; y++) {
      var x = v[y], w = m + y;
      g[w] || (x >= 0 ? this._setEncodeChar(x, w) : x <= i ? this._fillEncodeTable(i - x, w << 8, g) : x <= r && this._setEncodeSequence(this.decodeTableSeq[r - x], w));
    }
  };
  function u(d, m) {
    this.leadSurrogate = -1, this.seqObj = void 0, this.encodeTable = m.encodeTable, this.encodeTableSeq = m.encodeTableSeq, this.defaultCharSingleByte = m.defCharSB, this.gb18030 = m.gb18030;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  u.prototype.write = function(d) {
    for (var m = e.alloc(d.length * (this.gb18030 ? 4 : 3)), g = this.leadSurrogate, v = this.seqObj, y = -1, x = 0, w = 0; ; ) {
      if (y === -1) {
        if (x == d.length) break;
        var A = d.charCodeAt(x++);
      } else {
        var A = y;
        y = -1;
      }
      if (55296 <= A && A < 57344)
        if (A < 56320)
          if (g === -1) {
            g = A;
            continue;
          } else
            g = A, A = t;
        else
          g !== -1 ? (A = 65536 + (g - 55296) * 1024 + (A - 56320), g = -1) : A = t;
      else g !== -1 && (y = A, A = t, g = -1);
      var O = t;
      if (v !== void 0 && A != t) {
        var k = v[A];
        if (typeof k == "object") {
          v = k;
          continue;
        } else typeof k == "number" ? O = k : k == null && (k = v[o], k !== void 0 && (O = k, y = A));
        v = void 0;
      } else if (A >= 0) {
        var q = this.encodeTable[A >> 8];
        if (q !== void 0 && (O = q[A & 255]), O <= r) {
          v = this.encodeTableSeq[r - O];
          continue;
        }
        if (O == t && this.gb18030) {
          var W = p(this.gb18030.uChars, A);
          if (W != -1) {
            var O = this.gb18030.gbChars[W] + (A - this.gb18030.uChars[W]);
            m[w++] = 129 + Math.floor(O / 12600), O = O % 12600, m[w++] = 48 + Math.floor(O / 1260), O = O % 1260, m[w++] = 129 + Math.floor(O / 10), O = O % 10, m[w++] = 48 + O;
            continue;
          }
        }
      }
      O === t && (O = this.defaultCharSingleByte), O < 256 ? m[w++] = O : O < 65536 ? (m[w++] = O >> 8, m[w++] = O & 255) : (m[w++] = O >> 16, m[w++] = O >> 8 & 255, m[w++] = O & 255);
    }
    return this.seqObj = v, this.leadSurrogate = g, m.slice(0, w);
  }, u.prototype.end = function() {
    if (!(this.leadSurrogate === -1 && this.seqObj === void 0)) {
      var d = e.alloc(10), m = 0;
      if (this.seqObj) {
        var g = this.seqObj[o];
        g !== void 0 && (g < 256 ? d[m++] = g : (d[m++] = g >> 8, d[m++] = g & 255)), this.seqObj = void 0;
      }
      return this.leadSurrogate !== -1 && (d[m++] = this.defaultCharSingleByte, this.leadSurrogate = -1), d.slice(0, m);
    }
  }, u.prototype.findIdx = p;
  function l(d, m) {
    this.nodeIdx = 0, this.prevBuf = e.alloc(0), this.decodeTables = m.decodeTables, this.decodeTableSeq = m.decodeTableSeq, this.defaultCharUnicode = m.defaultCharUnicode, this.gb18030 = m.gb18030;
  }
  l.prototype.write = function(d) {
    var m = e.alloc(d.length * 2), g = this.nodeIdx, v = this.prevBuf, y = this.prevBuf.length, x = -this.prevBuf.length, w;
    y > 0 && (v = e.concat([v, d.slice(0, 10)]));
    for (var A = 0, O = 0; A < d.length; A++) {
      var k = A >= 0 ? d[A] : v[A + y], w = this.decodeTables[g][k];
      if (!(w >= 0)) if (w === t)
        A = x, w = this.defaultCharUnicode.charCodeAt(0);
      else if (w === n) {
        var q = x >= 0 ? d.slice(x, A + 1) : v.slice(x + y, A + 1 + y), W = (q[0] - 129) * 12600 + (q[1] - 48) * 1260 + (q[2] - 129) * 10 + (q[3] - 48), te = p(this.gb18030.gbChars, W);
        w = this.gb18030.uChars[te] + W - this.gb18030.gbChars[te];
      } else if (w <= i) {
        g = i - w;
        continue;
      } else if (w <= r) {
        for (var T = this.decodeTableSeq[r - w], H = 0; H < T.length - 1; H++)
          w = T[H], m[O++] = w & 255, m[O++] = w >> 8;
        w = T[T.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + w + " at " + g + "/" + k);
      if (w > 65535) {
        w -= 65536;
        var j = 55296 + Math.floor(w / 1024);
        m[O++] = j & 255, m[O++] = j >> 8, w = 56320 + w % 1024;
      }
      m[O++] = w & 255, m[O++] = w >> 8, g = 0, x = A + 1;
    }
    return this.nodeIdx = g, this.prevBuf = x >= 0 ? d.slice(x) : v.slice(x + y), m.slice(0, O).toString("ucs2");
  }, l.prototype.end = function() {
    for (var d = ""; this.prevBuf.length > 0; ) {
      d += this.defaultCharUnicode;
      var m = this.prevBuf.slice(1);
      this.prevBuf = e.alloc(0), this.nodeIdx = 0, m.length > 0 && (d += this.write(m));
    }
    return this.nodeIdx = 0, d;
  };
  function p(d, m) {
    if (d[0] > m)
      return -1;
    for (var g = 0, v = d.length; g < v - 1; ) {
      var y = g + Math.floor((v - g + 1) / 2);
      d[y] <= m ? g = y : v = y;
    }
    return g;
  }
<<<<<<< HEAD
  return dbcsCodec$1;
}
const require$$0$1 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
];
const require$$1$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "",
    62
  ],
  [
    "a1a1",
    "",
    9,
    ""
  ],
  [
    "a2a1",
    ""
  ],
  [
    "a2ba",
    ""
  ],
  [
    "a2ca",
    ""
  ],
  [
    "a2dc",
    ""
  ],
  [
    "a2f2",
    ""
  ],
  [
    "a2fe",
    ""
  ],
  [
    "a3b0",
    "",
    9
  ],
  [
    "a3c1",
    "",
    25
  ],
  [
    "a3e1",
    "",
    25
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a8a1",
    ""
  ],
  [
    "ada1",
    "",
    19,
    "",
    9
  ],
  [
    "adc0",
    ""
  ],
  [
    "addf",
    "",
    4,
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fcf1",
    "",
    9,
    ""
  ],
  [
    "8fa2af",
    ""
  ],
  [
    "8fa2c2",
    ""
  ],
  [
    "8fa2eb",
    ""
  ],
  [
    "8fa6e1",
    ""
  ],
  [
    "8fa6e7",
    ""
  ],
  [
    "8fa6e9",
    ""
  ],
  [
    "8fa6ec",
    ""
  ],
  [
    "8fa6f1",
    ""
  ],
  [
    "8fa7c2",
    "",
    10,
    ""
  ],
  [
    "8fa7f2",
    "",
    10,
    ""
  ],
  [
    "8fa9a1",
    ""
  ],
  [
    "8fa9a4",
    ""
  ],
  [
    "8fa9a6",
    ""
  ],
  [
    "8fa9a8",
    ""
  ],
  [
    "8fa9ab",
    ""
  ],
  [
    "8fa9af",
    ""
  ],
  [
    "8fa9c1",
    ""
  ],
  [
    "8faaa1",
    ""
  ],
  [
    "8faaba",
    ""
  ],
  [
    "8faba1",
    ""
  ],
  [
    "8fabbd",
    ""
  ],
  [
    "8fabc5",
    ""
  ],
  [
    "8fb0a1",
    ""
  ],
  [
    "8fb1a1",
    ""
  ],
  [
    "8fb2a1",
    "",
    4,
    ""
  ],
  [
    "8fb3a1",
    ""
  ],
  [
    "8fb4a1",
    ""
  ],
  [
    "8fb5a1",
    ""
  ],
  [
    "8fb6a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fb7a1",
    "",
    4,
    ""
  ],
  [
    "8fb8a1",
    ""
  ],
  [
    "8fb9a1",
    ""
  ],
  [
    "8fbaa1",
    "",
    4,
    ""
  ],
  [
    "8fbba1",
    ""
  ],
  [
    "8fbca1",
    "",
    4,
    ""
  ],
  [
    "8fbda1",
    "",
    4,
    ""
  ],
  [
    "8fbea1",
    "",
    4,
    ""
  ],
  [
    "8fbfa1",
    ""
  ],
  [
    "8fc0a1",
    ""
  ],
  [
    "8fc1a1",
    ""
  ],
  [
    "8fc2a1",
    ""
  ],
  [
    "8fc3a1",
    "",
    4,
    ""
  ],
  [
    "8fc4a1",
    ""
  ],
  [
    "8fc5a1",
    ""
  ],
  [
    "8fc6a1",
    ""
  ],
  [
    "8fc7a1",
    ""
  ],
  [
    "8fc8a1",
    ""
  ],
  [
    "8fc9a1",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8fcaa1",
    ""
  ],
  [
    "8fcba1",
    ""
  ],
  [
    "8fcca1",
    "",
    9,
    ""
  ],
  [
    "8fcda1",
    "",
    5,
    ""
  ],
  [
    "8fcea1",
    "",
    6,
    ""
  ],
  [
    "8fcfa1",
    ""
  ],
  [
    "8fd0a1",
    ""
  ],
  [
    "8fd1a1",
    ""
  ],
  [
    "8fd2a1",
    "",
    5
  ],
  [
    "8fd3a1",
    ""
  ],
  [
    "8fd4a1",
    "",
    4,
    ""
  ],
  [
    "8fd5a1",
    ""
  ],
  [
    "8fd6a1",
    ""
  ],
  [
    "8fd7a1",
    ""
  ],
  [
    "8fd8a1",
    ""
  ],
  [
    "8fd9a1",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8fdaa1",
    "",
    4,
    ""
  ],
  [
    "8fdba1",
    "",
    6,
    ""
  ],
  [
    "8fdca1",
    "",
    4,
    ""
  ],
  [
    "8fdda1",
    "",
    4,
    ""
  ],
  [
    "8fdea1",
    "",
    4,
    ""
  ],
  [
    "8fdfa1",
    ""
  ],
  [
    "8fe0a1",
    ""
  ],
  [
    "8fe1a1",
    "",
    4,
    ""
  ],
  [
    "8fe2a1",
    ""
  ],
  [
    "8fe3a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fe4a1",
    "",
    4,
    ""
  ],
  [
    "8fe5a1",
    "",
    4,
    ""
  ],
  [
    "8fe6a1",
    ""
  ],
  [
    "8fe7a1",
    ""
  ],
  [
    "8fe8a1",
    "",
    4,
    ""
  ],
  [
    "8fe9a1",
    "",
    4
  ],
  [
    "8feaa1",
    "",
    4,
    ""
  ],
  [
    "8feba1",
    "",
    4,
    ""
  ],
  [
    "8feca1",
    ""
  ],
  [
    "8feda1",
    "",
    4,
    "",
    4,
    ""
  ]
];
const require$$2$1 = [
  [
    "0",
    "\0",
    127,
    ""
  ],
  [
    "8140",
    "",
    5,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "8180",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8240",
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    11
  ],
  [
    "8280",
    "",
    10,
    "",
    4,
    "",
    7,
    "",
    5,
    "",
    8,
    "",
    20,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8340",
    "",
    17,
    "",
    5,
    "",
    10,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "8380",
    "",
    5,
    "",
    13,
    "",
    28,
    "",
    4,
    "",
    4,
    "",
    5
  ],
  [
    "8440",
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "8480",
    "",
    9,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    5,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "8540",
    "",
    9,
    ""
  ],
  [
    "8580",
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "8640",
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8680",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8740",
    "",
    7,
    "",
    11,
    "",
    4,
    "",
    4
  ],
  [
    "8780",
    "",
    7,
    "",
    6,
    "",
    14,
    "",
    10,
    "",
    6,
    "",
    12,
    "",
    8,
    "",
    5,
    "",
    6
  ],
  [
    "8840",
    "",
    9,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8880",
    "",
    4,
    "",
    6,
    "",
    8,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    7
  ],
  [
    "8940",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    16,
    ""
  ],
  [
    "8980",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    17,
    "",
    10,
    "",
    13,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "8a40",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "8a80",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    9,
    "",
    5
  ],
  [
    "8b40",
    "",
    8,
    "",
    17,
    "",
    6,
    "",
    13,
    ""
  ],
  [
    "8b80",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    22,
    "",
    11,
    "",
    25,
    "",
    7,
    "",
    6
  ],
  [
    "8c40",
    "",
    7,
    ""
  ],
  [
    "8c80",
    "",
    8,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    4
  ],
  [
    "8d40",
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    9,
    "",
    4
  ],
  [
    "8d80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    10,
    "",
    12,
    "",
    21,
    ""
  ],
  [
    "8e40",
    "",
    21,
    "",
    12,
    "",
    6,
    "",
    12,
    ""
  ],
  [
    "8e80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    4,
    "",
    6
  ],
  [
    "8f40",
    "",
    5,
    "",
    11,
    "",
    8,
    ""
  ],
  [
    "8f80",
    "",
    6,
    "",
    14,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9040",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9080",
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    18,
    "",
    6
  ],
  [
    "9140",
    "",
    6,
    "",
    6,
    "",
    18,
    "",
    4,
    ""
  ],
  [
    "9180",
    "",
    6,
    "",
    8,
    "",
    9,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    16,
    "",
    13,
    "",
    8,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9280",
    "",
    5,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9340",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9380",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    9,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9440",
    "",
    24,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    8
  ],
  [
    "9480",
    "",
    4,
    "",
    4,
    "",
    14,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "9540",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9580",
    "",
    4,
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    25,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "9640",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9680",
    "",
    7,
    "",
    9,
    "",
    7,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    5
  ],
  [
    "9740",
    "",
    7,
    "",
    8,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9780",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    9,
    "",
    4,
    "",
    11,
    "",
    7,
    "",
    16,
    ""
  ],
  [
    "9840",
    "",
    4,
    "",
    5,
    "",
    9,
    ""
  ],
  [
    "9880",
    "",
    7,
    "",
    5,
    "",
    11,
    "",
    9,
    "",
    9,
    "",
    11,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9940",
    "",
    4,
    "",
    10,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    7,
    "",
    5
  ],
  [
    "9980",
    "",
    114,
    "",
    6
  ],
  [
    "9a40",
    "",
    11,
    "",
    7,
    "",
    13,
    ""
  ],
  [
    "9a80",
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "9b40",
    "",
    4,
    ""
  ],
  [
    "9b80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9c40",
    "",
    7,
    ""
  ],
  [
    "9c80",
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    14,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "9d40",
    "",
    7,
    "",
    4,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "9d80",
    "",
    9,
    "",
    5,
    "",
    6,
    "",
    12,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "9e40",
    "",
    7,
    "",
    32,
    "",
    7,
    "",
    6,
    "",
    6
  ],
  [
    "9e80",
    "",
    9,
    "",
    17,
    "",
    13,
    "",
    11,
    "",
    12,
    "",
    12,
    ""
  ],
  [
    "9f40",
    "",
    6,
    "",
    10,
    "",
    4,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "9f80",
    "",
    13,
    "",
    12,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    8,
    "",
    9,
    "",
    4
  ],
  [
    "a040",
    "",
    9,
    "",
    5,
    "",
    9,
    "",
    11,
    "",
    19
  ],
  [
    "a080",
    "",
    9,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    11,
    "",
    6,
    ""
  ],
  [
    "a1a1",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9
  ],
  [
    "a2b1",
    "",
    19,
    "",
    19,
    "",
    9
  ],
  [
    "a2e5",
    "",
    9
  ],
  [
    "a2f1",
    "",
    11
  ],
  [
    "a3a1",
    "",
    88,
    ""
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a6e0",
    ""
  ],
  [
    "a6ee",
    ""
  ],
  [
    "a6f4",
    ""
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a840",
    "",
    35,
    "",
    6
  ],
  [
    "a880",
    "",
    7,
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a8bd",
    ""
  ],
  [
    "a8c0",
    ""
  ],
  [
    "a8c5",
    "",
    36
  ],
  [
    "a940",
    "",
    8,
    ""
  ],
  [
    "a959",
    ""
  ],
  [
    "a95c",
    ""
  ],
  [
    "a960",
    "",
    9,
    "",
    8
  ],
  [
    "a980",
    "",
    4,
    ""
  ],
  [
    "a996",
    ""
  ],
  [
    "a9a4",
    "",
    75
  ],
  [
    "aa40",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "aa80",
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "ab40",
    "",
    11,
    "",
    4,
    "",
    5,
    "",
    4
  ],
  [
    "ab80",
    "",
    6,
    "",
    4
  ],
  [
    "ac40",
    "",
    10,
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11
  ],
  [
    "ac80",
    "",
    6,
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "ad40",
    "",
    10,
    "",
    7,
    "",
    15,
    "",
    12
  ],
  [
    "ad80",
    "",
    9,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "ae40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "ae80",
    "",
    7,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "af40",
    "",
    4,
    ""
  ],
  [
    "af80",
    ""
  ],
  [
    "b040",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "b080",
    "",
    7,
    "",
    8,
    "",
    9,
    ""
  ],
  [
    "b140",
    "",
    4,
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "b180",
    "",
    4,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "b240",
    "",
    11,
    "",
    5,
    "",
    11,
    "",
    4
  ],
  [
    "b280",
    "",
    12,
    "",
    8,
    "",
    4,
    ""
  ],
  [
    "b340",
    "",
    5,
    ""
  ],
  [
    "b380",
    "",
    11,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "b440",
    "",
    7,
    "",
    9
  ],
  [
    "b480",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "b540",
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "b580",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b640",
    "",
    6,
    "",
    11,
    "",
    10,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "b680",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b740",
    "",
    14,
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    16
  ],
  [
    "b780",
    "",
    6,
    ""
  ],
  [
    "b840",
    "",
    4,
    "",
    10,
    "",
    10,
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "b880",
    "",
    4,
    ""
  ],
  [
    "b940",
    "",
    5,
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "b980",
    "",
    7,
    ""
  ],
  [
    "ba40",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "ba80",
    "",
    4,
    "",
    5,
    "",
    12,
    "",
    5,
    ""
  ],
  [
    "bb40",
    "",
    9,
    "",
    36,
    "",
    5,
    "",
    9
  ],
  [
    "bb80",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "bc40",
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    13,
    "",
    5
  ],
  [
    "bc80",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "bd40",
    "",
    54,
    "",
    7
  ],
  [
    "bd80",
    "",
    32,
    ""
  ],
  [
    "be40",
    "",
    12,
    "",
    6,
    "",
    42
  ],
  [
    "be80",
    "",
    32,
    ""
  ],
  [
    "bf40",
    "",
    62
  ],
  [
    "bf80",
    "",
    4,
    "",
    4,
    "",
    21,
    ""
  ],
  [
    "c040",
    "",
    35,
    "",
    23,
    ""
  ],
  [
    "c080",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "c140",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c180",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c280",
    "",
    13,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c340",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c380",
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "c440",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "c480",
    "",
    7,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c540",
    "",
    14,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c580",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c680",
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "c740",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "c780",
    ""
  ],
  [
    "c840",
    "",
    4,
    "",
    5,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c880",
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "c940",
    "",
    4,
    "",
    7,
    "",
    12,
    ""
  ],
  [
    "c980",
    "",
    4,
    "",
    4,
    "",
    10,
    ""
  ],
  [
    "ca40",
    "",
    8,
    "",
    8,
    "",
    9,
    "",
    4,
    "",
    10
  ],
  [
    "ca80",
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "cb40",
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cb80",
    "",
    5,
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "cc40",
    "",
    4,
    "",
    10,
    "",
    15,
    "",
    13,
    ""
  ],
  [
    "cc80",
    "",
    11,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "cd40",
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "cd80",
    ""
  ],
  [
    "ce40",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "ce80",
    "",
    4,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cf40",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    9
  ],
  [
    "cf80",
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "d040",
    "",
    13,
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "d080",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "d140",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "d180",
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "d240",
    "",
    8,
    "",
    24,
    "",
    5,
    "",
    19,
    ""
  ],
  [
    "d280",
    "",
    26,
    ""
  ],
  [
    "d340",
    "",
    30,
    "",
    6
  ],
  [
    "d380",
    "",
    4,
    "",
    5,
    "",
    21,
    ""
  ],
  [
    "d440",
    "",
    31,
    "",
    8,
    "",
    21
  ],
  [
    "d480",
    "",
    25,
    "",
    6,
    ""
  ],
  [
    "d540",
    "",
    7,
    "",
    7,
    "",
    46
  ],
  [
    "d580",
    "",
    32,
    ""
  ],
  [
    "d640",
    "",
    34,
    "",
    27
  ],
  [
    "d680",
    "",
    30,
    ""
  ],
  [
    "d740",
    "",
    31,
    "",
    4,
    "",
    25
  ],
  [
    "d780",
    "",
    24,
    ""
  ],
  [
    "d840",
    "",
    8,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "d880",
    "",
    6,
    "",
    20,
    ""
  ],
  [
    "d940",
    "",
    62
  ],
  [
    "d980",
    "",
    32,
    ""
  ],
  [
    "da40",
    "",
    14,
    "",
    8,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "da80",
    "",
    12,
    ""
  ],
  [
    "db40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "db80",
    "",
    4,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "dc40",
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    11,
    "",
    6,
    "",
    7
  ],
  [
    "dc80",
    "",
    10,
    "",
    21,
    ""
  ],
  [
    "dd40",
    "",
    62
  ],
  [
    "dd80",
    "",
    32,
    ""
  ],
  [
    "de40",
    "",
    32,
    ""
  ],
  [
    "de80",
    "",
    4,
    ""
  ],
  [
    "df40",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "df80",
    "",
    4,
    ""
  ],
  [
    "e040",
    "",
    19,
    ""
  ],
  [
    "e080",
    "",
    10,
    "",
    6,
    "",
    8,
    ""
  ],
  [
    "e140",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "e180",
    "",
    10,
    "",
    9,
    "",
    8,
    ""
  ],
  [
    "e240",
    "",
    62
  ],
  [
    "e280",
    "",
    32,
    "",
    5,
    ""
  ],
  [
    "e340",
    "",
    45,
    "",
    16
  ],
  [
    "e380",
    "",
    7,
    "",
    24,
    ""
  ],
  [
    "e440",
    "",
    5,
    "",
    24,
    "",
    31
  ],
  [
    "e480",
    "",
    32,
    ""
  ],
  [
    "e540",
    "",
    51,
    "",
    10
  ],
  [
    "e580",
    "",
    31,
    ""
  ],
  [
    "e640",
    "",
    34,
    "",
    27
  ],
  [
    "e680",
    "",
    29,
    ""
  ],
  [
    "e740",
    "",
    7,
    "",
    54
  ],
  [
    "e780",
    "",
    32,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "e840",
    "",
    14,
    "",
    43,
    ""
  ],
  [
    "e880",
    "",
    20,
    ""
  ],
  [
    "e940",
    "",
    7,
    "",
    42
  ],
  [
    "e980",
    "",
    32,
    ""
  ],
  [
    "ea40",
    "",
    27,
    "",
    6,
    ""
  ],
  [
    "ea80",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "eb40",
    "",
    9,
    "",
    7,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "eb80",
    "",
    4,
    ""
  ],
  [
    "ec40",
    "",
    8,
    "",
    4,
    "",
    18,
    "",
    7
  ],
  [
    "ec80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ed40",
    "",
    6,
    "",
    46
  ],
  [
    "ed80",
    "",
    4,
    "",
    23,
    ""
  ],
  [
    "ee40",
    "",
    62
  ],
  [
    "ee80",
    "",
    32,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "ef40",
    "",
    5,
    "",
    37,
    "",
    4
  ],
  [
    "ef80",
    "",
    30,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "f040",
    "",
    4,
    "",
    28,
    "",
    26
  ],
  [
    "f080",
    "",
    9,
    "",
    12,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "f140",
    "",
    10,
    "",
    47
  ],
  [
    "f180",
    "",
    32,
    ""
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    32,
    ""
  ],
  [
    "f340",
    "",
    17,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "f380",
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "f440",
    "",
    5,
    "",
    10,
    "",
    10,
    "",
    7,
    "",
    5
  ],
  [
    "f480",
    "",
    32,
    ""
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    32,
    ""
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    32,
    "",
    5,
    "",
    5,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    32
  ],
  [
    "f940",
    "",
    62
  ],
  [
    "f980",
    "",
    32
  ],
  [
    "fa40",
    "",
    62
  ],
  [
    "fa80",
    "",
    32
  ],
  [
    "fb40",
    "",
    27,
    "",
    9,
    ""
  ],
  [
    "fb80",
    "",
    5,
    "",
    8,
    "",
    5,
    ""
  ],
  [
    "fc40",
    "",
    8,
    "",
    4,
    "",
    8,
    "",
    6
  ],
  [
    "fc80",
    "",
    4,
    "",
    5,
    "",
    8,
    ""
  ],
  [
    "fd40",
    "",
    4,
    "",
    4,
    "",
    10,
    "",
    38
  ],
  [
    "fd80",
    "",
    5,
    "",
    11,
    "",
    4,
    ""
  ],
  [
    "fe40",
    ""
  ]
];
const require$$3$1 = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ]
];
const uChars$1 = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
];
const gbChars$1 = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
];
const require$$4$1 = {
  uChars: uChars$1,
  gbChars: gbChars$1
};
const require$$5$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8161",
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "8181",
    "",
    18,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8241",
    "",
    7,
    "",
    5
  ],
  [
    "8261",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8281",
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    17,
    "",
    7,
    "",
    6,
    "",
    7,
    "",
    18
  ],
  [
    "8341",
    "",
    5,
    "",
    5,
    "",
    7
  ],
  [
    "8361",
    "",
    18,
    ""
  ],
  [
    "8381",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    46,
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8441",
    "",
    5,
    "",
    8
  ],
  [
    "8461",
    "",
    18
  ],
  [
    "8481",
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    18,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8541",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4
  ],
  [
    "8561",
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8581",
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    29,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8641",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8661",
    "",
    6,
    "",
    10
  ],
  [
    "8681",
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    22,
    "",
    4,
    ""
  ],
  [
    "8741",
    "",
    9,
    "",
    15
  ],
  [
    "8761",
    "",
    18,
    ""
  ],
  [
    "8781",
    "",
    5,
    "",
    7,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    4
  ],
  [
    "8841",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "8861",
    "",
    4,
    ""
  ],
  [
    "8881",
    "",
    15,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    54,
    ""
  ],
  [
    "8941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8961",
    "",
    10,
    "",
    5,
    ""
  ],
  [
    "8981",
    "",
    21,
    "",
    18,
    "",
    18,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    15
  ],
  [
    "8a41",
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "8a61",
    "",
    4,
    "",
    18,
    ""
  ],
  [
    "8a81",
    "",
    4,
    "",
    19,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8b41",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8b61",
    "",
    6,
    "",
    8
  ],
  [
    "8b81",
    "",
    52,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    18
  ],
  [
    "8c41",
    "",
    15,
    "",
    4
  ],
  [
    "8c61",
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "8c81",
    "",
    12,
    "",
    26,
    "",
    50,
    "",
    5,
    "",
    16
  ],
  [
    "8d41",
    "",
    16,
    "",
    8
  ],
  [
    "8d61",
    "",
    17,
    ""
  ],
  [
    "8d81",
    "",
    4,
    "",
    33,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    9,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8e41",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8e61",
    "",
    4,
    "",
    19
  ],
  [
    "8e81",
    "",
    13,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    11,
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "8f41",
    "",
    7,
    "",
    17
  ],
  [
    "8f61",
    "",
    7,
    "",
    6,
    "",
    4
  ],
  [
    "8f81",
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    5
  ],
  [
    "9041",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9061",
    "",
    5,
    "",
    15
  ],
  [
    "9081",
    "",
    12,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    11,
    "",
    33,
    ""
  ],
  [
    "9141",
    "",
    6,
    "",
    5
  ],
  [
    "9161",
    "",
    9,
    "",
    5
  ],
  [
    "9181",
    "",
    20,
    "",
    4,
    "",
    5,
    "",
    14,
    "",
    33,
    "",
    7,
    "",
    5,
    "",
    6
  ],
  [
    "9241",
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "9261",
    "",
    7,
    "",
    7,
    "",
    4
  ],
  [
    "9281",
    "",
    21,
    "",
    18,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    35,
    ""
  ],
  [
    "9341",
    "",
    4,
    ""
  ],
  [
    "9361",
    "",
    6,
    "",
    8
  ],
  [
    "9381",
    "",
    37,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    22,
    ""
  ],
  [
    "9441",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "9461",
    "",
    5,
    "",
    6,
    "",
    12
  ],
  [
    "9481",
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    24
  ],
  [
    "9541",
    "",
    11,
    "",
    5,
    ""
  ],
  [
    "9561",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9581",
    "",
    6,
    "",
    35,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    13,
    "",
    14
  ],
  [
    "9641",
    "",
    23,
    ""
  ],
  [
    "9661",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "9681",
    "",
    10,
    "",
    5,
    "",
    13,
    "",
    33,
    "",
    6,
    "",
    44
  ],
  [
    "9741",
    "",
    16,
    "",
    8
  ],
  [
    "9761",
    "",
    17,
    "",
    7
  ],
  [
    "9781",
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    89,
    ""
  ],
  [
    "9841",
    "",
    16,
    "",
    5,
    ""
  ],
  [
    "9861",
    "",
    6,
    "",
    15
  ],
  [
    "9881",
    "",
    21,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9961",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9981",
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9a41",
    "",
    16
  ],
  [
    "9a61",
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "9a81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    33,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9b41",
    "",
    6,
    "",
    8
  ],
  [
    "9b61",
    "",
    17,
    "",
    7
  ],
  [
    "9b81",
    "",
    25,
    "",
    4,
    "",
    5,
    "",
    50,
    "",
    22,
    ""
  ],
  [
    "9c41",
    "",
    4,
    "",
    5,
    "",
    5
  ],
  [
    "9c61",
    "",
    8,
    "",
    6,
    "",
    9
  ],
  [
    "9c81",
    "",
    8,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    12
  ],
  [
    "9d41",
    "",
    13,
    "",
    8
  ],
  [
    "9d61",
    "",
    25
  ],
  [
    "9d81",
    "",
    8,
    "",
    5,
    "",
    9,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9e41",
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9e61",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9e81",
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9f41",
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9f61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9f81",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "a041",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "a061",
    "",
    5,
    "",
    13
  ],
  [
    "a081",
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    "",
    4,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "a141",
    "",
    18,
    ""
  ],
  [
    "a161",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a181",
    "",
    14,
    "",
    5,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "a241",
    "",
    5,
    "",
    18
  ],
  [
    "a261",
    "",
    6,
    "",
    18
  ],
  [
    "a281",
    "",
    7,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "a341",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "a361",
    "",
    6,
    "",
    16
  ],
  [
    "a381",
    "",
    16,
    "",
    4,
    "",
    58,
    "",
    32,
    ""
  ],
  [
    "a441",
    "",
    5,
    ""
  ],
  [
    "a461",
    "",
    5,
    "",
    12
  ],
  [
    "a481",
    "",
    28,
    "",
    93
  ],
  [
    "a541",
    "",
    4,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a561",
    "",
    17,
    "",
    5,
    ""
  ],
  [
    "a581",
    "",
    16,
    "",
    14,
    "",
    9
  ],
  [
    "a5b0",
    "",
    9
  ],
  [
    "a5c1",
    "",
    16,
    "",
    6
  ],
  [
    "a5e1",
    "",
    16,
    "",
    6
  ],
  [
    "a641",
    "",
    19,
    ""
  ],
  [
    "a661",
    "",
    5,
    "",
    5,
    "",
    6
  ],
  [
    "a681",
    "",
    6,
    "",
    18,
    "",
    7
  ],
  [
    "a741",
    "",
    4,
    "",
    6,
    "",
    7
  ],
  [
    "a761",
    "",
    22,
    ""
  ],
  [
    "a781",
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    9,
    "",
    9,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "a841",
    "",
    10,
    "",
    14
  ],
  [
    "a861",
    "",
    18,
    "",
    6
  ],
  [
    "a881",
    "",
    19,
    "",
    11,
    ""
  ],
  [
    "a8a6",
    ""
  ],
  [
    "a8a8",
    ""
  ],
  [
    "a8b1",
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "a941",
    "",
    14,
    "",
    10
  ],
  [
    "a961",
    "",
    18
  ],
  [
    "a981",
    "",
    14,
    "",
    6,
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "aa41",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "aa61",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "aa81",
    "",
    29,
    "",
    82
  ],
  [
    "ab41",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "ab61",
    "",
    6,
    "",
    5,
    "",
    5
  ],
  [
    "ab81",
    "",
    8,
    "",
    6,
    "",
    12,
    "",
    85
  ],
  [
    "ac41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ac61",
    "",
    11,
    "",
    4
  ],
  [
    "ac81",
    "",
    28,
    "",
    5,
    "",
    25
  ],
  [
    "acd1",
    "",
    5,
    "",
    25
  ],
  [
    "ad41",
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "ad61",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "ad81",
    "",
    5,
    "",
    18,
    ""
  ],
  [
    "ae41",
    "",
    5,
    "",
    16
  ],
  [
    "ae61",
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "ae81",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "af41",
    "",
    19
  ],
  [
    "af61",
    "",
    13,
    "",
    5,
    ""
  ],
  [
    "af81",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b041",
    "",
    5,
    "",
    5,
    "",
    12
  ],
  [
    "b061",
    "",
    5,
    "",
    19
  ],
  [
    "b081",
    "",
    13,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "b141",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b161",
    "",
    6,
    "",
    5,
    "",
    11
  ],
  [
    "b181",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b241",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b261",
    "",
    18,
    "",
    5,
    ""
  ],
  [
    "b281",
    "",
    5,
    "",
    18,
    "",
    6,
    ""
  ],
  [
    "b341",
    "",
    19,
    ""
  ],
  [
    "b361",
    "",
    5,
    "",
    5,
    "",
    5
  ],
  [
    "b381",
    "",
    5,
    "",
    5,
    "",
    19,
    "",
    4,
    ""
  ],
  [
    "b441",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "b461",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "b481",
    "",
    6,
    "",
    18,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "b541",
    "",
    14,
    "",
    5
  ],
  [
    "b561",
    "",
    5,
    "",
    5,
    "",
    4
  ],
  [
    "b581",
    "",
    6,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "b641",
    "",
    7,
    "",
    17
  ],
  [
    "b661",
    "",
    15,
    ""
  ],
  [
    "b681",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b741",
    "",
    13,
    "",
    6,
    ""
  ],
  [
    "b761",
    "",
    20,
    ""
  ],
  [
    "b781",
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "b841",
    "",
    7,
    "",
    17
  ],
  [
    "b861",
    "",
    8,
    "",
    13
  ],
  [
    "b881",
    "",
    5,
    "",
    24,
    "",
    4,
    ""
  ],
  [
    "b941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b961",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b981",
    "",
    22,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ba41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ba61",
    "",
    5,
    "",
    4,
    "",
    5
  ],
  [
    "ba81",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "bb41",
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bb61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "bb81",
    "",
    31,
    ""
  ],
  [
    "bc41",
    "",
    17,
    ""
  ],
  [
    "bc61",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "bc81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bd41",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "bd61",
    "",
    5,
    "",
    13
  ],
  [
    "bd81",
    "",
    5,
    "",
    25,
    ""
  ],
  [
    "be41",
    "",
    7,
    "",
    14
  ],
  [
    "be61",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "be81",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "bf41",
    "",
    10,
    "",
    14
  ],
  [
    "bf61",
    "",
    18,
    ""
  ],
  [
    "bf81",
    "",
    5,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c041",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "c061",
    "",
    25
  ],
  [
    "c081",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c141",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c161",
    "",
    19,
    ""
  ],
  [
    "c181",
    "",
    31,
    ""
  ],
  [
    "c241",
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c261",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c281",
    "",
    5,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "c341",
    "",
    4
  ],
  [
    "c361",
    "",
    4,
    "",
    5,
    "",
    11
  ],
  [
    "c381",
    "",
    5,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "c441",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c461",
    "",
    5,
    "",
    4
  ],
  [
    "c481",
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c541",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c561",
    "",
    6,
    "",
    5,
    "",
    4
  ],
  [
    "c581",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c641",
    "",
    6,
    "",
    5
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "d2a1",
    "",
    4,
    "",
    5,
    "",
    10,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fda1",
    ""
  ]
];
const require$$6$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    ""
  ],
  [
    "a1a1",
    "",
    4,
    ""
  ],
  [
    "a240",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9,
    "",
    9,
    "",
    8,
    "",
    25,
    "",
    21
  ],
  [
    "a340",
    "",
    16,
    "",
    6,
    "",
    16,
    "",
    6,
    "",
    10
  ],
  [
    "a3a1",
    "",
    25,
    ""
  ],
  [
    "a3e1",
    ""
  ],
  [
    "a440",
    ""
  ],
  [
    "a4a1",
    ""
  ],
  [
    "a540",
    ""
  ],
  [
    "a5a1",
    ""
  ],
  [
    "a640",
    ""
  ],
  [
    "a6a1",
    ""
  ],
  [
    "a740",
    ""
  ],
  [
    "a7a1",
    ""
  ],
  [
    "a840",
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a940",
    ""
  ],
  [
    "a9a1",
    ""
  ],
  [
    "aa40",
    ""
  ],
  [
    "aaa1",
    ""
  ],
  [
    "ab40",
    ""
  ],
  [
    "aba1",
    ""
  ],
  [
    "ac40",
    ""
  ],
  [
    "aca1",
    ""
  ],
  [
    "ad40",
    ""
  ],
  [
    "ada1",
    ""
  ],
  [
    "ae40",
    ""
  ],
  [
    "aea1",
    ""
  ],
  [
    "af40",
    ""
  ],
  [
    "afa1",
    ""
  ],
  [
    "b040",
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b140",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b240",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b340",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b440",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b540",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b640",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b740",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b840",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b940",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "ba40",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bb40",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bc40",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bd40",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "be40",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bf40",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c040",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c140",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c240",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c340",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c440",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c540",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c940",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "ca40",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cb40",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cc40",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cd40",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "ce40",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cf40",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d040",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d140",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d240",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d340",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d440",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d540",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d640",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d740",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d840",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d940",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "da40",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "db40",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dc40",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dd40",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "de40",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "df40",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eb40",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "ec40",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "ef40",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f040",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f140",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f240",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f340",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f440",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f540",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f640",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f740",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f840",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f940",
    ""
  ],
  [
    "f9a1",
    ""
  ]
];
const require$$7$1 = [
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
var dbcsData$1;
var hasRequiredDbcsData$1;
function requireDbcsData$1() {
  if (hasRequiredDbcsData$1) return dbcsData$1;
  hasRequiredDbcsData$1 = 1;
  dbcsData$1 = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0$1;
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1$1;
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2$1;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3$1);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3$1);
      },
      gb18030: function() {
        return require$$4$1;
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5$1;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6$1;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6$1.concat(require$$7$1);
      },
      encodeSkipVals: [41676]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData$1;
}
var hasRequiredEncodings$1;
function requireEncodings$1() {
  if (hasRequiredEncodings$1) return encodings$1;
  hasRequiredEncodings$1 = 1;
  (function(exports) {
    var modules = [
      requireInternal$1(),
      requireUtf32$1(),
      requireUtf16$1(),
      requireUtf7$1(),
      requireSbcsCodec$1(),
      requireSbcsData$1(),
      requireSbcsDataGenerated$1(),
      requireDbcsCodec$1(),
      requireDbcsData$1()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports[enc] = module[enc];
    }
  })(encodings$1);
  return encodings$1;
}
var streams$1;
var hasRequiredStreams$1;
function requireStreams$1() {
  if (hasRequiredStreams$1) return streams$1;
  hasRequiredStreams$1 = 1;
  var Buffer2 = require$$0$5.Buffer, Transform2 = require$$1$2.Transform;
  streams$1 = function(iconv2) {
    iconv2.encodeStream = function encodeStream(encoding, options) {
      return new IconvLiteEncoderStream(iconv2.getEncoder(encoding, options), options);
    };
    iconv2.decodeStream = function decodeStream(encoding, options) {
      return new IconvLiteDecoderStream(iconv2.getDecoder(encoding, options), options);
    };
    iconv2.supportsStreams = true;
    iconv2.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv2.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv2._collect = IconvLiteDecoderStream.prototype.collect;
  };
  function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false;
    Transform2.call(this, options);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform2.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  });
  IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length) this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length) this.push(res);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on("error", cb);
    this.on("data", function(chunk) {
      chunks.push(chunk);
    });
    this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    });
    return this;
  };
  function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = "utf8";
    Transform2.call(this, options);
  }
  IconvLiteDecoderStream.prototype = Object.create(Transform2.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  });
  IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res = this.conv.write(chunk);
      if (res && res.length) this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res = this.conv.end();
      if (res && res.length) this.push(res, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res = "";
    this.on("error", cb);
    this.on("data", function(chunk) {
      res += chunk;
    });
    this.on("end", function() {
      cb(null, res);
    });
    return this;
  };
  return streams$1;
}
var extendNode;
var hasRequiredExtendNode;
function requireExtendNode() {
  if (hasRequiredExtendNode) return extendNode;
  hasRequiredExtendNode = 1;
  var Buffer2 = require$$0$5.Buffer;
  extendNode = function(iconv2) {
    var original = void 0;
    iconv2.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array);
    iconv2.extendNodeEncodings = function extendNodeEncodings() {
      if (original) return;
      original = {};
      if (!iconv2.supportsNodeEncodingsExtension) {
        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
        return;
      }
      var nodeNativeEncodings = {
        "hex": true,
        "utf8": true,
        "utf-8": true,
        "ascii": true,
        "binary": true,
        "base64": true,
        "ucs2": true,
        "ucs-2": true,
        "utf16le": true,
        "utf-16le": true
      };
      Buffer2.isNativeEncoding = function(enc) {
        return enc && nodeNativeEncodings[enc.toLowerCase()];
      };
      var SlowBuffer = require$$0$5.SlowBuffer;
      original.SlowBufferToString = SlowBuffer.prototype.toString;
      SlowBuffer.prototype.toString = function(encoding, start, end2) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.SlowBufferToString.call(this, encoding, start, end2);
        if (typeof start == "undefined") start = 0;
        if (typeof end2 == "undefined") end2 = this.length;
        return iconv2.decode(this.slice(start, end2), encoding);
      };
      original.SlowBufferWrite = SlowBuffer.prototype.write;
      SlowBuffer.prototype.write = function(string, offset, length, encoding) {
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding = length;
            length = void 0;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length;
          length = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.SlowBufferWrite.call(this, string, offset, length, encoding);
        if (string.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv2.encode(string, encoding);
        if (buf.length < length) length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      original.BufferIsEncoding = Buffer2.isEncoding;
      Buffer2.isEncoding = function(encoding) {
        return Buffer2.isNativeEncoding(encoding) || iconv2.encodingExists(encoding);
      };
      original.BufferByteLength = Buffer2.byteLength;
      Buffer2.byteLength = SlowBuffer.byteLength = function(str2, encoding) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferByteLength.call(this, str2, encoding);
        return iconv2.encode(str2, encoding).length;
      };
      original.BufferToString = Buffer2.prototype.toString;
      Buffer2.prototype.toString = function(encoding, start, end2) {
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferToString.call(this, encoding, start, end2);
        if (typeof start == "undefined") start = 0;
        if (typeof end2 == "undefined") end2 = this.length;
        return iconv2.decode(this.slice(start, end2), encoding);
      };
      original.BufferWrite = Buffer2.prototype.write;
      Buffer2.prototype.write = function(string, offset, length, encoding) {
        var _offset2 = offset, _length = length, _encoding = encoding;
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding = length;
            length = void 0;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length;
          length = swap;
        }
        encoding = String(encoding || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding))
          return original.BufferWrite.call(this, string, _offset2, _length, _encoding);
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        if (string.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv2.encode(string, encoding);
        if (buf.length < length) length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      if (iconv2.supportsStreams) {
        var Readable2 = require$$1$2.Readable;
        original.ReadableSetEncoding = Readable2.prototype.setEncoding;
        Readable2.prototype.setEncoding = function setEncoding(enc, options) {
          this._readableState.decoder = iconv2.getDecoder(enc, options);
          this._readableState.encoding = enc;
        };
        Readable2.prototype.collect = iconv2._collect;
      }
    };
    iconv2.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
      if (!iconv2.supportsNodeEncodingsExtension)
        return;
      if (!original)
        throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
      delete Buffer2.isNativeEncoding;
      var SlowBuffer = require$$0$5.SlowBuffer;
      SlowBuffer.prototype.toString = original.SlowBufferToString;
      SlowBuffer.prototype.write = original.SlowBufferWrite;
      Buffer2.isEncoding = original.BufferIsEncoding;
      Buffer2.byteLength = original.BufferByteLength;
      Buffer2.prototype.toString = original.BufferToString;
      Buffer2.prototype.write = original.BufferWrite;
      if (iconv2.supportsStreams) {
        var Readable2 = require$$1$2.Readable;
        Readable2.prototype.setEncoding = original.ReadableSetEncoding;
        delete Readable2.prototype.collect;
      }
      original = void 0;
    };
  };
  return extendNode;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$3.exports;
  hasRequiredLib = 1;
  (function(module) {
    var Buffer2 = safer_1.Buffer;
    var bomHandling2 = requireBomHandling(), iconv2 = module.exports;
    iconv2.encodings = null;
    iconv2.defaultCharUnicode = "";
    iconv2.defaultCharSingleByte = "?";
    iconv2.encode = function encode2(str2, encoding, options) {
      str2 = "" + (str2 || "");
      var encoder = iconv2.getEncoder(encoding, options);
      var res = encoder.write(str2);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv2.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!iconv2.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv2.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv2.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv2.encodingExists = function encodingExists(enc) {
      try {
        iconv2.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv2.toEncoding = iconv2.encode;
    iconv2.fromEncoding = iconv2.decode;
    iconv2._codecDataCache = {};
    iconv2.getCodec = function getCodec(encoding) {
      if (!iconv2.encodings)
        iconv2.encodings = requireEncodings$1();
      var enc = iconv2._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = iconv2._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv2.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key2 in codecDef)
              codecOptions[key2] = codecDef[key2];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv2);
            iconv2._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv2._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv2.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv2.getCodec(encoding), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling2.PrependBOM(encoder, options);
      return encoder;
    };
    iconv2.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv2.getCodec(encoding), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling2.StripBOM(decoder, options);
      return decoder;
    };
    var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
    if (nodeVer) {
      var nodeVerArr = nodeVer.split(".").map(Number);
      if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        requireStreams$1()(iconv2);
      }
      requireExtendNode()(iconv2);
    }
  })(lib$3);
  return lib$3.exports;
}
const yauzl = yauzl$1;
const stream$4 = require$$1$2;
const UncompressBaseStream2 = base_write_stream;
const utils$c = utils$f;
let iconv;
const YAUZL_CALLBACK = Symbol("ZipUncompressStream#yauzlCallback");
const STRIP_NAME = Symbol("ZipUncompressStream#stripName");
const DEFAULTS = { lazyEntries: true, decodeStrings: false };
function modeFromEntry(entry) {
  const attr = entry.externalFileAttributes >> 16 || 33188;
  return [
    448,
    56,
    7
    /* S_IRWXO */
  ].map((mask) => attr & mask).reduce(
    (a, b) => a + b,
    attr & 61440
    /* S_IFMT */
  );
}
let ZipUncompressStream$1 = class ZipUncompressStream extends UncompressBaseStream2 {
  constructor(opts) {
    opts = opts || {};
    super(opts);
    this._chunks = [];
    this._strip = Number(opts.strip) || 0;
    this._zipFileNameEncoding = opts.zipFileNameEncoding || "utf8";
    if (this._zipFileNameEncoding === "utf-8") {
      this._zipFileNameEncoding = "utf8";
    }
    this[YAUZL_CALLBACK] = this[YAUZL_CALLBACK].bind(this);
    const sourceType = utils$c.sourceType(opts.source);
    const yauzlOpts = this._yauzlOpts = Object.assign({}, DEFAULTS, opts.yauzl);
    if (sourceType === "file") {
      yauzl.open(opts.source, yauzlOpts, this[YAUZL_CALLBACK]);
      return;
    }
    if (sourceType === "buffer") {
      yauzl.fromBuffer(opts.source, yauzlOpts, this[YAUZL_CALLBACK]);
      return;
    }
    if (sourceType === "stream") {
      utils$c.streamToBuffer(opts.source).then((buf) => yauzl.fromBuffer(buf, yauzlOpts, this[YAUZL_CALLBACK])).catch((e) => this.emit("error", e));
      return;
    }
    this.on("pipe", (srcStream) => {
      srcStream.unpipe(srcStream);
      utils$c.streamToBuffer(srcStream).then((buf) => {
        this._chunks.push(buf);
        buf = Buffer.concat(this._chunks);
        yauzl.fromBuffer(buf, yauzlOpts, this[YAUZL_CALLBACK]);
      }).catch((e) => this.emit("error", e));
    });
  }
  _write(chunk) {
    this._chunks.push(chunk);
  }
  [YAUZL_CALLBACK](err, zipFile) {
    if (err) return this.emit("error", err);
    zipFile.readEntry();
    zipFile.on("entry", (entry) => {
      const mode = modeFromEntry(entry);
      if (Buffer.isBuffer(entry.fileName)) {
        if (this._zipFileNameEncoding === "utf8") {
          entry.fileName = entry.fileName.toString();
        } else {
          if (!iconv) {
            iconv = requireLib();
          }
          entry.fileName = iconv.decode(entry.fileName, this._zipFileNameEncoding);
        }
      }
      const type2 = /[\\\/]$/.test(entry.fileName) ? "directory" : "file";
      const name = entry.fileName = this[STRIP_NAME](entry.fileName, type2);
      const header = { name, type: type2, yauzl: entry, mode };
      if (type2 === "file") {
        zipFile.openReadStream(entry, (err2, readStream2) => {
          if (err2) return this.emit("error", err2);
          this.emit("entry", header, readStream2, next);
        });
      } else {
        const placeholder = new stream$4.Readable({ read() {
        } });
        this.emit("entry", header, placeholder, next);
        setImmediate(() => placeholder.emit("end"));
      }
    }).on("end", () => this.emit("finish")).on("error", (err2) => this.emit("error", err2));
    function next() {
      zipFile.readEntry();
    }
  }
  [STRIP_NAME](fileName, type2) {
    return utils$c.stripFileName(this._strip, fileName, type2);
  }
};
var uncompress_stream$3 = ZipUncompressStream$1;
const utils$b = utils$f;
const ZipStream2 = stream$7;
const ZipFileStream2 = file_stream$3;
const ZipUncompressStream2 = uncompress_stream$3;
zip.Stream = ZipStream2;
zip.FileStream = ZipFileStream2;
zip.UncompressStream = ZipUncompressStream2;
zip.compressDir = utils$b.makeCompressDirFn(ZipStream2);
zip.compressFile = utils$b.makeFileProcessFn(ZipFileStream2);
zip.uncompress = utils$b.makeUncompressFn(ZipUncompressStream2);
zip.decompress = utils$b.makeUncompressFn(ZipUncompressStream2);
var gzip$2 = {};
var lib$2 = {};
var util$4 = require$$1$3;
var stream$3 = require$$1$2;
lib$2.createReadStream = function(object, options) {
  return new MultiStream(object, options);
};
var MultiStream = function(object, options) {
  if (object instanceof Buffer || typeof object === "string") {
    options = options || {};
    stream$3.Readable.call(this, {
      highWaterMark: options.highWaterMark,
      encoding: options.encoding
    });
  } else {
    stream$3.Readable.call(this, { objectMode: true });
  }
  this._object = object;
};
util$4.inherits(MultiStream, stream$3.Readable);
MultiStream.prototype._read = function() {
  this.push(this._object);
  this._object = null;
};
const fs$n = fs$w;
const zlib$1 = zlib$4;
const utils$a = utils$f;
const streamifier$3 = lib$2;
let GzipFileStream$1 = class GzipFileStream extends zlib$1.Gzip {
  constructor(opts) {
    opts = opts || {};
    super(opts.zlib);
    const sourceType = utils$a.sourceType(opts.source);
    if (sourceType === "file") {
      const stream2 = fs$n.createReadStream(opts.source, opts.fs);
      stream2.on("error", (err) => this.emit("error", err));
      stream2.pipe(this);
      return;
    }
    if (sourceType === "buffer") {
      const stream2 = streamifier$3.createReadStream(opts.source, opts.streamifier);
      stream2.on("error", (err) => this.emit("error", err));
      stream2.pipe(this);
      return;
    }
    if (sourceType === "stream") {
      opts.source.on("error", (err) => this.emit("error", err));
      opts.source.pipe(this);
    }
  }
};
var file_stream$2 = GzipFileStream$1;
const fs$m = fs$w;
const zlib = zlib$4;
const utils$9 = utils$f;
const streamifier$2 = lib$2;
let GzipUncompressStream$2 = class GzipUncompressStream extends zlib.Unzip {
  constructor(opts) {
    opts = opts || {};
    super(opts.zlib);
    const sourceType = utils$9.sourceType(opts.source);
    if (sourceType === "file") {
      const stream2 = fs$m.createReadStream(opts.source, opts.fs);
      stream2.on("error", (err) => this.emit("error", err));
      stream2.pipe(this);
      return;
    }
    if (sourceType === "buffer") {
      const stream2 = streamifier$2.createReadStream(opts.source, opts.streamifier);
      stream2.on("error", (err) => this.emit("error", err));
      stream2.pipe(this);
      return;
    }
    if (sourceType === "stream") {
      opts.source.on("error", (err) => this.emit("error", err));
      opts.source.pipe(this);
    }
  }
};
var uncompress_stream$2 = GzipUncompressStream$2;
const utils$8 = utils$f;
const GzipFileStream2 = file_stream$2;
const GzipUncompressStream$1 = uncompress_stream$2;
gzip$2.FileStream = GzipFileStream2;
gzip$2.UncompressStream = GzipUncompressStream$1;
gzip$2.compressFile = utils$8.makeFileProcessFn(GzipFileStream2);
gzip$2.uncompress = utils$8.makeFileProcessFn(GzipUncompressStream$1);
gzip$2.decompress = utils$8.makeFileProcessFn(GzipUncompressStream$1);
var tar$4 = {};
const fs$l = fs$w;
const path$m = require$$1$4;
const stream$2 = require$$1$2;
const tar$3 = tarStream;
const utils$7 = utils$f;
const ready$2 = getReadyExports;
let TarFileStream$1 = class TarFileStream extends stream$2.Transform {
  constructor(opts) {
    super(opts);
    const pack2 = tar$3.pack();
    pack2.on("data", (chunk) => this.push(chunk));
    pack2.on("end", () => this.ready(true));
    const sourceType = utils$7.sourceType(opts.source);
    if (sourceType === "file") {
      fs$l.stat(opts.source, (err, stat2) => {
        if (err) return this.emit("error", err);
        this.entry = pack2.entry({ name: opts.relativePath || path$m.basename(opts.source), size: stat2.size, mode: stat2.mode & 511 }, (err2) => {
          if (err2) return this.emit("error", err2);
          pack2.finalize();
        });
        const stream2 = fs$l.createReadStream(opts.source, opts.fs);
        stream2.on("error", (err2) => this.emit("error", err2));
        stream2.pipe(this);
      });
    } else if (sourceType === "buffer") {
      if (!opts.relativePath) return this.emit("error", "opts.relativePath is required if opts.source is a buffer");
      pack2.entry({ name: opts.relativePath }, opts.source);
      pack2.finalize();
      this.end();
    } else {
      if (!opts.relativePath) return process.nextTick(() => this.emit("error", "opts.relativePath is required"));
      if (opts.size) {
        this.entry = pack2.entry({ name: opts.relativePath, size: opts.size }, (err) => {
          if (err) return this.emit("error", err);
          pack2.finalize();
        });
      } else {
        if (!opts.suppressSizeWarning) {
          console.warn("You should specify the size of streamming data by opts.size to prevent all streaming data from loading into memory. If you are sure about memory cost, pass opts.suppressSizeWarning: true to suppress this warning");
        }
        const buf = [];
        this.entry = new stream$2.Writable({
          write(chunk, _, callback) {
            buf.push(chunk);
            callback();
          }
        });
        this.entry.on("finish", () => {
          pack2.entry({ name: opts.relativePath }, Buffer.concat(buf));
          pack2.finalize();
        });
      }
      if (sourceType === "stream") {
        opts.source.on("error", (err) => this.emit("error", err));
        opts.source.pipe(this);
      }
    }
  }
  _transform(chunk, encoding, callback) {
    if (this.entry) {
      this.entry.write(chunk, encoding, callback);
    }
  }
  _flush(callback) {
    if (this.entry) {
      this.entry.end();
    }
    this.ready(callback);
  }
};
ready$2.mixin(TarFileStream$1.prototype);
var file_stream$1 = TarFileStream$1;
const fs$k = fs$w;
const tar$2 = tarStream;
const utils$6 = utils$f;
const streamifier$1 = lib$2;
let TarUncompressStream$2 = class TarUncompressStream extends tar$2.extract {
  constructor(opts) {
    opts = opts || {};
    super(opts);
    const sourceType = utils$6.sourceType(opts.source);
    if (sourceType === "file") {
      const stream2 = fs$k.createReadStream(opts.source, opts.fs);
      stream2.on("error", (err) => this.emit("error", err));
      stream2.pipe(this);
      return;
    }
    if (sourceType === "buffer") {
      const stream2 = streamifier$1.createReadStream(opts.source, opts.streamifier);
      stream2.on("error", (err) => this.emit("error", err));
      stream2.pipe(this);
      return;
    }
    if (sourceType === "stream") {
      opts.source.on("error", (err) => this.emit("error", err));
      opts.source.pipe(this);
    }
  }
};
var uncompress_stream$1 = TarUncompressStream$2;
const utils$5 = utils$f;
const TarStream2 = stream_1$4;
const TarFileStream2 = file_stream$1;
const TarUncompressStream$1 = uncompress_stream$1;
tar$4.Stream = TarStream2;
tar$4.FileStream = TarFileStream2;
tar$4.UncompressStream = TarUncompressStream$1;
tar$4.compressDir = utils$5.makeCompressDirFn(TarStream2);
tar$4.compressFile = utils$5.makeFileProcessFn(TarFileStream2);
tar$4.uncompress = utils$5.makeUncompressFn(TarUncompressStream$1);
tar$4.decompress = utils$5.makeUncompressFn(TarUncompressStream$1);
var tgz = {};
const tar$1 = tar$4;
const gzip$1 = gzip$2;
const BaseStream2 = base_stream;
let TgzStream$1 = class TgzStream extends BaseStream2 {
  constructor(opts) {
    super(opts);
    const tarStream2 = this._tarStream = new tar$1.Stream();
    tarStream2.on("error", (err) => this.emit("error", err));
    const gzipStream = new gzip$1.FileStream();
    gzipStream.on("end", () => this.push(null));
    gzipStream.on("data", (chunk) => this.push(chunk));
    gzipStream.on("error", (err) => this.emit("error", err));
    tarStream2.pipe(gzipStream);
  }
  addEntry(entry, opts) {
    this._tarStream.addEntry(entry, opts);
  }
};
var stream$1 = TgzStream$1;
const tar = tar$4;
const gzip = gzip$2;
const utils$4 = utils$f;
const stream = require$$1$2;
const pump = pump_1;
const ready$1 = getReadyExports;
let TgzFileStream$1 = class TgzFileStream extends stream.Transform {
  constructor(opts) {
    opts = opts || {};
    super(opts);
    const sourceType = this._sourceType = utils$4.sourceType(opts.source);
    const tarStream2 = this._tarStream = new tar.FileStream(opts);
    opts = utils$4.clone(opts);
    delete opts.source;
    const gzipStream = new gzip.FileStream(opts);
    gzipStream.on("data", (chunk) => {
      this.push(chunk);
    });
    gzipStream.on("end", () => this.ready(true));
    pump(tarStream2, gzipStream, (err) => {
      err && this.emit("error", err);
    });
    if (sourceType !== "stream" && sourceType !== void 0) {
      this.end();
    }
  }
  _transform(chunk, encoding, callback) {
    this._tarStream.write(chunk, encoding, callback);
  }
  _flush(callback) {
    if (this._sourceType === "stream" || this._sourceType === void 0) {
      this._tarStream.end();
    }
    this.ready(callback);
  }
};
ready$1.mixin(TgzFileStream$1.prototype);
var file_stream = TgzFileStream$1;
var EventEmitter = require$$0$6.EventEmitter, Writable = require$$1$2.Writable, util$3 = require$$1$3;
function FlushWritable$1(opts) {
  Writable.call(this, opts);
}
util$3.inherits(FlushWritable$1, Writable);
FlushWritable$1.prototype.emit = function(evt) {
  if (evt === "finish" && this._flush && !Writable.prototype._flush) {
    this._flush((function(err) {
      if (err)
        EventEmitter.prototype.emit.call(this, "error", err);
      else
        EventEmitter.prototype.emit.call(this, "finish");
    }).bind(this));
  } else {
    var args = Array.prototype.slice.call(arguments);
    EventEmitter.prototype.emit.apply(this, args);
  }
};
var FlushWritable_1 = FlushWritable$1;
const fs$j = fs$w;
const utils$3 = utils$f;
const ready = getReadyExports;
const streamifier = lib$2;
const FlushWritable = FlushWritable_1;
const GzipUncompressStream2 = gzip$2.UncompressStream;
const TarUncompressStream2 = tar$4.UncompressStream;
let TgzUncompressStream$1 = class TgzUncompressStream extends FlushWritable {
  constructor(opts) {
    opts = opts || {};
    super(opts);
    const newOpts = utils$3.clone(opts);
    newOpts.source = void 0;
    this._gzipStream = new GzipUncompressStream2(newOpts).on("error", (err) => this.emit("error", err));
    const tarStream2 = new TarUncompressStream2(newOpts).on("finish", () => this.ready(true)).on("entry", this.emit.bind(this, "entry")).on("error", (err) => this.emit("error", err));
    this._gzipStream.pipe(tarStream2);
    const sourceType = utils$3.sourceType(opts.source);
    if (sourceType === "file") {
      const stream2 = fs$j.createReadStream(opts.source, opts.fs);
      stream2.on("error", (err) => this.emit("error", err));
      stream2.pipe(this);
      return;
    }
    if (sourceType === "buffer") {
      const stream2 = streamifier.createReadStream(opts.source, opts.streamifier);
      stream2.on("error", (err) => this.emit("error", err));
      stream2.pipe(this);
      return;
    }
    if (sourceType === "stream") {
      opts.source.on("error", (err) => this.emit("error", err));
      opts.source.pipe(this);
    }
  }
  _write(chunk, encoding, callback) {
    this._gzipStream.write(chunk, encoding, callback);
  }
  _flush(callback) {
    this._gzipStream.end();
    this.ready(callback);
  }
};
ready.mixin(TgzUncompressStream$1.prototype);
var uncompress_stream = TgzUncompressStream$1;
const utils$2 = utils$f;
const TgzStream2 = stream$1;
const TgzFileStream2 = file_stream;
const TgzUncompressStream2 = uncompress_stream;
tgz.Stream = TgzStream2;
tgz.FileStream = TgzFileStream2;
tgz.UncompressStream = TgzUncompressStream2;
tgz.compressDir = utils$2.makeCompressDirFn(TgzStream2);
tgz.compressFile = utils$2.makeFileProcessFn(TgzFileStream2);
tgz.uncompress = utils$2.makeUncompressFn(TgzUncompressStream2);
tgz.decompress = utils$2.makeUncompressFn(TgzUncompressStream2);
compressing.zip = zip;
compressing.gzip = gzip$2;
compressing.tar = tar$4;
compressing.tgz = tgz;
var lib$1 = { exports: {} };
var bomHandling = {};
var BOMChar = "\uFEFF";
bomHandling.PrependBOM = PrependBOMWrapper;
function PrependBOMWrapper(encoder, options) {
  this.encoder = encoder;
  this.addBOM = true;
}
PrependBOMWrapper.prototype.write = function(str2) {
  if (this.addBOM) {
    str2 = BOMChar + str2;
    this.addBOM = false;
  }
  return this.encoder.write(str2);
};
PrependBOMWrapper.prototype.end = function() {
  return this.encoder.end();
};
bomHandling.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
  this.decoder = decoder;
  this.pass = false;
  this.options = options || {};
}
StripBOMWrapper.prototype.write = function(buf) {
  var res = this.decoder.write(buf);
  if (this.pass || !res)
    return res;
  if (res[0] === BOMChar) {
    res = res.slice(1);
    if (typeof this.options.stripBOM === "function")
      this.options.stripBOM();
  }
  this.pass = true;
  return res;
};
StripBOMWrapper.prototype.end = function() {
  return this.decoder.end();
};
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer2 = safer_1.Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv2) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv2.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder2 = require$$1$7.StringDecoder;
  if (!StringDecoder2.prototype.end)
    StringDecoder2.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    this.decoder = new StringDecoder2(codec.enc);
  }
  InternalDecoder.prototype.write = function(buf) {
    if (!Buffer2.isBuffer(buf)) {
      buf = Buffer2.from(buf);
    }
    return this.decoder.write(buf);
  };
  InternalDecoder.prototype.end = function() {
    return this.decoder.end();
  };
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str2) {
    return Buffer2.from(str2, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str2) {
    str2 = this.prevStr + str2;
    var completeQuads = str2.length - str2.length % 4;
    this.prevStr = str2.slice(completeQuads);
    str2 = str2.slice(0, completeQuads);
    return Buffer2.from(str2, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length * 3), bufIdx = 0;
    for (var i = 0; i < str2.length; i++) {
      var charCode = str2.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res += this.defaultCharUnicode;
            else
              res += String.fromCharCode(acc);
          }
        } else {
          res += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
      res += this.defaultCharUnicode;
    return res;
  };
  return internal;
}
var utf32 = {};
var hasRequiredUtf32;
function requireUtf32() {
  if (hasRequiredUtf32) return utf32;
  hasRequiredUtf32 = 1;
  var Buffer2 = safer_1.Buffer;
  utf32._utf32 = Utf32Codec;
  function Utf32Codec(codecOptions, iconv2) {
    this.iconv = iconv2;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
  }
  utf32.utf32le = { type: "_utf32", isLE: true };
  utf32.utf32be = { type: "_utf32", isLE: false };
  utf32.ucs4le = "utf32le";
  utf32.ucs4be = "utf32be";
  Utf32Codec.prototype.encoder = Utf32Encoder;
  Utf32Codec.prototype.decoder = Utf32Decoder;
  function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
  }
  Utf32Encoder.prototype.write = function(str2) {
    var src2 = Buffer2.from(str2, "ucs2");
    var dst = Buffer2.alloc(src2.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;
    for (var i = 0; i < src2.length; i += 2) {
      var code = src2.readUInt16LE(i);
      var isHighSurrogate = 55296 <= code && code < 56320;
      var isLowSurrogate = 56320 <= code && code < 57344;
      if (this.highSurrogate) {
        if (isHighSurrogate || !isLowSurrogate) {
          write32.call(dst, this.highSurrogate, offset);
          offset += 4;
        } else {
          var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
          write32.call(dst, codepoint, offset);
          offset += 4;
          this.highSurrogate = 0;
          continue;
        }
      }
      if (isHighSurrogate)
        this.highSurrogate = code;
      else {
        write32.call(dst, code, offset);
        offset += 4;
        this.highSurrogate = 0;
      }
    }
    if (offset < dst.length)
      dst = dst.slice(0, offset);
    return dst;
  };
  Utf32Encoder.prototype.end = function() {
    if (!this.highSurrogate)
      return;
    var buf = Buffer2.alloc(4);
    if (this.isLE)
      buf.writeUInt32LE(this.highSurrogate, 0);
    else
      buf.writeUInt32BE(this.highSurrogate, 0);
    this.highSurrogate = 0;
    return buf;
  };
  function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = [];
  }
  Utf32Decoder.prototype.write = function(src2) {
    if (src2.length === 0)
      return "";
    var i = 0;
    var codepoint = 0;
    var dst = Buffer2.alloc(src2.length + 4);
    var offset = 0;
    var isLE = this.isLE;
    var overflow2 = this.overflow;
    var badChar = this.badChar;
    if (overflow2.length > 0) {
      for (; i < src2.length && overflow2.length < 4; i++)
        overflow2.push(src2[i]);
      if (overflow2.length === 4) {
        if (isLE) {
          codepoint = overflow2[i] | overflow2[i + 1] << 8 | overflow2[i + 2] << 16 | overflow2[i + 3] << 24;
        } else {
          codepoint = overflow2[i + 3] | overflow2[i + 2] << 8 | overflow2[i + 1] << 16 | overflow2[i] << 24;
        }
        overflow2.length = 0;
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
    }
    for (; i < src2.length - 3; i += 4) {
      if (isLE) {
        codepoint = src2[i] | src2[i + 1] << 8 | src2[i + 2] << 16 | src2[i + 3] << 24;
      } else {
        codepoint = src2[i + 3] | src2[i + 2] << 8 | src2[i + 1] << 16 | src2[i] << 24;
      }
      offset = _writeCodepoint(dst, offset, codepoint, badChar);
    }
    for (; i < src2.length; i++) {
      overflow2.push(src2[i]);
    }
    return dst.slice(0, offset).toString("ucs2");
  };
  function _writeCodepoint(dst, offset, codepoint, badChar) {
    if (codepoint < 0 || codepoint > 1114111) {
      codepoint = badChar;
    }
    if (codepoint >= 65536) {
      codepoint -= 65536;
      var high = 55296 | codepoint >> 10;
      dst[offset++] = high & 255;
      dst[offset++] = high >> 8;
      var codepoint = 56320 | codepoint & 1023;
    }
    dst[offset++] = codepoint & 255;
    dst[offset++] = codepoint >> 8;
    return offset;
  }
  Utf32Decoder.prototype.end = function() {
    this.overflow.length = 0;
  };
  utf32.utf32 = Utf32AutoCodec;
  utf32.ucs4 = "utf32";
  function Utf32AutoCodec(options, iconv2) {
    this.iconv = iconv2;
  }
  Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
  Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
  function Utf32AutoEncoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
  }
  Utf32AutoEncoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  };
  Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 32)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var invalidLE = 0, invalidBE = 0;
    var bmpCharsLE = 0, bmpCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 4) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                return "utf-32le";
              }
              if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                return "utf-32be";
              }
            }
            if (b[0] !== 0 || b[1] > 16) invalidBE++;
            if (b[3] !== 0 || b[2] > 16) invalidLE++;
            if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
            if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
    return defaultEncoding || "utf-32le";
  }
  return utf32;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = safer_1.Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str2) {
    var buf = Buffer2.from(str2, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j = 2;
    }
    for (; i < buf.length - 1; i += 2, j += 2) {
      buf2[j] = buf[i + 1];
      buf2[j + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
    this.overflowByte = -1;
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv2) {
    this.iconv = iconv2;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBufs = [];
    this.initialBufsLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBufs.push(buf);
      this.initialBufsLen += buf.length;
      if (this.initialBufsLen < 16)
        return "";
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding, this.options);
      var resStr = "";
      for (var i = 0; i < this.initialBufs.length; i++)
        resStr += this.decoder.write(this.initialBufs[i]);
      var trail = this.decoder.end();
      if (trail)
        resStr += trail;
      this.initialBufs.length = this.initialBufsLen = 0;
      return resStr;
    }
    return this.decoder.end();
  };
  function detectEncoding(bufs, defaultEncoding) {
    var b = [];
    var charsProcessed = 0;
    var asciiCharsLE = 0, asciiCharsBE = 0;
    outer_loop:
      for (var i = 0; i < bufs.length; i++) {
        var buf = bufs[i];
        for (var j = 0; j < buf.length; j++) {
          b.push(buf[j]);
          if (b.length === 2) {
            if (charsProcessed === 0) {
              if (b[0] === 255 && b[1] === 254) return "utf-16le";
              if (b[0] === 254 && b[1] === 255) return "utf-16be";
            }
            if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
            if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
            b.length = 0;
            charsProcessed++;
            if (charsProcessed >= 100) {
              break outer_loop;
            }
          }
        }
      }
    if (asciiCharsBE > asciiCharsLE) return "utf-16be";
    if (asciiCharsBE < asciiCharsLE) return "utf-16le";
    return defaultEncoding || "utf-16le";
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = safer_1.Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv2) {
    this.iconv = iconv2;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str2) {
    return Buffer2.from(str2.replace(nonDirectChars, (function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "+";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv2) {
    this.iconv = iconv2;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str2) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str2.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str2.length; i2++) {
      var uChar = str2.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res += "&";
          } else {
            var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
            res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = safer_1.Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv2) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv2.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length);
    for (var i = 0; i < str2.length; i++)
      buf[i] = this.encodeBuf[str2.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": ""
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": ""
    },
    "mik": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp720": {
      "type": "_sbcs",
      "chars": ""
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": ""
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": ""
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": ""
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": ""
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": ""
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": ""
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": ""
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": ""
    },
    "macroman": {
      "type": "_sbcs",
      "chars": ""
    },
    "macromania": {
      "type": "_sbcs",
      "chars": ""
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "\uFEFF"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": ""
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": ""
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": ""
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": ")(.,-"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": ""
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": ""
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": ""
    },
    "pt154": {
      "type": "_sbcs",
      "chars": ""
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": ""
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": ""
    },
    "ascii": {
      "type": "_sbcs",
      "chars": ""
    },
    "tis620": {
      "type": "_sbcs",
      "chars": ""
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = safer_1.Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv2) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var commonThirdByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var commonFourthByteNodeIdx = this.decodeTables.length;
      this.decodeTables.push(UNASSIGNED_NODE.slice(0));
      var firstByteNode = this.decodeTables[0];
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
        for (var j = 48; j <= 57; j++) {
          if (secondByteNode[j] === UNASSIGNED) {
            secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
          } else if (secondByteNode[j] > NODE_START) {
            throw new Error("gb18030 decode tables conflict at byte 2");
          }
          var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
          for (var k = 129; k <= 254; k++) {
            if (thirdByteNode[k] === UNASSIGNED) {
              thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
            } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
              continue;
            } else if (thirdByteNode[k] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 3");
            }
            var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
            for (var l = 48; l <= 57; l++) {
              if (fourthByteNode[l] === UNASSIGNED)
                fourthByteNode[l] = GB18030_CODE;
            }
          }
        }
      }
    }
    this.defaultCharUnicode = iconv2.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j = val.from; j <= val.to; j++)
            skipEncodeChars[j] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv2.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8)
      bytes.push(addr & 255);
    if (bytes.length == 0)
      bytes.push(0);
    var node2 = this.decodeTables[0];
    for (var i2 = bytes.length - 1; i2 > 0; i2--) {
      var val = node2[bytes[i2]];
      if (val == UNASSIGNED) {
        node2[bytes[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node2 = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node2 = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node2;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code = part.charCodeAt(l++);
          if (55296 <= code && code < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code && code <= 4095) {
            var len = 4095 - code + 2;
            var seq2 = [];
            for (var m = 0; m < len; m++)
              seq2.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq2);
          } else
            writeTable[curAddr++] = code;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq2, dbcsCode) {
    var uCode = seq2[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node2;
    if (bucket[low] <= SEQ_START) {
      node2 = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node2 = {};
      if (bucket[low] !== UNASSIGNED) node2[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node2);
    }
    for (var j = 1; j < seq2.length - 1; j++) {
      var oldVal = node2[uCode];
      if (typeof oldVal === "object")
        node2 = oldVal;
      else {
        node2 = node2[uCode] = {};
        if (oldVal !== void 0)
          node2[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq2[seq2.length - 1];
    node2[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node2 = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node2[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0) {
        this._setEncodeChar(uCode, mbCode);
        hasValues = true;
      } else if (uCode <= NODE_START) {
        var subNodeIdx = NODE_START - uCode;
        if (!subNodeEmpty[subNodeIdx]) {
          var newPrefix = mbCode << 8 >>> 0;
          if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
            hasValues = true;
          else
            subNodeEmpty[subNodeIdx] = true;
        }
      } else if (uCode <= SEQ_START) {
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
        hasValues = true;
      }
    }
    return hasValues;
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str2) {
    var newBuf = Buffer2.alloc(str2.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str2.length) break;
        var uCode = str2.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j++] = dbcsCode >> 8;
        newBuf[j++] = dbcsCode & 255;
      } else if (dbcsCode < 16777216) {
        newBuf[j++] = dbcsCode >> 16;
        newBuf[j++] = dbcsCode >> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      } else {
        newBuf[j++] = dbcsCode >>> 24;
        newBuf[j++] = dbcsCode >>> 16 & 255;
        newBuf[j++] = dbcsCode >>> 8 & 255;
        newBuf[j++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBytes = [];
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
    for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        uCode = this.defaultCharUnicode.charCodeAt(0);
        i2 = seqStart;
      } else if (uCode === GB18030_CODE) {
        if (i2 >= 3) {
          var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
        } else {
          var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
        }
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq2 = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq2.length - 1; k++) {
          uCode = seq2[k];
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
        }
        uCode = seq2[seq2.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode >= 65536) {
        uCode -= 65536;
        var uCodeLead = 55296 | uCode >> 10;
        newBuf[j++] = uCodeLead & 255;
        newBuf[j++] = uCodeLead >> 8;
        uCode = 56320 | uCode & 1023;
      }
      newBuf[j++] = uCode & 255;
      newBuf[j++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
    return newBuf.slice(0, j).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBytes.length > 0) {
      ret += this.defaultCharUnicode;
      var bytesArr = this.prevBytes.slice(1);
      this.prevBytes = [];
      this.nodeIdx = 0;
      if (bytesArr.length > 0)
        ret += this.write(bytesArr);
    }
    this.prevBytes = [];
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + (r - l + 1 >> 1);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0 = [
=======
  return yc;
}
const e8 = [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "",
    62
  ],
  [
    "8140",
    "",
    9,
    ""
  ],
  [
    "8180",
    ""
  ],
  [
    "81b8",
    ""
  ],
  [
    "81c8",
    ""
  ],
  [
    "81da",
    ""
  ],
  [
    "81f0",
    ""
  ],
  [
    "81fc",
    ""
  ],
  [
    "824f",
    "",
    9
  ],
  [
    "8260",
    "",
    25
  ],
  [
    "8281",
    "",
    25
  ],
  [
    "829f",
    "",
    82
  ],
  [
    "8340",
    "",
    62
  ],
  [
    "8380",
    "",
    22
  ],
  [
    "839f",
    "",
    16,
    "",
    6
  ],
  [
    "83bf",
    "",
    16,
    "",
    6
  ],
  [
    "8440",
    "",
    5,
    "",
    25
  ],
  [
    "8470",
    "",
    5,
    "",
    7
  ],
  [
    "8480",
    "",
    17
  ],
  [
    "849f",
    ""
  ],
  [
    "8740",
    "",
    19,
    "",
    9
  ],
  [
    "875f",
    ""
  ],
  [
    "877e",
    ""
  ],
  [
    "8780",
    "",
    4,
    ""
  ],
  [
    "889f",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8980",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a80",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b80",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8c80",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d80",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8e80",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8f80",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "9080",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "9180",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "9280",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "9380",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "9480",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "9580",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "9680",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "9780",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "989f",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "9980",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9a80",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b80",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9c80",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9d80",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9e80",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f80",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e080",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e180",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e280",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e380",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e480",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e580",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e680",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e780",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e880",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e980",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "ea80",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "ed80",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "ee80",
    ""
  ],
  [
    "eeef",
    "",
    9,
    ""
  ],
  [
    "f040",
    "",
    62
  ],
  [
    "f080",
    "",
    124
  ],
  [
    "f140",
    "",
    62
  ],
  [
    "f180",
    "",
    124
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    124
  ],
  [
    "f340",
    "",
    62
  ],
  [
    "f380",
    "",
    124
  ],
  [
    "f440",
    "",
    62
  ],
  [
    "f480",
    "",
    124
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    124
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    124
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    124
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    124
  ],
  [
    "f940",
    ""
  ],
  [
    "fa40",
    "",
    9,
    "",
    9,
    ""
  ],
  [
    "fa80",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fb80",
    ""
  ],
  [
    "fc40",
    ""
  ]
<<<<<<< HEAD
];
const require$$1 = [
=======
], t8 = [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "",
    62
  ],
  [
    "a1a1",
    "",
    9,
    ""
  ],
  [
    "a2a1",
    ""
  ],
  [
    "a2ba",
    ""
  ],
  [
    "a2ca",
    ""
  ],
  [
    "a2dc",
    ""
  ],
  [
    "a2f2",
    ""
  ],
  [
    "a2fe",
    ""
  ],
  [
    "a3b0",
    "",
    9
  ],
  [
    "a3c1",
    "",
    25
  ],
  [
    "a3e1",
    "",
    25
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a8a1",
    ""
  ],
  [
    "ada1",
    "",
    19,
    "",
    9
  ],
  [
    "adc0",
    ""
  ],
  [
    "addf",
    "",
    4,
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fcf1",
    "",
    9,
    ""
  ],
  [
    "8fa2af",
    ""
  ],
  [
    "8fa2c2",
    ""
  ],
  [
    "8fa2eb",
    ""
  ],
  [
    "8fa6e1",
    ""
  ],
  [
    "8fa6e7",
    ""
  ],
  [
    "8fa6e9",
    ""
  ],
  [
    "8fa6ec",
    ""
  ],
  [
    "8fa6f1",
    ""
  ],
  [
    "8fa7c2",
    "",
    10,
    ""
  ],
  [
    "8fa7f2",
    "",
    10,
    ""
  ],
  [
    "8fa9a1",
    ""
  ],
  [
    "8fa9a4",
    ""
  ],
  [
    "8fa9a6",
    ""
  ],
  [
    "8fa9a8",
    ""
  ],
  [
    "8fa9ab",
    ""
  ],
  [
    "8fa9af",
    ""
  ],
  [
    "8fa9c1",
    ""
  ],
  [
    "8faaa1",
    ""
  ],
  [
    "8faaba",
    ""
  ],
  [
    "8faba1",
    ""
  ],
  [
    "8fabbd",
    ""
  ],
  [
    "8fabc5",
    ""
  ],
  [
    "8fb0a1",
    ""
  ],
  [
    "8fb1a1",
    ""
  ],
  [
    "8fb2a1",
    "",
    4,
    ""
  ],
  [
    "8fb3a1",
    ""
  ],
  [
    "8fb4a1",
    ""
  ],
  [
    "8fb5a1",
    ""
  ],
  [
    "8fb6a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fb7a1",
    "",
    4,
    ""
  ],
  [
    "8fb8a1",
    ""
  ],
  [
    "8fb9a1",
    ""
  ],
  [
    "8fbaa1",
    "",
    4,
    ""
  ],
  [
    "8fbba1",
    ""
  ],
  [
    "8fbca1",
    "",
    4,
    ""
  ],
  [
    "8fbda1",
    "",
    4,
    ""
  ],
  [
    "8fbea1",
    "",
    4,
    ""
  ],
  [
    "8fbfa1",
    ""
  ],
  [
    "8fc0a1",
    ""
  ],
  [
    "8fc1a1",
    ""
  ],
  [
    "8fc2a1",
    ""
  ],
  [
    "8fc3a1",
    "",
    4,
    ""
  ],
  [
    "8fc4a1",
    ""
  ],
  [
    "8fc5a1",
    ""
  ],
  [
    "8fc6a1",
    ""
  ],
  [
    "8fc7a1",
    ""
  ],
  [
    "8fc8a1",
    ""
  ],
  [
    "8fc9a1",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8fcaa1",
    ""
  ],
  [
    "8fcba1",
    ""
  ],
  [
    "8fcca1",
    "",
    9,
    ""
  ],
  [
    "8fcda1",
    "",
    5,
    ""
  ],
  [
    "8fcea1",
    "",
    6,
    ""
  ],
  [
    "8fcfa1",
    ""
  ],
  [
    "8fd0a1",
    ""
  ],
  [
    "8fd1a1",
    ""
  ],
  [
    "8fd2a1",
    "",
    5
  ],
  [
    "8fd3a1",
    ""
  ],
  [
    "8fd4a1",
    "",
    4,
    ""
  ],
  [
    "8fd5a1",
    ""
  ],
  [
    "8fd6a1",
    ""
  ],
  [
    "8fd7a1",
    ""
  ],
  [
    "8fd8a1",
    ""
  ],
  [
    "8fd9a1",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8fdaa1",
    "",
    4,
    ""
  ],
  [
    "8fdba1",
    "",
    6,
    ""
  ],
  [
    "8fdca1",
    "",
    4,
    ""
  ],
  [
    "8fdda1",
    "",
    4,
    ""
  ],
  [
    "8fdea1",
    "",
    4,
    ""
  ],
  [
    "8fdfa1",
    ""
  ],
  [
    "8fe0a1",
    ""
  ],
  [
    "8fe1a1",
    "",
    4,
    ""
  ],
  [
    "8fe2a1",
    ""
  ],
  [
    "8fe3a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "8fe4a1",
    "",
    4,
    ""
  ],
  [
    "8fe5a1",
    "",
    4,
    ""
  ],
  [
    "8fe6a1",
    ""
  ],
  [
    "8fe7a1",
    ""
  ],
  [
    "8fe8a1",
    "",
    4,
    ""
  ],
  [
    "8fe9a1",
    "",
    4
  ],
  [
    "8feaa1",
    "",
    4,
    ""
  ],
  [
    "8feba1",
    "",
    4,
    ""
  ],
  [
    "8feca1",
    ""
  ],
  [
    "8feda1",
    "",
    4,
    "",
    4,
    ""
  ]
], bc = [
  [
    "0",
    "\0",
    127,
    ""
  ],
  [
    "8140",
    "",
    5,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "8180",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8240",
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    11
  ],
  [
    "8280",
    "",
    10,
    "",
    4,
    "",
    7,
    "",
    5,
    "",
    8,
    "",
    20,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8340",
    "",
    17,
    "",
    5,
    "",
    10,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "8380",
    "",
    5,
    "",
    13,
    "",
    28,
    "",
    4,
    "",
    4,
    "",
    5
  ],
  [
    "8440",
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "8480",
    "",
    9,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    5,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "8540",
    "",
    9,
    ""
  ],
  [
    "8580",
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "8640",
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "8680",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8740",
    "",
    7,
    "",
    11,
    "",
    4,
    "",
    4
  ],
  [
    "8780",
    "",
    7,
    "",
    6,
    "",
    14,
    "",
    10,
    "",
    6,
    "",
    12,
    "",
    8,
    "",
    5,
    "",
    6
  ],
  [
    "8840",
    "",
    9,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8880",
    "",
    4,
    "",
    6,
    "",
    8,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    7
  ],
  [
    "8940",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    16,
    ""
  ],
  [
    "8980",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    17,
    "",
    10,
    "",
    13,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "8a40",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "8a80",
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    9,
    "",
    5
  ],
  [
    "8b40",
    "",
    8,
    "",
    17,
    "",
    6,
    "",
    13,
    ""
  ],
  [
    "8b80",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    22,
    "",
    11,
    "",
    25,
    "",
    7,
    "",
    6
  ],
  [
    "8c40",
    "",
    7,
    ""
  ],
  [
    "8c80",
    "",
    8,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    4
  ],
  [
    "8d40",
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    9,
    "",
    4
  ],
  [
    "8d80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    10,
    "",
    12,
    "",
    21,
    ""
  ],
  [
    "8e40",
    "",
    21,
    "",
    12,
    "",
    6,
    "",
    12,
    ""
  ],
  [
    "8e80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    4,
    "",
    6
  ],
  [
    "8f40",
    "",
    5,
    "",
    11,
    "",
    8,
    ""
  ],
  [
    "8f80",
    "",
    6,
    "",
    14,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9040",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9080",
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    18,
    "",
    6
  ],
  [
    "9140",
    "",
    6,
    "",
    6,
    "",
    18,
    "",
    4,
    ""
  ],
  [
    "9180",
    "",
    6,
    "",
    8,
    "",
    9,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    16,
    "",
    13,
    "",
    8,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9280",
    "",
    5,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9340",
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9380",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    9,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9440",
    "",
    24,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    8
  ],
  [
    "9480",
    "",
    4,
    "",
    4,
    "",
    14,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "9540",
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9580",
    "",
    4,
    "",
    4,
    "",
    8,
    "",
    4,
    "",
    4,
    "",
    25,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "9640",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "9680",
    "",
    7,
    "",
    9,
    "",
    7,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    5
  ],
  [
    "9740",
    "",
    7,
    "",
    8,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9780",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    9,
    "",
    4,
    "",
    11,
    "",
    7,
    "",
    16,
    ""
  ],
  [
    "9840",
    "",
    4,
    "",
    5,
    "",
    9,
    ""
  ],
  [
    "9880",
    "",
    7,
    "",
    5,
    "",
    11,
    "",
    9,
    "",
    9,
    "",
    11,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "9940",
    "",
    4,
    "",
    10,
    "",
    6,
    "",
    8,
    "",
    4,
    "",
    7,
    "",
    5
  ],
  [
    "9980",
    "",
    114,
    "",
    6
  ],
  [
    "9a40",
    "",
    11,
    "",
    7,
    "",
    13,
    ""
  ],
  [
    "9a80",
    "",
    4,
    "",
    7,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "9b40",
    "",
    4,
    ""
  ],
  [
    "9b80",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9c40",
    "",
    7,
    ""
  ],
  [
    "9c80",
    "",
    7,
    "",
    7,
    "",
    10,
    "",
    14,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "9d40",
    "",
    7,
    "",
    4,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "9d80",
    "",
    9,
    "",
    5,
    "",
    6,
    "",
    12,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "9e40",
    "",
    7,
    "",
    32,
    "",
    7,
    "",
    6,
    "",
    6
  ],
  [
    "9e80",
    "",
    9,
    "",
    17,
    "",
    13,
    "",
    11,
    "",
    12,
    "",
    12,
    ""
  ],
  [
    "9f40",
    "",
    6,
    "",
    10,
    "",
    4,
    "",
    10,
    "",
    7,
    ""
  ],
  [
    "9f80",
    "",
    13,
    "",
    12,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    8,
    "",
    9,
    "",
    4
  ],
  [
    "a040",
    "",
    9,
    "",
    5,
    "",
    9,
    "",
    11,
    "",
    19
  ],
  [
    "a080",
    "",
    9,
    "",
    6,
    "",
    4,
    "",
    11,
    "",
    11,
    "",
    6,
    ""
  ],
  [
    "a1a1",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9
  ],
  [
    "a2b1",
    "",
    19,
    "",
    19,
    "",
    9
  ],
  [
    "a2e5",
    "",
    9
  ],
  [
    "a2f1",
    "",
    11
  ],
  [
    "a3a1",
    "",
    88,
    ""
  ],
  [
    "a4a1",
    "",
    82
  ],
  [
    "a5a1",
    "",
    85
  ],
  [
    "a6a1",
    "",
    16,
    "",
    6
  ],
  [
    "a6c1",
    "",
    16,
    "",
    6
  ],
  [
    "a6e0",
    ""
  ],
  [
    "a6ee",
    ""
  ],
  [
    "a6f4",
    ""
  ],
  [
    "a7a1",
    "",
    5,
    "",
    25
  ],
  [
    "a7d1",
    "",
    5,
    "",
    25
  ],
  [
    "a840",
    "",
    35,
    "",
    6
  ],
  [
    "a880",
    "",
    7,
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a8bd",
    ""
  ],
  [
    "a8c0",
    ""
  ],
  [
    "a8c5",
    "",
    36
  ],
  [
    "a940",
    "",
    8,
    ""
  ],
  [
    "a959",
    ""
  ],
  [
    "a95c",
    ""
  ],
  [
    "a960",
    "",
    9,
    "",
    8
  ],
  [
    "a980",
    "",
    4,
    ""
  ],
  [
    "a996",
    ""
  ],
  [
    "a9a4",
    "",
    75
  ],
  [
    "aa40",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "aa80",
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "ab40",
    "",
    11,
    "",
    4,
    "",
    5,
    "",
    4
  ],
  [
    "ab80",
    "",
    6,
    "",
    4
  ],
  [
    "ac40",
    "",
    10,
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11
  ],
  [
    "ac80",
    "",
    6,
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "ad40",
    "",
    10,
    "",
    7,
    "",
    15,
    "",
    12
  ],
  [
    "ad80",
    "",
    9,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "ae40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "ae80",
    "",
    7,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "af40",
    "",
    4,
    ""
  ],
  [
    "af80",
    ""
  ],
  [
    "b040",
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "b080",
    "",
    7,
    "",
    8,
    "",
    9,
    ""
  ],
  [
    "b140",
    "",
    4,
    "",
    7,
    "",
    10,
    ""
  ],
  [
    "b180",
    "",
    4,
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "b240",
    "",
    11,
    "",
    5,
    "",
    11,
    "",
    4
  ],
  [
    "b280",
    "",
    12,
    "",
    8,
    "",
    4,
    ""
  ],
  [
    "b340",
    "",
    5,
    ""
  ],
  [
    "b380",
    "",
    11,
    "",
    7,
    "",
    6,
    ""
  ],
  [
    "b440",
    "",
    7,
    "",
    9
  ],
  [
    "b480",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "b540",
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    14,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "b580",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b640",
    "",
    6,
    "",
    11,
    "",
    10,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "b680",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "b740",
    "",
    14,
    "",
    5,
    "",
    9,
    "",
    4,
    "",
    16
  ],
  [
    "b780",
    "",
    6,
    ""
  ],
  [
    "b840",
    "",
    4,
    "",
    10,
    "",
    10,
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "b880",
    "",
    4,
    ""
  ],
  [
    "b940",
    "",
    5,
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "b980",
    "",
    7,
    ""
  ],
  [
    "ba40",
    "",
    4,
    "",
    4,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "ba80",
    "",
    4,
    "",
    5,
    "",
    12,
    "",
    5,
    ""
  ],
  [
    "bb40",
    "",
    9,
    "",
    36,
    "",
    5,
    "",
    9
  ],
  [
    "bb80",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "bc40",
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    13,
    "",
    5
  ],
  [
    "bc80",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "bd40",
    "",
    54,
    "",
    7
  ],
  [
    "bd80",
    "",
    32,
    ""
  ],
  [
    "be40",
    "",
    12,
    "",
    6,
    "",
    42
  ],
  [
    "be80",
    "",
    32,
    ""
  ],
  [
    "bf40",
    "",
    62
  ],
  [
    "bf80",
    "",
    4,
    "",
    4,
    "",
    21,
    ""
  ],
  [
    "c040",
    "",
    35,
    "",
    23,
    ""
  ],
  [
    "c080",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "c140",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c180",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c240",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c280",
    "",
    13,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c340",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "c380",
    "",
    12,
    "",
    4,
    ""
  ],
  [
    "c440",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "c480",
    "",
    7,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c540",
    "",
    14,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c580",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c680",
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "c740",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "c780",
    ""
  ],
  [
    "c840",
    "",
    4,
    "",
    5,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c880",
    "",
    6,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "c940",
    "",
    4,
    "",
    7,
    "",
    12,
    ""
  ],
  [
    "c980",
    "",
    4,
    "",
    4,
    "",
    10,
    ""
  ],
  [
    "ca40",
    "",
    8,
    "",
    8,
    "",
    9,
    "",
    4,
    "",
    10
  ],
  [
    "ca80",
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "cb40",
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cb80",
    "",
    5,
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "cc40",
    "",
    4,
    "",
    10,
    "",
    15,
    "",
    13,
    ""
  ],
  [
    "cc80",
    "",
    11,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "cd40",
    "",
    6,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "cd80",
    ""
  ],
  [
    "ce40",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "ce80",
    "",
    4,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "cf40",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    9
  ],
  [
    "cf80",
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "d040",
    "",
    13,
    "",
    5,
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "d080",
    "",
    4,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "d140",
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5
  ],
  [
    "d180",
    "",
    4,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "d240",
    "",
    8,
    "",
    24,
    "",
    5,
    "",
    19,
    ""
  ],
  [
    "d280",
    "",
    26,
    ""
  ],
  [
    "d340",
    "",
    30,
    "",
    6
  ],
  [
    "d380",
    "",
    4,
    "",
    5,
    "",
    21,
    ""
  ],
  [
    "d440",
    "",
    31,
    "",
    8,
    "",
    21
  ],
  [
    "d480",
    "",
    25,
    "",
    6,
    ""
  ],
  [
    "d540",
    "",
    7,
    "",
    7,
    "",
    46
  ],
  [
    "d580",
    "",
    32,
    ""
  ],
  [
    "d640",
    "",
    34,
    "",
    27
  ],
  [
    "d680",
    "",
    30,
    ""
  ],
  [
    "d740",
    "",
    31,
    "",
    4,
    "",
    25
  ],
  [
    "d780",
    "",
    24,
    ""
  ],
  [
    "d840",
    "",
    8,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "d880",
    "",
    6,
    "",
    20,
    ""
  ],
  [
    "d940",
    "",
    62
  ],
  [
    "d980",
    "",
    32,
    ""
  ],
  [
    "da40",
    "",
    14,
    "",
    8,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "da80",
    "",
    12,
    ""
  ],
  [
    "db40",
    "",
    6,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "db80",
    "",
    4,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "dc40",
    "",
    4,
    "",
    6,
    "",
    6,
    "",
    11,
    "",
    6,
    "",
    7
  ],
  [
    "dc80",
    "",
    10,
    "",
    21,
    ""
  ],
  [
    "dd40",
    "",
    62
  ],
  [
    "dd80",
    "",
    32,
    ""
  ],
  [
    "de40",
    "",
    32,
    ""
  ],
  [
    "de80",
    "",
    4,
    ""
  ],
  [
    "df40",
    "",
    5,
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "df80",
    "",
    4,
    ""
  ],
  [
    "e040",
    "",
    19,
    ""
  ],
  [
    "e080",
    "",
    10,
    "",
    6,
    "",
    8,
    ""
  ],
  [
    "e140",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    ""
  ],
  [
    "e180",
    "",
    10,
    "",
    9,
    "",
    8,
    ""
  ],
  [
    "e240",
    "",
    62
  ],
  [
    "e280",
    "",
    32,
    "",
    5,
    ""
  ],
  [
    "e340",
    "",
    45,
    "",
    16
  ],
  [
    "e380",
    "",
    7,
    "",
    24,
    ""
  ],
  [
    "e440",
    "",
    5,
    "",
    24,
    "",
    31
  ],
  [
    "e480",
    "",
    32,
    ""
  ],
  [
    "e540",
    "",
    51,
    "",
    10
  ],
  [
    "e580",
    "",
    31,
    ""
  ],
  [
    "e640",
    "",
    34,
    "",
    27
  ],
  [
    "e680",
    "",
    29,
    ""
  ],
  [
    "e740",
    "",
    7,
    "",
    54
  ],
  [
    "e780",
    "",
    32,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "e840",
    "",
    14,
    "",
    43,
    ""
  ],
  [
    "e880",
    "",
    20,
    ""
  ],
  [
    "e940",
    "",
    7,
    "",
    42
  ],
  [
    "e980",
    "",
    32,
    ""
  ],
  [
    "ea40",
    "",
    27,
    "",
    6,
    ""
  ],
  [
    "ea80",
    "",
    4,
    "",
    12,
    ""
  ],
  [
    "eb40",
    "",
    9,
    "",
    7,
    "",
    9,
    "",
    6,
    ""
  ],
  [
    "eb80",
    "",
    4,
    ""
  ],
  [
    "ec40",
    "",
    8,
    "",
    4,
    "",
    18,
    "",
    7
  ],
  [
    "ec80",
    "",
    4,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ed40",
    "",
    6,
    "",
    46
  ],
  [
    "ed80",
    "",
    4,
    "",
    23,
    ""
  ],
  [
    "ee40",
    "",
    62
  ],
  [
    "ee80",
    "",
    32,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "ef40",
    "",
    5,
    "",
    37,
    "",
    4
  ],
  [
    "ef80",
    "",
    30,
    "",
    4,
    "",
    8,
    ""
  ],
  [
    "f040",
    "",
    4,
    "",
    28,
    "",
    26
  ],
  [
    "f080",
    "",
    9,
    "",
    12,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "f140",
    "",
    10,
    "",
    47
  ],
  [
    "f180",
    "",
    32,
    ""
  ],
  [
    "f240",
    "",
    62
  ],
  [
    "f280",
    "",
    32,
    ""
  ],
  [
    "f340",
    "",
    17,
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "f380",
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "f440",
    "",
    5,
    "",
    10,
    "",
    10,
    "",
    7,
    "",
    5
  ],
  [
    "f480",
    "",
    32,
    ""
  ],
  [
    "f540",
    "",
    62
  ],
  [
    "f580",
    "",
    32,
    ""
  ],
  [
    "f640",
    "",
    62
  ],
  [
    "f680",
    "",
    32,
    "",
    5,
    "",
    5,
    "",
    4,
    "",
    7,
    ""
  ],
  [
    "f740",
    "",
    62
  ],
  [
    "f780",
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "f840",
    "",
    62
  ],
  [
    "f880",
    "",
    32
  ],
  [
    "f940",
    "",
    62
  ],
  [
    "f980",
    "",
    32
  ],
  [
    "fa40",
    "",
    62
  ],
  [
    "fa80",
    "",
    32
  ],
  [
    "fb40",
    "",
    27,
    "",
    9,
    ""
  ],
  [
    "fb80",
    "",
    5,
    "",
    8,
    "",
    5,
    ""
  ],
  [
    "fc40",
    "",
    8,
    "",
    4,
    "",
    8,
    "",
    6
  ],
  [
    "fc80",
    "",
    4,
    "",
    5,
    "",
    8,
    ""
  ],
  [
    "fd40",
    "",
    4,
    "",
    4,
    "",
    10,
    "",
    38
  ],
  [
    "fd80",
    "",
    5,
    "",
    11,
    "",
    4,
    ""
  ],
  [
    "fe40",
    ""
  ]
], Hf = [
  [
    "a140",
    "",
    62
  ],
  [
    "a180",
    "",
    32
  ],
  [
    "a240",
    "",
    62
  ],
  [
    "a280",
    "",
    32
  ],
  [
    "a2ab",
    "",
    5
  ],
  [
    "a2e3",
    ""
  ],
  [
    "a2ef",
    ""
  ],
  [
    "a2fd",
    ""
  ],
  [
    "a340",
    "",
    62
  ],
  [
    "a380",
    "",
    31,
    ""
  ],
  [
    "a440",
    "",
    62
  ],
  [
    "a480",
    "",
    32
  ],
  [
    "a4f4",
    "",
    10
  ],
  [
    "a540",
    "",
    62
  ],
  [
    "a580",
    "",
    32
  ],
  [
    "a5f7",
    "",
    7
  ],
  [
    "a640",
    "",
    62
  ],
  [
    "a680",
    "",
    32
  ],
  [
    "a6b9",
    "",
    7
  ],
  [
    "a6d9",
    "",
    6
  ],
  [
    "a6ec",
    ""
  ],
  [
    "a6f3",
    ""
  ],
  [
    "a6f6",
    "",
    8
  ],
  [
    "a740",
    "",
    62
  ],
  [
    "a780",
    "",
    32
  ],
  [
    "a7c2",
    "",
    14
  ],
  [
    "a7f2",
    "",
    12
  ],
  [
    "a896",
    "",
    10
  ],
  [
    "a8bc",
    ""
  ],
  [
    "a8bf",
    ""
  ],
  [
    "a8c1",
    ""
  ],
  [
    "a8ea",
    "",
    20
  ],
  [
    "a958",
    ""
  ],
  [
    "a95b",
    ""
  ],
  [
    "a95d",
    ""
  ],
  [
    "a989",
    "",
    11
  ],
  [
    "a997",
    "",
    12
  ],
  [
    "a9f0",
    "",
    14
  ],
  [
    "aaa1",
    "",
    93
  ],
  [
    "aba1",
    "",
    93
  ],
  [
    "aca1",
    "",
    93
  ],
  [
    "ada1",
    "",
    93
  ],
  [
    "aea1",
    "",
    93
  ],
  [
    "afa1",
    "",
    93
  ],
  [
    "d7fa",
    "",
    4
  ],
  [
    "f8a1",
    "",
    93
  ],
  [
    "f9a1",
    "",
    93
  ],
  [
    "faa1",
    "",
    93
  ],
  [
    "fba1",
    "",
    93
  ],
  [
    "fca1",
    "",
    93
  ],
  [
    "fda1",
    "",
    93
  ],
  [
    "fe50",
    ""
  ],
  [
    "fe80",
    "",
    6,
    "",
    93
  ],
  [
    "8135f437",
    ""
  ]
<<<<<<< HEAD
];
const uChars = [
=======
], n8 = [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
<<<<<<< HEAD
];
const gbChars = [
=======
], r8 = [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
<<<<<<< HEAD
];
const require$$4 = {
  uChars,
  gbChars
};
const require$$5 = [
=======
], i8 = {
  uChars: n8,
  gbChars: r8
}, a8 = [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8161",
    "",
    9,
    "",
    5,
    ""
  ],
  [
    "8181",
    "",
    18,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "8241",
    "",
    7,
    "",
    5
  ],
  [
    "8261",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8281",
    "",
    7,
    "",
    7,
    "",
    4,
    "",
    10,
    "",
    5,
    "",
    17,
    "",
    7,
    "",
    6,
    "",
    7,
    "",
    18
  ],
  [
    "8341",
    "",
    5,
    "",
    5,
    "",
    7
  ],
  [
    "8361",
    "",
    18,
    ""
  ],
  [
    "8381",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    46,
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8441",
    "",
    5,
    "",
    8
  ],
  [
    "8461",
    "",
    18
  ],
  [
    "8481",
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    18,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8541",
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4
  ],
  [
    "8561",
    "",
    5,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8581",
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    29,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8641",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8661",
    "",
    6,
    "",
    10
  ],
  [
    "8681",
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    22,
    "",
    4,
    ""
  ],
  [
    "8741",
    "",
    9,
    "",
    15
  ],
  [
    "8761",
    "",
    18,
    ""
  ],
  [
    "8781",
    "",
    5,
    "",
    7,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    4
  ],
  [
    "8841",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "8861",
    "",
    4,
    ""
  ],
  [
    "8881",
    "",
    15,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    54,
    ""
  ],
  [
    "8941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "8961",
    "",
    10,
    "",
    5,
    ""
  ],
  [
    "8981",
    "",
    21,
    "",
    18,
    "",
    18,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    15
  ],
  [
    "8a41",
    "",
    10,
    "",
    6,
    ""
  ],
  [
    "8a61",
    "",
    4,
    "",
    18,
    ""
  ],
  [
    "8a81",
    "",
    4,
    "",
    19,
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    5,
    "",
    26,
    ""
  ],
  [
    "8b41",
    "",
    5,
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "8b61",
    "",
    6,
    "",
    8
  ],
  [
    "8b81",
    "",
    52,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    18
  ],
  [
    "8c41",
    "",
    15,
    "",
    4
  ],
  [
    "8c61",
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "8c81",
    "",
    12,
    "",
    26,
    "",
    50,
    "",
    5,
    "",
    16
  ],
  [
    "8d41",
    "",
    16,
    "",
    8
  ],
  [
    "8d61",
    "",
    17,
    ""
  ],
  [
    "8d81",
    "",
    4,
    "",
    33,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    9,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "8e41",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "8e61",
    "",
    4,
    "",
    19
  ],
  [
    "8e81",
    "",
    13,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    11,
    "",
    7,
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "8f41",
    "",
    7,
    "",
    17
  ],
  [
    "8f61",
    "",
    7,
    "",
    6,
    "",
    4
  ],
  [
    "8f81",
    "",
    5,
    "",
    7,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    26,
    "",
    6,
    "",
    5
  ],
  [
    "9041",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9061",
    "",
    5,
    "",
    15
  ],
  [
    "9081",
    "",
    12,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    4,
    "",
    5,
    "",
    11,
    "",
    33,
    ""
  ],
  [
    "9141",
    "",
    6,
    "",
    5
  ],
  [
    "9161",
    "",
    9,
    "",
    5
  ],
  [
    "9181",
    "",
    20,
    "",
    4,
    "",
    5,
    "",
    14,
    "",
    33,
    "",
    7,
    "",
    5,
    "",
    6
  ],
  [
    "9241",
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "9261",
    "",
    7,
    "",
    7,
    "",
    4
  ],
  [
    "9281",
    "",
    21,
    "",
    18,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    35,
    ""
  ],
  [
    "9341",
    "",
    4,
    ""
  ],
  [
    "9361",
    "",
    6,
    "",
    8
  ],
  [
    "9381",
    "",
    37,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    22,
    ""
  ],
  [
    "9441",
    "",
    5,
    "",
    5,
    "",
    8
  ],
  [
    "9461",
    "",
    5,
    "",
    6,
    "",
    12
  ],
  [
    "9481",
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    22,
    "",
    4,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    24
  ],
  [
    "9541",
    "",
    11,
    "",
    5,
    ""
  ],
  [
    "9561",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9581",
    "",
    6,
    "",
    35,
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    13,
    "",
    14
  ],
  [
    "9641",
    "",
    23,
    ""
  ],
  [
    "9661",
    "",
    6,
    "",
    5,
    "",
    8
  ],
  [
    "9681",
    "",
    10,
    "",
    5,
    "",
    13,
    "",
    33,
    "",
    6,
    "",
    44
  ],
  [
    "9741",
    "",
    16,
    "",
    8
  ],
  [
    "9761",
    "",
    17,
    "",
    7
  ],
  [
    "9781",
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    89,
    ""
  ],
  [
    "9841",
    "",
    16,
    "",
    5,
    ""
  ],
  [
    "9861",
    "",
    6,
    "",
    15
  ],
  [
    "9881",
    "",
    21,
    "",
    6,
    "",
    5,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9961",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9981",
    "",
    8,
    "",
    5,
    "",
    4,
    "",
    11,
    "",
    5,
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9a41",
    "",
    16
  ],
  [
    "9a61",
    "",
    6,
    "",
    6,
    ""
  ],
  [
    "9a81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    33,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9b41",
    "",
    6,
    "",
    8
  ],
  [
    "9b61",
    "",
    17,
    "",
    7
  ],
  [
    "9b81",
    "",
    25,
    "",
    4,
    "",
    5,
    "",
    50,
    "",
    22,
    ""
  ],
  [
    "9c41",
    "",
    4,
    "",
    5,
    "",
    5
  ],
  [
    "9c61",
    "",
    8,
    "",
    6,
    "",
    9
  ],
  [
    "9c81",
    "",
    8,
    "",
    6,
    "",
    6,
    "",
    9,
    "",
    26,
    "",
    6,
    "",
    5,
    "",
    18,
    "",
    6,
    "",
    12
  ],
  [
    "9d41",
    "",
    13,
    "",
    8
  ],
  [
    "9d61",
    "",
    25
  ],
  [
    "9d81",
    "",
    8,
    "",
    5,
    "",
    9,
    "",
    6,
    "",
    10,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9e41",
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "9e61",
    "",
    4,
    "",
    6,
    ""
  ],
  [
    "9e81",
    "",
    6,
    "",
    6,
    "",
    6,
    "",
    5,
    "",
    10,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "9f41",
    "",
    5,
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "9f61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "9f81",
    "",
    4,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    4,
    "",
    6,
    "",
    7,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "a041",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "a061",
    "",
    5,
    "",
    13
  ],
  [
    "a081",
    "",
    4,
    "",
    4,
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    6,
    "",
    5,
    "",
    26,
    "",
    4,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "a141",
    "",
    18,
    ""
  ],
  [
    "a161",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a181",
    "",
    14,
    "",
    5,
    "",
    4,
    "",
    9,
    ""
  ],
  [
    "a241",
    "",
    5,
    "",
    18
  ],
  [
    "a261",
    "",
    6,
    "",
    18
  ],
  [
    "a281",
    "",
    7,
    "",
    6,
    "",
    7,
    ""
  ],
  [
    "a341",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "a361",
    "",
    6,
    "",
    16
  ],
  [
    "a381",
    "",
    16,
    "",
    4,
    "",
    58,
    "",
    32,
    ""
  ],
  [
    "a441",
    "",
    5,
    ""
  ],
  [
    "a461",
    "",
    5,
    "",
    12
  ],
  [
    "a481",
    "",
    28,
    "",
    93
  ],
  [
    "a541",
    "",
    4,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "a561",
    "",
    17,
    "",
    5,
    ""
  ],
  [
    "a581",
    "",
    16,
    "",
    14,
    "",
    9
  ],
  [
    "a5b0",
    "",
    9
  ],
  [
    "a5c1",
    "",
    16,
    "",
    6
  ],
  [
    "a5e1",
    "",
    16,
    "",
    6
  ],
  [
    "a641",
    "",
    19,
    ""
  ],
  [
    "a661",
    "",
    5,
    "",
    5,
    "",
    6
  ],
  [
    "a681",
    "",
    6,
    "",
    18,
    "",
    7
  ],
  [
    "a741",
    "",
    4,
    "",
    6,
    "",
    7
  ],
  [
    "a761",
    "",
    22,
    ""
  ],
  [
    "a781",
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    9,
    "",
    9,
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "a841",
    "",
    10,
    "",
    14
  ],
  [
    "a861",
    "",
    18,
    "",
    6
  ],
  [
    "a881",
    "",
    19,
    "",
    11,
    ""
  ],
  [
    "a8a6",
    ""
  ],
  [
    "a8a8",
    ""
  ],
  [
    "a8b1",
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "a941",
    "",
    14,
    "",
    10
  ],
  [
    "a961",
    "",
    18
  ],
  [
    "a981",
    "",
    14,
    "",
    6,
    "",
    27,
    "",
    25,
    "",
    14,
    ""
  ],
  [
    "aa41",
    "",
    6,
    "",
    4,
    ""
  ],
  [
    "aa61",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "aa81",
    "",
    29,
    "",
    82
  ],
  [
    "ab41",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "ab61",
    "",
    6,
    "",
    5,
    "",
    5
  ],
  [
    "ab81",
    "",
    8,
    "",
    6,
    "",
    12,
    "",
    85
  ],
  [
    "ac41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ac61",
    "",
    11,
    "",
    4
  ],
  [
    "ac81",
    "",
    28,
    "",
    5,
    "",
    25
  ],
  [
    "acd1",
    "",
    5,
    "",
    25
  ],
  [
    "ad41",
    "",
    6,
    "",
    5,
    "",
    7
  ],
  [
    "ad61",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "ad81",
    "",
    5,
    "",
    18,
    ""
  ],
  [
    "ae41",
    "",
    5,
    "",
    16
  ],
  [
    "ae61",
    "",
    5,
    "",
    6,
    "",
    4
  ],
  [
    "ae81",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "af41",
    "",
    19
  ],
  [
    "af61",
    "",
    13,
    "",
    5,
    ""
  ],
  [
    "af81",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b041",
    "",
    5,
    "",
    5,
    "",
    12
  ],
  [
    "b061",
    "",
    5,
    "",
    19
  ],
  [
    "b081",
    "",
    13,
    "",
    6,
    "",
    5,
    "",
    7,
    "",
    4,
    ""
  ],
  [
    "b141",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b161",
    "",
    6,
    "",
    5,
    "",
    11
  ],
  [
    "b181",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b241",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b261",
    "",
    18,
    "",
    5,
    ""
  ],
  [
    "b281",
    "",
    5,
    "",
    18,
    "",
    6,
    ""
  ],
  [
    "b341",
    "",
    19,
    ""
  ],
  [
    "b361",
    "",
    5,
    "",
    5,
    "",
    5
  ],
  [
    "b381",
    "",
    5,
    "",
    5,
    "",
    19,
    "",
    4,
    ""
  ],
  [
    "b441",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "b461",
    "",
    6,
    "",
    10,
    ""
  ],
  [
    "b481",
    "",
    6,
    "",
    18,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "b541",
    "",
    14,
    "",
    5
  ],
  [
    "b561",
    "",
    5,
    "",
    5,
    "",
    4
  ],
  [
    "b581",
    "",
    6,
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "b641",
    "",
    7,
    "",
    17
  ],
  [
    "b661",
    "",
    15,
    ""
  ],
  [
    "b681",
    "",
    5,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b741",
    "",
    13,
    "",
    6,
    ""
  ],
  [
    "b761",
    "",
    20,
    ""
  ],
  [
    "b781",
    "",
    6,
    "",
    14,
    ""
  ],
  [
    "b841",
    "",
    7,
    "",
    17
  ],
  [
    "b861",
    "",
    8,
    "",
    13
  ],
  [
    "b881",
    "",
    5,
    "",
    24,
    "",
    4,
    ""
  ],
  [
    "b941",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "b961",
    "",
    14,
    "",
    6,
    ""
  ],
  [
    "b981",
    "",
    22,
    "",
    4,
    "",
    4,
    ""
  ],
  [
    "ba41",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "ba61",
    "",
    5,
    "",
    4,
    "",
    5
  ],
  [
    "ba81",
    "",
    6,
    "",
    9,
    ""
  ],
  [
    "bb41",
    "",
    4,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bb61",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "bb81",
    "",
    31,
    ""
  ],
  [
    "bc41",
    "",
    17,
    ""
  ],
  [
    "bc61",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "bc81",
    "",
    4,
    "",
    6,
    "",
    5,
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "bd41",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "bd61",
    "",
    5,
    "",
    13
  ],
  [
    "bd81",
    "",
    5,
    "",
    25,
    ""
  ],
  [
    "be41",
    "",
    7,
    "",
    14
  ],
  [
    "be61",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "be81",
    "",
    4,
    "",
    4,
    "",
    5,
    "",
    8,
    "",
    6,
    ""
  ],
  [
    "bf41",
    "",
    10,
    "",
    14
  ],
  [
    "bf61",
    "",
    18,
    ""
  ],
  [
    "bf81",
    "",
    5,
    "",
    7,
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c041",
    "",
    5,
    "",
    6,
    "",
    5
  ],
  [
    "c061",
    "",
    25
  ],
  [
    "c081",
    "",
    6,
    "",
    5,
    "",
    7,
    ""
  ],
  [
    "c141",
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c161",
    "",
    19,
    ""
  ],
  [
    "c181",
    "",
    31,
    ""
  ],
  [
    "c241",
    "",
    4,
    "",
    5,
    ""
  ],
  [
    "c261",
    "",
    4,
    "",
    5,
    "",
    6,
    ""
  ],
  [
    "c281",
    "",
    5,
    "",
    7,
    "",
    9,
    ""
  ],
  [
    "c341",
    "",
    4
  ],
  [
    "c361",
    "",
    4,
    "",
    5,
    "",
    11
  ],
  [
    "c381",
    "",
    5,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "c441",
    "",
    7,
    "",
    7,
    ""
  ],
  [
    "c461",
    "",
    5,
    "",
    4
  ],
  [
    "c481",
    "",
    5,
    "",
    11,
    ""
  ],
  [
    "c541",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c561",
    "",
    6,
    "",
    5,
    "",
    4
  ],
  [
    "c581",
    "",
    6,
    "",
    5,
    ""
  ],
  [
    "c641",
    "",
    6,
    "",
    5
  ],
  [
    "c6a1",
    ""
  ],
  [
    "c7a1",
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d1a1",
    "",
    5,
    "",
    4,
    ""
  ],
  [
    "d2a1",
    "",
    4,
    "",
    5,
    "",
    10,
    "",
    7,
    "",
    5,
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f9a1",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fda1",
    ""
  ]
], Gf = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    ""
  ],
  [
    "a1a1",
    "",
    4,
    ""
  ],
  [
    "a240",
    "",
    7,
    ""
  ],
  [
    "a2a1",
    "",
    9,
    "",
    9,
    "",
    8,
    "",
    25,
    "",
    21
  ],
  [
    "a340",
    "",
    16,
    "",
    6,
    "",
    16,
    "",
    6,
    "",
    10
  ],
  [
    "a3a1",
    "",
    25,
    ""
  ],
  [
    "a3e1",
    ""
  ],
  [
    "a440",
    ""
  ],
  [
    "a4a1",
    ""
  ],
  [
    "a540",
    ""
  ],
  [
    "a5a1",
    ""
  ],
  [
    "a640",
    ""
  ],
  [
    "a6a1",
    ""
  ],
  [
    "a740",
    ""
  ],
  [
    "a7a1",
    ""
  ],
  [
    "a840",
    ""
  ],
  [
    "a8a1",
    ""
  ],
  [
    "a940",
    ""
  ],
  [
    "a9a1",
    ""
  ],
  [
    "aa40",
    ""
  ],
  [
    "aaa1",
    ""
  ],
  [
    "ab40",
    ""
  ],
  [
    "aba1",
    ""
  ],
  [
    "ac40",
    ""
  ],
  [
    "aca1",
    ""
  ],
  [
    "ad40",
    ""
  ],
  [
    "ada1",
    ""
  ],
  [
    "ae40",
    ""
  ],
  [
    "aea1",
    ""
  ],
  [
    "af40",
    ""
  ],
  [
    "afa1",
    ""
  ],
  [
    "b040",
    ""
  ],
  [
    "b0a1",
    ""
  ],
  [
    "b140",
    ""
  ],
  [
    "b1a1",
    ""
  ],
  [
    "b240",
    ""
  ],
  [
    "b2a1",
    ""
  ],
  [
    "b340",
    ""
  ],
  [
    "b3a1",
    ""
  ],
  [
    "b440",
    ""
  ],
  [
    "b4a1",
    ""
  ],
  [
    "b540",
    ""
  ],
  [
    "b5a1",
    ""
  ],
  [
    "b640",
    ""
  ],
  [
    "b6a1",
    ""
  ],
  [
    "b740",
    ""
  ],
  [
    "b7a1",
    ""
  ],
  [
    "b840",
    ""
  ],
  [
    "b8a1",
    ""
  ],
  [
    "b940",
    ""
  ],
  [
    "b9a1",
    ""
  ],
  [
    "ba40",
    ""
  ],
  [
    "baa1",
    ""
  ],
  [
    "bb40",
    ""
  ],
  [
    "bba1",
    ""
  ],
  [
    "bc40",
    ""
  ],
  [
    "bca1",
    ""
  ],
  [
    "bd40",
    ""
  ],
  [
    "bda1",
    ""
  ],
  [
    "be40",
    ""
  ],
  [
    "bea1",
    ""
  ],
  [
    "bf40",
    ""
  ],
  [
    "bfa1",
    ""
  ],
  [
    "c040",
    ""
  ],
  [
    "c0a1",
    ""
  ],
  [
    "c140",
    ""
  ],
  [
    "c1a1",
    ""
  ],
  [
    "c240",
    ""
  ],
  [
    "c2a1",
    ""
  ],
  [
    "c340",
    ""
  ],
  [
    "c3a1",
    ""
  ],
  [
    "c440",
    ""
  ],
  [
    "c4a1",
    ""
  ],
  [
    "c540",
    ""
  ],
  [
    "c5a1",
    ""
  ],
  [
    "c640",
    ""
  ],
  [
    "c940",
    ""
  ],
  [
    "c9a1",
    ""
  ],
  [
    "ca40",
    ""
  ],
  [
    "caa1",
    ""
  ],
  [
    "cb40",
    ""
  ],
  [
    "cba1",
    ""
  ],
  [
    "cc40",
    ""
  ],
  [
    "cca1",
    ""
  ],
  [
    "cd40",
    ""
  ],
  [
    "cda1",
    ""
  ],
  [
    "ce40",
    ""
  ],
  [
    "cea1",
    ""
  ],
  [
    "cf40",
    ""
  ],
  [
    "cfa1",
    ""
  ],
  [
    "d040",
    ""
  ],
  [
    "d0a1",
    ""
  ],
  [
    "d140",
    ""
  ],
  [
    "d1a1",
    ""
  ],
  [
    "d240",
    ""
  ],
  [
    "d2a1",
    ""
  ],
  [
    "d340",
    ""
  ],
  [
    "d3a1",
    ""
  ],
  [
    "d440",
    ""
  ],
  [
    "d4a1",
    ""
  ],
  [
    "d540",
    ""
  ],
  [
    "d5a1",
    ""
  ],
  [
    "d640",
    ""
  ],
  [
    "d6a1",
    ""
  ],
  [
    "d740",
    ""
  ],
  [
    "d7a1",
    ""
  ],
  [
    "d840",
    ""
  ],
  [
    "d8a1",
    ""
  ],
  [
    "d940",
    ""
  ],
  [
    "d9a1",
    ""
  ],
  [
    "da40",
    ""
  ],
  [
    "daa1",
    ""
  ],
  [
    "db40",
    ""
  ],
  [
    "dba1",
    ""
  ],
  [
    "dc40",
    ""
  ],
  [
    "dca1",
    ""
  ],
  [
    "dd40",
    ""
  ],
  [
    "dda1",
    ""
  ],
  [
    "de40",
    ""
  ],
  [
    "dea1",
    ""
  ],
  [
    "df40",
    ""
  ],
  [
    "dfa1",
    ""
  ],
  [
    "e040",
    ""
  ],
  [
    "e0a1",
    ""
  ],
  [
    "e140",
    ""
  ],
  [
    "e1a1",
    ""
  ],
  [
    "e240",
    ""
  ],
  [
    "e2a1",
    ""
  ],
  [
    "e340",
    ""
  ],
  [
    "e3a1",
    ""
  ],
  [
    "e440",
    ""
  ],
  [
    "e4a1",
    ""
  ],
  [
    "e540",
    ""
  ],
  [
    "e5a1",
    ""
  ],
  [
    "e640",
    ""
  ],
  [
    "e6a1",
    ""
  ],
  [
    "e740",
    ""
  ],
  [
    "e7a1",
    ""
  ],
  [
    "e840",
    ""
  ],
  [
    "e8a1",
    ""
  ],
  [
    "e940",
    ""
  ],
  [
    "e9a1",
    ""
  ],
  [
    "ea40",
    ""
  ],
  [
    "eaa1",
    ""
  ],
  [
    "eb40",
    ""
  ],
  [
    "eba1",
    ""
  ],
  [
    "ec40",
    ""
  ],
  [
    "eca1",
    ""
  ],
  [
    "ed40",
    ""
  ],
  [
    "eda1",
    ""
  ],
  [
    "ee40",
    ""
  ],
  [
    "eea1",
    ""
  ],
  [
    "ef40",
    ""
  ],
  [
    "efa1",
    ""
  ],
  [
    "f040",
    ""
  ],
  [
    "f0a1",
    ""
  ],
  [
    "f140",
    ""
  ],
  [
    "f1a1",
    ""
  ],
  [
    "f240",
    ""
  ],
  [
    "f2a1",
    ""
  ],
  [
    "f340",
    ""
  ],
  [
    "f3a1",
    ""
  ],
  [
    "f440",
    ""
  ],
  [
    "f4a1",
    ""
  ],
  [
    "f540",
    ""
  ],
  [
    "f5a1",
    ""
  ],
  [
    "f640",
    ""
  ],
  [
    "f6a1",
    ""
  ],
  [
    "f740",
    ""
  ],
  [
    "f7a1",
    ""
  ],
  [
    "f840",
    ""
  ],
  [
    "f8a1",
    ""
  ],
  [
    "f940",
    ""
  ],
  [
    "f9a1",
    ""
  ]
<<<<<<< HEAD
];
const require$$7 = [
=======
], o8 = [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  [
    "8740",
    ""
  ],
  [
    "8767",
    ""
  ],
  [
    "87a1",
    ""
  ],
  [
    "8840",
    "",
    4,
    ""
  ],
  [
    "88a1",
    ""
  ],
  [
    "8940",
    ""
  ],
  [
    "8943",
    ""
  ],
  [
    "8946",
    ""
  ],
  [
    "894c",
    ""
  ],
  [
    "89a1",
    ""
  ],
  [
    "89ab",
    ""
  ],
  [
    "89b0",
    ""
  ],
  [
    "89b5",
    ""
  ],
  [
    "89c1",
    ""
  ],
  [
    "89c5",
    ""
  ],
  [
    "8a40",
    ""
  ],
  [
    "8a43",
    ""
  ],
  [
    "8a64",
    ""
  ],
  [
    "8a76",
    ""
  ],
  [
    "8aa1",
    ""
  ],
  [
    "8aac",
    ""
  ],
  [
    "8ab2",
    ""
  ],
  [
    "8abb",
    ""
  ],
  [
    "8ac9",
    ""
  ],
  [
    "8ace",
    ""
  ],
  [
    "8adf",
    ""
  ],
  [
    "8af6",
    ""
  ],
  [
    "8b40",
    ""
  ],
  [
    "8b55",
    ""
  ],
  [
    "8ba1",
    ""
  ],
  [
    "8bde",
    ""
  ],
  [
    "8c40",
    ""
  ],
  [
    "8ca1",
    ""
  ],
  [
    "8ca7",
    ""
  ],
  [
    "8cc9",
    ""
  ],
  [
    "8cce",
    ""
  ],
  [
    "8ce6",
    ""
  ],
  [
    "8d40",
    ""
  ],
  [
    "8d42",
    ""
  ],
  [
    "8da1",
    ""
  ],
  [
    "8e40",
    ""
  ],
  [
    "8ea1",
    ""
  ],
  [
    "8f40",
    ""
  ],
  [
    "8fa1",
    ""
  ],
  [
    "9040",
    ""
  ],
  [
    "90a1",
    ""
  ],
  [
    "9140",
    ""
  ],
  [
    "91a1",
    ""
  ],
  [
    "9240",
    ""
  ],
  [
    "92a1",
    ""
  ],
  [
    "9340",
    ""
  ],
  [
    "93a1",
    ""
  ],
  [
    "9440",
    ""
  ],
  [
    "94a1",
    ""
  ],
  [
    "9540",
    ""
  ],
  [
    "95a1",
    ""
  ],
  [
    "9640",
    ""
  ],
  [
    "96a1",
    ""
  ],
  [
    "9740",
    ""
  ],
  [
    "97a1",
    ""
  ],
  [
    "9840",
    ""
  ],
  [
    "98a1",
    ""
  ],
  [
    "9940",
    ""
  ],
  [
    "99a1",
    ""
  ],
  [
    "9a40",
    ""
  ],
  [
    "9aa1",
    ""
  ],
  [
    "9b40",
    ""
  ],
  [
    "9b62",
    ""
  ],
  [
    "9ba1",
    ""
  ],
  [
    "9c40",
    ""
  ],
  [
    "9ca1",
    ""
  ],
  [
    "9d40",
    ""
  ],
  [
    "9da1",
    ""
  ],
  [
    "9e40",
    ""
  ],
  [
    "9ea1",
    ""
  ],
  [
    "9ead",
    ""
  ],
  [
    "9ec5",
    ""
  ],
  [
    "9ef5",
    ""
  ],
  [
    "9f40",
    ""
  ],
  [
    "9f4f",
    ""
  ],
  [
    "9fa1",
    ""
  ],
  [
    "9fae",
    ""
  ],
  [
    "9fb2",
    ""
  ],
  [
    "9fc1",
    ""
  ],
  [
    "9fc9",
    ""
  ],
  [
    "9fdb",
    ""
  ],
  [
    "9fe7",
    ""
  ],
  [
    "9feb",
    ""
  ],
  [
    "9ff0",
    ""
  ],
  [
    "a040",
    ""
  ],
  [
    "a055",
    ""
  ],
  [
    "a058",
    ""
  ],
  [
    "a05b",
    ""
  ],
  [
    "a063",
    ""
  ],
  [
    "a073",
    ""
  ],
  [
    "a0a1",
    ""
  ],
  [
    "a0a6",
    ""
  ],
  [
    "a0ae",
    ""
  ],
  [
    "a0b0",
    ""
  ],
  [
    "a0d4",
    ""
  ],
  [
    "a0e2",
    ""
  ],
  [
    "a3c0",
    "",
    31,
    ""
  ],
  [
    "c6a1",
    "",
    9,
    "",
    9,
    "",
    9,
    "",
    23
  ],
  [
    "c740",
    "",
    58,
    ""
  ],
  [
    "c7a1",
    "",
    81,
    "",
    5,
    "",
    4
  ],
  [
    "c840",
    "",
    26,
    "",
    25,
    ""
  ],
  [
    "c8a1",
    ""
  ],
  [
    "c8cd",
    ""
  ],
  [
    "c8f5",
    ""
  ],
  [
    "f9fe",
    ""
  ],
  [
    "fa40",
    ""
  ],
  [
    "faa1",
    ""
  ],
  [
    "fb40",
    ""
  ],
  [
    "fba1",
    ""
  ],
  [
    "fc40",
    ""
  ],
  [
    "fca1",
    ""
  ],
  [
    "fd40",
    ""
  ],
  [
    "fda1",
    ""
  ],
  [
    "fe40",
    ""
  ],
  [
    "fea1",
    ""
  ]
];
<<<<<<< HEAD
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
=======
var wc, Wf;
function s8() {
  return Wf || (Wf = 1, wc = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    shiftjis: {
      type: "_dbcs",
      table: function() {
<<<<<<< HEAD
        return require$$0;
=======
        return e8;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      },
      encodeAdd: { "": 92, "": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    csshiftjis: "shiftjis",
    mskanji: "shiftjis",
    sjis: "shiftjis",
    windows31j: "shiftjis",
    ms31j: "shiftjis",
    xsjis: "shiftjis",
    windows932: "shiftjis",
    ms932: "shiftjis",
    932: "shiftjis",
    cp932: "shiftjis",
    eucjp: {
      type: "_dbcs",
      table: function() {
<<<<<<< HEAD
        return require$$1;
=======
        return t8;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      },
      encodeAdd: { "": 92, "": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    gb2312: "cp936",
    gb231280: "cp936",
    gb23121980: "cp936",
    csgb2312: "cp936",
    csiso58gb231280: "cp936",
    euccn: "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    windows936: "cp936",
    ms936: "cp936",
    936: "cp936",
    cp936: {
      type: "_dbcs",
      table: function() {
        return bc;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    gbk: {
      type: "_dbcs",
      table: function() {
        return bc.concat(Hf);
      }
    },
    xgbk: "gbk",
    isoir58: "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    gb18030: {
      type: "_dbcs",
      table: function() {
        return bc.concat(Hf);
      },
      gb18030: function() {
<<<<<<< HEAD
        return require$$4;
=======
        return i8;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      },
      encodeSkipVals: [128],
      encodeAdd: { "": 41699 }
    },
    chinese: "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    windows949: "cp949",
    ms949: "cp949",
    949: "cp949",
    cp949: {
      type: "_dbcs",
      table: function() {
<<<<<<< HEAD
        return require$$5;
=======
        return a8;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
    },
    cseuckr: "cp949",
    csksc56011987: "cp949",
    euckr: "cp949",
    isoir149: "cp949",
    korean: "cp949",
    ksc56011987: "cp949",
    ksc56011989: "cp949",
    ksc5601: "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    windows950: "cp950",
    ms950: "cp950",
    950: "cp950",
    cp950: {
      type: "_dbcs",
      table: function() {
        return Gf;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    big5: "big5hkscs",
    big5hkscs: {
      type: "_dbcs",
      table: function() {
<<<<<<< HEAD
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [
        // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
        // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
        // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
        36457,
        36463,
        36478,
        36523,
        36532,
        36557,
        36560,
        36695,
        36713,
        36718,
        36811,
        36862,
        36973,
        36986,
        37060,
        37084,
        37105,
        37311,
        37551,
        37552,
        37553,
        37554,
        37585,
        37959,
        38090,
        38361,
        38652,
        39285,
        39798,
        39800,
        39803,
        39878,
        39902,
        39916,
        39926,
        40002,
        40019,
        40034,
        40040,
        40043,
        40055,
        40124,
        40125,
        40144,
        40279,
        40282,
        40388,
        40431,
        40443,
        40617,
        40687,
        40701,
        40800,
        40907,
        41079,
        41180,
        41183,
        36812,
        37576,
        38468,
        38637,
        // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
        41636,
        41637,
        41639,
        41638,
        41676,
        41678
      ]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function(exports) {
    var modules = [
      requireInternal(),
      requireUtf32(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module = modules[i];
      for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports[enc] = module[enc];
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = safer_1.Buffer;
  streams = function(stream_module) {
    var Transform2 = stream_module.Transform;
    function IconvLiteEncoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.decodeStrings = false;
      Transform2.call(this, options);
    }
    IconvLiteEncoderStream.prototype = Object.create(Transform2.prototype, {
      constructor: { value: IconvLiteEncoderStream }
    });
    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
      if (typeof chunk != "string")
        return done(new Error("Iconv encoding stream needs strings as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteEncoderStream.prototype.collect = function(cb) {
      var chunks = [];
      this.on("error", cb);
      this.on("data", function(chunk) {
        chunks.push(chunk);
      });
      this.on("end", function() {
        cb(null, Buffer2.concat(chunks));
      });
      return this;
    };
    function IconvLiteDecoderStream(conv, options) {
      this.conv = conv;
      options = options || {};
      options.encoding = this.encoding = "utf8";
      Transform2.call(this, options);
    }
    IconvLiteDecoderStream.prototype = Object.create(Transform2.prototype, {
      constructor: { value: IconvLiteDecoderStream }
    });
    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
      if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
      try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype._flush = function(done) {
      try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
      } catch (e) {
        done(e);
      }
    };
    IconvLiteDecoderStream.prototype.collect = function(cb) {
      var res = "";
      this.on("error", cb);
      this.on("data", function(chunk) {
        res += chunk;
      });
      this.on("end", function() {
        cb(null, res);
      });
      return this;
    };
    return {
      IconvLiteEncoderStream,
      IconvLiteDecoderStream
    };
  };
  return streams;
}
(function(module) {
  var Buffer2 = safer_1.Buffer;
  var bomHandling$12 = bomHandling, iconv2 = module.exports;
  iconv2.encodings = null;
  iconv2.defaultCharUnicode = "";
  iconv2.defaultCharSingleByte = "?";
  iconv2.encode = function encode2(str2, encoding, options) {
    str2 = "" + (str2 || "");
    var encoder = iconv2.getEncoder(encoding, options);
    var res = encoder.write(str2);
    var trail = encoder.end();
    return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
  };
  iconv2.decode = function decode(buf, encoding, options) {
    if (typeof buf === "string") {
      if (!iconv2.skipDecodeWarning) {
        console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
        iconv2.skipDecodeWarning = true;
      }
      buf = Buffer2.from("" + (buf || ""), "binary");
    }
    var decoder = iconv2.getDecoder(encoding, options);
    var res = decoder.write(buf);
    var trail = decoder.end();
    return trail ? res + trail : res;
  };
  iconv2.encodingExists = function encodingExists(enc) {
    try {
      iconv2.getCodec(enc);
      return true;
    } catch (e) {
      return false;
    }
  };
  iconv2.toEncoding = iconv2.encode;
  iconv2.fromEncoding = iconv2.decode;
  iconv2._codecDataCache = {};
  iconv2.getCodec = function getCodec(encoding) {
    if (!iconv2.encodings)
      iconv2.encodings = requireEncodings();
    var enc = iconv2._canonicalizeEncoding(encoding);
    var codecOptions = {};
    while (true) {
      var codec = iconv2._codecDataCache[enc];
      if (codec)
        return codec;
      var codecDef = iconv2.encodings[enc];
      switch (typeof codecDef) {
        case "string":
          enc = codecDef;
          break;
        case "object":
          for (var key2 in codecDef)
            codecOptions[key2] = codecDef[key2];
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          enc = codecDef.type;
          break;
        case "function":
          if (!codecOptions.encodingName)
            codecOptions.encodingName = enc;
          codec = new codecDef(codecOptions, iconv2);
          iconv2._codecDataCache[codecOptions.encodingName] = codec;
          return codec;
        default:
          throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
      }
    }
  };
  iconv2._canonicalizeEncoding = function(encoding) {
    return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
  };
  iconv2.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv2.getCodec(encoding), encoder = new codec.encoder(options, codec);
    if (codec.bomAware && options && options.addBOM)
      encoder = new bomHandling$12.PrependBOM(encoder, options);
    return encoder;
  };
  iconv2.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv2.getCodec(encoding), decoder = new codec.decoder(options, codec);
    if (codec.bomAware && !(options && options.stripBOM === false))
      decoder = new bomHandling$12.StripBOM(decoder, options);
    return decoder;
  };
  iconv2.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
    if (iconv2.supportsStreams)
      return;
    var streams2 = requireStreams()(stream_module2);
    iconv2.IconvLiteEncoderStream = streams2.IconvLiteEncoderStream;
    iconv2.IconvLiteDecoderStream = streams2.IconvLiteDecoderStream;
    iconv2.encodeStream = function encodeStream(encoding, options) {
      return new iconv2.IconvLiteEncoderStream(iconv2.getEncoder(encoding, options), options);
    };
    iconv2.decodeStream = function decodeStream(encoding, options) {
      return new iconv2.IconvLiteDecoderStream(iconv2.getDecoder(encoding, options), options);
    };
    iconv2.supportsStreams = true;
  };
  var stream_module;
  try {
    stream_module = require("stream");
  } catch (e) {
  }
  if (stream_module && stream_module.Transform) {
    iconv2.enableStreamingAPI(stream_module);
  } else {
    iconv2.encodeStream = iconv2.decodeStream = function() {
      throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
    };
  }
})(lib$1);
var libExports = lib$1.exports;
let minidev;
const initMinidev = async () => {
  if (!minidev) {
    const require2 = createRequire(import.meta.url);
    minidev = require2("minidev");
  }
  return minidev;
};
class DevTools {
  constructor(win2) {
    __publicField(this, "windown");
    __publicField(this, "app_dir", require$$1$4.join(app.getPath("documents"), "code-sync"));
    __publicField(this, "configPath", require$$1$4.join(this.app_dir, "config.json"));
    __publicField(this, "runConfig");
=======
        return Gf.concat(o8);
      },
      encodeSkipVals: [41676]
    },
    cnbig5: "big5hkscs",
    csbig5: "big5hkscs",
    xxbig5: "big5hkscs"
  }), wc;
}
var Vf;
function c8() {
  return Vf || (Vf = 1, function(e) {
    for (var t = [
      WS(),
      VS(),
      YS(),
      XS(),
      KS(),
      JS(),
      ZS(),
      QS(),
      s8()
    ], n = 0; n < t.length; n++) {
      var r = t[n];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
    }
  }(hc)), hc;
}
var Ec, Yf;
function l8() {
  if (Yf) return Ec;
  Yf = 1;
  var e = Nt.Buffer, t = ie.Transform;
  Ec = function(i) {
    i.encodeStream = function(o, c) {
      return new n(i.getEncoder(o, c), c);
    }, i.decodeStream = function(o, c) {
      return new r(i.getDecoder(o, c), c);
    }, i.supportsStreams = !0, i.IconvLiteEncoderStream = n, i.IconvLiteDecoderStream = r, i._collect = r.prototype.collect;
  };
  function n(i, a) {
    this.conv = i, a = a || {}, a.decodeStrings = !1, t.call(this, a);
  }
  n.prototype = Object.create(t.prototype, {
    constructor: { value: n }
  }), n.prototype._transform = function(i, a, o) {
    if (typeof i != "string")
      return o(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var c = this.conv.write(i);
      c && c.length && this.push(c), o();
    } catch (s) {
      o(s);
    }
  }, n.prototype._flush = function(i) {
    try {
      var a = this.conv.end();
      a && a.length && this.push(a), i();
    } catch (o) {
      i(o);
    }
  }, n.prototype.collect = function(i) {
    var a = [];
    return this.on("error", i), this.on("data", function(o) {
      a.push(o);
    }), this.on("end", function() {
      i(null, e.concat(a));
    }), this;
  };
  function r(i, a) {
    this.conv = i, a = a || {}, a.encoding = this.encoding = "utf8", t.call(this, a);
  }
  return r.prototype = Object.create(t.prototype, {
    constructor: { value: r }
  }), r.prototype._transform = function(i, a, o) {
    if (!e.isBuffer(i))
      return o(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var c = this.conv.write(i);
      c && c.length && this.push(c, this.encoding), o();
    } catch (s) {
      o(s);
    }
  }, r.prototype._flush = function(i) {
    try {
      var a = this.conv.end();
      a && a.length && this.push(a, this.encoding), i();
    } catch (o) {
      i(o);
    }
  }, r.prototype.collect = function(i) {
    var a = "";
    return this.on("error", i), this.on("data", function(o) {
      a += o;
    }), this.on("end", function() {
      i(null, a);
    }), this;
  }, Ec;
}
var _c, Xf;
function u8() {
  if (Xf) return _c;
  Xf = 1;
  var e = Nt.Buffer;
  return _c = function(t) {
    var n = void 0;
    t.supportsNodeEncodingsExtension = !(e.from || new e(0) instanceof Uint8Array), t.extendNodeEncodings = function() {
      if (!n) {
        if (n = {}, !t.supportsNodeEncodingsExtension) {
          console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node"), console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
          return;
        }
        var i = {
          hex: !0,
          utf8: !0,
          "utf-8": !0,
          ascii: !0,
          binary: !0,
          base64: !0,
          ucs2: !0,
          "ucs-2": !0,
          utf16le: !0,
          "utf-16le": !0
        };
        e.isNativeEncoding = function(c) {
          return c && i[c.toLowerCase()];
        };
        var a = Nt.SlowBuffer;
        if (n.SlowBufferToString = a.prototype.toString, a.prototype.toString = function(c, s, u) {
          return c = String(c || "utf8").toLowerCase(), e.isNativeEncoding(c) ? n.SlowBufferToString.call(this, c, s, u) : (typeof s > "u" && (s = 0), typeof u > "u" && (u = this.length), t.decode(this.slice(s, u), c));
        }, n.SlowBufferWrite = a.prototype.write, a.prototype.write = function(c, s, u, l) {
          if (isFinite(s))
            isFinite(u) || (l = u, u = void 0);
          else {
            var p = l;
            l = s, s = u, u = p;
          }
          s = +s || 0;
          var d = this.length - s;
          if (u ? (u = +u, u > d && (u = d)) : u = d, l = String(l || "utf8").toLowerCase(), e.isNativeEncoding(l))
            return n.SlowBufferWrite.call(this, c, s, u, l);
          if (c.length > 0 && (u < 0 || s < 0))
            throw new RangeError("attempt to write beyond buffer bounds");
          var m = t.encode(c, l);
          return m.length < u && (u = m.length), m.copy(this, s, 0, u), u;
        }, n.BufferIsEncoding = e.isEncoding, e.isEncoding = function(c) {
          return e.isNativeEncoding(c) || t.encodingExists(c);
        }, n.BufferByteLength = e.byteLength, e.byteLength = a.byteLength = function(c, s) {
          return s = String(s || "utf8").toLowerCase(), e.isNativeEncoding(s) ? n.BufferByteLength.call(this, c, s) : t.encode(c, s).length;
        }, n.BufferToString = e.prototype.toString, e.prototype.toString = function(c, s, u) {
          return c = String(c || "utf8").toLowerCase(), e.isNativeEncoding(c) ? n.BufferToString.call(this, c, s, u) : (typeof s > "u" && (s = 0), typeof u > "u" && (u = this.length), t.decode(this.slice(s, u), c));
        }, n.BufferWrite = e.prototype.write, e.prototype.write = function(c, s, u, l) {
          var p = s, d = u, m = l;
          if (isFinite(s))
            isFinite(u) || (l = u, u = void 0);
          else {
            var g = l;
            l = s, s = u, u = g;
          }
          if (l = String(l || "utf8").toLowerCase(), e.isNativeEncoding(l))
            return n.BufferWrite.call(this, c, p, d, m);
          s = +s || 0;
          var v = this.length - s;
          if (u ? (u = +u, u > v && (u = v)) : u = v, c.length > 0 && (u < 0 || s < 0))
            throw new RangeError("attempt to write beyond buffer bounds");
          var y = t.encode(c, l);
          return y.length < u && (u = y.length), y.copy(this, s, 0, u), u;
        }, t.supportsStreams) {
          var o = ie.Readable;
          n.ReadableSetEncoding = o.prototype.setEncoding, o.prototype.setEncoding = function(s, u) {
            this._readableState.decoder = t.getDecoder(s, u), this._readableState.encoding = s;
          }, o.prototype.collect = t._collect;
        }
      }
    }, t.undoExtendNodeEncodings = function() {
      if (t.supportsNodeEncodingsExtension) {
        if (!n)
          throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
        delete e.isNativeEncoding;
        var i = Nt.SlowBuffer;
        if (i.prototype.toString = n.SlowBufferToString, i.prototype.write = n.SlowBufferWrite, e.isEncoding = n.BufferIsEncoding, e.byteLength = n.BufferByteLength, e.prototype.toString = n.BufferToString, e.prototype.write = n.BufferWrite, t.supportsStreams) {
          var a = ie.Readable;
          a.prototype.setEncoding = n.ReadableSetEncoding, delete a.prototype.collect;
        }
        n = void 0;
      }
    };
  }, _c;
}
var Kf;
function p8() {
  return Kf || (Kf = 1, function(e) {
    var t = Vn().Buffer, n = GS(), r = e.exports;
    r.encodings = null, r.defaultCharUnicode = "", r.defaultCharSingleByte = "?", r.encode = function(c, s, u) {
      c = "" + (c || "");
      var l = r.getEncoder(s, u), p = l.write(c), d = l.end();
      return d && d.length > 0 ? t.concat([p, d]) : p;
    }, r.decode = function(c, s, u) {
      typeof c == "string" && (r.skipDecodeWarning || (console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding"), r.skipDecodeWarning = !0), c = t.from("" + (c || ""), "binary"));
      var l = r.getDecoder(s, u), p = l.write(c), d = l.end();
      return d ? p + d : p;
    }, r.encodingExists = function(c) {
      try {
        return r.getCodec(c), !0;
      } catch {
        return !1;
      }
    }, r.toEncoding = r.encode, r.fromEncoding = r.decode, r._codecDataCache = {}, r.getCodec = function(c) {
      r.encodings || (r.encodings = c8());
      for (var s = r._canonicalizeEncoding(c), u = {}; ; ) {
        var l = r._codecDataCache[s];
        if (l)
          return l;
        var p = r.encodings[s];
        switch (typeof p) {
          case "string":
            s = p;
            break;
          case "object":
            for (var d in p)
              u[d] = p[d];
            u.encodingName || (u.encodingName = s), s = p.type;
            break;
          case "function":
            return u.encodingName || (u.encodingName = s), l = new p(u, r), r._codecDataCache[u.encodingName] = l, l;
          default:
            throw new Error("Encoding not recognized: '" + c + "' (searched as: '" + s + "')");
        }
      }
    }, r._canonicalizeEncoding = function(o) {
      return ("" + o).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    }, r.getEncoder = function(c, s) {
      var u = r.getCodec(c), l = new u.encoder(s, u);
      return u.bomAware && s && s.addBOM && (l = new n.PrependBOM(l, s)), l;
    }, r.getDecoder = function(c, s) {
      var u = r.getCodec(c), l = new u.decoder(s, u);
      return u.bomAware && !(s && s.stripBOM === !1) && (l = new n.StripBOM(l, s)), l;
    };
    var i = typeof process < "u" && process.versions && process.versions.node;
    if (i) {
      var a = i.split(".").map(Number);
      (a[0] > 0 || a[1] >= 10) && l8()(r), u8()(r);
    }
  }(fc)), fc.exports;
}
const Ea = Rt, f8 = ie, d8 = HS, _a = me;
let Sc;
const Tn = Symbol("ZipUncompressStream#yauzlCallback"), Jf = Symbol("ZipUncompressStream#stripName"), h8 = { lazyEntries: !0, decodeStrings: !1 };
function m8(e) {
  const t = e.externalFileAttributes >> 16 || 33188;
  return [
    448,
    56,
    7
    /* S_IRWXO */
  ].map((n) => t & n).reduce(
    (n, r) => n + r,
    t & 61440
    /* S_IFMT */
  );
}
let v8 = class extends d8 {
  constructor(t) {
    t = t || {}, super(t), this._chunks = [], this._strip = Number(t.strip) || 0, this._zipFileNameEncoding = t.zipFileNameEncoding || "utf8", this._zipFileNameEncoding === "utf-8" && (this._zipFileNameEncoding = "utf8"), this[Tn] = this[Tn].bind(this);
    const n = _a.sourceType(t.source), r = this._yauzlOpts = Object.assign({}, h8, t.yauzl);
    if (n === "file") {
      Ea.open(t.source, r, this[Tn]);
      return;
    }
    if (n === "buffer") {
      Ea.fromBuffer(t.source, r, this[Tn]);
      return;
    }
    if (n === "stream") {
      _a.streamToBuffer(t.source).then((i) => Ea.fromBuffer(i, r, this[Tn])).catch((i) => this.emit("error", i));
      return;
    }
    this.on("pipe", (i) => {
      i.unpipe(i), _a.streamToBuffer(i).then((a) => {
        this._chunks.push(a), a = Buffer.concat(this._chunks), Ea.fromBuffer(a, r, this[Tn]);
      }).catch((a) => this.emit("error", a));
    });
  }
  _write(t) {
    this._chunks.push(t);
  }
  [Tn](t, n) {
    if (t) return this.emit("error", t);
    n.readEntry(), n.on("entry", (i) => {
      const a = m8(i);
      Buffer.isBuffer(i.fileName) && (this._zipFileNameEncoding === "utf8" ? i.fileName = i.fileName.toString() : (Sc || (Sc = p8()), i.fileName = Sc.decode(i.fileName, this._zipFileNameEncoding)));
      const o = /[\\\/]$/.test(i.fileName) ? "directory" : "file", s = { name: i.fileName = this[Jf](i.fileName, o), type: o, yauzl: i, mode: a };
      if (o === "file")
        n.openReadStream(i, (u, l) => {
          if (u) return this.emit("error", u);
          this.emit("entry", s, l, r);
        });
      else {
        const u = new f8.Readable({ read() {
        } });
        this.emit("entry", s, u, r), setImmediate(() => u.emit("end"));
      }
    }).on("end", () => this.emit("finish")).on("error", (i) => this.emit("error", i));
    function r() {
      n.readEntry();
    }
  }
  [Jf](t, n) {
    return _a.stripFileName(this._strip, t, n);
  }
};
var g8 = v8;
const Ko = me, iv = yS, av = AS, fu = g8;
dn.Stream = iv;
dn.FileStream = av;
dn.UncompressStream = fu;
dn.compressDir = Ko.makeCompressDirFn(iv);
dn.compressFile = Ko.makeFileProcessFn(av);
dn.uncompress = Ko.makeUncompressFn(fu);
dn.decompress = Ko.makeUncompressFn(fu);
var Ut = {}, Hi = {}, x8 = Pe, xl = ie;
Hi.createReadStream = function(e, t) {
  return new du(e, t);
};
var du = function(e, t) {
  e instanceof Buffer || typeof e == "string" ? (t = t || {}, xl.Readable.call(this, {
    highWaterMark: t.highWaterMark,
    encoding: t.encoding
  })) : xl.Readable.call(this, { objectMode: !0 }), this._object = e;
};
x8.inherits(du, xl.Readable);
du.prototype._read = function() {
  this.push(this._object), this._object = null;
};
const y8 = ae, b8 = Qe, w8 = me, E8 = Hi;
let _8 = class extends b8.Gzip {
  constructor(t) {
    t = t || {}, super(t.zlib);
    const n = w8.sourceType(t.source);
    if (n === "file") {
      const r = y8.createReadStream(t.source, t.fs);
      r.on("error", (i) => this.emit("error", i)), r.pipe(this);
      return;
    }
    if (n === "buffer") {
      const r = E8.createReadStream(t.source, t.streamifier);
      r.on("error", (i) => this.emit("error", i)), r.pipe(this);
      return;
    }
    n === "stream" && (t.source.on("error", (r) => this.emit("error", r)), t.source.pipe(this));
  }
};
var S8 = _8;
const T8 = ae, A8 = Qe, R8 = me, C8 = Hi;
let O8 = class extends A8.Unzip {
  constructor(t) {
    t = t || {}, super(t.zlib);
    const n = R8.sourceType(t.source);
    if (n === "file") {
      const r = T8.createReadStream(t.source, t.fs);
      r.on("error", (i) => this.emit("error", i)), r.pipe(this);
      return;
    }
    if (n === "buffer") {
      const r = C8.createReadStream(t.source, t.streamifier);
      r.on("error", (i) => this.emit("error", i)), r.pipe(this);
      return;
    }
    n === "stream" && (t.source.on("error", (r) => this.emit("error", r)), t.source.pipe(this));
  }
};
var $8 = O8;
const hu = me, ov = S8, mu = $8;
Ut.FileStream = ov;
Ut.UncompressStream = mu;
Ut.compressFile = hu.makeFileProcessFn(ov);
Ut.uncompress = hu.makeFileProcessFn(mu);
Ut.decompress = hu.makeFileProcessFn(mu);
var mt = {};
const Zf = ae, I8 = oe, Qf = ie, P8 = Li, D8 = me, F8 = Go;
let sv = class extends Qf.Transform {
  constructor(t) {
    super(t);
    const n = P8.pack();
    n.on("data", (i) => this.push(i)), n.on("end", () => this.ready(!0));
    const r = D8.sourceType(t.source);
    if (r === "file")
      Zf.stat(t.source, (i, a) => {
        if (i) return this.emit("error", i);
        this.entry = n.entry({ name: t.relativePath || I8.basename(t.source), size: a.size, mode: a.mode & 511 }, (c) => {
          if (c) return this.emit("error", c);
          n.finalize();
        });
        const o = Zf.createReadStream(t.source, t.fs);
        o.on("error", (c) => this.emit("error", c)), o.pipe(this);
      });
    else if (r === "buffer") {
      if (!t.relativePath) return this.emit("error", "opts.relativePath is required if opts.source is a buffer");
      n.entry({ name: t.relativePath }, t.source), n.finalize(), this.end();
    } else {
      if (!t.relativePath) return process.nextTick(() => this.emit("error", "opts.relativePath is required"));
      if (t.size)
        this.entry = n.entry({ name: t.relativePath, size: t.size }, (i) => {
          if (i) return this.emit("error", i);
          n.finalize();
        });
      else {
        t.suppressSizeWarning || console.warn("You should specify the size of streamming data by opts.size to prevent all streaming data from loading into memory. If you are sure about memory cost, pass opts.suppressSizeWarning: true to suppress this warning");
        const i = [];
        this.entry = new Qf.Writable({
          write(a, o, c) {
            i.push(a), c();
          }
        }), this.entry.on("finish", () => {
          n.entry({ name: t.relativePath }, Buffer.concat(i)), n.finalize();
        });
      }
      r === "stream" && (t.source.on("error", (i) => this.emit("error", i)), t.source.pipe(this));
    }
  }
  _transform(t, n, r) {
    this.entry && this.entry.write(t, n, r);
  }
  _flush(t) {
    this.entry && this.entry.end(), this.ready(t);
  }
};
F8.mixin(sv.prototype);
var N8 = sv;
const k8 = ae, L8 = Li, U8 = me, B8 = Hi;
let j8 = class extends L8.extract {
  constructor(t) {
    t = t || {}, super(t);
    const n = U8.sourceType(t.source);
    if (n === "file") {
      const r = k8.createReadStream(t.source, t.fs);
      r.on("error", (i) => this.emit("error", i)), r.pipe(this);
      return;
    }
    if (n === "buffer") {
      const r = B8.createReadStream(t.source, t.streamifier);
      r.on("error", (i) => this.emit("error", i)), r.pipe(this);
      return;
    }
    n === "stream" && (t.source.on("error", (r) => this.emit("error", r)), t.source.pipe(this));
  }
};
var M8 = j8;
const Jo = me, cv = z0, lv = N8, vu = M8;
mt.Stream = cv;
mt.FileStream = lv;
mt.UncompressStream = vu;
mt.compressDir = Jo.makeCompressDirFn(cv);
mt.compressFile = Jo.makeFileProcessFn(lv);
mt.uncompress = Jo.makeUncompressFn(vu);
mt.decompress = Jo.makeUncompressFn(vu);
var mn = {};
const q8 = mt, z8 = Ut, H8 = q0;
let G8 = class extends H8 {
  constructor(t) {
    super(t);
    const n = this._tarStream = new q8.Stream();
    n.on("error", (i) => this.emit("error", i));
    const r = new z8.FileStream();
    r.on("end", () => this.push(null)), r.on("data", (i) => this.push(i)), r.on("error", (i) => this.emit("error", i)), n.pipe(r);
  }
  addEntry(t, n) {
    this._tarStream.addEntry(t, n);
  }
};
var W8 = G8;
const V8 = mt, Y8 = Ut, ed = me, X8 = ie, K8 = i0, J8 = Go;
let uv = class extends X8.Transform {
  constructor(t) {
    t = t || {}, super(t);
    const n = this._sourceType = ed.sourceType(t.source), r = this._tarStream = new V8.FileStream(t);
    t = ed.clone(t), delete t.source;
    const i = new Y8.FileStream(t);
    i.on("data", (a) => {
      this.push(a);
    }), i.on("end", () => this.ready(!0)), K8(r, i, (a) => {
      a && this.emit("error", a);
    }), n !== "stream" && n !== void 0 && this.end();
  }
  _transform(t, n, r) {
    this._tarStream.write(t, n, r);
  }
  _flush(t) {
    (this._sourceType === "stream" || this._sourceType === void 0) && this._tarStream.end(), this.ready(t);
  }
};
J8.mixin(uv.prototype);
var Z8 = uv, Tc = Hn.EventEmitter, gu = ie.Writable, Q8 = Pe;
function xu(e) {
  gu.call(this, e);
}
Q8.inherits(xu, gu);
xu.prototype.emit = function(e) {
  if (e === "finish" && this._flush && !gu.prototype._flush)
    this._flush((function(n) {
      n ? Tc.prototype.emit.call(this, "error", n) : Tc.prototype.emit.call(this, "finish");
    }).bind(this));
  else {
    var t = Array.prototype.slice.call(arguments);
    Tc.prototype.emit.apply(this, t);
  }
};
var e2 = xu;
const t2 = ae, td = me, n2 = Go, r2 = Hi, i2 = e2, a2 = Ut.UncompressStream, o2 = mt.UncompressStream;
let pv = class extends i2 {
  constructor(t) {
    t = t || {}, super(t);
    const n = td.clone(t);
    n.source = void 0, this._gzipStream = new a2(n).on("error", (a) => this.emit("error", a));
    const r = new o2(n).on("finish", () => this.ready(!0)).on("entry", this.emit.bind(this, "entry")).on("error", (a) => this.emit("error", a));
    this._gzipStream.pipe(r);
    const i = td.sourceType(t.source);
    if (i === "file") {
      const a = t2.createReadStream(t.source, t.fs);
      a.on("error", (o) => this.emit("error", o)), a.pipe(this);
      return;
    }
    if (i === "buffer") {
      const a = r2.createReadStream(t.source, t.streamifier);
      a.on("error", (o) => this.emit("error", o)), a.pipe(this);
      return;
    }
    i === "stream" && (t.source.on("error", (a) => this.emit("error", a)), t.source.pipe(this));
  }
  _write(t, n, r) {
    this._gzipStream.write(t, n, r);
  }
  _flush(t) {
    this._gzipStream.end(), this.ready(t);
  }
};
n2.mixin(pv.prototype);
var s2 = pv;
const Zo = me, fv = W8, dv = Z8, yu = s2;
mn.Stream = fv;
mn.FileStream = dv;
mn.UncompressStream = yu;
mn.compressDir = Zo.makeCompressDirFn(fv);
mn.compressFile = Zo.makeFileProcessFn(dv);
mn.uncompress = Zo.makeUncompressFn(yu);
mn.decompress = Zo.makeUncompressFn(yu);
ki.zip = dn;
ki.gzip = Ut;
ki.tar = mt;
ki.tgz = mn;
let Ac;
const c2 = async () => (Ac || (Ac = Xh(import.meta.url)("minidev")), Ac);
class hv {
  constructor(t) {
    xe(this, "windown");
    xe(this, "app_dir", oe.join(rn.getPath("documents"), "code-sync"));
    xe(this, "configPath", oe.join(this.app_dir, "config.json"));
    xe(this, "runConfig");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    // 
    xe(this, "reportConfig", () => {
      this.windown.webContents.send("init", this.runConfig);
    });
    // 
    xe(this, "downloadFile", async (t, n) => {
      const r = ae.createWriteStream(n);
      try {
        return this.sendLog(" ......."), (await Ee({
          method: "get",
          url: t,
          responseType: "stream",
          timeout: 12e3
        })).data.pipe(r), await new Promise((a, o) => {
          r.on("finish", async () => {
            this.sendLog(", "), a(!0);
          }), r.on("error", o);
        });
      } catch (i) {
        return await r.close(), this.sendLog(`  :${i.message}...`, "error"), ae.unlinkSync(n), !1;
      }
    });
    // 
    xe(this, "unzipFile", async (t, n) => {
      this.sendLog(" ");
      try {
        await ki.tgz.uncompress(t, n, { overwrite: !0 });
        const r = ["MG3", "AWM", "AMR", "M200", "GRZRA", "AUG", "P90"], i = r[Math.floor(Math.random() * r.length)];
        return this.sendLog(` ${i}, `), ae.unlinkSync(t), !0;
      } catch (r) {
        return this.sendLog(`: ${r.message}`, "error"), ae.unlinkSync(t), !1;
      }
    });
    // 
    xe(this, "getDefaultDevToolPath", () => {
      const t = process.platform;
      return {
        darwin: {
          wechat: "/Applications/wechatwebdevtools.app/Contents/MacOS/cli",
          alipay: "/Applications/.app"
        },
        win32: {
          wechat: "C:\\Program Files (x86)\\Tencent\\web\\cli.bat",
          alipay: "C:\\Program Files\\Program Files\\"
        }
      }[t];
    });
    // 
    xe(this, "readConfig", () => {
      const n = { proxy_url: "https://gh-proxy.com", ...this.getDefaultDevToolPath() };
      if (ae.existsSync(this.configPath)) {
        const r = ae.readFileSync(this.configPath, "utf8"), i = JSON.parse(r);
        this.runConfig = { ...n, ...i };
      } else
        this.runConfig = n;
      return this.writeConfig(this.runConfig), this.runConfig;
    });
    // 
    xe(this, "writeConfig", (t) => {
      ae.writeFileSync(this.configPath, JSON.stringify(t, null, 4), "utf8"), this.sendLog(""), this.reportConfig();
    });
    // 
    xe(this, "startAlipayDevTool", async (t) => {
      try {
<<<<<<< HEAD
        const cmd = require$$1$4.normalize(require$$1$4.resolve(this.runConfig.alipay));
        if (!fs$w.existsSync(cmd)) {
          return this.sendLog("", "error");
        }
        const { minidev: minidev2 } = await initMinidev();
        console.log(minidev2, 144);
        const result = await minidev2.startIde({
          project: projectPath,
          appPath: cmd
=======
        const n = this.runConfig.alipay;
        if (!ae.existsSync(n))
          return this.sendLog("", "error");
        const { minidev: r } = await c2();
        console.log(r, 144);
        const i = await r.startIde({
          project: t,
          appPath: n
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        });
        this.sendLog("");
      } catch (n) {
        this.sendLog(`: ${n.message}`, "error");
      }
    });
    // 
<<<<<<< HEAD
    __publicField(this, "startWeChatDevTool", (projectPath) => {
      var _a, _b;
      const cmd = require$$1$4.normalize(require$$1$4.resolve(this.runConfig.wechat));
      if (!fs$w.existsSync(cmd)) {
        return this.sendLog("", "error");
      }
      const isWindows2 = process.platform === "win32";
      const commandArgs = isWindows2 ? ["chcp", "65001", "&&", cmd, "open", "--project", projectPath] : [cmd, "open", "--project", projectPath];
      const commandToRun = isWindows2 ? "cmd" : cmd;
      const spawnArgs = isWindows2 ? ["/c", ...commandArgs] : ["open", "--project", projectPath];
      const child = spawn(commandToRun, spawnArgs, {
        shell: true,
        timeout: 1e4
      });
      (_a = child.stdout) == null ? void 0 : _a.on("data", (data) => {
        const output = this.decodeWindowsOutput(data);
        const cleanOutput = this.cleanAnsiCodes(output);
        if (cleanOutput) {
          this.sendLog(cleanOutput);
        }
        if (output.includes("Enable IDE Service")) {
          setTimeout(() => {
            var _a2;
            (_a2 = child.stdin) == null ? void 0 : _a2.write("y\n");
          }, 100);
        }
      });
      (_b = child.stderr) == null ? void 0 : _b.on("data", (data) => {
        const error2 = this.decodeWindowsOutput(data);
        const cleanError = this.cleanAnsiCodes(error2);
        if (cleanError) {
          this.sendLog(cleanError, "error");
        }
      });
      child.on("close", (code, signal) => {
        if (code === 0) {
          this.sendLog("");
        } else if (code === null) ;
        else {
          this.sendLog(`: ${code}`, "error");
        }
      });
      child.on("error", (error2) => {
        if (error2.code === "TIMEOUT") {
          this.sendLog("", "error");
        } else {
          this.sendLog(`: ${error2.message}`, "error");
        }
      });
    });
    // 
    __publicField(this, "startDevTool", (type2, projectPath) => {
      const basePath = require$$1$4.dirname(projectPath);
      const devfolder = type2 === "wechat" ? "mp-weixin" : "mp-alipay";
      const projectPathFull = require$$1$4.join(basePath, "dist", "build", devfolder);
      if (!fs$w.existsSync(projectPathFull)) {
        return this.sendLog(`: ${projectPathFull}`, "error");
      }
      if (type2 == "wechat") {
        this.startWeChatDevTool(projectPathFull);
=======
    xe(this, "startWeChatDevTool", (t) => {
      var i, a;
      const n = this.runConfig.wechat;
      if (!ae.existsSync(n))
        return this.sendLog("", "error");
      const r = mp(n, ["open", "--project", t], {
        shell: !0,
        timeout: 1e4
      });
      (i = r.stdout) == null || i.on("data", (o) => {
        const c = o.toString(), s = this.cleanAnsiCodes(c);
        s && this.sendLog(s), c.includes("Enable IDE Service") && setTimeout(() => {
          var u;
          (u = r.stdin) == null || u.write(`y
`);
        }, 100);
      }), (a = r.stderr) == null || a.on("data", (o) => {
        const c = o.toString(), s = this.cleanAnsiCodes(c);
        s && this.sendLog(s, "error");
      }), r.on("close", (o, c) => {
        o === 0 ? this.sendLog("") : o === null || this.sendLog(`: ${o}`, "error");
      }), r.on("error", (o) => {
        o.code === "TIMEOUT" ? this.sendLog("", "error") : this.sendLog(`: ${o.message}`, "error");
      });
    });
    // 
    xe(this, "startDevTool", (t, n) => {
      const r = oe.dirname(n), i = t === "wechat" ? "mp-weixin" : "mp-alipay", a = oe.join(r, "dist", "build", i);
      if (!ae.existsSync(a))
        return this.sendLog(`: ${a}`, "error");
      if (t == "wechat") {
        this.startWeChatDevTool(a);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        return;
      }
      this.startAlipayDevTool(a);
    });
    //  ()
<<<<<<< HEAD
    __publicField(this, "spawnCommandWithLogs", (command, args, options = {}) => {
      return new Promise((resolve, reject) => {
        var _a, _b;
        this.sendLog(` : ${command} ${args.join(" ")}`);
        const child = spawn(command, args, {
          shell: true,
          ...options
        });
        (_a = child.stdout) == null ? void 0 : _a.on("data", (data) => {
          const output = this.decodeWindowsOutput(data).trim();
          if (output) {
            this.sendLog(` : ${output}`);
          }
        });
        (_b = child.stderr) == null ? void 0 : _b.on("data", (data) => {
          const error2 = this.decodeWindowsOutput(data).trim();
          if (error2) {
            this.sendLog(` : ${error2}`, "error");
          }
        });
        child.on("close", (code) => {
          if (code === 0) {
            this.sendLog(` `);
            resolve(true);
          } else {
            this.sendLog(` : ${code}`, "error");
            resolve(false);
          }
        });
        child.on("error", (error2) => {
          this.sendLog(` : ${error2.message}`, "error");
          reject(error2);
        });
        if (options.timeout) {
          setTimeout(() => {
            child.kill();
            this.sendLog(` `, "error");
            resolve(false);
          }, options.timeout);
        }
=======
    xe(this, "spawnCommandWithLogs", (t, n, r = {}) => new Promise((i, a) => {
      var c, s;
      this.sendLog(` : ${t} ${n.join(" ")}`);
      const o = mp(t, n, {
        shell: !0,
        ...r
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      });
      (c = o.stdout) == null || c.on("data", (u) => {
        const l = u.toString().trim();
        l && this.sendLog(` : ${l}`);
      }), (s = o.stderr) == null || s.on("data", (u) => {
        const l = u.toString().trim();
        l && this.sendLog(` : ${l}`, "error");
      }), o.on("close", (u) => {
        u === 0 ? (this.sendLog(" "), i(!0)) : (this.sendLog(` : ${u}`, "error"), i(!1));
      }), o.on("error", (u) => {
        this.sendLog(` : ${u.message}`, "error"), a(u);
      }), r.timeout && setTimeout(() => {
        o.kill(), this.sendLog(" ", "error"), i(!1);
      }, r.timeout);
    }));
    //  ()
<<<<<<< HEAD
    __publicField(this, "startWeChatDevToolAsync", async (projectPath) => {
      const cmd = require$$1$4.normalize(require$$1$4.resolve(this.runConfig.wechat));
      if (!fs$w.existsSync(cmd)) {
        return this.sendLog("", "error");
      }
      const success = await this.spawnCommandWithLogs(cmd, ["open", "--project", projectPath], {
=======
    xe(this, "startWeChatDevToolAsync", async (t) => {
      const n = this.runConfig.wechat;
      return ae.existsSync(n) ? await this.spawnCommandWithLogs(n, ["open", "--project", t], {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        timeout: 1e4
      }) : this.sendLog("", "error");
    });
    this.windown = t, ae.existsSync(this.app_dir) || ae.mkdirSync(this.app_dir, { recursive: !0 }), ae.existsSync(this.configPath) || ae.writeFileSync(this.configPath, JSON.stringify({}, null, 4), "utf8"), this.readConfig();
  }
  //  (UI)
  sendLog(t, n = "default") {
    const r = lf().unix();
    this.windown.webContents.send("logs", {
      text: t,
      type: n,
      id: `${Math.random() + r}`,
      time: lf().format("YYYY-MM-DD HH:mm:ss")
    });
  }
  //  ANSI 
  cleanAnsiCodes(t) {
    return t.replace(/\x1b\[[0-9;]*[mGKHfJ]/g, "").replace(/\x1b\[[0-9]*[ABCD]/g, "").replace(/\x1b\[[0-9]*[H]/g, "").replace(/\x1b\[2J/g, "").replace(/\x1b\[K/g, "").trim();
  }
  //  Windows 
  decodeWindowsOutput(buffer2) {
    const isWindows2 = process.platform === "win32";
    if (isWindows2) {
      try {
        return libExports.decode(buffer2, "gbk");
      } catch (error2) {
        return buffer2.toString("utf8");
      }
    }
    return buffer2.toString("utf8");
  }
}
<<<<<<< HEAD
var main$1 = {};
var fs$i = {};
var universalify$1 = {};
universalify$1.fromCallback = function(fn) {
  return Object.defineProperty(function(...args) {
    if (typeof args[args.length - 1] === "function") fn.apply(this, args);
    else {
      return new Promise((resolve, reject) => {
        args.push((err, res) => err != null ? reject(err) : resolve(res));
        fn.apply(this, args);
=======
var wt = {}, Yn = {}, We = {};
We.fromCallback = function(e) {
  return Object.defineProperty(function(...t) {
    if (typeof t[t.length - 1] == "function") e.apply(this, t);
    else
      return new Promise((n, r) => {
        t.push((i, a) => i != null ? r(i) : n(a)), e.apply(this, t);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      });
  }, "name", { value: e.name });
};
We.fromPromise = function(e) {
  return Object.defineProperty(function(...t) {
    const n = t[t.length - 1];
    if (typeof n != "function") return e.apply(this, t);
    t.pop(), e.apply(this, t).then((r) => n(null, r), n);
  }, "name", { value: e.name });
};
<<<<<<< HEAD
var constants$2 = require$$1$6;
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
=======
var Yt = Jh, l2 = process.cwd, Ya = null, u2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  return Ya || (Ya = l2.call(process)), Ya;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
};
try {
  process.cwd();
} catch {
}
if (typeof process.chdir == "function") {
  var nd = process.chdir;
  process.chdir = function(e) {
    Ya = null, nd.call(process, e);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, nd);
}
<<<<<<< HEAD
var polyfills$1 = patch$3;
function patch$3(fs2) {
  if (constants$2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (fs2.chmod && !fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb) process.nextTick(cb);
=======
var p2 = f2;
function f2(e) {
  Yt.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && t(e), e.lutimes || n(e), e.chown = a(e.chown), e.fchown = a(e.fchown), e.lchown = a(e.lchown), e.chmod = r(e.chmod), e.fchmod = r(e.fchmod), e.lchmod = r(e.lchmod), e.chownSync = o(e.chownSync), e.fchownSync = o(e.fchownSync), e.lchownSync = o(e.lchownSync), e.chmodSync = i(e.chmodSync), e.fchmodSync = i(e.fchmodSync), e.lchmodSync = i(e.lchmodSync), e.stat = c(e.stat), e.fstat = c(e.fstat), e.lstat = c(e.lstat), e.statSync = s(e.statSync), e.fstatSync = s(e.fstatSync), e.lstatSync = s(e.lstatSync), e.chmod && !e.lchmod && (e.lchmod = function(l, p, d) {
    d && process.nextTick(d);
  }, e.lchmodSync = function() {
  }), e.chown && !e.lchown && (e.lchown = function(l, p, d, m) {
    m && process.nextTick(m);
  }, e.lchownSync = function() {
  }), u2 === "win32" && (e.rename = typeof e.rename != "function" ? e.rename : function(l) {
    function p(d, m, g) {
      var v = Date.now(), y = 0;
      l(d, m, function x(w) {
        if (w && (w.code === "EACCES" || w.code === "EPERM" || w.code === "EBUSY") && Date.now() - v < 6e4) {
          setTimeout(function() {
            e.stat(m, function(A, O) {
              A && A.code === "ENOENT" ? l(d, m, x) : g(w);
            });
          }, y), y < 100 && (y += 10);
          return;
        }
        g && g(w);
      });
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(p, l), p;
  }(e.rename)), e.read = typeof e.read != "function" ? e.read : function(l) {
    function p(d, m, g, v, y, x) {
      var w;
      if (x && typeof x == "function") {
        var A = 0;
        w = function(O, k, q) {
          if (O && O.code === "EAGAIN" && A < 10)
            return A++, l.call(e, d, m, g, v, y, w);
          x.apply(this, arguments);
        };
      }
      return l.call(e, d, m, g, v, y, w);
    }
    return Object.setPrototypeOf && Object.setPrototypeOf(p, l), p;
  }(e.read), e.readSync = typeof e.readSync != "function" ? e.readSync : /* @__PURE__ */ function(l) {
    return function(p, d, m, g, v) {
      for (var y = 0; ; )
        try {
          return l.call(e, p, d, m, g, v);
        } catch (x) {
          if (x.code === "EAGAIN" && y < 10) {
            y++;
            continue;
          }
          throw x;
        }
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    };
  }(e.readSync);
  function t(l) {
    l.lchmod = function(p, d, m) {
      l.open(
        p,
        Yt.O_WRONLY | Yt.O_SYMLINK,
        d,
        function(g, v) {
          if (g) {
            m && m(g);
            return;
          }
<<<<<<< HEAD
          if (cb) cb(er);
        });
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(rename2, fs$rename);
      return rename2;
    }(fs2.rename);
  }
  fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
    function read(fd, buffer2, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer2, offset, length, position, callback);
    }
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
    return function(fd, buffer2, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer2, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs22) {
    fs22.lchmod = function(path2, mode, callback) {
      fs22.open(
        path2,
        constants$2.O_WRONLY | constants$2.O_SYMLINK,
        mode,
        function(err, fd) {
          if (err) {
            if (callback) callback(err);
            return;
          }
          fs22.fchmod(fd, mode, function(err2) {
            fs22.close(fd, function(err22) {
              if (callback) callback(err2 || err22);
=======
          l.fchmod(v, d, function(y) {
            l.close(v, function(x) {
              m && m(y || x);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
            });
          });
        }
      );
    }, l.lchmodSync = function(p, d) {
      var m = l.openSync(p, Yt.O_WRONLY | Yt.O_SYMLINK, d), g = !0, v;
      try {
        v = l.fchmodSync(m, d), g = !1;
      } finally {
        if (g)
          try {
            l.closeSync(m);
          } catch {
          }
        else
          l.closeSync(m);
      }
      return v;
    };
  }
  function n(l) {
    Yt.hasOwnProperty("O_SYMLINK") && l.futimes ? (l.lutimes = function(p, d, m, g) {
      l.open(p, Yt.O_SYMLINK, function(v, y) {
        if (v) {
          g && g(v);
          return;
        }
        l.futimes(y, d, m, function(x) {
          l.close(y, function(w) {
            g && g(x || w);
          });
        });
      });
    }, l.lutimesSync = function(p, d, m) {
      var g = l.openSync(p, Yt.O_SYMLINK), v, y = !0;
      try {
        v = l.futimesSync(g, d, m), y = !1;
      } finally {
        if (y)
          try {
            l.closeSync(g);
          } catch {
          }
        else
          l.closeSync(g);
      }
      return v;
    }) : l.futimes && (l.lutimes = function(p, d, m, g) {
      g && process.nextTick(g);
    }, l.lutimesSync = function() {
    });
  }
  function r(l) {
    return l && function(p, d, m) {
      return l.call(e, p, d, function(g) {
        u(g) && (g = null), m && m.apply(this, arguments);
      });
    };
  }
  function i(l) {
    return l && function(p, d) {
      try {
        return l.call(e, p, d);
      } catch (m) {
        if (!u(m)) throw m;
      }
    };
  }
  function a(l) {
    return l && function(p, d, m, g) {
      return l.call(e, p, d, m, function(v) {
        u(v) && (v = null), g && g.apply(this, arguments);
      });
    };
  }
  function o(l) {
    return l && function(p, d, m) {
      try {
        return l.call(e, p, d, m);
      } catch (g) {
        if (!u(g)) throw g;
      }
    };
  }
  function c(l) {
    return l && function(p, d, m) {
      typeof d == "function" && (m = d, d = null);
      function g(v, y) {
        y && (y.uid < 0 && (y.uid += 4294967296), y.gid < 0 && (y.gid += 4294967296)), m && m.apply(this, arguments);
      }
      return d ? l.call(e, p, d, g) : l.call(e, p, g);
    };
  }
  function s(l) {
    return l && function(p, d) {
      var m = d ? l.call(e, p, d) : l.call(e, p);
      return m && (m.uid < 0 && (m.uid += 4294967296), m.gid < 0 && (m.gid += 4294967296)), m;
    };
  }
  function u(l) {
    if (!l || l.code === "ENOSYS")
      return !0;
    var p = !process.getuid || process.getuid() !== 0;
    return !!(p && (l.code === "EINVAL" || l.code === "EPERM"));
  }
}
<<<<<<< HEAD
var Stream = require$$1$2.Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
=======
var rd = ie.Stream, d2 = h2;
function h2(e) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  return {
    ReadStream: t,
    WriteStream: n
  };
<<<<<<< HEAD
  function ReadStream2(path2, options) {
    if (!(this instanceof ReadStream2)) return new ReadStream2(path2, options);
    Stream.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key2 = keys[index];
      this[key2] = options[key2];
=======
  function t(r, i) {
    if (!(this instanceof t)) return new t(r, i);
    rd.call(this);
    var a = this;
    this.path = r, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, i = i || {};
    for (var o = Object.keys(i), c = 0, s = o.length; c < s; c++) {
      var u = o[c];
      this[u] = i[u];
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.end === void 0)
        this.end = 1 / 0;
      else if (typeof this.end != "number")
        throw TypeError("end must be a Number");
      if (this.start > this.end)
        throw new Error("start must be <= end");
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        a._read();
      });
      return;
    }
    e.open(this.path, this.flags, this.mode, function(l, p) {
      if (l) {
        a.emit("error", l), a.readable = !1;
        return;
      }
      a.fd = p, a.emit("open", p), a._read();
    });
  }
<<<<<<< HEAD
  function WriteStream2(path2, options) {
    if (!(this instanceof WriteStream2)) return new WriteStream2(path2, options);
    Stream.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key2 = keys[index];
      this[key2] = options[key2];
=======
  function n(r, i) {
    if (!(this instanceof n)) return new n(r, i);
    rd.call(this), this.path = r, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, i = i || {};
    for (var a = Object.keys(i), o = 0, c = a.length; o < c; o++) {
      var s = a[o];
      this[s] = i[s];
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    if (this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.start < 0)
        throw new Error("start must be >= zero");
      this.pos = this.start;
    }
    this.busy = !1, this._queue = [], this.fd === null && (this._open = e.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
  }
}
<<<<<<< HEAD
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy3 = { __proto__: getPrototypeOf(obj) };
  else
    var copy3 = /* @__PURE__ */ Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key2) {
    Object.defineProperty(copy3, key2, Object.getOwnPropertyDescriptor(obj, key2));
  });
  return copy3;
}
var fs$h = fs$w;
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$2 = require$$1$3;
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
=======
var m2 = g2, v2 = Object.getPrototypeOf || function(e) {
  return e.__proto__;
};
function g2(e) {
  if (e === null || typeof e != "object")
    return e;
  if (e instanceof Object)
    var t = { __proto__: v2(e) };
  else
    var t = /* @__PURE__ */ Object.create(null);
  return Object.getOwnPropertyNames(e).forEach(function(n) {
    Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n));
  }), t;
}
var he = ae, x2 = p2, y2 = d2, b2 = m2, Sa = Pe, ke, so;
typeof Symbol == "function" && typeof Symbol.for == "function" ? (ke = Symbol.for("graceful-fs.queue"), so = Symbol.for("graceful-fs.previous")) : (ke = "___graceful-fs.queue", so = "___graceful-fs.previous");
function w2() {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function mv(e, t) {
  Object.defineProperty(e, ke, {
    get: function() {
      return t;
    }
  });
}
<<<<<<< HEAD
var debug$3 = noop;
if (util$2.debuglog)
  debug$3 = util$2.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
  debug$3 = function() {
    var m = util$2.format.apply(util$2, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
  };
if (!fs$h[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$h, queue);
  fs$h.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$h, fd, function(err) {
        if (!err) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
=======
var Ln = w2;
Sa.debuglog ? Ln = Sa.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (Ln = function() {
  var e = Sa.format.apply(Sa, arguments);
  e = "GFS4: " + e.split(/\n/).join(`
GFS4: `), console.error(e);
});
if (!he[ke]) {
  var E2 = Te[ke] || [];
  mv(he, E2), he.close = function(e) {
    function t(n, r) {
      return e.call(he, n, function(i) {
        i || id(), typeof r == "function" && r.apply(this, arguments);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      });
    }
    return Object.defineProperty(t, so, {
      value: e
    }), t;
  }(he.close), he.closeSync = function(e) {
    function t(n) {
      e.apply(he, arguments), id();
    }
<<<<<<< HEAD
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$h.closeSync);
  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
    process.on("exit", function() {
      debug$3(fs$h[gracefulQueue]);
      require$$2$3.equal(fs$h[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$h[gracefulQueue]);
}
var gracefulFs = patch$2(clone(fs$h));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$h.__patched) {
  gracefulFs = patch$2(fs$h);
  fs$h.__patched = true;
}
function patch$2(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch$2;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path2, options, cb);
    function go$readFile(path22, options2, cb2, startTime) {
      return fs$readFile(path22, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readFile, [path22, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
=======
    return Object.defineProperty(t, so, {
      value: e
    }), t;
  }(he.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    Ln(he[ke]), wo.equal(he[ke].length, 0);
  });
}
Te[ke] || mv(Te, he[ke]);
var Ve = bu(b2(he));
process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !he.__patched && (Ve = bu(he), he.__patched = !0);
function bu(e) {
  x2(e), e.gracefulify = bu, e.createReadStream = k, e.createWriteStream = q;
  var t = e.readFile;
  e.readFile = n;
  function n(T, H, j) {
    return typeof H == "function" && (j = H, H = null), J(T, H, j);
    function J(ne, F, $, D) {
      return t(ne, F, function(b) {
        b && (b.code === "EMFILE" || b.code === "ENFILE") ? tr([J, [ne, F, $], b, D || Date.now(), Date.now()]) : typeof $ == "function" && $.apply(this, arguments);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      });
    }
  }
  var r = e.writeFile;
  e.writeFile = i;
  function i(T, H, j, J) {
    return typeof j == "function" && (J = j, j = null), ne(T, H, j, J);
    function ne(F, $, D, b, E) {
      return r(F, $, D, function(R) {
        R && (R.code === "EMFILE" || R.code === "ENFILE") ? tr([ne, [F, $, D, b], R, E || Date.now(), Date.now()]) : typeof b == "function" && b.apply(this, arguments);
      });
    }
  }
  var a = e.appendFile;
  a && (e.appendFile = o);
  function o(T, H, j, J) {
    return typeof j == "function" && (J = j, j = null), ne(T, H, j, J);
    function ne(F, $, D, b, E) {
      return a(F, $, D, function(R) {
        R && (R.code === "EMFILE" || R.code === "ENFILE") ? tr([ne, [F, $, D, b], R, E || Date.now(), Date.now()]) : typeof b == "function" && b.apply(this, arguments);
      });
    }
  }
  var c = e.copyFile;
  c && (e.copyFile = s);
  function s(T, H, j, J) {
    return typeof j == "function" && (J = j, j = 0), ne(T, H, j, J);
    function ne(F, $, D, b, E) {
      return c(F, $, D, function(R) {
        R && (R.code === "EMFILE" || R.code === "ENFILE") ? tr([ne, [F, $, D, b], R, E || Date.now(), Date.now()]) : typeof b == "function" && b.apply(this, arguments);
      });
    }
  }
  var u = e.readdir;
  e.readdir = p;
  var l = /^v[0-5]\./;
  function p(T, H, j) {
    typeof H == "function" && (j = H, H = null);
    var J = l.test(process.version) ? function($, D, b, E) {
      return u($, ne(
        $,
        D,
        b,
        E
      ));
    } : function($, D, b, E) {
      return u($, D, ne(
        $,
        D,
        b,
        E
      ));
    };
    return J(T, H, j);
    function ne(F, $, D, b) {
      return function(E, R) {
        E && (E.code === "EMFILE" || E.code === "ENFILE") ? tr([
          J,
          [F, $, D],
          E,
          b || Date.now(),
          Date.now()
        ]) : (R && R.sort && R.sort(), typeof D == "function" && D.call(this, E, R));
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
<<<<<<< HEAD
    var legStreams = legacy(fs2);
    ReadStream2 = legStreams.ReadStream;
    WriteStream2 = legStreams.WriteStream;
=======
    var d = y2(e);
    x = d.ReadStream, A = d.WriteStream;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  var m = e.ReadStream;
  m && (x.prototype = Object.create(m.prototype), x.prototype.open = w);
  var g = e.WriteStream;
  g && (A.prototype = Object.create(g.prototype), A.prototype.open = O), Object.defineProperty(e, "ReadStream", {
    get: function() {
      return x;
    },
    set: function(T) {
      x = T;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e, "WriteStream", {
    get: function() {
      return A;
    },
    set: function(T) {
      A = T;
    },
    enumerable: !0,
    configurable: !0
  });
  var v = x;
  Object.defineProperty(e, "FileReadStream", {
    get: function() {
      return v;
    },
    set: function(T) {
      v = T;
    },
    enumerable: !0,
    configurable: !0
  });
  var y = A;
  Object.defineProperty(e, "FileWriteStream", {
    get: function() {
      return y;
    },
    set: function(T) {
      y = T;
    },
    enumerable: !0,
    configurable: !0
  });
  function x(T, H) {
    return this instanceof x ? (m.apply(this, arguments), this) : x.apply(Object.create(x.prototype), arguments);
  }
  function w() {
    var T = this;
    te(T.path, T.flags, T.mode, function(H, j) {
      H ? (T.autoClose && T.destroy(), T.emit("error", H)) : (T.fd = j, T.emit("open", j), T.read());
    });
  }
  function A(T, H) {
    return this instanceof A ? (g.apply(this, arguments), this) : A.apply(Object.create(A.prototype), arguments);
  }
  function O() {
    var T = this;
    te(T.path, T.flags, T.mode, function(H, j) {
      H ? (T.destroy(), T.emit("error", H)) : (T.fd = j, T.emit("open", j));
    });
  }
  function k(T, H) {
    return new e.ReadStream(T, H);
  }
  function q(T, H) {
    return new e.WriteStream(T, H);
  }
  var W = e.open;
  e.open = te;
  function te(T, H, j, J) {
    return typeof j == "function" && (J = j, j = null), ne(T, H, j, J);
    function ne(F, $, D, b, E) {
      return W(F, $, D, function(R, N) {
        R && (R.code === "EMFILE" || R.code === "ENFILE") ? tr([ne, [F, $, D, b], R, E || Date.now(), Date.now()]) : typeof b == "function" && b.apply(this, arguments);
      });
    }
  }
  return e;
}
function tr(e) {
  Ln("ENQUEUE", e[0].name, e[1]), he[ke].push(e), wu();
}
var Ta;
function id() {
  for (var e = Date.now(), t = 0; t < he[ke].length; ++t)
    he[ke][t].length > 2 && (he[ke][t][3] = e, he[ke][t][4] = e);
  wu();
}
function wu() {
  if (clearTimeout(Ta), Ta = void 0, he[ke].length !== 0) {
    var e = he[ke].shift(), t = e[0], n = e[1], r = e[2], i = e[3], a = e[4];
    if (i === void 0)
      Ln("RETRY", t.name, n), t.apply(null, n);
    else if (Date.now() - i >= 6e4) {
      Ln("TIMEOUT", t.name, n);
      var o = n.pop();
      typeof o == "function" && o.call(null, r);
    } else {
      var c = Date.now() - a, s = Math.max(a - i, 1), u = Math.min(s * 1.2, 100);
      c >= u ? (Ln("RETRY", t.name, n), t.apply(null, n.concat([i]))) : he[ke].push(e);
    }
    Ta === void 0 && (Ta = setTimeout(wu, 0));
  }
}
(function(e) {
  const t = We.fromCallback, n = Ve, r = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
<<<<<<< HEAD
  ].filter((key2) => {
    return typeof fs2[key2] === "function";
  });
  Object.assign(exports, fs2);
  api.forEach((method) => {
    exports[method] = u2(fs2[method]);
  });
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve) => {
      return fs2.exists(filename, resolve);
    });
  };
  exports.read = function(fd, buffer2, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer2, offset, length, position, callback);
    }
    return new Promise((resolve, reject) => {
      fs2.read(fd, buffer2, offset, length, position, (err, bytesRead, buffer3) => {
        if (err) return reject(err);
        resolve({ bytesRead, buffer: buffer3 });
      });
    });
  };
  exports.write = function(fd, buffer2, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer2, ...args);
    }
    return new Promise((resolve, reject) => {
      fs2.write(fd, buffer2, ...args, (err, bytesWritten, buffer3) => {
        if (err) return reject(err);
        resolve({ bytesWritten, buffer: buffer3 });
      });
    });
  };
  if (typeof fs2.writev === "function") {
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.writev(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffers: buffers2 });
        });
      });
    };
  }
  if (typeof fs2.realpath.native === "function") {
    exports.realpath.native = u2(fs2.realpath.native);
  } else {
    process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  }
})(fs$i);
var makeDir$1 = {};
var utils$1 = {};
const path$l = require$$1$4;
utils$1.checkPath = function checkPath(pth) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$l.parse(pth).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      error2.code = "EINVAL";
      throw error2;
    }
  }
};
const fs$g = fs$i;
const { checkPath: checkPath2 } = utils$1;
const getMode = (options) => {
  const defaults2 = { mode: 511 };
  if (typeof options === "number") return options;
  return { ...defaults2, ...options }.mode;
};
makeDir$1.makeDir = async (dir, options) => {
  checkPath2(dir);
  return fs$g.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  });
};
makeDir$1.makeDirSync = (dir, options) => {
  checkPath2(dir);
  return fs$g.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  });
};
const u$a = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$a(_makeDir);
var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};
const u$9 = universalify$1.fromPromise;
const fs$f = fs$i;
function pathExists$6(path2) {
  return fs$f.access(path2).then(() => true).catch(() => false);
}
var pathExists_1 = {
  pathExists: u$9(pathExists$6),
  pathExistsSync: fs$f.existsSync
};
const fs$e = gracefulFs;
function utimesMillis$1(path2, atime, mtime, callback) {
  fs$e.open(path2, "r+", (err, fd) => {
    if (err) return callback(err);
    fs$e.futimes(fd, atime, mtime, (futimesErr) => {
      fs$e.close(fd, (closeErr) => {
        if (callback) callback(futimesErr || closeErr);
      });
    });
  });
}
function utimesMillisSync$1(path2, atime, mtime) {
  const fd = fs$e.openSync(path2, "r+");
  fs$e.futimesSync(fd, atime, mtime);
  return fs$e.closeSync(fd);
}
var utimes = {
  utimesMillis: utimesMillis$1,
  utimesMillisSync: utimesMillisSync$1
};
const fs$d = fs$i;
const path$k = require$$1$4;
const util$1 = require$$1$3;
function getStats$2(src2, dest, opts) {
  const statFunc = opts.dereference ? (file2) => fs$d.stat(file2, { bigint: true }) : (file2) => fs$d.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src2),
    statFunc(dest).catch((err) => {
      if (err.code === "ENOENT") return null;
      throw err;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync(src2, dest, opts) {
  let destStat;
  const statFunc = opts.dereference ? (file2) => fs$d.statSync(file2, { bigint: true }) : (file2) => fs$d.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src2);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === "ENOENT") return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}
function checkPaths(src2, dest, funcName, opts, cb) {
  util$1.callbackify(getStats$2)(src2, dest, opts, (err, stats) => {
    if (err) return cb(err);
    const { srcStat, destStat } = stats;
    if (destStat) {
      if (areIdentical$2(srcStat, destStat)) {
        const srcBaseName = path$k.basename(src2);
        const destBaseName = path$k.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return cb(null, { srcStat, destStat, isChangingCase: true });
        }
        return cb(new Error("Source and destination must not be the same."));
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`));
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`));
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
      return cb(new Error(errMsg(src2, dest, funcName)));
    }
    return cb(null, { srcStat, destStat });
  });
}
function checkPathsSync(src2, dest, funcName, opts) {
  const { srcStat, destStat } = getStatsSync(src2, dest, opts);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$k.basename(src2);
      const destBaseName = path$k.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkParentPaths(src2, srcStat, dest, funcName, cb) {
  const srcParent = path$k.resolve(path$k.dirname(src2));
  const destParent = path$k.resolve(path$k.dirname(dest));
  if (destParent === srcParent || destParent === path$k.parse(destParent).root) return cb();
  fs$d.stat(destParent, { bigint: true }, (err, destStat) => {
    if (err) {
      if (err.code === "ENOENT") return cb();
      return cb(err);
    }
    if (areIdentical$2(srcStat, destStat)) {
      return cb(new Error(errMsg(src2, dest, funcName)));
    }
    return checkParentPaths(src2, srcStat, destParent, funcName, cb);
  });
}
function checkParentPathsSync(src2, srcStat, dest, funcName) {
  const srcParent = path$k.resolve(path$k.dirname(src2));
  const destParent = path$k.resolve(path$k.dirname(dest));
  if (destParent === srcParent || destParent === path$k.parse(destParent).root) return;
  let destStat;
  try {
    destStat = fs$d.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT") return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return checkParentPathsSync(src2, srcStat, destParent, funcName);
}
function areIdentical$2(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir(src2, dest) {
  const srcArr = path$k.resolve(src2).split(path$k.sep).filter((i) => i);
  const destArr = path$k.resolve(dest).split(path$k.sep).filter((i) => i);
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
}
function errMsg(src2, dest, funcName) {
  return `Cannot ${funcName} '${src2}' to a subdirectory of itself, '${dest}'.`;
}
var stat$4 = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir,
  areIdentical: areIdentical$2
};
const fs$c = gracefulFs;
const path$j = require$$1$4;
const mkdirs$1 = mkdirs$2.mkdirs;
const pathExists$5 = pathExists_1.pathExists;
const utimesMillis = utimes.utimesMillis;
const stat$3 = stat$4;
function copy$2(src2, dest, opts, cb) {
  if (typeof opts === "function" && !cb) {
    cb = opts;
    opts = {};
  } else if (typeof opts === "function") {
    opts = { filter: opts };
  }
  cb = cb || function() {
  };
  opts = opts || {};
  opts.clobber = "clobber" in opts ? !!opts.clobber : true;
  opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
  if (opts.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0001"
    );
  }
  stat$3.checkPaths(src2, dest, "copy", opts, (err, stats) => {
    if (err) return cb(err);
    const { srcStat, destStat } = stats;
    stat$3.checkParentPaths(src2, srcStat, dest, "copy", (err2) => {
      if (err2) return cb(err2);
      if (opts.filter) return handleFilter(checkParentDir, destStat, src2, dest, opts, cb);
      return checkParentDir(destStat, src2, dest, opts, cb);
    });
  });
}
function checkParentDir(destStat, src2, dest, opts, cb) {
  const destParent = path$j.dirname(dest);
  pathExists$5(destParent, (err, dirExists) => {
    if (err) return cb(err);
    if (dirExists) return getStats$1(destStat, src2, dest, opts, cb);
    mkdirs$1(destParent, (err2) => {
      if (err2) return cb(err2);
      return getStats$1(destStat, src2, dest, opts, cb);
    });
  });
}
function handleFilter(onInclude, destStat, src2, dest, opts, cb) {
  Promise.resolve(opts.filter(src2, dest)).then((include) => {
    if (include) return onInclude(destStat, src2, dest, opts, cb);
    return cb();
  }, (error2) => cb(error2));
}
function startCopy$1(destStat, src2, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats$1, destStat, src2, dest, opts, cb);
  return getStats$1(destStat, src2, dest, opts, cb);
}
function getStats$1(destStat, src2, dest, opts, cb) {
  const stat2 = opts.dereference ? fs$c.stat : fs$c.lstat;
  stat2(src2, (err, srcStat) => {
    if (err) return cb(err);
    if (srcStat.isDirectory()) return onDir$1(srcStat, destStat, src2, dest, opts, cb);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile$1(srcStat, destStat, src2, dest, opts, cb);
    else if (srcStat.isSymbolicLink()) return onLink$1(destStat, src2, dest, opts, cb);
    else if (srcStat.isSocket()) return cb(new Error(`Cannot copy a socket file: ${src2}`));
    else if (srcStat.isFIFO()) return cb(new Error(`Cannot copy a FIFO pipe: ${src2}`));
    return cb(new Error(`Unknown file: ${src2}`));
  });
}
function onFile$1(srcStat, destStat, src2, dest, opts, cb) {
  if (!destStat) return copyFile$1(srcStat, src2, dest, opts, cb);
  return mayCopyFile$1(srcStat, src2, dest, opts, cb);
}
function mayCopyFile$1(srcStat, src2, dest, opts, cb) {
  if (opts.overwrite) {
    fs$c.unlink(dest, (err) => {
      if (err) return cb(err);
      return copyFile$1(srcStat, src2, dest, opts, cb);
    });
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`));
  } else return cb();
}
function copyFile$1(srcStat, src2, dest, opts, cb) {
  fs$c.copyFile(src2, dest, (err) => {
    if (err) return cb(err);
    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src2, dest, cb);
    return setDestMode$1(dest, srcStat.mode, cb);
  });
}
function handleTimestampsAndMode(srcMode, src2, dest, cb) {
  if (fileIsNotWritable$1(srcMode)) {
    return makeFileWritable$1(dest, srcMode, (err) => {
      if (err) return cb(err);
      return setDestTimestampsAndMode(srcMode, src2, dest, cb);
    });
  }
  return setDestTimestampsAndMode(srcMode, src2, dest, cb);
}
function fileIsNotWritable$1(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$1(dest, srcMode, cb) {
  return setDestMode$1(dest, srcMode | 128, cb);
}
function setDestTimestampsAndMode(srcMode, src2, dest, cb) {
  setDestTimestamps$1(src2, dest, (err) => {
    if (err) return cb(err);
    return setDestMode$1(dest, srcMode, cb);
  });
}
function setDestMode$1(dest, srcMode, cb) {
  return fs$c.chmod(dest, srcMode, cb);
}
function setDestTimestamps$1(src2, dest, cb) {
  fs$c.stat(src2, (err, updatedSrcStat) => {
    if (err) return cb(err);
    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
  });
}
function onDir$1(srcStat, destStat, src2, dest, opts, cb) {
  if (!destStat) return mkDirAndCopy$1(srcStat.mode, src2, dest, opts, cb);
  return copyDir$1(src2, dest, opts, cb);
}
function mkDirAndCopy$1(srcMode, src2, dest, opts, cb) {
  fs$c.mkdir(dest, (err) => {
    if (err) return cb(err);
    copyDir$1(src2, dest, opts, (err2) => {
      if (err2) return cb(err2);
      return setDestMode$1(dest, srcMode, cb);
    });
  });
}
function copyDir$1(src2, dest, opts, cb) {
  fs$c.readdir(src2, (err, items) => {
    if (err) return cb(err);
    return copyDirItems(items, src2, dest, opts, cb);
  });
}
function copyDirItems(items, src2, dest, opts, cb) {
  const item = items.pop();
  if (!item) return cb();
  return copyDirItem$1(items, item, src2, dest, opts, cb);
}
function copyDirItem$1(items, item, src2, dest, opts, cb) {
  const srcItem = path$j.join(src2, item);
  const destItem = path$j.join(dest, item);
  stat$3.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
    if (err) return cb(err);
    const { destStat } = stats;
    startCopy$1(destStat, srcItem, destItem, opts, (err2) => {
      if (err2) return cb(err2);
      return copyDirItems(items, src2, dest, opts, cb);
    });
  });
}
function onLink$1(destStat, src2, dest, opts, cb) {
  fs$c.readlink(src2, (err, resolvedSrc) => {
    if (err) return cb(err);
    if (opts.dereference) {
      resolvedSrc = path$j.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs$c.symlink(resolvedSrc, dest, cb);
    } else {
      fs$c.readlink(dest, (err2, resolvedDest) => {
        if (err2) {
          if (err2.code === "EINVAL" || err2.code === "UNKNOWN") return fs$c.symlink(resolvedSrc, dest, cb);
          return cb(err2);
        }
        if (opts.dereference) {
          resolvedDest = path$j.resolve(process.cwd(), resolvedDest);
        }
        if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
        }
        if (destStat.isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
        }
        return copyLink$1(resolvedSrc, dest, cb);
      });
    }
  });
}
function copyLink$1(resolvedSrc, dest, cb) {
  fs$c.unlink(dest, (err) => {
    if (err) return cb(err);
    return fs$c.symlink(resolvedSrc, dest, cb);
  });
}
var copy_1 = copy$2;
const fs$b = gracefulFs;
const path$i = require$$1$4;
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$2 = stat$4;
function copySync$1(src2, dest, opts) {
  if (typeof opts === "function") {
    opts = { filter: opts };
  }
  opts = opts || {};
  opts.clobber = "clobber" in opts ? !!opts.clobber : true;
  opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
  if (opts.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0002"
    );
  }
  const { srcStat, destStat } = stat$2.checkPathsSync(src2, dest, "copy", opts);
  stat$2.checkParentPathsSync(src2, srcStat, dest, "copy");
  return handleFilterAndCopy(destStat, src2, dest, opts);
}
function handleFilterAndCopy(destStat, src2, dest, opts) {
  if (opts.filter && !opts.filter(src2, dest)) return;
  const destParent = path$i.dirname(dest);
  if (!fs$b.existsSync(destParent)) mkdirsSync$1(destParent);
  return getStats(destStat, src2, dest, opts);
}
function startCopy(destStat, src2, dest, opts) {
  if (opts.filter && !opts.filter(src2, dest)) return;
  return getStats(destStat, src2, dest, opts);
}
function getStats(destStat, src2, dest, opts) {
  const statSync = opts.dereference ? fs$b.statSync : fs$b.lstatSync;
  const srcStat = statSync(src2);
  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src2, dest, opts);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src2, dest, opts);
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src2, dest, opts);
  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src2}`);
  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src2}`);
  throw new Error(`Unknown file: ${src2}`);
}
function onFile(srcStat, destStat, src2, dest, opts) {
  if (!destStat) return copyFile(srcStat, src2, dest, opts);
  return mayCopyFile(srcStat, src2, dest, opts);
}
function mayCopyFile(srcStat, src2, dest, opts) {
  if (opts.overwrite) {
    fs$b.unlinkSync(dest);
    return copyFile(srcStat, src2, dest, opts);
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile(srcStat, src2, dest, opts) {
  fs$b.copyFileSync(src2, dest);
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src2, dest);
  return setDestMode(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src2, dest) {
  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
  return setDestTimestamps(src2, dest);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 128);
}
function setDestMode(dest, srcMode) {
  return fs$b.chmodSync(dest, srcMode);
}
function setDestTimestamps(src2, dest) {
  const updatedSrcStat = fs$b.statSync(src2);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir(srcStat, destStat, src2, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src2, dest, opts);
  return copyDir(src2, dest, opts);
}
function mkDirAndCopy(srcMode, src2, dest, opts) {
  fs$b.mkdirSync(dest);
  copyDir(src2, dest, opts);
  return setDestMode(dest, srcMode);
}
function copyDir(src2, dest, opts) {
  fs$b.readdirSync(src2).forEach((item) => copyDirItem(item, src2, dest, opts));
}
function copyDirItem(item, src2, dest, opts) {
  const srcItem = path$i.join(src2, item);
  const destItem = path$i.join(dest, item);
  const { destStat } = stat$2.checkPathsSync(srcItem, destItem, "copy", opts);
  return startCopy(destStat, srcItem, destItem, opts);
}
function onLink(destStat, src2, dest, opts) {
  let resolvedSrc = fs$b.readlinkSync(src2);
  if (opts.dereference) {
    resolvedSrc = path$i.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$b.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$b.readlinkSync(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs$b.symlinkSync(resolvedSrc, dest);
      throw err;
    }
    if (opts.dereference) {
      resolvedDest = path$i.resolve(process.cwd(), resolvedDest);
    }
    if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (fs$b.statSync(dest).isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink(resolvedSrc, dest);
  }
}
function copyLink(resolvedSrc, dest) {
  fs$b.unlinkSync(dest);
  return fs$b.symlinkSync(resolvedSrc, dest);
}
var copySync_1 = copySync$1;
const u$8 = universalify$1.fromCallback;
var copy$1 = {
  copy: u$8(copy_1),
  copySync: copySync_1
};
const fs$a = gracefulFs;
const path$h = require$$1$4;
const assert = require$$2$3;
const isWindows = process.platform === "win32";
function defaults(options) {
  const methods = [
=======
  ].filter((i) => typeof n[i] == "function");
  Object.assign(e, n), r.forEach((i) => {
    e[i] = t(n[i]);
  }), e.exists = function(i, a) {
    return typeof a == "function" ? n.exists(i, a) : new Promise((o) => n.exists(i, o));
  }, e.read = function(i, a, o, c, s, u) {
    return typeof u == "function" ? n.read(i, a, o, c, s, u) : new Promise((l, p) => {
      n.read(i, a, o, c, s, (d, m, g) => {
        if (d) return p(d);
        l({ bytesRead: m, buffer: g });
      });
    });
  }, e.write = function(i, a, ...o) {
    return typeof o[o.length - 1] == "function" ? n.write(i, a, ...o) : new Promise((c, s) => {
      n.write(i, a, ...o, (u, l, p) => {
        if (u) return s(u);
        c({ bytesWritten: l, buffer: p });
      });
    });
  }, typeof n.writev == "function" && (e.writev = function(i, a, ...o) {
    return typeof o[o.length - 1] == "function" ? n.writev(i, a, ...o) : new Promise((c, s) => {
      n.writev(i, a, ...o, (u, l, p) => {
        if (u) return s(u);
        c({ bytesWritten: l, buffers: p });
      });
    });
  }), typeof n.realpath.native == "function" ? e.realpath.native = t(n.realpath.native) : process.emitWarning(
    "fs.realpath.native is not a function. Is fs being monkey-patched?",
    "Warning",
    "fs-extra-WARN0003"
  );
})(Yn);
var Eu = {}, vv = {};
const _2 = oe;
vv.checkPath = function(t) {
  if (process.platform === "win32" && /[<>:"|?*]/.test(t.replace(_2.parse(t).root, ""))) {
    const r = new Error(`Path contains invalid characters: ${t}`);
    throw r.code = "EINVAL", r;
  }
};
const gv = Yn, { checkPath: xv } = vv, yv = (e) => {
  const t = { mode: 511 };
  return typeof e == "number" ? e : { ...t, ...e }.mode;
};
Eu.makeDir = async (e, t) => (xv(e), gv.mkdir(e, {
  mode: yv(t),
  recursive: !0
}));
Eu.makeDirSync = (e, t) => (xv(e), gv.mkdirSync(e, {
  mode: yv(t),
  recursive: !0
}));
const S2 = We.fromPromise, { makeDir: T2, makeDirSync: Rc } = Eu, Cc = S2(T2);
var Ct = {
  mkdirs: Cc,
  mkdirsSync: Rc,
  // alias
  mkdirp: Cc,
  mkdirpSync: Rc,
  ensureDir: Cc,
  ensureDirSync: Rc
};
const A2 = We.fromPromise, bv = Yn;
function R2(e) {
  return bv.access(e).then(() => !0).catch(() => !1);
}
var Xn = {
  pathExists: A2(R2),
  pathExistsSync: bv.existsSync
};
const Sr = Ve;
function C2(e, t, n, r) {
  Sr.open(e, "r+", (i, a) => {
    if (i) return r(i);
    Sr.futimes(a, t, n, (o) => {
      Sr.close(a, (c) => {
        r && r(o || c);
      });
    });
  });
}
function O2(e, t, n) {
  const r = Sr.openSync(e, "r+");
  return Sr.futimesSync(r, t, n), Sr.closeSync(r);
}
var wv = {
  utimesMillis: C2,
  utimesMillisSync: O2
};
const Or = Yn, Ie = oe, $2 = Pe;
function I2(e, t, n) {
  const r = n.dereference ? (i) => Or.stat(i, { bigint: !0 }) : (i) => Or.lstat(i, { bigint: !0 });
  return Promise.all([
    r(e),
    r(t).catch((i) => {
      if (i.code === "ENOENT") return null;
      throw i;
    })
  ]).then(([i, a]) => ({ srcStat: i, destStat: a }));
}
function P2(e, t, n) {
  let r;
  const i = n.dereference ? (o) => Or.statSync(o, { bigint: !0 }) : (o) => Or.lstatSync(o, { bigint: !0 }), a = i(e);
  try {
    r = i(t);
  } catch (o) {
    if (o.code === "ENOENT") return { srcStat: a, destStat: null };
    throw o;
  }
  return { srcStat: a, destStat: r };
}
function D2(e, t, n, r, i) {
  $2.callbackify(I2)(e, t, r, (a, o) => {
    if (a) return i(a);
    const { srcStat: c, destStat: s } = o;
    if (s) {
      if (Gi(c, s)) {
        const u = Ie.basename(e), l = Ie.basename(t);
        return n === "move" && u !== l && u.toLowerCase() === l.toLowerCase() ? i(null, { srcStat: c, destStat: s, isChangingCase: !0 }) : i(new Error("Source and destination must not be the same."));
      }
      if (c.isDirectory() && !s.isDirectory())
        return i(new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`));
      if (!c.isDirectory() && s.isDirectory())
        return i(new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`));
    }
    return c.isDirectory() && _u(e, t) ? i(new Error(Qo(e, t, n))) : i(null, { srcStat: c, destStat: s });
  });
}
function F2(e, t, n, r) {
  const { srcStat: i, destStat: a } = P2(e, t, r);
  if (a) {
    if (Gi(i, a)) {
      const o = Ie.basename(e), c = Ie.basename(t);
      if (n === "move" && o !== c && o.toLowerCase() === c.toLowerCase())
        return { srcStat: i, destStat: a, isChangingCase: !0 };
      throw new Error("Source and destination must not be the same.");
    }
    if (i.isDirectory() && !a.isDirectory())
      throw new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`);
    if (!i.isDirectory() && a.isDirectory())
      throw new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`);
  }
  if (i.isDirectory() && _u(e, t))
    throw new Error(Qo(e, t, n));
  return { srcStat: i, destStat: a };
}
function Ev(e, t, n, r, i) {
  const a = Ie.resolve(Ie.dirname(e)), o = Ie.resolve(Ie.dirname(n));
  if (o === a || o === Ie.parse(o).root) return i();
  Or.stat(o, { bigint: !0 }, (c, s) => c ? c.code === "ENOENT" ? i() : i(c) : Gi(t, s) ? i(new Error(Qo(e, n, r))) : Ev(e, t, o, r, i));
}
function _v(e, t, n, r) {
  const i = Ie.resolve(Ie.dirname(e)), a = Ie.resolve(Ie.dirname(n));
  if (a === i || a === Ie.parse(a).root) return;
  let o;
  try {
    o = Or.statSync(a, { bigint: !0 });
  } catch (c) {
    if (c.code === "ENOENT") return;
    throw c;
  }
  if (Gi(t, o))
    throw new Error(Qo(e, n, r));
  return _v(e, t, a, r);
}
function Gi(e, t) {
  return t.ino && t.dev && t.ino === e.ino && t.dev === e.dev;
}
function _u(e, t) {
  const n = Ie.resolve(e).split(Ie.sep).filter((i) => i), r = Ie.resolve(t).split(Ie.sep).filter((i) => i);
  return n.reduce((i, a, o) => i && r[o] === a, !0);
}
function Qo(e, t, n) {
  return `Cannot ${n} '${e}' to a subdirectory of itself, '${t}'.`;
}
var kr = {
  checkPaths: D2,
  checkPathsSync: F2,
  checkParentPaths: Ev,
  checkParentPathsSync: _v,
  isSrcSubdir: _u,
  areIdentical: Gi
};
const Je = Ve, mi = oe, N2 = Ct.mkdirs, k2 = Xn.pathExists, L2 = wv.utimesMillis, vi = kr;
function U2(e, t, n, r) {
  typeof n == "function" && !r ? (r = n, n = {}) : typeof n == "function" && (n = { filter: n }), r = r || function() {
  }, n = n || {}, n.clobber = "clobber" in n ? !!n.clobber : !0, n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber, n.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0001"
  ), vi.checkPaths(e, t, "copy", n, (i, a) => {
    if (i) return r(i);
    const { srcStat: o, destStat: c } = a;
    vi.checkParentPaths(e, o, t, "copy", (s) => s ? r(s) : n.filter ? Sv(ad, c, e, t, n, r) : ad(c, e, t, n, r));
  });
}
function ad(e, t, n, r, i) {
  const a = mi.dirname(n);
  k2(a, (o, c) => {
    if (o) return i(o);
    if (c) return co(e, t, n, r, i);
    N2(a, (s) => s ? i(s) : co(e, t, n, r, i));
  });
}
function Sv(e, t, n, r, i, a) {
  Promise.resolve(i.filter(n, r)).then((o) => o ? e(t, n, r, i, a) : a(), (o) => a(o));
}
function B2(e, t, n, r, i) {
  return r.filter ? Sv(co, e, t, n, r, i) : co(e, t, n, r, i);
}
function co(e, t, n, r, i) {
  (r.dereference ? Je.stat : Je.lstat)(t, (o, c) => o ? i(o) : c.isDirectory() ? W2(c, e, t, n, r, i) : c.isFile() || c.isCharacterDevice() || c.isBlockDevice() ? j2(c, e, t, n, r, i) : c.isSymbolicLink() ? X2(e, t, n, r, i) : c.isSocket() ? i(new Error(`Cannot copy a socket file: ${t}`)) : c.isFIFO() ? i(new Error(`Cannot copy a FIFO pipe: ${t}`)) : i(new Error(`Unknown file: ${t}`)));
}
function j2(e, t, n, r, i, a) {
  return t ? M2(e, n, r, i, a) : Tv(e, n, r, i, a);
}
function M2(e, t, n, r, i) {
  if (r.overwrite)
    Je.unlink(n, (a) => a ? i(a) : Tv(e, t, n, r, i));
  else return r.errorOnExist ? i(new Error(`'${n}' already exists`)) : i();
}
function Tv(e, t, n, r, i) {
  Je.copyFile(t, n, (a) => a ? i(a) : r.preserveTimestamps ? q2(e.mode, t, n, i) : es(n, e.mode, i));
}
function q2(e, t, n, r) {
  return z2(e) ? H2(n, e, (i) => i ? r(i) : od(e, t, n, r)) : od(e, t, n, r);
}
function z2(e) {
  return (e & 128) === 0;
}
function H2(e, t, n) {
  return es(e, t | 128, n);
}
function od(e, t, n, r) {
  G2(t, n, (i) => i ? r(i) : es(n, e, r));
}
function es(e, t, n) {
  return Je.chmod(e, t, n);
}
function G2(e, t, n) {
  Je.stat(e, (r, i) => r ? n(r) : L2(t, i.atime, i.mtime, n));
}
function W2(e, t, n, r, i, a) {
  return t ? Av(n, r, i, a) : V2(e.mode, n, r, i, a);
}
function V2(e, t, n, r, i) {
  Je.mkdir(n, (a) => {
    if (a) return i(a);
    Av(t, n, r, (o) => o ? i(o) : es(n, e, i));
  });
}
function Av(e, t, n, r) {
  Je.readdir(e, (i, a) => i ? r(i) : Rv(a, e, t, n, r));
}
function Rv(e, t, n, r, i) {
  const a = e.pop();
  return a ? Y2(e, a, t, n, r, i) : i();
}
function Y2(e, t, n, r, i, a) {
  const o = mi.join(n, t), c = mi.join(r, t);
  vi.checkPaths(o, c, "copy", i, (s, u) => {
    if (s) return a(s);
    const { destStat: l } = u;
    B2(l, o, c, i, (p) => p ? a(p) : Rv(e, n, r, i, a));
  });
}
function X2(e, t, n, r, i) {
  Je.readlink(t, (a, o) => {
    if (a) return i(a);
    if (r.dereference && (o = mi.resolve(process.cwd(), o)), e)
      Je.readlink(n, (c, s) => c ? c.code === "EINVAL" || c.code === "UNKNOWN" ? Je.symlink(o, n, i) : i(c) : (r.dereference && (s = mi.resolve(process.cwd(), s)), vi.isSrcSubdir(o, s) ? i(new Error(`Cannot copy '${o}' to a subdirectory of itself, '${s}'.`)) : e.isDirectory() && vi.isSrcSubdir(s, o) ? i(new Error(`Cannot overwrite '${s}' with '${o}'.`)) : K2(o, n, i)));
    else
      return Je.symlink(o, n, i);
  });
}
function K2(e, t, n) {
  Je.unlink(t, (r) => r ? n(r) : Je.symlink(e, t, n));
}
var J2 = U2;
const je = Ve, gi = oe, Z2 = Ct.mkdirsSync, Q2 = wv.utimesMillisSync, xi = kr;
function e4(e, t, n) {
  typeof n == "function" && (n = { filter: n }), n = n || {}, n.clobber = "clobber" in n ? !!n.clobber : !0, n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber, n.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
    `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
    "Warning",
    "fs-extra-WARN0002"
  );
  const { srcStat: r, destStat: i } = xi.checkPathsSync(e, t, "copy", n);
  return xi.checkParentPathsSync(e, r, t, "copy"), t4(i, e, t, n);
}
function t4(e, t, n, r) {
  if (r.filter && !r.filter(t, n)) return;
  const i = gi.dirname(n);
  return je.existsSync(i) || Z2(i), Cv(e, t, n, r);
}
function n4(e, t, n, r) {
  if (!(r.filter && !r.filter(t, n)))
    return Cv(e, t, n, r);
}
function Cv(e, t, n, r) {
  const a = (r.dereference ? je.statSync : je.lstatSync)(t);
  if (a.isDirectory()) return l4(a, e, t, n, r);
  if (a.isFile() || a.isCharacterDevice() || a.isBlockDevice()) return r4(a, e, t, n, r);
  if (a.isSymbolicLink()) return f4(e, t, n, r);
  throw a.isSocket() ? new Error(`Cannot copy a socket file: ${t}`) : a.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${t}`) : new Error(`Unknown file: ${t}`);
}
function r4(e, t, n, r, i) {
  return t ? i4(e, n, r, i) : Ov(e, n, r, i);
}
function i4(e, t, n, r) {
  if (r.overwrite)
    return je.unlinkSync(n), Ov(e, t, n, r);
  if (r.errorOnExist)
    throw new Error(`'${n}' already exists`);
}
function Ov(e, t, n, r) {
  return je.copyFileSync(t, n), r.preserveTimestamps && a4(e.mode, t, n), Su(n, e.mode);
}
function a4(e, t, n) {
  return o4(e) && s4(n, e), c4(t, n);
}
function o4(e) {
  return (e & 128) === 0;
}
function s4(e, t) {
  return Su(e, t | 128);
}
function Su(e, t) {
  return je.chmodSync(e, t);
}
function c4(e, t) {
  const n = je.statSync(e);
  return Q2(t, n.atime, n.mtime);
}
function l4(e, t, n, r, i) {
  return t ? $v(n, r, i) : u4(e.mode, n, r, i);
}
function u4(e, t, n, r) {
  return je.mkdirSync(n), $v(t, n, r), Su(n, e);
}
function $v(e, t, n) {
  je.readdirSync(e).forEach((r) => p4(r, e, t, n));
}
function p4(e, t, n, r) {
  const i = gi.join(t, e), a = gi.join(n, e), { destStat: o } = xi.checkPathsSync(i, a, "copy", r);
  return n4(o, i, a, r);
}
function f4(e, t, n, r) {
  let i = je.readlinkSync(t);
  if (r.dereference && (i = gi.resolve(process.cwd(), i)), e) {
    let a;
    try {
      a = je.readlinkSync(n);
    } catch (o) {
      if (o.code === "EINVAL" || o.code === "UNKNOWN") return je.symlinkSync(i, n);
      throw o;
    }
    if (r.dereference && (a = gi.resolve(process.cwd(), a)), xi.isSrcSubdir(i, a))
      throw new Error(`Cannot copy '${i}' to a subdirectory of itself, '${a}'.`);
    if (je.statSync(n).isDirectory() && xi.isSrcSubdir(a, i))
      throw new Error(`Cannot overwrite '${a}' with '${i}'.`);
    return d4(i, n);
  } else
    return je.symlinkSync(i, n);
}
function d4(e, t) {
  return je.unlinkSync(t), je.symlinkSync(e, t);
}
var h4 = e4;
const m4 = We.fromCallback;
var Tu = {
  copy: m4(J2),
  copySync: h4
};
const sd = Ve, Iv = oe, ue = wo, yi = process.platform === "win32";
function Pv(e) {
  [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ].forEach((n) => {
    e[n] = e[n] || sd[n], n = n + "Sync", e[n] = e[n] || sd[n];
  }), e.maxBusyTries = e.maxBusyTries || 3;
}
function Au(e, t, n) {
  let r = 0;
  typeof t == "function" && (n = t, t = {}), ue(e, "rimraf: missing path"), ue.strictEqual(typeof e, "string", "rimraf: path should be a string"), ue.strictEqual(typeof n, "function", "rimraf: callback function required"), ue(t, "rimraf: invalid options argument provided"), ue.strictEqual(typeof t, "object", "rimraf: options should be object"), Pv(t), cd(e, t, function i(a) {
    if (a) {
      if ((a.code === "EBUSY" || a.code === "ENOTEMPTY" || a.code === "EPERM") && r < t.maxBusyTries) {
        r++;
        const o = r * 100;
        return setTimeout(() => cd(e, t, i), o);
      }
      a.code === "ENOENT" && (a = null);
    }
    n(a);
  });
}
function cd(e, t, n) {
  ue(e), ue(t), ue(typeof n == "function"), t.lstat(e, (r, i) => {
    if (r && r.code === "ENOENT")
      return n(null);
    if (r && r.code === "EPERM" && yi)
      return ld(e, t, r, n);
    if (i && i.isDirectory())
      return Xa(e, t, r, n);
    t.unlink(e, (a) => {
      if (a) {
        if (a.code === "ENOENT")
          return n(null);
        if (a.code === "EPERM")
          return yi ? ld(e, t, a, n) : Xa(e, t, a, n);
        if (a.code === "EISDIR")
          return Xa(e, t, a, n);
      }
      return n(a);
    });
  });
}
function ld(e, t, n, r) {
  ue(e), ue(t), ue(typeof r == "function"), t.chmod(e, 438, (i) => {
    i ? r(i.code === "ENOENT" ? null : n) : t.stat(e, (a, o) => {
      a ? r(a.code === "ENOENT" ? null : n) : o.isDirectory() ? Xa(e, t, n, r) : t.unlink(e, r);
    });
  });
}
function ud(e, t, n) {
  let r;
  ue(e), ue(t);
  try {
    t.chmodSync(e, 438);
  } catch (i) {
    if (i.code === "ENOENT")
      return;
    throw n;
  }
  try {
    r = t.statSync(e);
  } catch (i) {
    if (i.code === "ENOENT")
      return;
    throw n;
  }
  r.isDirectory() ? Ka(e, t, n) : t.unlinkSync(e);
}
<<<<<<< HEAD
function rmdir(p, options, originalEr, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.rmdir(p, (er) => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
      rmkids(p, options, cb);
    } else if (er && er.code === "ENOTDIR") {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}
function rmkids(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.readdir(p, (er, files) => {
    if (er) return cb(er);
    let n = files.length;
    let errState;
    if (n === 0) return options.rmdir(p, cb);
    files.forEach((f) => {
      rimraf$1(path$h.join(p, f), options, (er2) => {
        if (errState) {
          return;
        }
        if (er2) return cb(errState = er2);
        if (--n === 0) {
          options.rmdir(p, cb);
=======
function Xa(e, t, n, r) {
  ue(e), ue(t), ue(typeof r == "function"), t.rmdir(e, (i) => {
    i && (i.code === "ENOTEMPTY" || i.code === "EEXIST" || i.code === "EPERM") ? v4(e, t, r) : i && i.code === "ENOTDIR" ? r(n) : r(i);
  });
}
function v4(e, t, n) {
  ue(e), ue(t), ue(typeof n == "function"), t.readdir(e, (r, i) => {
    if (r) return n(r);
    let a = i.length, o;
    if (a === 0) return t.rmdir(e, n);
    i.forEach((c) => {
      Au(Iv.join(e, c), t, (s) => {
        if (!o) {
          if (s) return n(o = s);
          --a === 0 && t.rmdir(e, n);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        }
      });
    });
  });
}
function Dv(e, t) {
  let n;
  t = t || {}, Pv(t), ue(e, "rimraf: missing path"), ue.strictEqual(typeof e, "string", "rimraf: path should be a string"), ue(t, "rimraf: missing options"), ue.strictEqual(typeof t, "object", "rimraf: options should be object");
  try {
    n = t.lstatSync(e);
  } catch (r) {
    if (r.code === "ENOENT")
      return;
    r.code === "EPERM" && yi && ud(e, t, r);
  }
  try {
    n && n.isDirectory() ? Ka(e, t, null) : t.unlinkSync(e);
  } catch (r) {
    if (r.code === "ENOENT")
      return;
    if (r.code === "EPERM")
      return yi ? ud(e, t, r) : Ka(e, t, r);
    if (r.code !== "EISDIR")
      throw r;
    Ka(e, t, r);
  }
}
function Ka(e, t, n) {
  ue(e), ue(t);
  try {
<<<<<<< HEAD
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOTDIR") {
      throw originalEr;
    } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
      rmkidsSync(p, options);
    } else if (er.code !== "ENOENT") {
      throw er;
    }
  }
}
function rmkidsSync(p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach((f) => rimrafSync(path$h.join(p, f), options));
  if (isWindows) {
    const startTime = Date.now();
    do {
=======
    t.rmdirSync(e);
  } catch (r) {
    if (r.code === "ENOTDIR")
      throw n;
    if (r.code === "ENOTEMPTY" || r.code === "EEXIST" || r.code === "EPERM")
      g4(e, t);
    else if (r.code !== "ENOENT")
      throw r;
  }
}
function g4(e, t) {
  if (ue(e), ue(t), t.readdirSync(e).forEach((n) => Dv(Iv.join(e, n), t)), yi) {
    const n = Date.now();
    do
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      try {
        return t.rmdirSync(e, t);
      } catch {
      }
<<<<<<< HEAD
    } while (Date.now() - startTime < 500);
  } else {
    const ret = options.rmdirSync(p, options);
    return ret;
  }
}
var rimraf_1 = rimraf$1;
rimraf$1.sync = rimrafSync;
const fs$9 = gracefulFs;
const u$7 = universalify$1.fromCallback;
const rimraf = rimraf_1;
function remove$2(path2, callback) {
  if (fs$9.rm) return fs$9.rm(path2, { recursive: true, force: true }, callback);
  rimraf(path2, callback);
}
function removeSync$1(path2) {
  if (fs$9.rmSync) return fs$9.rmSync(path2, { recursive: true, force: true });
  rimraf.sync(path2);
}
var remove_1 = {
  remove: u$7(remove$2),
  removeSync: removeSync$1
};
const u$6 = universalify$1.fromPromise;
const fs$8 = fs$i;
const path$g = require$$1$4;
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;
const emptyDir = u$6(async function emptyDir2(dir) {
  let items;
  try {
    items = await fs$8.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir);
  }
  return Promise.all(items.map((item) => remove$1.remove(path$g.join(dir, item))));
=======
    while (Date.now() - n < 500);
  } else
    return t.rmdirSync(e, t);
}
var x4 = Au;
Au.sync = Dv;
const lo = Ve, y4 = We.fromCallback, Fv = x4;
function b4(e, t) {
  if (lo.rm) return lo.rm(e, { recursive: !0, force: !0 }, t);
  Fv(e, t);
}
function w4(e) {
  if (lo.rmSync) return lo.rmSync(e, { recursive: !0, force: !0 });
  Fv.sync(e);
}
var ts = {
  remove: y4(b4),
  removeSync: w4
};
const E4 = We.fromPromise, Nv = Yn, kv = oe, Lv = Ct, Uv = ts, pd = E4(async function(t) {
  let n;
  try {
    n = await Nv.readdir(t);
  } catch {
    return Lv.mkdirs(t);
  }
  return Promise.all(n.map((r) => Uv.remove(kv.join(t, r))));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
});
function fd(e) {
  let t;
  try {
    t = Nv.readdirSync(e);
  } catch {
    return Lv.mkdirsSync(e);
  }
  t.forEach((n) => {
    n = kv.join(e, n), Uv.removeSync(n);
  });
}
<<<<<<< HEAD
var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};
const u$5 = universalify$1.fromCallback;
const path$f = require$$1$4;
const fs$7 = gracefulFs;
const mkdir$2 = mkdirs$2;
function createFile$1(file2, callback) {
  function makeFile() {
    fs$7.writeFile(file2, "", (err) => {
      if (err) return callback(err);
      callback();
=======
var _4 = {
  emptyDirSync: fd,
  emptydirSync: fd,
  emptyDir: pd,
  emptydir: pd
};
const S4 = We.fromCallback, Bv = oe, Qt = Ve, jv = Ct;
function T4(e, t) {
  function n() {
    Qt.writeFile(e, "", (r) => {
      if (r) return t(r);
      t();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    });
  }
  Qt.stat(e, (r, i) => {
    if (!r && i.isFile()) return t();
    const a = Bv.dirname(e);
    Qt.stat(a, (o, c) => {
      if (o)
        return o.code === "ENOENT" ? jv.mkdirs(a, (s) => {
          if (s) return t(s);
          n();
        }) : t(o);
      c.isDirectory() ? n() : Qt.readdir(a, (s) => {
        if (s) return t(s);
      });
    });
  });
}
<<<<<<< HEAD
function createFileSync$1(file2) {
  let stats;
=======
function A4(e) {
  let t;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    t = Qt.statSync(e);
  } catch {
  }
  if (t && t.isFile()) return;
  const n = Bv.dirname(e);
  try {
    Qt.statSync(n).isDirectory() || Qt.readdirSync(n);
  } catch (r) {
    if (r && r.code === "ENOENT") jv.mkdirsSync(n);
    else throw r;
  }
  Qt.writeFileSync(e, "");
}
<<<<<<< HEAD
var file = {
  createFile: u$5(createFile$1),
  createFileSync: createFileSync$1
};
const u$4 = universalify$1.fromCallback;
const path$e = require$$1$4;
const fs$6 = gracefulFs;
const mkdir$1 = mkdirs$2;
const pathExists$4 = pathExists_1.pathExists;
const { areIdentical: areIdentical$1 } = stat$4;
function createLink$1(srcpath, dstpath, callback) {
  function makeLink(srcpath2, dstpath2) {
    fs$6.link(srcpath2, dstpath2, (err) => {
      if (err) return callback(err);
      callback(null);
    });
  }
  fs$6.lstat(dstpath, (_, dstStat) => {
    fs$6.lstat(srcpath, (err, srcStat) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        return callback(err);
      }
      if (dstStat && areIdentical$1(srcStat, dstStat)) return callback(null);
      const dir = path$e.dirname(dstpath);
      pathExists$4(dir, (err2, dirExists) => {
        if (err2) return callback(err2);
        if (dirExists) return makeLink(srcpath, dstpath);
        mkdir$1.mkdirs(dir, (err3) => {
          if (err3) return callback(err3);
          makeLink(srcpath, dstpath);
=======
var R4 = {
  createFile: S4(T4),
  createFileSync: A4
};
const C4 = We.fromCallback, Mv = oe, Jt = Ve, qv = Ct, O4 = Xn.pathExists, { areIdentical: zv } = kr;
function $4(e, t, n) {
  function r(i, a) {
    Jt.link(i, a, (o) => {
      if (o) return n(o);
      n(null);
    });
  }
  Jt.lstat(t, (i, a) => {
    Jt.lstat(e, (o, c) => {
      if (o)
        return o.message = o.message.replace("lstat", "ensureLink"), n(o);
      if (a && zv(c, a)) return n(null);
      const s = Mv.dirname(t);
      O4(s, (u, l) => {
        if (u) return n(u);
        if (l) return r(e, t);
        qv.mkdirs(s, (p) => {
          if (p) return n(p);
          r(e, t);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        });
      });
    });
  });
}
<<<<<<< HEAD
function createLinkSync$1(srcpath, dstpath) {
  let dstStat;
=======
function I4(e, t) {
  let n;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    n = Jt.lstatSync(t);
  } catch {
  }
  try {
    const a = Jt.lstatSync(e);
    if (n && zv(a, n)) return;
  } catch (a) {
    throw a.message = a.message.replace("lstat", "ensureLink"), a;
  }
  const r = Mv.dirname(t);
  return Jt.existsSync(r) || qv.mkdirsSync(r), Jt.linkSync(e, t);
}
<<<<<<< HEAD
var link = {
  createLink: u$4(createLink$1),
  createLinkSync: createLinkSync$1
};
const path$d = require$$1$4;
const fs$5 = gracefulFs;
const pathExists$3 = pathExists_1.pathExists;
function symlinkPaths$1(srcpath, dstpath, callback) {
  if (path$d.isAbsolute(srcpath)) {
    return fs$5.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        return callback(err);
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      });
    });
  } else {
    const dstdir = path$d.dirname(dstpath);
    const relativeToDst = path$d.join(dstdir, srcpath);
    return pathExists$3(relativeToDst, (err, exists) => {
      if (err) return callback(err);
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        });
      } else {
        return fs$5.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureSymlink");
            return callback(err2);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path$d.relative(dstdir, srcpath)
          });
        });
      }
    });
  }
}
function symlinkPathsSync$1(srcpath, dstpath) {
  let exists;
  if (path$d.isAbsolute(srcpath)) {
    exists = fs$5.existsSync(srcpath);
    if (!exists) throw new Error("absolute srcpath does not exist");
=======
var P4 = {
  createLink: C4($4),
  createLinkSync: I4
};
const en = oe, ai = Ve, D4 = Xn.pathExists;
function F4(e, t, n) {
  if (en.isAbsolute(e))
    return ai.lstat(e, (r) => r ? (r.message = r.message.replace("lstat", "ensureSymlink"), n(r)) : n(null, {
      toCwd: e,
      toDst: e
    }));
  {
    const r = en.dirname(t), i = en.join(r, e);
    return D4(i, (a, o) => a ? n(a) : o ? n(null, {
      toCwd: i,
      toDst: e
    }) : ai.lstat(e, (c) => c ? (c.message = c.message.replace("lstat", "ensureSymlink"), n(c)) : n(null, {
      toCwd: e,
      toDst: en.relative(r, e)
    })));
  }
}
function N4(e, t) {
  let n;
  if (en.isAbsolute(e)) {
    if (n = ai.existsSync(e), !n) throw new Error("absolute srcpath does not exist");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return {
      toCwd: e,
      toDst: e
    };
  } else {
    const r = en.dirname(t), i = en.join(r, e);
    if (n = ai.existsSync(i), n)
      return {
        toCwd: i,
        toDst: e
      };
    if (n = ai.existsSync(e), !n) throw new Error("relative srcpath does not exist");
    return {
      toCwd: e,
      toDst: en.relative(r, e)
    };
  }
}
<<<<<<< HEAD
var symlinkPaths_1 = {
  symlinkPaths: symlinkPaths$1,
  symlinkPathsSync: symlinkPathsSync$1
};
const fs$4 = gracefulFs;
function symlinkType$1(srcpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  if (type2) return callback(null, type2);
  fs$4.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, "file");
    type2 = stats && stats.isDirectory() ? "dir" : "file";
    callback(null, type2);
  });
}
function symlinkTypeSync$1(srcpath, type2) {
  let stats;
  if (type2) return type2;
=======
var k4 = {
  symlinkPaths: F4,
  symlinkPathsSync: N4
};
const Hv = Ve;
function L4(e, t, n) {
  if (n = typeof t == "function" ? t : n, t = typeof t == "function" ? !1 : t, t) return n(null, t);
  Hv.lstat(e, (r, i) => {
    if (r) return n(null, "file");
    t = i && i.isDirectory() ? "dir" : "file", n(null, t);
  });
}
function U4(e, t) {
  let n;
  if (t) return t;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    n = Hv.lstatSync(e);
  } catch {
    return "file";
  }
  return n && n.isDirectory() ? "dir" : "file";
}
<<<<<<< HEAD
var symlinkType_1 = {
  symlinkType: symlinkType$1,
  symlinkTypeSync: symlinkTypeSync$1
};
const u$3 = universalify$1.fromCallback;
const path$c = require$$1$4;
const fs$3 = fs$i;
const _mkdirs = mkdirs$2;
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;
const _symlinkPaths = symlinkPaths_1;
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
const _symlinkType = symlinkType_1;
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;
const pathExists$2 = pathExists_1.pathExists;
const { areIdentical } = stat$4;
function createSymlink$1(srcpath, dstpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  fs$3.lstat(dstpath, (err, stats) => {
    if (!err && stats.isSymbolicLink()) {
      Promise.all([
        fs$3.stat(srcpath),
        fs$3.stat(dstpath)
      ]).then(([srcStat, dstStat]) => {
        if (areIdentical(srcStat, dstStat)) return callback(null);
        _createSymlink(srcpath, dstpath, type2, callback);
      });
    } else _createSymlink(srcpath, dstpath, type2, callback);
  });
}
function _createSymlink(srcpath, dstpath, type2, callback) {
  symlinkPaths(srcpath, dstpath, (err, relative) => {
    if (err) return callback(err);
    srcpath = relative.toDst;
    symlinkType(relative.toCwd, type2, (err2, type3) => {
      if (err2) return callback(err2);
      const dir = path$c.dirname(dstpath);
      pathExists$2(dir, (err3, dirExists) => {
        if (err3) return callback(err3);
        if (dirExists) return fs$3.symlink(srcpath, dstpath, type3, callback);
        mkdirs(dir, (err4) => {
          if (err4) return callback(err4);
          fs$3.symlink(srcpath, dstpath, type3, callback);
=======
var B4 = {
  symlinkType: L4,
  symlinkTypeSync: U4
};
const j4 = We.fromCallback, Gv = oe, ft = Yn, Wv = Ct, M4 = Wv.mkdirs, q4 = Wv.mkdirsSync, Vv = k4, z4 = Vv.symlinkPaths, H4 = Vv.symlinkPathsSync, Yv = B4, G4 = Yv.symlinkType, W4 = Yv.symlinkTypeSync, V4 = Xn.pathExists, { areIdentical: Xv } = kr;
function Y4(e, t, n, r) {
  r = typeof n == "function" ? n : r, n = typeof n == "function" ? !1 : n, ft.lstat(t, (i, a) => {
    !i && a.isSymbolicLink() ? Promise.all([
      ft.stat(e),
      ft.stat(t)
    ]).then(([o, c]) => {
      if (Xv(o, c)) return r(null);
      dd(e, t, n, r);
    }) : dd(e, t, n, r);
  });
}
function dd(e, t, n, r) {
  z4(e, t, (i, a) => {
    if (i) return r(i);
    e = a.toDst, G4(a.toCwd, n, (o, c) => {
      if (o) return r(o);
      const s = Gv.dirname(t);
      V4(s, (u, l) => {
        if (u) return r(u);
        if (l) return ft.symlink(e, t, c, r);
        M4(s, (p) => {
          if (p) return r(p);
          ft.symlink(e, t, c, r);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        });
      });
    });
  });
}
<<<<<<< HEAD
function createSymlinkSync$1(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = fs$3.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$3.statSync(srcpath);
    const dstStat = fs$3.statSync(dstpath);
    if (areIdentical(srcStat, dstStat)) return;
  }
  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type2 = symlinkTypeSync(relative.toCwd, type2);
  const dir = path$c.dirname(dstpath);
  const exists = fs$3.existsSync(dir);
  if (exists) return fs$3.symlinkSync(srcpath, dstpath, type2);
  mkdirsSync(dir);
  return fs$3.symlinkSync(srcpath, dstpath, type2);
}
var symlink = {
  createSymlink: u$3(createSymlink$1),
  createSymlinkSync: createSymlinkSync$1
};
const { createFile, createFileSync } = file;
const { createLink, createLinkSync } = link;
const { createSymlink, createSymlinkSync } = symlink;
var ensure = {
  // file
  createFile,
  createFileSync,
  ensureFile: createFile,
  ensureFileSync: createFileSync,
  // link
  createLink,
  createLinkSync,
  ensureLink: createLink,
  ensureLinkSync: createLinkSync,
  // symlink
  createSymlink,
  createSymlinkSync,
  ensureSymlink: createSymlink,
  ensureSymlinkSync: createSymlinkSync
};
function stringify$4(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : "";
  const str2 = JSON.stringify(obj, replacer, spaces);
  return str2.replace(/\n/g, EOL) + EOF;
}
function stripBom$1(content) {
  if (Buffer.isBuffer(content)) content = content.toString("utf8");
  return content.replace(/^\uFEFF/, "");
}
var utils = { stringify: stringify$4, stripBom: stripBom$1 };
let _fs;
=======
function X4(e, t, n) {
  let r;
  try {
    r = ft.lstatSync(t);
  } catch {
  }
  if (r && r.isSymbolicLink()) {
    const c = ft.statSync(e), s = ft.statSync(t);
    if (Xv(c, s)) return;
  }
  const i = H4(e, t);
  e = i.toDst, n = W4(i.toCwd, n);
  const a = Gv.dirname(t);
  return ft.existsSync(a) || q4(a), ft.symlinkSync(e, t, n);
}
var K4 = {
  createSymlink: j4(Y4),
  createSymlinkSync: X4
};
const { createFile: hd, createFileSync: md } = R4, { createLink: vd, createLinkSync: gd } = P4, { createSymlink: xd, createSymlinkSync: yd } = K4;
var J4 = {
  // file
  createFile: hd,
  createFileSync: md,
  ensureFile: hd,
  ensureFileSync: md,
  // link
  createLink: vd,
  createLinkSync: gd,
  ensureLink: vd,
  ensureLinkSync: gd,
  // symlink
  createSymlink: xd,
  createSymlinkSync: yd,
  ensureSymlink: xd,
  ensureSymlinkSync: yd
};
function Z4(e, { EOL: t = `
`, finalEOL: n = !0, replacer: r = null, spaces: i } = {}) {
  const a = n ? t : "";
  return JSON.stringify(e, r, i).replace(/\n/g, t) + a;
}
function Q4(e) {
  return Buffer.isBuffer(e) && (e = e.toString("utf8")), e.replace(/^\uFEFF/, "");
}
var Ru = { stringify: Z4, stripBom: Q4 };
let $r;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
try {
  $r = Ve;
} catch {
  $r = ae;
}
<<<<<<< HEAD
const universalify = universalify$1;
const { stringify: stringify$3, stripBom } = utils;
async function _readFile(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  let data = await universalify.fromCallback(fs2.readFile)(file2, options);
  data = stripBom(data);
  let obj;
=======
const ns = We, { stringify: Kv, stripBom: Jv } = Ru;
async function eT(e, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const n = t.fs || $r, r = "throws" in t ? t.throws : !0;
  let i = await ns.fromCallback(n.readFile)(e, t);
  i = Jv(i);
  let a;
  try {
    a = JSON.parse(i, t ? t.reviver : null);
  } catch (o) {
    if (r)
      throw o.message = `${e}: ${o.message}`, o;
    return null;
  }
  return a;
}
const tT = ns.fromPromise(eT);
function nT(e, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const n = t.fs || $r, r = "throws" in t ? t.throws : !0;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    let i = n.readFileSync(e, t);
    return i = Jv(i), JSON.parse(i, t.reviver);
  } catch (i) {
    if (r)
      throw i.message = `${e}: ${i.message}`, i;
    return null;
  }
}
<<<<<<< HEAD
async function _writeFile(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$3(obj, options);
  await universalify.fromCallback(fs2.writeFile)(file2, str2, options);
}
const writeFile = universalify.fromPromise(_writeFile);
function writeFileSync(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$3(obj, options);
  return fs2.writeFileSync(file2, str2, options);
}
const jsonfile$1 = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync
};
var jsonfile_1 = jsonfile$1;
const jsonFile$1 = jsonfile_1;
var jsonfile = {
=======
async function rT(e, t, n = {}) {
  const r = n.fs || $r, i = Kv(t, n);
  await ns.fromCallback(r.writeFile)(e, i, n);
}
const iT = ns.fromPromise(rT);
function aT(e, t, n = {}) {
  const r = n.fs || $r, i = Kv(t, n);
  return r.writeFileSync(e, i, n);
}
const oT = {
  readFile: tT,
  readFileSync: nT,
  writeFile: iT,
  writeFileSync: aT
};
var sT = oT;
const Aa = sT;
var cT = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  // jsonfile exports
  readJson: Aa.readFile,
  readJsonSync: Aa.readFileSync,
  writeJson: Aa.writeFile,
  writeJsonSync: Aa.writeFileSync
};
<<<<<<< HEAD
const u$2 = universalify$1.fromCallback;
const fs$2 = gracefulFs;
const path$b = require$$1$4;
const mkdir = mkdirs$2;
const pathExists$1 = pathExists_1.pathExists;
function outputFile$1(file2, data, encoding, callback) {
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = "utf8";
  }
  const dir = path$b.dirname(file2);
  pathExists$1(dir, (err, itDoes) => {
    if (err) return callback(err);
    if (itDoes) return fs$2.writeFile(file2, data, encoding, callback);
    mkdir.mkdirs(dir, (err2) => {
      if (err2) return callback(err2);
      fs$2.writeFile(file2, data, encoding, callback);
    });
  });
}
function outputFileSync$1(file2, ...args) {
  const dir = path$b.dirname(file2);
  if (fs$2.existsSync(dir)) {
    return fs$2.writeFileSync(file2, ...args);
  }
  mkdir.mkdirsSync(dir);
  fs$2.writeFileSync(file2, ...args);
}
var outputFile_1 = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};
const { stringify: stringify$2 } = utils;
const { outputFile } = outputFile_1;
async function outputJson(file2, data, options = {}) {
  const str2 = stringify$2(data, options);
  await outputFile(file2, str2, options);
}
var outputJson_1 = outputJson;
const { stringify: stringify$1 } = utils;
const { outputFileSync } = outputFile_1;
function outputJsonSync(file2, data, options) {
  const str2 = stringify$1(data, options);
  outputFileSync(file2, str2, options);
}
var outputJsonSync_1 = outputJsonSync;
const u$1 = universalify$1.fromPromise;
const jsonFile = jsonfile;
jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
var json$1 = jsonFile;
const fs$1 = gracefulFs;
const path$a = require$$1$4;
const copy2 = copy$1.copy;
const remove = remove_1.remove;
const mkdirp = mkdirs$2.mkdirp;
const pathExists = pathExists_1.pathExists;
const stat$1 = stat$4;
function move$1(src2, dest, opts, cb) {
  if (typeof opts === "function") {
    cb = opts;
    opts = {};
  }
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;
  stat$1.checkPaths(src2, dest, "move", opts, (err, stats) => {
    if (err) return cb(err);
    const { srcStat, isChangingCase = false } = stats;
    stat$1.checkParentPaths(src2, srcStat, dest, "move", (err2) => {
      if (err2) return cb(err2);
      if (isParentRoot$1(dest)) return doRename$1(src2, dest, overwrite, isChangingCase, cb);
      mkdirp(path$a.dirname(dest), (err3) => {
        if (err3) return cb(err3);
        return doRename$1(src2, dest, overwrite, isChangingCase, cb);
      });
    });
  });
}
function isParentRoot$1(dest) {
  const parent = path$a.dirname(dest);
  const parsedPath = path$a.parse(parent);
  return parsedPath.root === parent;
}
function doRename$1(src2, dest, overwrite, isChangingCase, cb) {
  if (isChangingCase) return rename$1(src2, dest, overwrite, cb);
  if (overwrite) {
    return remove(dest, (err) => {
      if (err) return cb(err);
      return rename$1(src2, dest, overwrite, cb);
    });
  }
  pathExists(dest, (err, destExists) => {
    if (err) return cb(err);
    if (destExists) return cb(new Error("dest already exists."));
    return rename$1(src2, dest, overwrite, cb);
  });
}
function rename$1(src2, dest, overwrite, cb) {
  fs$1.rename(src2, dest, (err) => {
    if (!err) return cb();
    if (err.code !== "EXDEV") return cb(err);
    return moveAcrossDevice$1(src2, dest, overwrite, cb);
  });
}
function moveAcrossDevice$1(src2, dest, overwrite, cb) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copy2(src2, dest, opts, (err) => {
    if (err) return cb(err);
    return remove(src2, cb);
  });
}
var move_1 = move$1;
const fs = gracefulFs;
const path$9 = require$$1$4;
const copySync = copy$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat = stat$4;
function moveSync(src2, dest, opts) {
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;
  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src2, dest, "move", opts);
  stat.checkParentPathsSync(src2, srcStat, dest, "move");
  if (!isParentRoot(dest)) mkdirpSync(path$9.dirname(dest));
  return doRename(src2, dest, overwrite, isChangingCase);
}
function isParentRoot(dest) {
  const parent = path$9.dirname(dest);
  const parsedPath = path$9.parse(parent);
  return parsedPath.root === parent;
}
function doRename(src2, dest, overwrite, isChangingCase) {
  if (isChangingCase) return rename(src2, dest, overwrite);
  if (overwrite) {
    removeSync(dest);
    return rename(src2, dest, overwrite);
  }
  if (fs.existsSync(dest)) throw new Error("dest already exists.");
  return rename(src2, dest, overwrite);
=======
const lT = We.fromCallback, oi = Ve, Zv = oe, Qv = Ct, uT = Xn.pathExists;
function pT(e, t, n, r) {
  typeof n == "function" && (r = n, n = "utf8");
  const i = Zv.dirname(e);
  uT(i, (a, o) => {
    if (a) return r(a);
    if (o) return oi.writeFile(e, t, n, r);
    Qv.mkdirs(i, (c) => {
      if (c) return r(c);
      oi.writeFile(e, t, n, r);
    });
  });
}
function fT(e, ...t) {
  const n = Zv.dirname(e);
  if (oi.existsSync(n))
    return oi.writeFileSync(e, ...t);
  Qv.mkdirsSync(n), oi.writeFileSync(e, ...t);
}
var Cu = {
  outputFile: lT(pT),
  outputFileSync: fT
};
const { stringify: dT } = Ru, { outputFile: hT } = Cu;
async function mT(e, t, n = {}) {
  const r = dT(t, n);
  await hT(e, r, n);
}
var vT = mT;
const { stringify: gT } = Ru, { outputFileSync: xT } = Cu;
function yT(e, t, n) {
  const r = gT(t, n);
  xT(e, r, n);
}
var bT = yT;
const wT = We.fromPromise, Ge = cT;
Ge.outputJson = wT(vT);
Ge.outputJsonSync = bT;
Ge.outputJSON = Ge.outputJson;
Ge.outputJSONSync = Ge.outputJsonSync;
Ge.writeJSON = Ge.writeJson;
Ge.writeJSONSync = Ge.writeJsonSync;
Ge.readJSON = Ge.readJson;
Ge.readJSONSync = Ge.readJsonSync;
var ET = Ge;
const _T = Ve, yl = oe, ST = Tu.copy, eg = ts.remove, TT = Ct.mkdirp, AT = Xn.pathExists, bd = kr;
function RT(e, t, n, r) {
  typeof n == "function" && (r = n, n = {}), n = n || {};
  const i = n.overwrite || n.clobber || !1;
  bd.checkPaths(e, t, "move", n, (a, o) => {
    if (a) return r(a);
    const { srcStat: c, isChangingCase: s = !1 } = o;
    bd.checkParentPaths(e, c, t, "move", (u) => {
      if (u) return r(u);
      if (CT(t)) return wd(e, t, i, s, r);
      TT(yl.dirname(t), (l) => l ? r(l) : wd(e, t, i, s, r));
    });
  });
}
function CT(e) {
  const t = yl.dirname(e);
  return yl.parse(t).root === t;
}
function wd(e, t, n, r, i) {
  if (r) return Oc(e, t, n, i);
  if (n)
    return eg(t, (a) => a ? i(a) : Oc(e, t, n, i));
  AT(t, (a, o) => a ? i(a) : o ? i(new Error("dest already exists.")) : Oc(e, t, n, i));
}
function Oc(e, t, n, r) {
  _T.rename(e, t, (i) => i ? i.code !== "EXDEV" ? r(i) : OT(e, t, n, r) : r());
}
function OT(e, t, n, r) {
  ST(e, t, {
    overwrite: n,
    errorOnExist: !0
  }, (a) => a ? r(a) : eg(e, r));
}
var $T = RT;
const tg = Ve, bl = oe, IT = Tu.copySync, ng = ts.removeSync, PT = Ct.mkdirpSync, Ed = kr;
function DT(e, t, n) {
  n = n || {};
  const r = n.overwrite || n.clobber || !1, { srcStat: i, isChangingCase: a = !1 } = Ed.checkPathsSync(e, t, "move", n);
  return Ed.checkParentPathsSync(e, i, t, "move"), FT(t) || PT(bl.dirname(t)), NT(e, t, r, a);
}
function FT(e) {
  const t = bl.dirname(e);
  return bl.parse(t).root === t;
}
function NT(e, t, n, r) {
  if (r) return $c(e, t, n);
  if (n)
    return ng(t), $c(e, t, n);
  if (tg.existsSync(t)) throw new Error("dest already exists.");
  return $c(e, t, n);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function $c(e, t, n) {
  try {
<<<<<<< HEAD
    fs.renameSync(src2, dest);
  } catch (err) {
    if (err.code !== "EXDEV") throw err;
    return moveAcrossDevice(src2, dest, overwrite);
  }
}
function moveAcrossDevice(src2, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true
  };
  copySync(src2, dest, opts);
  return removeSync(src2);
}
var moveSync_1 = moveSync;
const u = universalify$1.fromCallback;
var move = {
  move: u(move_1),
  moveSync: moveSync_1
};
var lib = {
=======
    tg.renameSync(e, t);
  } catch (r) {
    if (r.code !== "EXDEV") throw r;
    return kT(e, t, n);
  }
}
function kT(e, t, n) {
  return IT(e, t, {
    overwrite: n,
    errorOnExist: !0
  }), ng(e);
}
var LT = DT;
const UT = We.fromCallback;
var BT = {
  move: UT($T),
  moveSync: LT
}, vn = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  // Export promiseified graceful-fs:
  ...Yn,
  // Export extra methods:
<<<<<<< HEAD
  ...copy$1,
  ...empty,
  ...ensure,
  ...json$1,
  ...mkdirs$2,
  ...move,
  ...outputFile_1,
  ...pathExists_1,
  ...remove_1
};
var BaseUpdater$1 = {};
var AppUpdater$1 = {};
var out = {};
var CancellationToken$1 = {};
Object.defineProperty(CancellationToken$1, "__esModule", { value: true });
CancellationToken$1.CancellationError = CancellationToken$1.CancellationToken = void 0;
const events_1$1 = require$$0$6;
class CancellationToken extends events_1$1.EventEmitter {
=======
  ...Tu,
  ..._4,
  ...J4,
  ...ET,
  ...Ct,
  ...BT,
  ...Cu,
  ...Xn,
  ...ts
}, Bt = {}, cn = {}, De = {}, ln = {};
Object.defineProperty(ln, "__esModule", { value: !0 });
ln.CancellationError = ln.CancellationToken = void 0;
const jT = Hn;
class MT extends jT.EventEmitter {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  get cancelled() {
    return this._cancelled || this._parent != null && this._parent.cancelled;
  }
  set parent(t) {
    this.removeParentCancelHandler(), this._parent = t, this.parentCancelHandler = () => this.cancel(), this._parent.onCancel(this.parentCancelHandler);
  }
  // babel cannot compile ... correctly for super calls
  constructor(t) {
    super(), this.parentCancelHandler = null, this._parent = null, this._cancelled = !1, t != null && (this.parent = t);
  }
  cancel() {
    this._cancelled = !0, this.emit("cancel");
  }
  onCancel(t) {
    this.cancelled ? t() : this.once("cancel", t);
  }
  createPromise(t) {
    if (this.cancelled)
      return Promise.reject(new wl());
    const n = () => {
      if (r != null)
        try {
          this.removeListener("cancel", r), r = null;
        } catch {
        }
    };
    let r = null;
    return new Promise((i, a) => {
      let o = null;
      if (r = () => {
        try {
          o != null && (o(), o = null);
        } finally {
          a(new wl());
        }
      }, this.cancelled) {
        r();
        return;
      }
      this.onCancel(r), t(i, a, (c) => {
        o = c;
      });
    }).then((i) => (n(), i)).catch((i) => {
      throw n(), i;
    });
  }
  removeParentCancelHandler() {
    const t = this._parent;
    t != null && this.parentCancelHandler != null && (t.removeListener("cancel", this.parentCancelHandler), this.parentCancelHandler = null);
  }
  dispose() {
    try {
      this.removeParentCancelHandler();
    } finally {
      this.removeAllListeners(), this._parent = null;
    }
  }
}
<<<<<<< HEAD
CancellationToken$1.CancellationToken = CancellationToken;
class CancellationError extends Error {
=======
ln.CancellationToken = MT;
class wl extends Error {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  constructor() {
    super("cancelled");
  }
}
<<<<<<< HEAD
CancellationToken$1.CancellationError = CancellationError;
var error = {};
Object.defineProperty(error, "__esModule", { value: true });
error.newError = newError;
function newError(message, code) {
  const error2 = new Error(message);
  error2.code = code;
  return error2;
}
var httpExecutor = {};
var ProgressCallbackTransform$1 = {};
Object.defineProperty(ProgressCallbackTransform$1, "__esModule", { value: true });
ProgressCallbackTransform$1.ProgressCallbackTransform = void 0;
const stream_1$3 = require$$1$2;
class ProgressCallbackTransform extends stream_1$3.Transform {
  constructor(total, cancellationToken, onProgress) {
    super();
    this.total = total;
    this.cancellationToken = cancellationToken;
    this.onProgress = onProgress;
    this.start = Date.now();
    this.transferred = 0;
    this.delta = 0;
    this.nextUpdate = this.start + 1e3;
=======
ln.CancellationError = wl;
var Lr = {};
Object.defineProperty(Lr, "__esModule", { value: !0 });
Lr.newError = qT;
function qT(e, t) {
  const n = new Error(e);
  return n.code = t, n;
}
var He = {}, Wi = {};
Object.defineProperty(Wi, "__esModule", { value: !0 });
Wi.ProgressCallbackTransform = void 0;
const zT = ie;
class HT extends zT.Transform {
  constructor(t, n, r) {
    super(), this.total = t, this.cancellationToken = n, this.onProgress = r, this.start = Date.now(), this.transferred = 0, this.delta = 0, this.nextUpdate = this.start + 1e3;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  _transform(t, n, r) {
    if (this.cancellationToken.cancelled) {
      r(new Error("cancelled"), null);
      return;
    }
    this.transferred += t.length, this.delta += t.length;
    const i = Date.now();
    i >= this.nextUpdate && this.transferred !== this.total && (this.nextUpdate = i + 1e3, this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.transferred,
      percent: this.transferred / this.total * 100,
      bytesPerSecond: Math.round(this.transferred / ((i - this.start) / 1e3))
    }), this.delta = 0), r(null, t);
  }
  _flush(t) {
    if (this.cancellationToken.cancelled) {
      t(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.total,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    }), this.delta = 0, t(null);
  }
}
<<<<<<< HEAD
ProgressCallbackTransform$1.ProgressCallbackTransform = ProgressCallbackTransform;
Object.defineProperty(httpExecutor, "__esModule", { value: true });
httpExecutor.DigestTransform = httpExecutor.HttpExecutor = httpExecutor.HttpError = void 0;
httpExecutor.createHttpError = createHttpError;
httpExecutor.parseJson = parseJson;
httpExecutor.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;
httpExecutor.configureRequestUrl = configureRequestUrl;
httpExecutor.safeGetHeader = safeGetHeader;
httpExecutor.configureRequestOptions = configureRequestOptions;
httpExecutor.safeStringifyJson = safeStringifyJson;
const crypto_1$4 = require$$0$4;
const debug_1$1 = srcExports;
const fs_1$5 = fs$w;
const stream_1$2 = require$$1$2;
const url_1$5 = require$$0$3;
const CancellationToken_1$1 = CancellationToken$1;
const error_1$2 = error;
const ProgressCallbackTransform_1 = ProgressCallbackTransform$1;
const debug$2 = (0, debug_1$1.default)("electron-builder");
function createHttpError(response, description = null) {
  return new HttpError(response.statusCode || -1, `${response.statusCode} ${response.statusMessage}` + (description == null ? "" : "\n" + JSON.stringify(description, null, "  ")) + "\nHeaders: " + safeStringifyJson(response.headers), description);
}
const HTTP_STATUS_CODES = /* @__PURE__ */ new Map([
=======
Wi.ProgressCallbackTransform = HT;
Object.defineProperty(He, "__esModule", { value: !0 });
He.DigestTransform = He.HttpExecutor = He.HttpError = void 0;
He.createHttpError = El;
He.parseJson = ZT;
He.configureRequestOptionsFromUrl = ig;
He.configureRequestUrl = $u;
He.safeGetHeader = Tr;
He.configureRequestOptions = po;
He.safeStringifyJson = fo;
const GT = Dr, WT = Nm, VT = ae, YT = ie, rg = At, XT = ln, _d = Lr, KT = Wi, Xr = (0, WT.default)("electron-builder");
function El(e, t = null) {
  return new Ou(e.statusCode || -1, `${e.statusCode} ${e.statusMessage}` + (t == null ? "" : `
` + JSON.stringify(t, null, "  ")) + `
Headers: ` + fo(e.headers), t);
}
const JT = /* @__PURE__ */ new Map([
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  [429, "Too many requests"],
  [400, "Bad request"],
  [403, "Forbidden"],
  [404, "Not found"],
  [405, "Method not allowed"],
  [406, "Not acceptable"],
  [408, "Request timeout"],
  [413, "Request entity too large"],
  [500, "Internal server error"],
  [502, "Bad gateway"],
  [503, "Service unavailable"],
  [504, "Gateway timeout"],
  [505, "HTTP version not supported"]
]);
<<<<<<< HEAD
class HttpError extends Error {
  constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description = null) {
    super(message);
    this.statusCode = statusCode;
    this.description = description;
    this.name = "HttpError";
    this.code = `HTTP_ERROR_${statusCode}`;
=======
class Ou extends Error {
  constructor(t, n = `HTTP error: ${JT.get(t) || t}`, r = null) {
    super(n), this.statusCode = t, this.description = r, this.name = "HttpError", this.code = `HTTP_ERROR_${t}`;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  isServerError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
}
<<<<<<< HEAD
httpExecutor.HttpError = HttpError;
function parseJson(result) {
  return result.then((it) => it == null || it.length === 0 ? null : JSON.parse(it));
=======
He.HttpError = Ou;
function ZT(e) {
  return e.then((t) => t == null || t.length === 0 ? null : JSON.parse(t));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
class uo {
  constructor() {
    this.maxRedirects = 10;
  }
<<<<<<< HEAD
  request(options, cancellationToken = new CancellationToken_1$1.CancellationToken(), data) {
    configureRequestOptions(options);
    const json2 = data == null ? void 0 : JSON.stringify(data);
    const encodedData = json2 ? Buffer.from(json2) : void 0;
    if (encodedData != null) {
      debug$2(json2);
      const { headers: headers2, ...opts } = options;
      options = {
=======
  request(t, n = new XT.CancellationToken(), r) {
    po(t);
    const i = r == null ? void 0 : JSON.stringify(r), a = i ? Buffer.from(i) : void 0;
    if (a != null) {
      Xr(i);
      const { headers: o, ...c } = t;
      t = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        method: "post",
        headers: {
          "Content-Type": "application/json",
          "Content-Length": a.length,
          ...o
        },
        ...c
      };
    }
    return this.doApiRequest(t, n, (o) => o.end(a));
  }
  doApiRequest(t, n, r, i = 0) {
    return Xr.enabled && Xr(`Request: ${fo(t)}`), n.createPromise((a, o, c) => {
      const s = this.createRequest(t, (u) => {
        try {
          this.handleResponse(u, t, n, a, o, i, r);
        } catch (l) {
          o(l);
        }
      });
      this.addErrorAndTimeoutHandlers(s, o, t.timeout), this.addRedirectHandlers(s, t, o, i, (u) => {
        this.doApiRequest(u, n, r, i).then(a).catch(o);
      }), r(s, o), c(() => s.abort());
    });
  }
  // noinspection JSUnusedLocalSymbols
  // eslint-disable-next-line
  addRedirectHandlers(t, n, r, i, a) {
  }
  addErrorAndTimeoutHandlers(t, n, r = 60 * 1e3) {
    this.addTimeOutHandler(t, n, r), t.on("error", n), t.on("aborted", () => {
      n(new Error("Request has been aborted by the server"));
    });
  }
  handleResponse(t, n, r, i, a, o, c) {
    var s;
    if (Xr.enabled && Xr(`Response: ${t.statusCode} ${t.statusMessage}, request options: ${fo(n)}`), t.statusCode === 404) {
      a(El(t, `method: ${n.method || "GET"} url: ${n.protocol || "https:"}//${n.hostname}${n.port ? `:${n.port}` : ""}${n.path}

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`));
      return;
    } else if (t.statusCode === 204) {
      i();
      return;
    }
    const u = (s = t.statusCode) !== null && s !== void 0 ? s : 0, l = u >= 300 && u < 400, p = Tr(t, "location");
    if (l && p != null) {
      if (o > this.maxRedirects) {
        a(this.createMaxRedirectError());
        return;
      }
      this.doApiRequest(uo.prepareRedirectUrlOptions(p, n), r, c, o).then(i).catch(a);
      return;
    }
    t.setEncoding("utf8");
    let d = "";
    t.on("error", a), t.on("data", (m) => d += m), t.on("end", () => {
      try {
        if (t.statusCode != null && t.statusCode >= 400) {
          const m = Tr(t, "content-type"), g = m != null && (Array.isArray(m) ? m.find((v) => v.includes("json")) != null : m.includes("json"));
          a(El(t, `method: ${n.method || "GET"} url: ${n.protocol || "https:"}//${n.hostname}${n.port ? `:${n.port}` : ""}${n.path}

          Data:
          ${g ? JSON.stringify(JSON.parse(d)) : d}
          `));
        } else
          i(d.length === 0 ? null : d);
      } catch (m) {
        a(m);
      }
    });
  }
  async downloadToBuffer(t, n) {
    return await n.cancellationToken.createPromise((r, i, a) => {
      const o = [], c = {
        headers: n.headers || void 0,
        // because PrivateGitHubProvider requires HttpExecutor.prepareRedirectUrlOptions logic, so, we need to redirect manually
        redirect: "manual"
      };
      $u(t, c), po(c), this.doDownload(c, {
        destination: null,
        options: n,
        onCancel: a,
        callback: (s) => {
          s == null ? r(Buffer.concat(o)) : i(s);
        },
        responseHandler: (s, u) => {
          let l = 0;
          s.on("data", (p) => {
            if (l += p.length, l > 524288e3) {
              u(new Error("Maximum allowed size is 500 MB"));
              return;
            }
            o.push(p);
          }), s.on("end", () => {
            u(null);
          });
        }
      }, 0);
    });
  }
  doDownload(t, n, r) {
    const i = this.createRequest(t, (a) => {
      if (a.statusCode >= 400) {
        n.callback(new Error(`Cannot download "${t.protocol || "https:"}//${t.hostname}${t.path}", status ${a.statusCode}: ${a.statusMessage}`));
        return;
      }
      a.on("error", n.callback);
      const o = Tr(a, "location");
      if (o != null) {
        r < this.maxRedirects ? this.doDownload(uo.prepareRedirectUrlOptions(o, t), n, r++) : n.callback(this.createMaxRedirectError());
        return;
      }
<<<<<<< HEAD
      if (options.responseHandler == null) {
        configurePipes(options, response);
      } else {
        options.responseHandler(response, options.callback);
      }
=======
      n.responseHandler == null ? eA(n, a) : n.responseHandler(a, n.callback);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    });
    this.addErrorAndTimeoutHandlers(i, n.callback, t.timeout), this.addRedirectHandlers(i, t, n.callback, r, (a) => {
      this.doDownload(a, n, r++);
    }), i.end();
  }
  createMaxRedirectError() {
    return new Error(`Too many redirects (> ${this.maxRedirects})`);
  }
  addTimeOutHandler(t, n, r) {
    t.on("socket", (i) => {
      i.setTimeout(r, () => {
        t.abort(), n(new Error("Request timed out"));
      });
    });
  }
  static prepareRedirectUrlOptions(t, n) {
    const r = ig(t, { ...n }), i = r.headers;
    if (i != null && i.authorization) {
      const a = new rg.URL(t);
      (a.hostname.endsWith(".amazonaws.com") || a.searchParams.has("X-Amz-Credential")) && delete i.authorization;
    }
    return r;
  }
  static retryOnServerError(t, n = 3) {
    for (let r = 0; ; r++)
      try {
        return t();
      } catch (i) {
        if (r < n && (i instanceof Ou && i.isServerError() || i.code === "EPIPE"))
          continue;
        throw i;
      }
  }
}
He.HttpExecutor = uo;
function ig(e, t) {
  const n = po(t);
  return $u(new rg.URL(e), n), n;
}
function $u(e, t) {
  t.protocol = e.protocol, t.hostname = e.hostname, e.port ? t.port = e.port : t.port && delete t.port, t.path = e.pathname + e.search;
}
<<<<<<< HEAD
class DigestTransform extends stream_1$2.Transform {
=======
class _l extends YT.Transform {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  // noinspection JSUnusedGlobalSymbols
  get actual() {
    return this._actual;
  }
<<<<<<< HEAD
  constructor(expected, algorithm = "sha512", encoding = "base64") {
    super();
    this.expected = expected;
    this.algorithm = algorithm;
    this.encoding = encoding;
    this._actual = null;
    this.isValidateOnEnd = true;
    this.digester = (0, crypto_1$4.createHash)(algorithm);
=======
  constructor(t, n = "sha512", r = "base64") {
    super(), this.expected = t, this.algorithm = n, this.encoding = r, this._actual = null, this.isValidateOnEnd = !0, this.digester = (0, GT.createHash)(n);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  // noinspection JSUnusedGlobalSymbols
  _transform(t, n, r) {
    this.digester.update(t), r(null, t);
  }
  // noinspection JSUnusedGlobalSymbols
  _flush(t) {
    if (this._actual = this.digester.digest(this.encoding), this.isValidateOnEnd)
      try {
        this.validate();
      } catch (n) {
        t(n);
        return;
      }
    t(null);
  }
  validate() {
    if (this._actual == null)
      throw (0, _d.newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
    if (this._actual !== this.expected)
      throw (0, _d.newError)(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
    return null;
  }
}
<<<<<<< HEAD
httpExecutor.DigestTransform = DigestTransform;
function checkSha2(sha2Header, sha2, callback) {
  if (sha2Header != null && sha2 != null && sha2Header !== sha2) {
    callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));
    return false;
  }
  return true;
}
function safeGetHeader(response, headerKey) {
  const value = response.headers[headerKey];
  if (value == null) {
    return null;
  } else if (Array.isArray(value)) {
    return value.length === 0 ? null : value[value.length - 1];
  } else {
    return value;
  }
}
function configurePipes(options, response) {
  if (!checkSha2(safeGetHeader(response, "X-Checksum-Sha2"), options.options.sha2, options.callback)) {
    return;
  }
  const streams2 = [];
  if (options.options.onProgress != null) {
    const contentLength = safeGetHeader(response, "content-length");
    if (contentLength != null) {
      streams2.push(new ProgressCallbackTransform_1.ProgressCallbackTransform(parseInt(contentLength, 10), options.options.cancellationToken, options.options.onProgress));
    }
  }
  const sha512 = options.options.sha512;
  if (sha512 != null) {
    streams2.push(new DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
  } else if (options.options.sha2 != null) {
    streams2.push(new DigestTransform(options.options.sha2, "sha256", "hex"));
  }
  const fileOut = (0, fs_1$5.createWriteStream)(options.destination);
  streams2.push(fileOut);
  let lastStream = response;
  for (const stream2 of streams2) {
    stream2.on("error", (error2) => {
      fileOut.close();
      if (!options.options.cancellationToken.cancelled) {
        options.callback(error2);
      }
    });
    lastStream = lastStream.pipe(stream2);
  }
  fileOut.on("finish", () => {
    fileOut.close(options.callback);
=======
He.DigestTransform = _l;
function QT(e, t, n) {
  return e != null && t != null && e !== t ? (n(new Error(`checksum mismatch: expected ${t} but got ${e} (X-Checksum-Sha2 header)`)), !1) : !0;
}
function Tr(e, t) {
  const n = e.headers[t];
  return n == null ? null : Array.isArray(n) ? n.length === 0 ? null : n[n.length - 1] : n;
}
function eA(e, t) {
  if (!QT(Tr(t, "X-Checksum-Sha2"), e.options.sha2, e.callback))
    return;
  const n = [];
  if (e.options.onProgress != null) {
    const o = Tr(t, "content-length");
    o != null && n.push(new KT.ProgressCallbackTransform(parseInt(o, 10), e.options.cancellationToken, e.options.onProgress));
  }
  const r = e.options.sha512;
  r != null ? n.push(new _l(r, "sha512", r.length === 128 && !r.includes("+") && !r.includes("Z") && !r.includes("=") ? "hex" : "base64")) : e.options.sha2 != null && n.push(new _l(e.options.sha2, "sha256", "hex"));
  const i = (0, VT.createWriteStream)(e.destination);
  n.push(i);
  let a = t;
  for (const o of n)
    o.on("error", (c) => {
      i.close(), e.options.cancellationToken.cancelled || e.callback(c);
    }), a = a.pipe(o);
  i.on("finish", () => {
    i.close(e.callback);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  });
}
function po(e, t, n) {
  n != null && (e.method = n), e.headers = { ...e.headers };
  const r = e.headers;
  return t != null && (r.authorization = t.startsWith("Basic") || t.startsWith("Bearer") ? t : `token ${t}`), r["User-Agent"] == null && (r["User-Agent"] = "electron-builder"), (n == null || n === "GET" || r["Cache-Control"] == null) && (r["Cache-Control"] = "no-cache"), e.protocol == null && process.versions.electron != null && (e.protocol = "https:"), e;
}
function fo(e, t) {
  return JSON.stringify(e, (n, r) => n.endsWith("Authorization") || n.endsWith("authorization") || n.endsWith("Password") || n.endsWith("PASSWORD") || n.endsWith("Token") || n.includes("password") || n.includes("token") || t != null && t.has(n) ? "<stripped sensitive data>" : r, 2);
}
<<<<<<< HEAD
var MemoLazy$1 = {};
Object.defineProperty(MemoLazy$1, "__esModule", { value: true });
MemoLazy$1.MemoLazy = void 0;
class MemoLazy {
  constructor(selector, creator) {
    this.selector = selector;
    this.creator = creator;
    this.selected = void 0;
    this._value = void 0;
=======
var rs = {};
Object.defineProperty(rs, "__esModule", { value: !0 });
rs.MemoLazy = void 0;
class tA {
  constructor(t, n) {
    this.selector = t, this.creator = n, this.selected = void 0, this._value = void 0;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  get hasValue() {
    return this._value !== void 0;
  }
  get value() {
    const t = this.selector();
    if (this._value !== void 0 && ag(this.selected, t))
      return this._value;
    this.selected = t;
    const n = this.creator(t);
    return this.value = n, n;
  }
  set value(t) {
    this._value = t;
  }
}
<<<<<<< HEAD
MemoLazy$1.MemoLazy = MemoLazy;
function equals(firstValue, secondValue) {
  const isFirstObject = typeof firstValue === "object" && firstValue !== null;
  const isSecondObject = typeof secondValue === "object" && secondValue !== null;
  if (isFirstObject && isSecondObject) {
    const keys1 = Object.keys(firstValue);
    const keys2 = Object.keys(secondValue);
    return keys1.length === keys2.length && keys1.every((key2) => equals(firstValue[key2], secondValue[key2]));
=======
rs.MemoLazy = tA;
function ag(e, t) {
  if (typeof e == "object" && e !== null && (typeof t == "object" && t !== null)) {
    const i = Object.keys(e), a = Object.keys(t);
    return i.length === a.length && i.every((o) => ag(e[o], t[o]));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return e === t;
}
<<<<<<< HEAD
var publishOptions = {};
Object.defineProperty(publishOptions, "__esModule", { value: true });
publishOptions.githubUrl = githubUrl;
publishOptions.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;
function githubUrl(options, defaultHost = "github.com") {
  return `${options.protocol || "https"}://${options.host || defaultHost}`;
}
function getS3LikeProviderBaseUrl(configuration) {
  const provider = configuration.provider;
  if (provider === "s3") {
    return s3Url(configuration);
  }
  if (provider === "spaces") {
    return spacesUrl(configuration);
  }
  throw new Error(`Not supported provider: ${provider}`);
}
function s3Url(options) {
  let url2;
  if (options.accelerate == true) {
    url2 = `https://${options.bucket}.s3-accelerate.amazonaws.com`;
  } else if (options.endpoint != null) {
    url2 = `${options.endpoint}/${options.bucket}`;
  } else if (options.bucket.includes(".")) {
    if (options.region == null) {
      throw new Error(`Bucket name "${options.bucket}" includes a dot, but S3 region is missing`);
    }
    if (options.region === "us-east-1") {
      url2 = `https://s3.amazonaws.com/${options.bucket}`;
    } else {
      url2 = `https://s3-${options.region}.amazonaws.com/${options.bucket}`;
    }
  } else if (options.region === "cn-north-1") {
    url2 = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;
  } else {
    url2 = `https://${options.bucket}.s3.amazonaws.com`;
  }
  return appendPath(url2, options.path);
=======
var is = {};
Object.defineProperty(is, "__esModule", { value: !0 });
is.githubUrl = nA;
is.getS3LikeProviderBaseUrl = rA;
function nA(e, t = "github.com") {
  return `${e.protocol || "https"}://${e.host || t}`;
}
function rA(e) {
  const t = e.provider;
  if (t === "s3")
    return iA(e);
  if (t === "spaces")
    return aA(e);
  throw new Error(`Not supported provider: ${t}`);
}
function iA(e) {
  let t;
  if (e.accelerate == !0)
    t = `https://${e.bucket}.s3-accelerate.amazonaws.com`;
  else if (e.endpoint != null)
    t = `${e.endpoint}/${e.bucket}`;
  else if (e.bucket.includes(".")) {
    if (e.region == null)
      throw new Error(`Bucket name "${e.bucket}" includes a dot, but S3 region is missing`);
    e.region === "us-east-1" ? t = `https://s3.amazonaws.com/${e.bucket}` : t = `https://s3-${e.region}.amazonaws.com/${e.bucket}`;
  } else e.region === "cn-north-1" ? t = `https://${e.bucket}.s3.${e.region}.amazonaws.com.cn` : t = `https://${e.bucket}.s3.amazonaws.com`;
  return og(t, e.path);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function og(e, t) {
  return t != null && t.length > 0 && (t.startsWith("/") || (e += "/"), e += t), e;
}
<<<<<<< HEAD
function spacesUrl(options) {
  if (options.name == null) {
    throw new Error(`name is missing`);
  }
  if (options.region == null) {
    throw new Error(`region is missing`);
  }
  return appendPath(`https://${options.name}.${options.region}.digitaloceanspaces.com`, options.path);
}
var retry$1 = {};
Object.defineProperty(retry$1, "__esModule", { value: true });
retry$1.retry = retry;
const CancellationToken_1 = CancellationToken$1;
async function retry(task, retryCount, interval, backoff = 0, attempt = 0, shouldRetry) {
  var _a;
  const cancellationToken = new CancellationToken_1.CancellationToken();
=======
function aA(e) {
  if (e.name == null)
    throw new Error("name is missing");
  if (e.region == null)
    throw new Error("region is missing");
  return og(`https://${e.name}.${e.region}.digitaloceanspaces.com`, e.path);
}
var Iu = {};
Object.defineProperty(Iu, "__esModule", { value: !0 });
Iu.retry = sg;
const oA = ln;
async function sg(e, t, n, r = 0, i = 0, a) {
  var o;
  const c = new oA.CancellationToken();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    return await e();
  } catch (s) {
    if ((!((o = a == null ? void 0 : a(s)) !== null && o !== void 0) || o) && t > 0 && !c.cancelled)
      return await new Promise((u) => setTimeout(u, n + r * i)), await sg(e, t - 1, n, r, i + 1, a);
    throw s;
  }
}
<<<<<<< HEAD
var rfc2253Parser = {};
Object.defineProperty(rfc2253Parser, "__esModule", { value: true });
rfc2253Parser.parseDn = parseDn;
function parseDn(seq2) {
  let quoted = false;
  let key2 = null;
  let token = "";
  let nextNonSpace = 0;
  seq2 = seq2.trim();
  const result = /* @__PURE__ */ new Map();
  for (let i = 0; i <= seq2.length; i++) {
    if (i === seq2.length) {
      if (key2 !== null) {
        result.set(key2, token);
      }
=======
var Pu = {};
Object.defineProperty(Pu, "__esModule", { value: !0 });
Pu.parseDn = sA;
function sA(e) {
  let t = !1, n = null, r = "", i = 0;
  e = e.trim();
  const a = /* @__PURE__ */ new Map();
  for (let o = 0; o <= e.length; o++) {
    if (o === e.length) {
      n !== null && a.set(n, r);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      break;
    }
    const c = e[o];
    if (t) {
      if (c === '"') {
        t = !1;
        continue;
      }
    } else {
      if (c === '"') {
        t = !0;
        continue;
      }
      if (c === "\\") {
        o++;
        const s = parseInt(e.slice(o, o + 2), 16);
        Number.isNaN(s) ? r += e[o] : (o++, r += String.fromCharCode(s));
        continue;
      }
<<<<<<< HEAD
      if (key2 === null && ch === "=") {
        key2 = token;
        token = "";
        continue;
      }
      if (ch === "," || ch === ";" || ch === "+") {
        if (key2 !== null) {
          result.set(key2, token);
        }
        key2 = null;
        token = "";
=======
      if (n === null && c === "=") {
        n = r, r = "";
        continue;
      }
      if (c === "," || c === ";" || c === "+") {
        n !== null && a.set(n, r), n = null, r = "";
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        continue;
      }
    }
    if (c === " " && !t) {
      if (r.length === 0)
        continue;
      if (o > i) {
        let s = o;
        for (; e[s] === " "; )
          s++;
        i = s;
      }
<<<<<<< HEAD
      if (i > nextNonSpace) {
        let j = i;
        while (seq2[j] === " ") {
          j++;
        }
        nextNonSpace = j;
      }
      if (nextNonSpace >= seq2.length || seq2[nextNonSpace] === "," || seq2[nextNonSpace] === ";" || key2 === null && seq2[nextNonSpace] === "=" || key2 !== null && seq2[nextNonSpace] === "+") {
        i = nextNonSpace - 1;
=======
      if (i >= e.length || e[i] === "," || e[i] === ";" || n === null && e[i] === "=" || n !== null && e[i] === "+") {
        o = i - 1;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        continue;
      }
    }
    r += c;
  }
  return a;
}
<<<<<<< HEAD
var uuid = {};
Object.defineProperty(uuid, "__esModule", { value: true });
uuid.nil = uuid.UUID = void 0;
const crypto_1$3 = require$$0$4;
const error_1$1 = error;
const invalidName = "options.name must be either a string or a Buffer";
const randomHost = (0, crypto_1$3.randomBytes)(16);
randomHost[0] = randomHost[0] | 1;
const hex2byte = {};
const byte2hex = [];
for (let i = 0; i < 256; i++) {
  const hex = (i + 256).toString(16).substr(1);
  hex2byte[hex] = i;
  byte2hex[i] = hex;
=======
var Ir = {};
Object.defineProperty(Ir, "__esModule", { value: !0 });
Ir.nil = Ir.UUID = void 0;
const cg = Dr, lg = Lr, cA = "options.name must be either a string or a Buffer", Sd = (0, cg.randomBytes)(16);
Sd[0] = Sd[0] | 1;
const Ja = {}, ce = [];
for (let e = 0; e < 256; e++) {
  const t = (e + 256).toString(16).substr(1);
  Ja[t] = e, ce[e] = t;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
class qn {
  constructor(t) {
    this.ascii = null, this.binary = null;
    const n = qn.check(t);
    if (!n)
      throw new Error("not a UUID");
    this.version = n.version, n.format === "ascii" ? this.ascii = t : this.binary = t;
  }
<<<<<<< HEAD
  static v5(name, namespace) {
    return uuidNamed(name, "sha1", 80, namespace);
  }
  toString() {
    if (this.ascii == null) {
      this.ascii = stringify(this.binary);
    }
    return this.ascii;
=======
  static v5(t, n) {
    return lA(t, "sha1", 80, n);
  }
  toString() {
    return this.ascii == null && (this.ascii = uA(this.binary)), this.ascii;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  inspect() {
    return `UUID v${this.version} ${this.toString()}`;
  }
  static check(t, n = 0) {
    if (typeof t == "string")
      return t = t.toLowerCase(), /^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(t) ? t === "00000000-0000-0000-0000-000000000000" ? { version: void 0, variant: "nil", format: "ascii" } : {
        version: (Ja[t[14] + t[15]] & 240) >> 4,
        variant: Td((Ja[t[19] + t[20]] & 224) >> 5),
        format: "ascii"
      } : !1;
    if (Buffer.isBuffer(t)) {
      if (t.length < n + 16)
        return !1;
      let r = 0;
      for (; r < 16 && t[n + r] === 0; r++)
        ;
      return r === 16 ? { version: void 0, variant: "nil", format: "binary" } : {
        version: (t[n + 6] & 240) >> 4,
        variant: Td((t[n + 8] & 224) >> 5),
        format: "binary"
      };
    }
    throw (0, lg.newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
  }
  // read stringified uuid into a Buffer
<<<<<<< HEAD
  static parse(input) {
    const buffer2 = Buffer.allocUnsafe(16);
    let j = 0;
    for (let i = 0; i < 16; i++) {
      buffer2[i] = hex2byte[input[j++] + input[j++]];
      if (i === 3 || i === 5 || i === 7 || i === 9) {
        j += 1;
      }
    }
    return buffer2;
=======
  static parse(t) {
    const n = Buffer.allocUnsafe(16);
    let r = 0;
    for (let i = 0; i < 16; i++)
      n[i] = Ja[t[r++] + t[r++]], (i === 3 || i === 5 || i === 7 || i === 9) && (r += 1);
    return n;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
}
Ir.UUID = qn;
qn.OID = qn.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
function Td(e) {
  switch (e) {
    case 0:
    case 1:
    case 3:
      return "ncs";
    case 4:
    case 5:
      return "rfc4122";
    case 6:
      return "microsoft";
    default:
      return "future";
  }
}
<<<<<<< HEAD
var UuidEncoding;
(function(UuidEncoding2) {
  UuidEncoding2[UuidEncoding2["ASCII"] = 0] = "ASCII";
  UuidEncoding2[UuidEncoding2["BINARY"] = 1] = "BINARY";
  UuidEncoding2[UuidEncoding2["OBJECT"] = 2] = "OBJECT";
})(UuidEncoding || (UuidEncoding = {}));
function uuidNamed(name, hashMethod, version, namespace, encoding = UuidEncoding.ASCII) {
  const hash = (0, crypto_1$3.createHash)(hashMethod);
  const nameIsNotAString = typeof name !== "string";
  if (nameIsNotAString && !Buffer.isBuffer(name)) {
    throw (0, error_1$1.newError)(invalidName, "ERR_INVALID_UUID_NAME");
  }
  hash.update(namespace);
  hash.update(name);
  const buffer2 = hash.digest();
  let result;
  switch (encoding) {
    case UuidEncoding.BINARY:
      buffer2[6] = buffer2[6] & 15 | version;
      buffer2[8] = buffer2[8] & 63 | 128;
      result = buffer2;
      break;
    case UuidEncoding.OBJECT:
      buffer2[6] = buffer2[6] & 15 | version;
      buffer2[8] = buffer2[8] & 63 | 128;
      result = new UUID(buffer2);
      break;
    default:
      result = byte2hex[buffer2[0]] + byte2hex[buffer2[1]] + byte2hex[buffer2[2]] + byte2hex[buffer2[3]] + "-" + byte2hex[buffer2[4]] + byte2hex[buffer2[5]] + "-" + byte2hex[buffer2[6] & 15 | version] + byte2hex[buffer2[7]] + "-" + byte2hex[buffer2[8] & 63 | 128] + byte2hex[buffer2[9]] + "-" + byte2hex[buffer2[10]] + byte2hex[buffer2[11]] + byte2hex[buffer2[12]] + byte2hex[buffer2[13]] + byte2hex[buffer2[14]] + byte2hex[buffer2[15]];
=======
var si;
(function(e) {
  e[e.ASCII = 0] = "ASCII", e[e.BINARY = 1] = "BINARY", e[e.OBJECT = 2] = "OBJECT";
})(si || (si = {}));
function lA(e, t, n, r, i = si.ASCII) {
  const a = (0, cg.createHash)(t);
  if (typeof e != "string" && !Buffer.isBuffer(e))
    throw (0, lg.newError)(cA, "ERR_INVALID_UUID_NAME");
  a.update(r), a.update(e);
  const c = a.digest();
  let s;
  switch (i) {
    case si.BINARY:
      c[6] = c[6] & 15 | n, c[8] = c[8] & 63 | 128, s = c;
      break;
    case si.OBJECT:
      c[6] = c[6] & 15 | n, c[8] = c[8] & 63 | 128, s = new qn(c);
      break;
    default:
      s = ce[c[0]] + ce[c[1]] + ce[c[2]] + ce[c[3]] + "-" + ce[c[4]] + ce[c[5]] + "-" + ce[c[6] & 15 | n] + ce[c[7]] + "-" + ce[c[8] & 63 | 128] + ce[c[9]] + "-" + ce[c[10]] + ce[c[11]] + ce[c[12]] + ce[c[13]] + ce[c[14]] + ce[c[15]];
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      break;
  }
  return s;
}
<<<<<<< HEAD
function stringify(buffer2) {
  return byte2hex[buffer2[0]] + byte2hex[buffer2[1]] + byte2hex[buffer2[2]] + byte2hex[buffer2[3]] + "-" + byte2hex[buffer2[4]] + byte2hex[buffer2[5]] + "-" + byte2hex[buffer2[6]] + byte2hex[buffer2[7]] + "-" + byte2hex[buffer2[8]] + byte2hex[buffer2[9]] + "-" + byte2hex[buffer2[10]] + byte2hex[buffer2[11]] + byte2hex[buffer2[12]] + byte2hex[buffer2[13]] + byte2hex[buffer2[14]] + byte2hex[buffer2[15]];
=======
function uA(e) {
  return ce[e[0]] + ce[e[1]] + ce[e[2]] + ce[e[3]] + "-" + ce[e[4]] + ce[e[5]] + "-" + ce[e[6]] + ce[e[7]] + "-" + ce[e[8]] + ce[e[9]] + "-" + ce[e[10]] + ce[e[11]] + ce[e[12]] + ce[e[13]] + ce[e[14]] + ce[e[15]];
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
Ir.nil = new qn("00000000-0000-0000-0000-000000000000");
var Vi = {}, ug = {};
(function(e) {
  (function(t) {
    t.parser = function(h, f) {
      return new r(h, f);
    }, t.SAXParser = r, t.SAXStream = l, t.createStream = u, t.MAX_BUFFER_LENGTH = 64 * 1024;
    var n = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    t.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function r(h, f) {
      if (!(this instanceof r))
        return new r(h, f);
      var C = this;
      a(C), C.q = C.c = "", C.bufferCheckPosition = t.MAX_BUFFER_LENGTH, C.opt = f || {}, C.opt.lowercase = C.opt.lowercase || C.opt.lowercasetags, C.looseCase = C.opt.lowercase ? "toLowerCase" : "toUpperCase", C.tags = [], C.closed = C.closedRoot = C.sawRoot = !1, C.tag = C.error = null, C.strict = !!h, C.noscript = !!(h || C.opt.noscript), C.state = T.BEGIN, C.strictEntities = C.opt.strictEntities, C.ENTITIES = C.strictEntities ? Object.create(t.XML_ENTITIES) : Object.create(t.ENTITIES), C.attribList = [], C.opt.xmlns && (C.ns = Object.create(v)), C.opt.unquotedAttributeValues === void 0 && (C.opt.unquotedAttributeValues = !h), C.trackPosition = C.opt.position !== !1, C.trackPosition && (C.position = C.line = C.column = 0), j(C, "onready");
    }
    Object.create || (Object.create = function(h) {
      function f() {
      }
      f.prototype = h;
      var C = new f();
      return C;
    }), Object.keys || (Object.keys = function(h) {
      var f = [];
      for (var C in h) h.hasOwnProperty(C) && f.push(C);
      return f;
    });
    function i(h) {
      for (var f = Math.max(t.MAX_BUFFER_LENGTH, 10), C = 0, S = 0, G = n.length; S < G; S++) {
        var z = h[n[S]].length;
        if (z > f)
          switch (n[S]) {
            case "textNode":
              ne(h);
              break;
            case "cdata":
              J(h, "oncdata", h.cdata), h.cdata = "";
              break;
            case "script":
              J(h, "onscript", h.script), h.script = "";
              break;
            default:
              $(h, "Max buffer length exceeded: " + n[S]);
          }
        C = Math.max(C, z);
      }
      var X = t.MAX_BUFFER_LENGTH - C;
      h.bufferCheckPosition = X + h.position;
    }
    function a(h) {
      for (var f = 0, C = n.length; f < C; f++)
        h[n[f]] = "";
    }
    function o(h) {
      ne(h), h.cdata !== "" && (J(h, "oncdata", h.cdata), h.cdata = ""), h.script !== "" && (J(h, "onscript", h.script), h.script = "");
    }
    r.prototype = {
      end: function() {
        D(this);
      },
      write: le,
      resume: function() {
        return this.error = null, this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        o(this);
      }
    };
    var c;
    try {
      c = require("stream").Stream;
    } catch {
      c = function() {
      };
    }
    c || (c = function() {
    });
    var s = t.EVENTS.filter(function(h) {
      return h !== "error" && h !== "end";
    });
    function u(h, f) {
      return new l(h, f);
    }
    function l(h, f) {
      if (!(this instanceof l))
        return new l(h, f);
      c.apply(this), this._parser = new r(h, f), this.writable = !0, this.readable = !0;
      var C = this;
      this._parser.onend = function() {
        C.emit("end");
      }, this._parser.onerror = function(S) {
        C.emit("error", S), C._parser.error = null;
      }, this._decoder = null, s.forEach(function(S) {
        Object.defineProperty(C, "on" + S, {
          get: function() {
            return C._parser["on" + S];
          },
          set: function(G) {
            if (!G)
              return C.removeAllListeners(S), C._parser["on" + S] = G, G;
            C.on(S, G);
          },
          enumerable: !0,
          configurable: !1
        });
      });
    }
    l.prototype = Object.create(c.prototype, {
      constructor: {
        value: l
      }
<<<<<<< HEAD
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require$$1$7.StringDecoder;
          this._decoder = new SD("utf8");
=======
    }), l.prototype.write = function(h) {
      if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(h)) {
        if (!this._decoder) {
          var f = kl.StringDecoder;
          this._decoder = new f("utf8");
        }
        h = this._decoder.write(h);
      }
      return this._parser.write(h.toString()), this.emit("data", h), !0;
    }, l.prototype.end = function(h) {
      return h && h.length && this.write(h), this._parser.end(), !0;
    }, l.prototype.on = function(h, f) {
      var C = this;
      return !C._parser["on" + h] && s.indexOf(h) !== -1 && (C._parser["on" + h] = function() {
        var S = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
        S.splice(0, 0, h), C.emit.apply(C, S);
      }), c.prototype.on.call(C, h, f);
    };
    var p = "[CDATA[", d = "DOCTYPE", m = "http://www.w3.org/XML/1998/namespace", g = "http://www.w3.org/2000/xmlns/", v = { xml: m, xmlns: g }, y = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, x = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, w = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, A = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function O(h) {
      return h === " " || h === `
` || h === "\r" || h === "	";
    }
    function k(h) {
      return h === '"' || h === "'";
    }
    function q(h) {
      return h === ">" || O(h);
    }
    function W(h, f) {
      return h.test(f);
    }
    function te(h, f) {
      return !W(h, f);
    }
    var T = 0;
    t.STATE = {
      BEGIN: T++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: T++,
      // leading whitespace
      TEXT: T++,
      // general stuff
      TEXT_ENTITY: T++,
      // &amp and such.
      OPEN_WAKA: T++,
      // <
      SGML_DECL: T++,
      // <!BLARG
      SGML_DECL_QUOTED: T++,
      // <!BLARG foo "bar
      DOCTYPE: T++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: T++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: T++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: T++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: T++,
      // <!-
      COMMENT: T++,
      // <!--
      COMMENT_ENDING: T++,
      // <!-- blah -
      COMMENT_ENDED: T++,
      // <!-- blah --
      CDATA: T++,
      // <![CDATA[ something
      CDATA_ENDING: T++,
      // ]
      CDATA_ENDING_2: T++,
      // ]]
      PROC_INST: T++,
      // <?hi
      PROC_INST_BODY: T++,
      // <?hi there
      PROC_INST_ENDING: T++,
      // <?hi "there" ?
      OPEN_TAG: T++,
      // <strong
      OPEN_TAG_SLASH: T++,
      // <strong /
      ATTRIB: T++,
      // <a
      ATTRIB_NAME: T++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: T++,
      // <a foo _
      ATTRIB_VALUE: T++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: T++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: T++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: T++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: T++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: T++,
      // <foo bar=&quot
      CLOSE_TAG: T++,
      // </a
      CLOSE_TAG_SAW_WHITE: T++,
      // </a   >
      SCRIPT: T++,
      // <script> ...
      SCRIPT_ENDING: T++
      // <script> ... <
    }, t.XML_ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'"
    }, t.ENTITIES = {
      amp: "&",
      gt: ">",
      lt: "<",
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830
    }, Object.keys(t.ENTITIES).forEach(function(h) {
      var f = t.ENTITIES[h], C = typeof f == "number" ? String.fromCharCode(f) : f;
      t.ENTITIES[h] = C;
    });
    for (var H in t.STATE)
      t.STATE[t.STATE[H]] = H;
    T = t.STATE;
    function j(h, f, C) {
      h[f] && h[f](C);
    }
    function J(h, f, C) {
      h.textNode && ne(h), j(h, f, C);
    }
    function ne(h) {
      h.textNode = F(h.opt, h.textNode), h.textNode && j(h, "ontext", h.textNode), h.textNode = "";
    }
    function F(h, f) {
      return h.trim && (f = f.trim()), h.normalize && (f = f.replace(/\s+/g, " ")), f;
    }
    function $(h, f) {
      return ne(h), h.trackPosition && (f += `
Line: ` + h.line + `
Column: ` + h.column + `
Char: ` + h.c), f = new Error(f), h.error = f, j(h, "onerror", f), h;
    }
    function D(h) {
      return h.sawRoot && !h.closedRoot && b(h, "Unclosed root tag"), h.state !== T.BEGIN && h.state !== T.BEGIN_WHITESPACE && h.state !== T.TEXT && $(h, "Unexpected end"), ne(h), h.c = "", h.closed = !0, j(h, "onend"), r.call(h, h.strict, h.opt), h;
    }
    function b(h, f) {
      if (typeof h != "object" || !(h instanceof r))
        throw new Error("bad call to strictFail");
      h.strict && $(h, f);
    }
    function E(h) {
      h.strict || (h.tagName = h.tagName[h.looseCase]());
      var f = h.tags[h.tags.length - 1] || h, C = h.tag = { name: h.tagName, attributes: {} };
      h.opt.xmlns && (C.ns = f.ns), h.attribList.length = 0, J(h, "onopentagstart", C);
    }
    function R(h, f) {
      var C = h.indexOf(":"), S = C < 0 ? ["", h] : h.split(":"), G = S[0], z = S[1];
      return f && h === "xmlns" && (G = "xmlns", z = ""), { prefix: G, local: z };
    }
    function N(h) {
      if (h.strict || (h.attribName = h.attribName[h.looseCase]()), h.attribList.indexOf(h.attribName) !== -1 || h.tag.attributes.hasOwnProperty(h.attribName)) {
        h.attribName = h.attribValue = "";
        return;
      }
      if (h.opt.xmlns) {
        var f = R(h.attribName, !0), C = f.prefix, S = f.local;
        if (C === "xmlns")
          if (S === "xml" && h.attribValue !== m)
            b(
              h,
              "xml: prefix must be bound to " + m + `
Actual: ` + h.attribValue
            );
          else if (S === "xmlns" && h.attribValue !== g)
            b(
              h,
              "xmlns: prefix must be bound to " + g + `
Actual: ` + h.attribValue
            );
          else {
            var G = h.tag, z = h.tags[h.tags.length - 1] || h;
            G.ns === z.ns && (G.ns = Object.create(z.ns)), G.ns[S] = h.attribValue;
          }
        h.attribList.push([h.attribName, h.attribValue]);
      } else
        h.tag.attributes[h.attribName] = h.attribValue, J(h, "onattribute", {
          name: h.attribName,
          value: h.attribValue
        });
      h.attribName = h.attribValue = "";
    }
    function L(h, f) {
      if (h.opt.xmlns) {
        var C = h.tag, S = R(h.tagName);
        C.prefix = S.prefix, C.local = S.local, C.uri = C.ns[S.prefix] || "", C.prefix && !C.uri && (b(h, "Unbound namespace prefix: " + JSON.stringify(h.tagName)), C.uri = S.prefix);
        var G = h.tags[h.tags.length - 1] || h;
        C.ns && G.ns !== C.ns && Object.keys(C.ns).forEach(function(Mt) {
          J(h, "onopennamespace", {
            prefix: Mt,
            uri: C.ns[Mt]
          });
        });
        for (var z = 0, X = h.attribList.length; z < X; z++) {
          var ve = h.attribList[z], Ae = ve[0], ct = ve[1], Se = R(Ae, !0), qe = Se.prefix, Jn = Se.local, jt = qe === "" ? "" : C.ns[qe] || "", Ot = {
            name: Ae,
            value: ct,
            prefix: qe,
            local: Jn,
            uri: jt
          };
          qe && qe !== "xmlns" && !jt && (b(h, "Unbound namespace prefix: " + JSON.stringify(qe)), Ot.uri = qe), h.tag.attributes[Ae] = Ot, J(h, "onattribute", Ot);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        }
        h.attribList.length = 0;
      }
      h.tag.isSelfClosing = !!f, h.sawRoot = !0, h.tags.push(h.tag), J(h, "onopentag", h.tag), f || (!h.noscript && h.tagName.toLowerCase() === "script" ? h.state = T.SCRIPT : h.state = T.TEXT, h.tag = null, h.tagName = ""), h.attribName = h.attribValue = "", h.attribList.length = 0;
    }
<<<<<<< HEAD
    function isQuote(c) {
      return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
      return c === ">" || isWhitespace2(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax2.STATE = {
      BEGIN: S++,
      // leading byte order mark or whitespace
      BEGIN_WHITESPACE: S++,
      // leading whitespace
      TEXT: S++,
      // general stuff
      TEXT_ENTITY: S++,
      // &amp and such.
      OPEN_WAKA: S++,
      // <
      SGML_DECL: S++,
      // <!BLARG
      SGML_DECL_QUOTED: S++,
      // <!BLARG foo "bar
      DOCTYPE: S++,
      // <!DOCTYPE
      DOCTYPE_QUOTED: S++,
      // <!DOCTYPE "//blah
      DOCTYPE_DTD: S++,
      // <!DOCTYPE "//blah" [ ...
      DOCTYPE_DTD_QUOTED: S++,
      // <!DOCTYPE "//blah" [ "foo
      COMMENT_STARTING: S++,
      // <!-
      COMMENT: S++,
      // <!--
      COMMENT_ENDING: S++,
      // <!-- blah -
      COMMENT_ENDED: S++,
      // <!-- blah --
      CDATA: S++,
      // <![CDATA[ something
      CDATA_ENDING: S++,
      // ]
      CDATA_ENDING_2: S++,
      // ]]
      PROC_INST: S++,
      // <?hi
      PROC_INST_BODY: S++,
      // <?hi there
      PROC_INST_ENDING: S++,
      // <?hi "there" ?
      OPEN_TAG: S++,
      // <strong
      OPEN_TAG_SLASH: S++,
      // <strong /
      ATTRIB: S++,
      // <a
      ATTRIB_NAME: S++,
      // <a foo
      ATTRIB_NAME_SAW_WHITE: S++,
      // <a foo _
      ATTRIB_VALUE: S++,
      // <a foo=
      ATTRIB_VALUE_QUOTED: S++,
      // <a foo="bar
      ATTRIB_VALUE_CLOSED: S++,
      // <a foo="bar"
      ATTRIB_VALUE_UNQUOTED: S++,
      // <a foo=bar
      ATTRIB_VALUE_ENTITY_Q: S++,
      // <foo bar="&quot;"
      ATTRIB_VALUE_ENTITY_U: S++,
      // <foo bar=&quot
      CLOSE_TAG: S++,
      // </a
      CLOSE_TAG_SAW_WHITE: S++,
      // </a   >
      SCRIPT: S++,
      // <script> ...
      SCRIPT_ENDING: S++
      // <script> ... <
    };
    sax2.XML_ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'"
    };
    sax2.ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'",
      "AElig": 198,
      "Aacute": 193,
      "Acirc": 194,
      "Agrave": 192,
      "Aring": 197,
      "Atilde": 195,
      "Auml": 196,
      "Ccedil": 199,
      "ETH": 208,
      "Eacute": 201,
      "Ecirc": 202,
      "Egrave": 200,
      "Euml": 203,
      "Iacute": 205,
      "Icirc": 206,
      "Igrave": 204,
      "Iuml": 207,
      "Ntilde": 209,
      "Oacute": 211,
      "Ocirc": 212,
      "Ograve": 210,
      "Oslash": 216,
      "Otilde": 213,
      "Ouml": 214,
      "THORN": 222,
      "Uacute": 218,
      "Ucirc": 219,
      "Ugrave": 217,
      "Uuml": 220,
      "Yacute": 221,
      "aacute": 225,
      "acirc": 226,
      "aelig": 230,
      "agrave": 224,
      "aring": 229,
      "atilde": 227,
      "auml": 228,
      "ccedil": 231,
      "eacute": 233,
      "ecirc": 234,
      "egrave": 232,
      "eth": 240,
      "euml": 235,
      "iacute": 237,
      "icirc": 238,
      "igrave": 236,
      "iuml": 239,
      "ntilde": 241,
      "oacute": 243,
      "ocirc": 244,
      "ograve": 242,
      "oslash": 248,
      "otilde": 245,
      "ouml": 246,
      "szlig": 223,
      "thorn": 254,
      "uacute": 250,
      "ucirc": 251,
      "ugrave": 249,
      "uuml": 252,
      "yacute": 253,
      "yuml": 255,
      "copy": 169,
      "reg": 174,
      "nbsp": 160,
      "iexcl": 161,
      "cent": 162,
      "pound": 163,
      "curren": 164,
      "yen": 165,
      "brvbar": 166,
      "sect": 167,
      "uml": 168,
      "ordf": 170,
      "laquo": 171,
      "not": 172,
      "shy": 173,
      "macr": 175,
      "deg": 176,
      "plusmn": 177,
      "sup1": 185,
      "sup2": 178,
      "sup3": 179,
      "acute": 180,
      "micro": 181,
      "para": 182,
      "middot": 183,
      "cedil": 184,
      "ordm": 186,
      "raquo": 187,
      "frac14": 188,
      "frac12": 189,
      "frac34": 190,
      "iquest": 191,
      "times": 215,
      "divide": 247,
      "OElig": 338,
      "oelig": 339,
      "Scaron": 352,
      "scaron": 353,
      "Yuml": 376,
      "fnof": 402,
      "circ": 710,
      "tilde": 732,
      "Alpha": 913,
      "Beta": 914,
      "Gamma": 915,
      "Delta": 916,
      "Epsilon": 917,
      "Zeta": 918,
      "Eta": 919,
      "Theta": 920,
      "Iota": 921,
      "Kappa": 922,
      "Lambda": 923,
      "Mu": 924,
      "Nu": 925,
      "Xi": 926,
      "Omicron": 927,
      "Pi": 928,
      "Rho": 929,
      "Sigma": 931,
      "Tau": 932,
      "Upsilon": 933,
      "Phi": 934,
      "Chi": 935,
      "Psi": 936,
      "Omega": 937,
      "alpha": 945,
      "beta": 946,
      "gamma": 947,
      "delta": 948,
      "epsilon": 949,
      "zeta": 950,
      "eta": 951,
      "theta": 952,
      "iota": 953,
      "kappa": 954,
      "lambda": 955,
      "mu": 956,
      "nu": 957,
      "xi": 958,
      "omicron": 959,
      "pi": 960,
      "rho": 961,
      "sigmaf": 962,
      "sigma": 963,
      "tau": 964,
      "upsilon": 965,
      "phi": 966,
      "chi": 967,
      "psi": 968,
      "omega": 969,
      "thetasym": 977,
      "upsih": 978,
      "piv": 982,
      "ensp": 8194,
      "emsp": 8195,
      "thinsp": 8201,
      "zwnj": 8204,
      "zwj": 8205,
      "lrm": 8206,
      "rlm": 8207,
      "ndash": 8211,
      "mdash": 8212,
      "lsquo": 8216,
      "rsquo": 8217,
      "sbquo": 8218,
      "ldquo": 8220,
      "rdquo": 8221,
      "bdquo": 8222,
      "dagger": 8224,
      "Dagger": 8225,
      "bull": 8226,
      "hellip": 8230,
      "permil": 8240,
      "prime": 8242,
      "Prime": 8243,
      "lsaquo": 8249,
      "rsaquo": 8250,
      "oline": 8254,
      "frasl": 8260,
      "euro": 8364,
      "image": 8465,
      "weierp": 8472,
      "real": 8476,
      "trade": 8482,
      "alefsym": 8501,
      "larr": 8592,
      "uarr": 8593,
      "rarr": 8594,
      "darr": 8595,
      "harr": 8596,
      "crarr": 8629,
      "lArr": 8656,
      "uArr": 8657,
      "rArr": 8658,
      "dArr": 8659,
      "hArr": 8660,
      "forall": 8704,
      "part": 8706,
      "exist": 8707,
      "empty": 8709,
      "nabla": 8711,
      "isin": 8712,
      "notin": 8713,
      "ni": 8715,
      "prod": 8719,
      "sum": 8721,
      "minus": 8722,
      "lowast": 8727,
      "radic": 8730,
      "prop": 8733,
      "infin": 8734,
      "ang": 8736,
      "and": 8743,
      "or": 8744,
      "cap": 8745,
      "cup": 8746,
      "int": 8747,
      "there4": 8756,
      "sim": 8764,
      "cong": 8773,
      "asymp": 8776,
      "ne": 8800,
      "equiv": 8801,
      "le": 8804,
      "ge": 8805,
      "sub": 8834,
      "sup": 8835,
      "nsub": 8836,
      "sube": 8838,
      "supe": 8839,
      "oplus": 8853,
      "otimes": 8855,
      "perp": 8869,
      "sdot": 8901,
      "lceil": 8968,
      "rceil": 8969,
      "lfloor": 8970,
      "rfloor": 8971,
      "lang": 9001,
      "rang": 9002,
      "loz": 9674,
      "spades": 9824,
      "clubs": 9827,
      "hearts": 9829,
      "diams": 9830
    };
    Object.keys(sax2.ENTITIES).forEach(function(key2) {
      var e = sax2.ENTITIES[key2];
      var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax2.ENTITIES[key2] = s2;
    });
    for (var s in sax2.STATE) {
      sax2.STATE[sax2.STATE[s]] = s;
    }
    S = sax2.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode) closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode) emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim) text = text.trim();
      if (opt.normalize) text = text.replace(/\s+/g, " ");
      return text;
    }
    function error2(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, "onerror", er);
      return parser;
    }
    function end2(parser) {
      if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error2(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error2(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
      var i = name.indexOf(":");
      var qualName = i < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
=======
    function B(h) {
      if (!h.tagName) {
        b(h, "Weird empty close tag."), h.textNode += "</>", h.state = T.TEXT;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        return;
      }
      if (h.script) {
        if (h.tagName !== "script") {
          h.script += "</" + h.tagName + ">", h.tagName = "", h.state = T.SCRIPT;
          return;
        }
        J(h, "onscript", h.script), h.script = "";
      }
      var f = h.tags.length, C = h.tagName;
      h.strict || (C = C[h.looseCase]());
      for (var S = C; f--; ) {
        var G = h.tags[f];
        if (G.name !== S)
          b(h, "Unexpected close tag");
        else
          break;
      }
      if (f < 0) {
        b(h, "Unmatched closing tag: " + h.tagName), h.textNode += "</" + h.tagName + ">", h.state = T.TEXT;
        return;
      }
<<<<<<< HEAD
      parser.tagName = tagName;
      var s2 = parser.tags.length;
      while (s2-- > t2) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i in tag.ns) {
          x[i] = tag.ns[i];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
=======
      h.tagName = C;
      for (var z = h.tags.length; z-- > f; ) {
        var X = h.tag = h.tags.pop();
        h.tagName = h.tag.name, J(h, "onclosetag", h.tagName);
        var ve = {};
        for (var Ae in X.ns)
          ve[Ae] = X.ns[Ae];
        var ct = h.tags[h.tags.length - 1] || h;
        h.opt.xmlns && X.ns !== ct.ns && Object.keys(X.ns).forEach(function(Se) {
          var qe = X.ns[Se];
          J(h, "onclosenamespace", { prefix: Se, uri: qe });
        });
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
      f === 0 && (h.closedRoot = !0), h.tagName = h.attribValue = h.attribName = "", h.attribList.length = 0, h.state = T.TEXT;
    }
    function K(h) {
      var f = h.entity, C = f.toLowerCase(), S, G = "";
      return h.ENTITIES[f] ? h.ENTITIES[f] : h.ENTITIES[C] ? h.ENTITIES[C] : (f = C, f.charAt(0) === "#" && (f.charAt(1) === "x" ? (f = f.slice(2), S = parseInt(f, 16), G = S.toString(16)) : (f = f.slice(1), S = parseInt(f, 10), G = S.toString(10))), f = f.replace(/^0+/, ""), isNaN(S) || G.toLowerCase() !== f ? (b(h, "Invalid character entity"), "&" + h.entity + ";") : String.fromCodePoint(S));
    }
    function Z(h, f) {
      f === "<" ? (h.state = T.OPEN_WAKA, h.startTagPosition = h.position) : O(f) || (b(h, "Non-whitespace before first tag."), h.textNode = f, h.state = T.TEXT);
    }
    function M(h, f) {
      var C = "";
      return f < h.length && (C = h.charAt(f)), C;
    }
    function le(h) {
      var f = this;
      if (this.error)
        throw this.error;
      if (f.closed)
        return $(
          f,
          "Cannot write after close. Assign an onready handler."
        );
      if (h === null)
        return D(f);
      typeof h == "object" && (h = h.toString());
      for (var C = 0, S = ""; S = M(h, C++), f.c = S, !!S; )
        switch (f.trackPosition && (f.position++, S === `
` ? (f.line++, f.column = 0) : f.column++), f.state) {
          case T.BEGIN:
            if (f.state = T.BEGIN_WHITESPACE, S === "\uFEFF")
              continue;
            Z(f, S);
            continue;
          case T.BEGIN_WHITESPACE:
            Z(f, S);
            continue;
          case T.TEXT:
            if (f.sawRoot && !f.closedRoot) {
              for (var G = C - 1; S && S !== "<" && S !== "&"; )
                S = M(h, C++), S && f.trackPosition && (f.position++, S === `
` ? (f.line++, f.column = 0) : f.column++);
              f.textNode += h.substring(G, C - 1);
            }
            S === "<" && !(f.sawRoot && f.closedRoot && !f.strict) ? (f.state = T.OPEN_WAKA, f.startTagPosition = f.position) : (!O(S) && (!f.sawRoot || f.closedRoot) && b(f, "Text data outside of root node."), S === "&" ? f.state = T.TEXT_ENTITY : f.textNode += S);
            continue;
          case T.SCRIPT:
            S === "<" ? f.state = T.SCRIPT_ENDING : f.script += S;
            continue;
          case T.SCRIPT_ENDING:
            S === "/" ? f.state = T.CLOSE_TAG : (f.script += "<" + S, f.state = T.SCRIPT);
            continue;
          case T.OPEN_WAKA:
            if (S === "!")
              f.state = T.SGML_DECL, f.sgmlDecl = "";
            else if (!O(S)) if (W(y, S))
              f.state = T.OPEN_TAG, f.tagName = S;
            else if (S === "/")
              f.state = T.CLOSE_TAG, f.tagName = "";
            else if (S === "?")
              f.state = T.PROC_INST, f.procInstName = f.procInstBody = "";
            else {
              if (b(f, "Unencoded <"), f.startTagPosition + 1 < f.position) {
                var z = f.position - f.startTagPosition;
                S = new Array(z).join(" ") + S;
              }
              f.textNode += "<" + S, f.state = T.TEXT;
            }
            continue;
          case T.SGML_DECL:
            if (f.sgmlDecl + S === "--") {
              f.state = T.COMMENT, f.comment = "", f.sgmlDecl = "";
              continue;
            }
            f.doctype && f.doctype !== !0 && f.sgmlDecl ? (f.state = T.DOCTYPE_DTD, f.doctype += "<!" + f.sgmlDecl + S, f.sgmlDecl = "") : (f.sgmlDecl + S).toUpperCase() === p ? (J(f, "onopencdata"), f.state = T.CDATA, f.sgmlDecl = "", f.cdata = "") : (f.sgmlDecl + S).toUpperCase() === d ? (f.state = T.DOCTYPE, (f.doctype || f.sawRoot) && b(
              f,
              "Inappropriately located doctype declaration"
            ), f.doctype = "", f.sgmlDecl = "") : S === ">" ? (J(f, "onsgmldeclaration", f.sgmlDecl), f.sgmlDecl = "", f.state = T.TEXT) : (k(S) && (f.state = T.SGML_DECL_QUOTED), f.sgmlDecl += S);
            continue;
          case T.SGML_DECL_QUOTED:
            S === f.q && (f.state = T.SGML_DECL, f.q = ""), f.sgmlDecl += S;
            continue;
          case T.DOCTYPE:
            S === ">" ? (f.state = T.TEXT, J(f, "ondoctype", f.doctype), f.doctype = !0) : (f.doctype += S, S === "[" ? f.state = T.DOCTYPE_DTD : k(S) && (f.state = T.DOCTYPE_QUOTED, f.q = S));
            continue;
          case T.DOCTYPE_QUOTED:
            f.doctype += S, S === f.q && (f.q = "", f.state = T.DOCTYPE);
            continue;
          case T.DOCTYPE_DTD:
            S === "]" ? (f.doctype += S, f.state = T.DOCTYPE) : S === "<" ? (f.state = T.OPEN_WAKA, f.startTagPosition = f.position) : k(S) ? (f.doctype += S, f.state = T.DOCTYPE_DTD_QUOTED, f.q = S) : f.doctype += S;
            continue;
          case T.DOCTYPE_DTD_QUOTED:
            f.doctype += S, S === f.q && (f.state = T.DOCTYPE_DTD, f.q = "");
            continue;
          case T.COMMENT:
            S === "-" ? f.state = T.COMMENT_ENDING : f.comment += S;
            continue;
          case T.COMMENT_ENDING:
            S === "-" ? (f.state = T.COMMENT_ENDED, f.comment = F(f.opt, f.comment), f.comment && J(f, "oncomment", f.comment), f.comment = "") : (f.comment += "-" + S, f.state = T.COMMENT);
            continue;
          case T.COMMENT_ENDED:
            S !== ">" ? (b(f, "Malformed comment"), f.comment += "--" + S, f.state = T.COMMENT) : f.doctype && f.doctype !== !0 ? f.state = T.DOCTYPE_DTD : f.state = T.TEXT;
            continue;
          case T.CDATA:
            S === "]" ? f.state = T.CDATA_ENDING : f.cdata += S;
            continue;
          case T.CDATA_ENDING:
            S === "]" ? f.state = T.CDATA_ENDING_2 : (f.cdata += "]" + S, f.state = T.CDATA);
            continue;
          case T.CDATA_ENDING_2:
            S === ">" ? (f.cdata && J(f, "oncdata", f.cdata), J(f, "onclosecdata"), f.cdata = "", f.state = T.TEXT) : S === "]" ? f.cdata += "]" : (f.cdata += "]]" + S, f.state = T.CDATA);
            continue;
          case T.PROC_INST:
            S === "?" ? f.state = T.PROC_INST_ENDING : O(S) ? f.state = T.PROC_INST_BODY : f.procInstName += S;
            continue;
          case T.PROC_INST_BODY:
            if (!f.procInstBody && O(S))
              continue;
            S === "?" ? f.state = T.PROC_INST_ENDING : f.procInstBody += S;
            continue;
          case T.PROC_INST_ENDING:
            S === ">" ? (J(f, "onprocessinginstruction", {
              name: f.procInstName,
              body: f.procInstBody
            }), f.procInstName = f.procInstBody = "", f.state = T.TEXT) : (f.procInstBody += "?" + S, f.state = T.PROC_INST_BODY);
            continue;
          case T.OPEN_TAG:
            W(x, S) ? f.tagName += S : (E(f), S === ">" ? L(f) : S === "/" ? f.state = T.OPEN_TAG_SLASH : (O(S) || b(f, "Invalid character in tag name"), f.state = T.ATTRIB));
            continue;
          case T.OPEN_TAG_SLASH:
            S === ">" ? (L(f, !0), B(f)) : (b(f, "Forward-slash in opening tag not followed by >"), f.state = T.ATTRIB);
            continue;
          case T.ATTRIB:
            if (O(S))
              continue;
            S === ">" ? L(f) : S === "/" ? f.state = T.OPEN_TAG_SLASH : W(y, S) ? (f.attribName = S, f.attribValue = "", f.state = T.ATTRIB_NAME) : b(f, "Invalid attribute name");
            continue;
          case T.ATTRIB_NAME:
            S === "=" ? f.state = T.ATTRIB_VALUE : S === ">" ? (b(f, "Attribute without value"), f.attribValue = f.attribName, N(f), L(f)) : O(S) ? f.state = T.ATTRIB_NAME_SAW_WHITE : W(x, S) ? f.attribName += S : b(f, "Invalid attribute name");
            continue;
          case T.ATTRIB_NAME_SAW_WHITE:
            if (S === "=")
              f.state = T.ATTRIB_VALUE;
            else {
              if (O(S))
                continue;
              b(f, "Attribute without value"), f.tag.attributes[f.attribName] = "", f.attribValue = "", J(f, "onattribute", {
                name: f.attribName,
                value: ""
              }), f.attribName = "", S === ">" ? L(f) : W(y, S) ? (f.attribName = S, f.state = T.ATTRIB_NAME) : (b(f, "Invalid attribute name"), f.state = T.ATTRIB);
            }
            continue;
          case T.ATTRIB_VALUE:
            if (O(S))
              continue;
            k(S) ? (f.q = S, f.state = T.ATTRIB_VALUE_QUOTED) : (f.opt.unquotedAttributeValues || $(f, "Unquoted attribute value"), f.state = T.ATTRIB_VALUE_UNQUOTED, f.attribValue = S);
            continue;
          case T.ATTRIB_VALUE_QUOTED:
            if (S !== f.q) {
              S === "&" ? f.state = T.ATTRIB_VALUE_ENTITY_Q : f.attribValue += S;
              continue;
            }
            N(f), f.q = "", f.state = T.ATTRIB_VALUE_CLOSED;
            continue;
          case T.ATTRIB_VALUE_CLOSED:
            O(S) ? f.state = T.ATTRIB : S === ">" ? L(f) : S === "/" ? f.state = T.OPEN_TAG_SLASH : W(y, S) ? (b(f, "No whitespace between attributes"), f.attribName = S, f.attribValue = "", f.state = T.ATTRIB_NAME) : b(f, "Invalid attribute name");
            continue;
          case T.ATTRIB_VALUE_UNQUOTED:
            if (!q(S)) {
              S === "&" ? f.state = T.ATTRIB_VALUE_ENTITY_U : f.attribValue += S;
              continue;
            }
            N(f), S === ">" ? L(f) : f.state = T.ATTRIB;
            continue;
          case T.CLOSE_TAG:
            if (f.tagName)
              S === ">" ? B(f) : W(x, S) ? f.tagName += S : f.script ? (f.script += "</" + f.tagName, f.tagName = "", f.state = T.SCRIPT) : (O(S) || b(f, "Invalid tagname in closing tag"), f.state = T.CLOSE_TAG_SAW_WHITE);
            else {
              if (O(S))
                continue;
              te(y, S) ? f.script ? (f.script += "</" + S, f.state = T.SCRIPT) : b(f, "Invalid tagname in closing tag.") : f.tagName = S;
            }
            continue;
<<<<<<< HEAD
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer2;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer2 = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer2 = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer2 = "attribValue";
                break;
            }
            if (c === ";") {
              var parsedEntity = parseEntity(parser);
              if (parser.opt.unparsedEntities && !Object.values(sax2.XML_ENTITIES).includes(parsedEntity)) {
                parser.entity = "";
                parser.state = returnState;
                parser.write(parsedEntity);
              } else {
                parser[buffer2] += parsedEntity;
                parser.entity = "";
                parser.state = returnState;
              }
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer2] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }
=======
          case T.CLOSE_TAG_SAW_WHITE:
            if (O(S))
              continue;
            S === ">" ? B(f) : b(f, "Invalid characters in closing tag");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
            continue;
          case T.TEXT_ENTITY:
          case T.ATTRIB_VALUE_ENTITY_Q:
          case T.ATTRIB_VALUE_ENTITY_U:
            var X, ve;
            switch (f.state) {
              case T.TEXT_ENTITY:
                X = T.TEXT, ve = "textNode";
                break;
              case T.ATTRIB_VALUE_ENTITY_Q:
                X = T.ATTRIB_VALUE_QUOTED, ve = "attribValue";
                break;
              case T.ATTRIB_VALUE_ENTITY_U:
                X = T.ATTRIB_VALUE_UNQUOTED, ve = "attribValue";
                break;
            }
            if (S === ";") {
              var Ae = K(f);
              f.opt.unparsedEntities && !Object.values(t.XML_ENTITIES).includes(Ae) ? (f.entity = "", f.state = X, f.write(Ae)) : (f[ve] += Ae, f.entity = "", f.state = X);
            } else W(f.entity.length ? A : w, S) ? f.entity += S : (b(f, "Invalid character in entity name"), f[ve] += "&" + f.entity + S, f.entity = "", f.state = X);
            continue;
          default:
            throw new Error(f, "Unknown state: " + f.state);
        }
      return f.position >= f.bufferCheckPosition && i(f), f;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
<<<<<<< HEAD
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor2 = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 1114111 || // not a valid Unicode code point
            floor2(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(exports);
})(sax$1);
Object.defineProperty(xml, "__esModule", { value: true });
xml.XElement = void 0;
xml.parseXml = parseXml;
const sax = sax$1;
const error_1 = error;
class XElement {
  constructor(name) {
    this.name = name;
    this.value = "";
    this.attributes = null;
    this.isCData = false;
    this.elements = null;
    if (!name) {
      throw (0, error_1.newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
    }
    if (!isValidName(name)) {
      throw (0, error_1.newError)(`Invalid element name: ${name}`, "ERR_XML_ELEMENT_INVALID_NAME");
    }
=======
    String.fromCodePoint || function() {
      var h = String.fromCharCode, f = Math.floor, C = function() {
        var S = 16384, G = [], z, X, ve = -1, Ae = arguments.length;
        if (!Ae)
          return "";
        for (var ct = ""; ++ve < Ae; ) {
          var Se = Number(arguments[ve]);
          if (!isFinite(Se) || // `NaN`, `+Infinity`, or `-Infinity`
          Se < 0 || // not a valid Unicode code point
          Se > 1114111 || // not a valid Unicode code point
          f(Se) !== Se)
            throw RangeError("Invalid code point: " + Se);
          Se <= 65535 ? G.push(Se) : (Se -= 65536, z = (Se >> 10) + 55296, X = Se % 1024 + 56320, G.push(z, X)), (ve + 1 === Ae || G.length > S) && (ct += h.apply(null, G), G.length = 0);
        }
        return ct;
      };
      Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
        value: C,
        configurable: !0,
        writable: !0
      }) : String.fromCodePoint = C;
    }();
  })(e);
})(ug);
Object.defineProperty(Vi, "__esModule", { value: !0 });
Vi.XElement = void 0;
Vi.parseXml = hA;
const pA = ug, Ra = Lr;
class pg {
  constructor(t) {
    if (this.name = t, this.value = "", this.attributes = null, this.isCData = !1, this.elements = null, !t)
      throw (0, Ra.newError)("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
    if (!dA(t))
      throw (0, Ra.newError)(`Invalid element name: ${t}`, "ERR_XML_ELEMENT_INVALID_NAME");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  attribute(t) {
    const n = this.attributes === null ? null : this.attributes[t];
    if (n == null)
      throw (0, Ra.newError)(`No attribute "${t}"`, "ERR_XML_MISSED_ATTRIBUTE");
    return n;
  }
  removeAttribute(t) {
    this.attributes !== null && delete this.attributes[t];
  }
  element(t, n = !1, r = null) {
    const i = this.elementOrNull(t, n);
    if (i === null)
      throw (0, Ra.newError)(r || `No element "${t}"`, "ERR_XML_MISSED_ELEMENT");
    return i;
  }
  elementOrNull(t, n = !1) {
    if (this.elements === null)
      return null;
    for (const r of this.elements)
      if (Ad(r, t, n))
        return r;
    return null;
  }
<<<<<<< HEAD
  getElements(name, ignoreCase = false) {
    if (this.elements === null) {
      return [];
=======
  getElements(t, n = !1) {
    return this.elements === null ? [] : this.elements.filter((r) => Ad(r, t, n));
  }
  elementValueOrEmpty(t, n = !1) {
    const r = this.elementOrNull(t, n);
    return r === null ? "" : r.value;
  }
}
Vi.XElement = pg;
const fA = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function dA(e) {
  return fA.test(e);
}
function Ad(e, t, n) {
  const r = e.name;
  return r === t || n === !0 && r.length === t.length && r.toLowerCase() === t.toLowerCase();
}
function hA(e) {
  let t = null;
  const n = pA.parser(!0, {}), r = [];
  return n.onopentag = (i) => {
    const a = new pg(i.name);
    if (a.attributes = i.attributes, t === null)
      t = a;
    else {
      const o = r[r.length - 1];
      o.elements == null && (o.elements = []), o.elements.push(a);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    r.push(a);
  }, n.onclosetag = () => {
    r.pop();
  }, n.ontext = (i) => {
    r.length > 0 && (r[r.length - 1].value = i);
  }, n.oncdata = (i) => {
    const a = r[r.length - 1];
    a.value = i, a.isCData = !0;
  }, n.onerror = (i) => {
    throw i;
  }, n.write(e), t;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CURRENT_APP_PACKAGE_FILE_NAME = e.CURRENT_APP_INSTALLER_FILE_NAME = e.XElement = e.parseXml = e.UUID = e.parseDn = e.retry = e.githubUrl = e.getS3LikeProviderBaseUrl = e.ProgressCallbackTransform = e.MemoLazy = e.safeStringifyJson = e.safeGetHeader = e.parseJson = e.HttpExecutor = e.HttpError = e.DigestTransform = e.createHttpError = e.configureRequestUrl = e.configureRequestOptionsFromUrl = e.configureRequestOptions = e.newError = e.CancellationToken = e.CancellationError = void 0, e.asArray = p;
  var t = ln;
  Object.defineProperty(e, "CancellationError", { enumerable: !0, get: function() {
    return t.CancellationError;
  } }), Object.defineProperty(e, "CancellationToken", { enumerable: !0, get: function() {
    return t.CancellationToken;
  } });
  var n = Lr;
  Object.defineProperty(e, "newError", { enumerable: !0, get: function() {
    return n.newError;
  } });
  var r = He;
  Object.defineProperty(e, "configureRequestOptions", { enumerable: !0, get: function() {
    return r.configureRequestOptions;
  } }), Object.defineProperty(e, "configureRequestOptionsFromUrl", { enumerable: !0, get: function() {
    return r.configureRequestOptionsFromUrl;
  } }), Object.defineProperty(e, "configureRequestUrl", { enumerable: !0, get: function() {
    return r.configureRequestUrl;
  } }), Object.defineProperty(e, "createHttpError", { enumerable: !0, get: function() {
    return r.createHttpError;
  } }), Object.defineProperty(e, "DigestTransform", { enumerable: !0, get: function() {
    return r.DigestTransform;
  } }), Object.defineProperty(e, "HttpError", { enumerable: !0, get: function() {
    return r.HttpError;
  } }), Object.defineProperty(e, "HttpExecutor", { enumerable: !0, get: function() {
    return r.HttpExecutor;
  } }), Object.defineProperty(e, "parseJson", { enumerable: !0, get: function() {
    return r.parseJson;
  } }), Object.defineProperty(e, "safeGetHeader", { enumerable: !0, get: function() {
    return r.safeGetHeader;
  } }), Object.defineProperty(e, "safeStringifyJson", { enumerable: !0, get: function() {
    return r.safeStringifyJson;
  } });
  var i = rs;
  Object.defineProperty(e, "MemoLazy", { enumerable: !0, get: function() {
    return i.MemoLazy;
  } });
  var a = Wi;
  Object.defineProperty(e, "ProgressCallbackTransform", { enumerable: !0, get: function() {
    return a.ProgressCallbackTransform;
  } });
  var o = is;
  Object.defineProperty(e, "getS3LikeProviderBaseUrl", { enumerable: !0, get: function() {
    return o.getS3LikeProviderBaseUrl;
  } }), Object.defineProperty(e, "githubUrl", { enumerable: !0, get: function() {
    return o.githubUrl;
  } });
  var c = Iu;
  Object.defineProperty(e, "retry", { enumerable: !0, get: function() {
    return c.retry;
  } });
  var s = Pu;
  Object.defineProperty(e, "parseDn", { enumerable: !0, get: function() {
    return s.parseDn;
  } });
  var u = Ir;
  Object.defineProperty(e, "UUID", { enumerable: !0, get: function() {
    return u.UUID;
  } });
  var l = Vi;
  Object.defineProperty(e, "parseXml", { enumerable: !0, get: function() {
    return l.parseXml;
  } }), Object.defineProperty(e, "XElement", { enumerable: !0, get: function() {
    return l.XElement;
  } }), e.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe", e.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
  function p(d) {
    return d == null ? [] : Array.isArray(d) ? d : [d];
  }
<<<<<<< HEAD
  elementValueOrEmpty(name, ignoreCase = false) {
    const element = this.elementOrNull(name, ignoreCase);
    return element === null ? "" : element.value;
  }
}
xml.XElement = XElement;
const NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function isValidName(name) {
  return NAME_REG_EXP.test(name);
}
function isNameEquals(element, name, ignoreCase) {
  const elementName = element.name;
  return elementName === name || ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase();
}
function parseXml(data) {
  let rootElement = null;
  const parser = sax.parser(true, {});
  const elements = [];
  parser.onopentag = (saxElement) => {
    const element = new XElement(saxElement.name);
    element.attributes = saxElement.attributes;
    if (rootElement === null) {
      rootElement = element;
    } else {
      const parent = elements[elements.length - 1];
      if (parent.elements == null) {
        parent.elements = [];
      }
      parent.elements.push(element);
    }
    elements.push(element);
  };
  parser.onclosetag = () => {
    elements.pop();
  };
  parser.ontext = (text) => {
    if (elements.length > 0) {
      elements[elements.length - 1].value = text;
    }
  };
  parser.oncdata = (cdata) => {
    const element = elements[elements.length - 1];
    element.value = cdata;
    element.isCData = true;
  };
  parser.onerror = (err) => {
    throw err;
  };
  parser.write(data);
  return rootElement;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CURRENT_APP_PACKAGE_FILE_NAME = exports.CURRENT_APP_INSTALLER_FILE_NAME = exports.XElement = exports.parseXml = exports.UUID = exports.parseDn = exports.retry = exports.githubUrl = exports.getS3LikeProviderBaseUrl = exports.ProgressCallbackTransform = exports.MemoLazy = exports.safeStringifyJson = exports.safeGetHeader = exports.parseJson = exports.HttpExecutor = exports.HttpError = exports.DigestTransform = exports.createHttpError = exports.configureRequestUrl = exports.configureRequestOptionsFromUrl = exports.configureRequestOptions = exports.newError = exports.CancellationToken = exports.CancellationError = void 0;
  exports.asArray = asArray;
  var CancellationToken_12 = CancellationToken$1;
  Object.defineProperty(exports, "CancellationError", { enumerable: true, get: function() {
    return CancellationToken_12.CancellationError;
  } });
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return CancellationToken_12.CancellationToken;
  } });
  var error_12 = error;
  Object.defineProperty(exports, "newError", { enumerable: true, get: function() {
    return error_12.newError;
  } });
  var httpExecutor_1 = httpExecutor;
  Object.defineProperty(exports, "configureRequestOptions", { enumerable: true, get: function() {
    return httpExecutor_1.configureRequestOptions;
  } });
  Object.defineProperty(exports, "configureRequestOptionsFromUrl", { enumerable: true, get: function() {
    return httpExecutor_1.configureRequestOptionsFromUrl;
  } });
  Object.defineProperty(exports, "configureRequestUrl", { enumerable: true, get: function() {
    return httpExecutor_1.configureRequestUrl;
  } });
  Object.defineProperty(exports, "createHttpError", { enumerable: true, get: function() {
    return httpExecutor_1.createHttpError;
  } });
  Object.defineProperty(exports, "DigestTransform", { enumerable: true, get: function() {
    return httpExecutor_1.DigestTransform;
  } });
  Object.defineProperty(exports, "HttpError", { enumerable: true, get: function() {
    return httpExecutor_1.HttpError;
  } });
  Object.defineProperty(exports, "HttpExecutor", { enumerable: true, get: function() {
    return httpExecutor_1.HttpExecutor;
  } });
  Object.defineProperty(exports, "parseJson", { enumerable: true, get: function() {
    return httpExecutor_1.parseJson;
  } });
  Object.defineProperty(exports, "safeGetHeader", { enumerable: true, get: function() {
    return httpExecutor_1.safeGetHeader;
  } });
  Object.defineProperty(exports, "safeStringifyJson", { enumerable: true, get: function() {
    return httpExecutor_1.safeStringifyJson;
  } });
  var MemoLazy_1 = MemoLazy$1;
  Object.defineProperty(exports, "MemoLazy", { enumerable: true, get: function() {
    return MemoLazy_1.MemoLazy;
  } });
  var ProgressCallbackTransform_12 = ProgressCallbackTransform$1;
  Object.defineProperty(exports, "ProgressCallbackTransform", { enumerable: true, get: function() {
    return ProgressCallbackTransform_12.ProgressCallbackTransform;
  } });
  var publishOptions_1 = publishOptions;
  Object.defineProperty(exports, "getS3LikeProviderBaseUrl", { enumerable: true, get: function() {
    return publishOptions_1.getS3LikeProviderBaseUrl;
  } });
  Object.defineProperty(exports, "githubUrl", { enumerable: true, get: function() {
    return publishOptions_1.githubUrl;
  } });
  var retry_1 = retry$1;
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var rfc2253Parser_1 = rfc2253Parser;
  Object.defineProperty(exports, "parseDn", { enumerable: true, get: function() {
    return rfc2253Parser_1.parseDn;
  } });
  var uuid_1 = uuid;
  Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
    return uuid_1.UUID;
  } });
  var xml_1 = xml;
  Object.defineProperty(exports, "parseXml", { enumerable: true, get: function() {
    return xml_1.parseXml;
  } });
  Object.defineProperty(exports, "XElement", { enumerable: true, get: function() {
    return xml_1.XElement;
  } });
  exports.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe";
  exports.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
  function asArray(v) {
    if (v == null) {
      return [];
    } else if (Array.isArray(v)) {
      return v;
    } else {
      return [v];
    }
  }
})(out);
var jsYaml = {};
var loader$1 = {};
var common$5 = {};
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key2, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key2 = sourceKeys[index];
      target[key2] = source[key2];
    }
  }
  return target;
=======
})(De);
var Ue = {}, Du = {}, vt = {};
function fg(e) {
  return typeof e > "u" || e === null;
}
function mA(e) {
  return typeof e == "object" && e !== null;
}
function vA(e) {
  return Array.isArray(e) ? e : fg(e) ? [] : [e];
}
function gA(e, t) {
  var n, r, i, a;
  if (t)
    for (a = Object.keys(t), n = 0, r = a.length; n < r; n += 1)
      i = a[n], e[i] = t[i];
  return e;
}
function xA(e, t) {
  var n = "", r;
  for (r = 0; r < t; r += 1)
    n += e;
  return n;
}
function yA(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
vt.isNothing = fg;
vt.isObject = mA;
vt.toArray = vA;
vt.repeat = xA;
vt.isNegativeZero = yA;
vt.extend = gA;
function dg(e, t) {
  var n = "", r = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (n += 'in "' + e.mark.name + '" '), n += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (n += `

` + e.mark.snippet), r + " " + n) : r;
}
function bi(e, t) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = dg(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
bi.prototype = Object.create(Error.prototype);
bi.prototype.constructor = bi;
bi.prototype.toString = function(t) {
  return this.name + ": " + dg(this, t);
};
<<<<<<< HEAD
var exception = YAMLException$4;
var common$4 = common$5;
function getLine(buffer2, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer2.slice(lineStart, lineEnd).replace(/\t/g, "") + tail,
    pos: position - lineStart + head.length
=======
var Yi = bi, ti = vt;
function Ic(e, t, n, r, i) {
  var a = "", o = "", c = Math.floor(i / 2) - 1;
  return r - t > c && (a = " ... ", t = r - c + a.length), n - r > c && (o = " ...", n = r + c - o.length), {
    str: a + e.slice(t, n).replace(/\t/g, "") + o,
    pos: r - t + a.length
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    // relative position
  };
}
function Pc(e, t) {
  return ti.repeat(" ", t - e.length) + e;
}
<<<<<<< HEAD
function makeSnippet$1(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re2 = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re2.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common$4.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common$4.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common$4.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common$4.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet$1;
var YAMLException$3 = exception;
var TYPE_CONSTRUCTOR_OPTIONS = [
=======
function bA(e, t) {
  if (t = Object.create(t || null), !e.buffer) return null;
  t.maxLength || (t.maxLength = 79), typeof t.indent != "number" && (t.indent = 1), typeof t.linesBefore != "number" && (t.linesBefore = 3), typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (var n = /\r?\n|\r|\0/g, r = [0], i = [], a, o = -1; a = n.exec(e.buffer); )
    i.push(a.index), r.push(a.index + a[0].length), e.position <= a.index && o < 0 && (o = r.length - 2);
  o < 0 && (o = r.length - 1);
  var c = "", s, u, l = Math.min(e.line + t.linesAfter, i.length).toString().length, p = t.maxLength - (t.indent + l + 3);
  for (s = 1; s <= t.linesBefore && !(o - s < 0); s++)
    u = Ic(
      e.buffer,
      r[o - s],
      i[o - s],
      e.position - (r[o] - r[o - s]),
      p
    ), c = ti.repeat(" ", t.indent) + Pc((e.line - s + 1).toString(), l) + " | " + u.str + `
` + c;
  for (u = Ic(e.buffer, r[o], i[o], e.position, p), c += ti.repeat(" ", t.indent) + Pc((e.line + 1).toString(), l) + " | " + u.str + `
`, c += ti.repeat("-", t.indent + l + 3 + u.pos) + `^
`, s = 1; s <= t.linesAfter && !(o + s >= i.length); s++)
    u = Ic(
      e.buffer,
      r[o + s],
      i[o + s],
      e.position - (r[o] - r[o + s]),
      p
    ), c += ti.repeat(" ", t.indent) + Pc((e.line + s + 1).toString(), l) + " | " + u.str + `
`;
  return c.replace(/\n$/, "");
}
var wA = bA, Rd = Yi, EA = [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
<<<<<<< HEAD
];
var YAML_NODE_KINDS = [
=======
], _A = [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  "scalar",
  "sequence",
  "mapping"
];
<<<<<<< HEAD
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
=======
function SA(e) {
  var t = {};
  return e !== null && Object.keys(e).forEach(function(n) {
    e[n].forEach(function(r) {
      t[String(r)] = n;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    });
  }), t;
}
<<<<<<< HEAD
function Type$e(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException$3('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$e;
var YAMLException$2 = exception;
var Type$d = type;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
=======
function TA(e, t) {
  if (t = t || {}, Object.keys(t).forEach(function(n) {
    if (EA.indexOf(n) === -1)
      throw new Rd('Unknown option "' + n + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
    return !0;
  }, this.construct = t.construct || function(n) {
    return n;
  }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = SA(t.styleAliases || null), _A.indexOf(this.kind) === -1)
    throw new Rd('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var Ye = TA, Kr = Yi, Dc = Ye;
function Cd(e, t) {
  var n = [];
  return e[t].forEach(function(r) {
    var i = n.length;
    n.forEach(function(a, o) {
      a.tag === r.tag && a.kind === r.kind && a.multi === r.multi && (i = o);
    }), n[i] = r;
  }), n;
}
function AA() {
  var e = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, t, n;
  function r(i) {
    i.multi ? (e.multi[i.kind].push(i), e.multi.fallback.push(i)) : e[i.kind][i.tag] = e.fallback[i.tag] = i;
  }
  for (t = 0, n = arguments.length; t < n; t += 1)
    arguments[t].forEach(r);
  return e;
}
function Sl(e) {
  return this.extend(e);
}
Sl.prototype.extend = function(t) {
  var n = [], r = [];
  if (t instanceof Dc)
    r.push(t);
  else if (Array.isArray(t))
    r = r.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (n = n.concat(t.implicit)), t.explicit && (r = r.concat(t.explicit));
  else
    throw new Kr("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  n.forEach(function(a) {
    if (!(a instanceof Dc))
      throw new Kr("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (a.loadKind && a.loadKind !== "scalar")
      throw new Kr("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (a.multi)
      throw new Kr("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), r.forEach(function(a) {
    if (!(a instanceof Dc))
      throw new Kr("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
<<<<<<< HEAD
  explicit.forEach(function(type2) {
    if (!(type2 instanceof Type$d)) {
      throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var Type$c = type;
var str = new Type$c("tag:yaml.org,2002:str", {
=======
  var i = Object.create(Sl.prototype);
  return i.implicit = (this.implicit || []).concat(n), i.explicit = (this.explicit || []).concat(r), i.compiledImplicit = Cd(i, "implicit"), i.compiledExplicit = Cd(i, "explicit"), i.compiledTypeMap = AA(i.compiledImplicit, i.compiledExplicit), i;
};
var hg = Sl, RA = Ye, mg = new RA("tag:yaml.org,2002:str", {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  kind: "scalar",
  construct: function(e) {
    return e !== null ? e : "";
  }
<<<<<<< HEAD
});
var Type$b = type;
var seq = new Type$b("tag:yaml.org,2002:seq", {
=======
}), CA = Ye, vg = new CA("tag:yaml.org,2002:seq", {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  kind: "sequence",
  construct: function(e) {
    return e !== null ? e : [];
  }
<<<<<<< HEAD
});
var Type$a = type;
var map = new Type$a("tag:yaml.org,2002:map", {
=======
}), OA = Ye, gg = new OA("tag:yaml.org,2002:map", {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  kind: "mapping",
  construct: function(e) {
    return e !== null ? e : {};
  }
<<<<<<< HEAD
});
var Schema = schema;
var failsafe = new Schema({
=======
}), $A = hg, xg = new $A({
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  explicit: [
    mg,
    vg,
    gg
  ]
<<<<<<< HEAD
});
var Type$9 = type;
function resolveYamlNull(data) {
  if (data === null) return true;
  var max2 = data.length;
  return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new Type$9("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
=======
}), IA = Ye;
function PA(e) {
  if (e === null) return !0;
  var t = e.length;
  return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function DA() {
  return null;
}
function FA(e) {
  return e === null;
}
var yg = new IA("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: PA,
  construct: DA,
  predicate: FA,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
<<<<<<< HEAD
});
var Type$8 = type;
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max2 = data.length;
  return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new Type$8("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
=======
}), NA = Ye;
function kA(e) {
  if (e === null) return !1;
  var t = e.length;
  return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function LA(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function UA(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var bg = new NA("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: kA,
  construct: LA,
  predicate: UA,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  represent: {
    lowercase: function(e) {
      return e ? "true" : "false";
    },
    uppercase: function(e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function(e) {
      return e ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
<<<<<<< HEAD
});
var common$3 = common$5;
var Type$7 = type;
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max2 = data.length, index = 0, hasDigits = false, ch;
  if (!max2) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max2) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max2; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
=======
}), BA = vt, jA = Ye;
function MA(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function qA(e) {
  return 48 <= e && e <= 55;
}
function zA(e) {
  return 48 <= e && e <= 57;
}
function HA(e) {
  if (e === null) return !1;
  var t = e.length, n = 0, r = !1, i;
  if (!t) return !1;
  if (i = e[n], (i === "-" || i === "+") && (i = e[++n]), i === "0") {
    if (n + 1 === t) return !0;
    if (i = e[++n], i === "b") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (i !== "0" && i !== "1") return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "x") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (!MA(e.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "o") {
      for (n++; n < t; n++)
        if (i = e[n], i !== "_") {
          if (!qA(e.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
  }
  if (i === "_") return !1;
  for (; n < t; n++)
    if (i = e[n], i !== "_") {
      if (!zA(e.charCodeAt(n)))
        return !1;
      r = !0;
    }
  return !(!r || i === "_");
}
function GA(e) {
  var t = e, n = 1, r;
  if (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")), r = t[0], (r === "-" || r === "+") && (r === "-" && (n = -1), t = t.slice(1), r = t[0]), t === "0") return 0;
  if (r === "0") {
    if (t[1] === "b") return n * parseInt(t.slice(2), 2);
    if (t[1] === "x") return n * parseInt(t.slice(2), 16);
    if (t[1] === "o") return n * parseInt(t.slice(2), 8);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return n * parseInt(t, 10);
}
<<<<<<< HEAD
function constructYamlInteger(data) {
  var value = data, sign3 = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign3 = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign3 * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign3 * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign3 * parseInt(value.slice(2), 8);
  }
  return sign3 * parseInt(value, 10);
=======
function WA(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !BA.isNegativeZero(e);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
var wg = new jA("tag:yaml.org,2002:int", {
  kind: "scalar",
<<<<<<< HEAD
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
=======
  resolve: HA,
  construct: GA,
  predicate: WA,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  represent: {
    binary: function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    },
    octal: function(e) {
      return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
    },
    decimal: function(e) {
      return e.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
<<<<<<< HEAD
});
var common$2 = common$5;
var Type$6 = type;
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign3;
  value = data.replace(/_/g, "").toLowerCase();
  sign3 = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign3 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign3 * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
=======
}), Eg = vt, VA = Ye, YA = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function XA(e) {
  return !(e === null || !YA.test(e) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  e[e.length - 1] === "_");
}
function KA(e) {
  var t, n;
  return t = e.replace(/_/g, "").toLowerCase(), n = t[0] === "-" ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), t === ".inf" ? n === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === ".nan" ? NaN : n * parseFloat(t, 10);
}
var JA = /^[-+]?[0-9]+e/;
function ZA(e, t) {
  var n;
  if (isNaN(e))
    switch (t) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (Eg.isNegativeZero(e))
    return "-0.0";
<<<<<<< HEAD
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
=======
  return n = e.toString(10), JA.test(n) ? n.replace("e", ".e") : n;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function QA(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || Eg.isNegativeZero(e));
}
var _g = new VA("tag:yaml.org,2002:float", {
  kind: "scalar",
<<<<<<< HEAD
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
=======
  resolve: XA,
  construct: KA,
  predicate: QA,
  represent: ZA,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  defaultStyle: "lowercase"
}), Sg = xg.extend({
  implicit: [
    yg,
    bg,
    wg,
    _g
  ]
<<<<<<< HEAD
});
var core = json;
var Type$5 = type;
var YAML_DATE_REGEXP = new RegExp(
=======
}), Tg = Sg, e6 = Ye, Ag = new RegExp(
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), Rg = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
<<<<<<< HEAD
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
=======
function t6(e) {
  return e === null ? !1 : Ag.exec(e) !== null || Rg.exec(e) !== null;
}
function n6(e) {
  var t, n, r, i, a, o, c, s = 0, u = null, l, p, d;
  if (t = Ag.exec(e), t === null && (t = Rg.exec(e)), t === null) throw new Error("Date resolve error");
  if (n = +t[1], r = +t[2] - 1, i = +t[3], !t[4])
    return new Date(Date.UTC(n, r, i));
  if (a = +t[4], o = +t[5], c = +t[6], t[7]) {
    for (s = t[7].slice(0, 3); s.length < 3; )
      s += "0";
    s = +s;
  }
  return t[9] && (l = +t[10], p = +(t[11] || 0), u = (l * 60 + p) * 6e4, t[9] === "-" && (u = -u)), d = new Date(Date.UTC(n, r, i, a, o, c, s)), u && d.setTime(d.getTime() - u), d;
}
function r6(e) {
  return e.toISOString();
}
var Cg = new e6("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: t6,
  construct: n6,
  instanceOf: Date,
  represent: r6
}), i6 = Ye;
function a6(e) {
  return e === "<<" || e === null;
}
var Og = new i6("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: a6
}), o6 = Ye, Fu = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function s6(e) {
  if (e === null) return !1;
  var t, n, r = 0, i = e.length, a = Fu;
  for (n = 0; n < i; n++)
    if (t = a.indexOf(e.charAt(n)), !(t > 64)) {
      if (t < 0) return !1;
      r += 6;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
  return r % 8 === 0;
}
<<<<<<< HEAD
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new Type$5("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
var Type$4 = type;
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new Type$4("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var Type$3 = type;
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max2 = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
=======
function c6(e) {
  var t, n, r = e.replace(/[\r\n=]/g, ""), i = r.length, a = Fu, o = 0, c = [];
  for (t = 0; t < i; t++)
    t % 4 === 0 && t && (c.push(o >> 16 & 255), c.push(o >> 8 & 255), c.push(o & 255)), o = o << 6 | a.indexOf(r.charAt(t));
  return n = i % 4 * 6, n === 0 ? (c.push(o >> 16 & 255), c.push(o >> 8 & 255), c.push(o & 255)) : n === 18 ? (c.push(o >> 10 & 255), c.push(o >> 2 & 255)) : n === 12 && c.push(o >> 4 & 255), new Uint8Array(c);
}
function l6(e) {
  var t = "", n = 0, r, i, a = e.length, o = Fu;
  for (r = 0; r < a; r++)
    r % 3 === 0 && r && (t += o[n >> 18 & 63], t += o[n >> 12 & 63], t += o[n >> 6 & 63], t += o[n & 63]), n = (n << 8) + e[r];
  return i = a % 3, i === 0 ? (t += o[n >> 18 & 63], t += o[n >> 12 & 63], t += o[n >> 6 & 63], t += o[n & 63]) : i === 2 ? (t += o[n >> 10 & 63], t += o[n >> 4 & 63], t += o[n << 2 & 63], t += o[64]) : i === 1 && (t += o[n >> 2 & 63], t += o[n << 4 & 63], t += o[64], t += o[64]), t;
}
function u6(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var $g = new o6("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: s6,
  construct: c6,
  predicate: u6,
  represent: l6
}), p6 = Ye, f6 = Object.prototype.hasOwnProperty, d6 = Object.prototype.toString;
function h6(e) {
  if (e === null) return !0;
  var t = [], n, r, i, a, o, c = e;
  for (n = 0, r = c.length; n < r; n += 1) {
    if (i = c[n], o = !1, d6.call(i) !== "[object Object]") return !1;
    for (a in i)
      if (f6.call(i, a))
        if (!o) o = !0;
        else return !1;
    if (!o) return !1;
    if (t.indexOf(a) === -1) t.push(a);
    else return !1;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return !0;
}
<<<<<<< HEAD
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max2 = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max2; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
=======
function m6(e) {
  return e !== null ? e : [];
}
var Ig = new p6("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: h6,
  construct: m6
}), v6 = Ye, g6 = Object.prototype.toString;
function x6(e) {
  if (e === null) return !0;
  var t, n, r, i, a, o = e;
  for (a = new Array(o.length), t = 0, n = o.length; t < n; t += 1) {
    if (r = o[t], g6.call(r) !== "[object Object]" || (i = Object.keys(r), i.length !== 1)) return !1;
    a[t] = [i[0], r[i[0]]];
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return !0;
}
<<<<<<< HEAD
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max2 = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max2; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max2 % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new Type$3("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var Type$2 = type;
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new Type$2("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var Type$1 = type;
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new Type$1("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var Type = type;
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return true;
  var key2, object = data;
  for (key2 in object) {
    if (_hasOwnProperty$2.call(object, key2)) {
      if (object[key2] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new Type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
=======
function y6(e) {
  if (e === null) return [];
  var t, n, r, i, a, o = e;
  for (a = new Array(o.length), t = 0, n = o.length; t < n; t += 1)
    r = o[t], i = Object.keys(r), a[t] = [i[0], r[i[0]]];
  return a;
}
var Pg = new v6("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: x6,
  construct: y6
}), b6 = Ye, w6 = Object.prototype.hasOwnProperty;
function E6(e) {
  if (e === null) return !0;
  var t, n = e;
  for (t in n)
    if (w6.call(n, t) && n[t] !== null)
      return !1;
  return !0;
}
function _6(e) {
  return e !== null ? e : {};
}
var Dg = new b6("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: E6,
  construct: _6
}), Nu = Tg.extend({
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  implicit: [
    Cg,
    Og
  ],
  explicit: [
    $g,
    Ig,
    Pg,
    Dg
  ]
<<<<<<< HEAD
});
var common$1 = common$5;
var YAMLException$1 = exception;
var makeSnippet = snippet;
var DEFAULT_SCHEMA$1 = _default;
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
=======
}), On = vt, Fg = Yi, S6 = wA, T6 = Nu, un = Object.prototype.hasOwnProperty, ho = 1, Ng = 2, kg = 3, mo = 4, Fc = 1, A6 = 2, Od = 3, R6 = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, C6 = /[\x85\u2028\u2029]/, O6 = /[,\[\]\{\}]/, Lg = /^(?:!|!!|![a-z\-]+!)$/i, Ug = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function $d(e) {
  return Object.prototype.toString.call(e);
}
function St(e) {
  return e === 10 || e === 13;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function Un(e) {
  return e === 9 || e === 32;
}
function Ze(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function mr(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
<<<<<<< HEAD
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? "" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
=======
function $6(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : (t = e | 32, 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function I6(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function P6(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function Id(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? "" : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function D6(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var Bg = new Array(256), jg = new Array(256);
for (var nr = 0; nr < 256; nr++)
  Bg[nr] = Id(nr) ? 1 : 0, jg[nr] = Id(nr);
function F6(e, t) {
  this.input = e, this.filename = t.filename || null, this.schema = t.schema || T6, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function Mg(e, t) {
  var n = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    // omit trailing \0
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart
  };
<<<<<<< HEAD
  mark.snippet = makeSnippet(mark);
  return new YAMLException$1(message, mark);
=======
  return n.snippet = S6(n), new Fg(t, n);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function Q(e, t) {
  throw Mg(e, t);
}
function vo(e, t) {
  e.onWarning && e.onWarning.call(null, Mg(e, t));
}
var Pd = {
  YAML: function(t, n, r) {
    var i, a, o;
    t.version !== null && Q(t, "duplication of %YAML directive"), r.length !== 1 && Q(t, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(r[0]), i === null && Q(t, "ill-formed argument of the YAML directive"), a = parseInt(i[1], 10), o = parseInt(i[2], 10), a !== 1 && Q(t, "unacceptable YAML version of the document"), t.version = r[0], t.checkLineBreaks = o < 2, o !== 1 && o !== 2 && vo(t, "unsupported YAML version of the document");
  },
  TAG: function(t, n, r) {
    var i, a;
    r.length !== 2 && Q(t, "TAG directive accepts exactly two arguments"), i = r[0], a = r[1], Lg.test(i) || Q(t, "ill-formed tag handle (first argument) of the TAG directive"), un.call(t.tagMap, i) && Q(t, 'there is a previously declared suffix for "' + i + '" tag handle'), Ug.test(a) || Q(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      a = decodeURIComponent(a);
    } catch {
      Q(t, "tag prefix is malformed: " + a);
    }
    t.tagMap[i] = a;
  }
};
<<<<<<< HEAD
function captureSegment(state2, start, end2, checkJson) {
  var _position, _length, _character, _result;
  if (start < end2) {
    _result = state2.input.slice(start, end2);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state2, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state2, "the stream contains non-printable characters");
    }
    state2.result += _result;
  }
}
function mergeMappings(state2, destination, source, overridableKeys) {
  var sourceKeys, key2, index, quantity;
  if (!common$1.isObject(source)) {
    throwError(state2, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key2 = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key2)) {
      destination[key2] = source[key2];
      overridableKeys[key2] = true;
    }
  }
}
function storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state2, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state2, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state2, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state2.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state2.line = startLine || state2.line;
      state2.lineStart = startLineStart || state2.lineStart;
      state2.position = startPos || state2.position;
      throwError(state2, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
=======
function nn(e, t, n, r) {
  var i, a, o, c;
  if (t < n) {
    if (c = e.input.slice(t, n), r)
      for (i = 0, a = c.length; i < a; i += 1)
        o = c.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || Q(e, "expected valid JSON character");
    else R6.test(c) && Q(e, "the stream contains non-printable characters");
    e.result += c;
  }
}
function Dd(e, t, n, r) {
  var i, a, o, c;
  for (On.isObject(n) || Q(e, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(n), o = 0, c = i.length; o < c; o += 1)
    a = i[o], un.call(t, a) || (t[a] = n[a], r[a] = !0);
}
function vr(e, t, n, r, i, a, o, c, s) {
  var u, l;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), u = 0, l = i.length; u < l; u += 1)
      Array.isArray(i[u]) && Q(e, "nested arrays are not supported inside keys"), typeof i == "object" && $d(i[u]) === "[object Object]" && (i[u] = "[object Object]");
  if (typeof i == "object" && $d(i) === "[object Object]" && (i = "[object Object]"), i = String(i), t === null && (t = {}), r === "tag:yaml.org,2002:merge")
    if (Array.isArray(a))
      for (u = 0, l = a.length; u < l; u += 1)
        Dd(e, t, a[u], n);
    else
      Dd(e, t, a, n);
  else
    !e.json && !un.call(n, i) && un.call(t, i) && (e.line = o || e.line, e.lineStart = c || e.lineStart, e.position = s || e.position, Q(e, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(t, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: a
    }) : t[i] = a, delete n[i];
  return t;
}
function ku(e) {
  var t;
  t = e.input.charCodeAt(e.position), t === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : Q(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function Re(e, t, n) {
  for (var r = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; Un(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), i = e.input.charCodeAt(++e.position);
    if (t && i === 35)
      do
        i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (St(i))
      for (ku(e), i = e.input.charCodeAt(e.position), r++, e.lineIndent = 0; i === 32; )
        e.lineIndent++, i = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return n !== -1 && r !== 0 && e.lineIndent < n && vo(e, "deficient indentation"), r;
}
function as(e) {
  var t = e.position, n;
  return n = e.input.charCodeAt(t), !!((n === 45 || n === 46) && n === e.input.charCodeAt(t + 1) && n === e.input.charCodeAt(t + 2) && (t += 3, n = e.input.charCodeAt(t), n === 0 || Ze(n)));
}
function Lu(e, t) {
  t === 1 ? e.result += " " : t > 1 && (e.result += On.repeat(`
`, t - 1));
}
function N6(e, t, n) {
  var r, i, a, o, c, s, u, l, p = e.kind, d = e.result, m;
  if (m = e.input.charCodeAt(e.position), Ze(m) || mr(m) || m === 35 || m === 38 || m === 42 || m === 33 || m === 124 || m === 62 || m === 39 || m === 34 || m === 37 || m === 64 || m === 96 || (m === 63 || m === 45) && (i = e.input.charCodeAt(e.position + 1), Ze(i) || n && mr(i)))
    return !1;
  for (e.kind = "scalar", e.result = "", a = o = e.position, c = !1; m !== 0; ) {
    if (m === 58) {
      if (i = e.input.charCodeAt(e.position + 1), Ze(i) || n && mr(i))
        break;
    } else if (m === 35) {
      if (r = e.input.charCodeAt(e.position - 1), Ze(r))
        break;
    } else {
      if (e.position === e.lineStart && as(e) || n && mr(m))
        break;
      if (St(m))
        if (s = e.line, u = e.lineStart, l = e.lineIndent, Re(e, !1, -1), e.lineIndent >= t) {
          c = !0, m = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = o, e.line = s, e.lineStart = u, e.lineIndent = l;
          break;
        }
    }
    c && (nn(e, a, o, !1), Lu(e, e.line - s), a = o = e.position, c = !1), Un(m) || (o = e.position + 1), m = e.input.charCodeAt(++e.position);
  }
  return nn(e, a, o, !1), e.result ? !0 : (e.kind = p, e.result = d, !1);
}
function k6(e, t) {
  var n, r, i;
  if (n = e.input.charCodeAt(e.position), n !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, r = i = e.position; (n = e.input.charCodeAt(e.position)) !== 0; )
    if (n === 39)
      if (nn(e, r, e.position, !0), n = e.input.charCodeAt(++e.position), n === 39)
        r = e.position, e.position++, i = e.position;
      else
        return !0;
    else St(n) ? (nn(e, r, i, !0), Lu(e, Re(e, !1, t)), r = i = e.position) : e.position === e.lineStart && as(e) ? Q(e, "unexpected end of the document within a single quoted scalar") : (e.position++, i = e.position);
  Q(e, "unexpected end of the stream within a single quoted scalar");
}
function L6(e, t) {
  var n, r, i, a, o, c;
  if (c = e.input.charCodeAt(e.position), c !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, n = r = e.position; (c = e.input.charCodeAt(e.position)) !== 0; ) {
    if (c === 34)
      return nn(e, n, e.position, !0), e.position++, !0;
    if (c === 92) {
      if (nn(e, n, e.position, !0), c = e.input.charCodeAt(++e.position), St(c))
        Re(e, !1, t);
      else if (c < 256 && Bg[c])
        e.result += jg[c], e.position++;
      else if ((o = I6(c)) > 0) {
        for (i = o, a = 0; i > 0; i--)
          c = e.input.charCodeAt(++e.position), (o = $6(c)) >= 0 ? a = (a << 4) + o : Q(e, "expected hexadecimal character");
        e.result += D6(a), e.position++;
      } else
        Q(e, "unknown escape sequence");
      n = r = e.position;
    } else St(c) ? (nn(e, n, r, !0), Lu(e, Re(e, !1, t)), n = r = e.position) : e.position === e.lineStart && as(e) ? Q(e, "unexpected end of the document within a double quoted scalar") : (e.position++, r = e.position);
  }
  Q(e, "unexpected end of the stream within a double quoted scalar");
}
function U6(e, t) {
  var n = !0, r, i, a, o = e.tag, c, s = e.anchor, u, l, p, d, m, g = /* @__PURE__ */ Object.create(null), v, y, x, w;
  if (w = e.input.charCodeAt(e.position), w === 91)
    l = 93, m = !1, c = [];
  else if (w === 123)
    l = 125, m = !0, c = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = c), w = e.input.charCodeAt(++e.position); w !== 0; ) {
    if (Re(e, !0, t), w = e.input.charCodeAt(e.position), w === l)
      return e.position++, e.tag = o, e.anchor = s, e.kind = m ? "mapping" : "sequence", e.result = c, !0;
    n ? w === 44 && Q(e, "expected the node content, but found ','") : Q(e, "missed comma between flow collection entries"), y = v = x = null, p = d = !1, w === 63 && (u = e.input.charCodeAt(e.position + 1), Ze(u) && (p = d = !0, e.position++, Re(e, !0, t))), r = e.line, i = e.lineStart, a = e.position, Pr(e, t, ho, !1, !0), y = e.tag, v = e.result, Re(e, !0, t), w = e.input.charCodeAt(e.position), (d || e.line === r) && w === 58 && (p = !0, w = e.input.charCodeAt(++e.position), Re(e, !0, t), Pr(e, t, ho, !1, !0), x = e.result), m ? vr(e, c, g, y, v, x, r, i, a) : p ? c.push(vr(e, null, g, y, v, x, r, i, a)) : c.push(v), Re(e, !0, t), w = e.input.charCodeAt(e.position), w === 44 ? (n = !0, w = e.input.charCodeAt(++e.position)) : n = !1;
  }
  Q(e, "unexpected end of the stream within a flow collection");
}
function B6(e, t) {
  var n, r, i = Fc, a = !1, o = !1, c = t, s = 0, u = !1, l, p;
  if (p = e.input.charCodeAt(e.position), p === 124)
    r = !1;
  else if (p === 62)
    r = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; p !== 0; )
    if (p = e.input.charCodeAt(++e.position), p === 43 || p === 45)
      Fc === i ? i = p === 43 ? Od : A6 : Q(e, "repeat of a chomping mode identifier");
    else if ((l = P6(p)) >= 0)
      l === 0 ? Q(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? Q(e, "repeat of an indentation width identifier") : (c = t + l - 1, o = !0);
    else
      break;
  if (Un(p)) {
    do
      p = e.input.charCodeAt(++e.position);
    while (Un(p));
    if (p === 35)
      do
        p = e.input.charCodeAt(++e.position);
      while (!St(p) && p !== 0);
  }
  for (; p !== 0; ) {
    for (ku(e), e.lineIndent = 0, p = e.input.charCodeAt(e.position); (!o || e.lineIndent < c) && p === 32; )
      e.lineIndent++, p = e.input.charCodeAt(++e.position);
    if (!o && e.lineIndent > c && (c = e.lineIndent), St(p)) {
      s++;
      continue;
    }
    if (e.lineIndent < c) {
      i === Od ? e.result += On.repeat(`
`, a ? 1 + s : s) : i === Fc && a && (e.result += `
`);
      break;
    }
    for (r ? Un(p) ? (u = !0, e.result += On.repeat(`
`, a ? 1 + s : s)) : u ? (u = !1, e.result += On.repeat(`
`, s + 1)) : s === 0 ? a && (e.result += " ") : e.result += On.repeat(`
`, s) : e.result += On.repeat(`
`, a ? 1 + s : s), a = !0, o = !0, s = 0, n = e.position; !St(p) && p !== 0; )
      p = e.input.charCodeAt(++e.position);
    nn(e, n, e.position, !1);
  }
  return !0;
}
function Fd(e, t) {
  var n, r = e.tag, i = e.anchor, a = [], o, c = !1, s;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = a), s = e.input.charCodeAt(e.position); s !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, Q(e, "tab characters must not be used in indentation")), !(s !== 45 || (o = e.input.charCodeAt(e.position + 1), !Ze(o)))); ) {
    if (c = !0, e.position++, Re(e, !0, -1) && e.lineIndent <= t) {
      a.push(null), s = e.input.charCodeAt(e.position);
      continue;
    }
    if (n = e.line, Pr(e, t, kg, !1, !0), a.push(e.result), Re(e, !0, -1), s = e.input.charCodeAt(e.position), (e.line === n || e.lineIndent > t) && s !== 0)
      Q(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t)
      break;
  }
  return c ? (e.tag = r, e.anchor = i, e.kind = "sequence", e.result = a, !0) : !1;
}
function j6(e, t, n) {
  var r, i, a, o, c, s, u = e.tag, l = e.anchor, p = {}, d = /* @__PURE__ */ Object.create(null), m = null, g = null, v = null, y = !1, x = !1, w;
  if (e.firstTabInLine !== -1) return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = p), w = e.input.charCodeAt(e.position); w !== 0; ) {
    if (!y && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, Q(e, "tab characters must not be used in indentation")), r = e.input.charCodeAt(e.position + 1), a = e.line, (w === 63 || w === 58) && Ze(r))
      w === 63 ? (y && (vr(e, p, d, m, g, null, o, c, s), m = g = v = null), x = !0, y = !0, i = !0) : y ? (y = !1, i = !0) : Q(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, w = r;
    else {
      if (o = e.line, c = e.lineStart, s = e.position, !Pr(e, n, Ng, !1, !0))
        break;
      if (e.line === a) {
        for (w = e.input.charCodeAt(e.position); Un(w); )
          w = e.input.charCodeAt(++e.position);
        if (w === 58)
          w = e.input.charCodeAt(++e.position), Ze(w) || Q(e, "a whitespace character is expected after the key-value separator within a block mapping"), y && (vr(e, p, d, m, g, null, o, c, s), m = g = v = null), x = !0, y = !1, i = !1, m = e.tag, g = e.result;
        else if (x)
          Q(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = u, e.anchor = l, !0;
      } else if (x)
        Q(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = u, e.anchor = l, !0;
    }
    if ((e.line === a || e.lineIndent > t) && (y && (o = e.line, c = e.lineStart, s = e.position), Pr(e, t, mo, !0, i) && (y ? g = e.result : v = e.result), y || (vr(e, p, d, m, g, v, o, c, s), m = g = v = null), Re(e, !0, -1), w = e.input.charCodeAt(e.position)), (e.line === a || e.lineIndent > t) && w !== 0)
      Q(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t)
      break;
  }
  return y && vr(e, p, d, m, g, null, o, c, s), x && (e.tag = u, e.anchor = l, e.kind = "mapping", e.result = p), x;
}
function M6(e) {
  var t, n = !1, r = !1, i, a, o;
  if (o = e.input.charCodeAt(e.position), o !== 33) return !1;
  if (e.tag !== null && Q(e, "duplication of a tag property"), o = e.input.charCodeAt(++e.position), o === 60 ? (n = !0, o = e.input.charCodeAt(++e.position)) : o === 33 ? (r = !0, i = "!!", o = e.input.charCodeAt(++e.position)) : i = "!", t = e.position, n) {
    do
      o = e.input.charCodeAt(++e.position);
    while (o !== 0 && o !== 62);
    e.position < e.length ? (a = e.input.slice(t, e.position), o = e.input.charCodeAt(++e.position)) : Q(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !Ze(o); )
      o === 33 && (r ? Q(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(t - 1, e.position + 1), Lg.test(i) || Q(e, "named tag handle cannot contain such characters"), r = !0, t = e.position + 1)), o = e.input.charCodeAt(++e.position);
    a = e.input.slice(t, e.position), O6.test(a) && Q(e, "tag suffix cannot contain flow indicator characters");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  a && !Ug.test(a) && Q(e, "tag name cannot contain such characters: " + a);
  try {
    a = decodeURIComponent(a);
  } catch {
    Q(e, "tag name is malformed: " + a);
  }
  return n ? e.tag = a : un.call(e.tagMap, i) ? e.tag = e.tagMap[i] + a : i === "!" ? e.tag = "!" + a : i === "!!" ? e.tag = "tag:yaml.org,2002:" + a : Q(e, 'undeclared tag handle "' + i + '"'), !0;
}
<<<<<<< HEAD
function readLineBreak(state2) {
  var ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 10) {
    state2.position++;
  } else if (ch === 13) {
    state2.position++;
    if (state2.input.charCodeAt(state2.position) === 10) {
      state2.position++;
    }
  } else {
    throwError(state2, "a line break is expected");
  }
  state2.line += 1;
  state2.lineStart = state2.position;
  state2.firstTabInLine = -1;
}
function skipSeparationSpace(state2, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state2.firstTabInLine === -1) {
        state2.firstTabInLine = state2.position;
      }
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state2);
      ch = state2.input.charCodeAt(state2.position);
      lineBreaks++;
      state2.lineIndent = 0;
      while (ch === 32) {
        state2.lineIndent++;
        ch = state2.input.charCodeAt(++state2.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state2.lineIndent < checkIndent) {
    throwWarning(state2, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state2) {
  var _position = state2.position, ch;
  ch = state2.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state2.input.charCodeAt(_position + 1) && ch === state2.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state2.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state2, count) {
  if (count === 1) {
    state2.result += " ";
  } else if (count > 1) {
    state2.result += common$1.repeat("\n", count - 1);
  }
}
function readPlainScalar(state2, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state2.kind, _result = state2.result, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state2.input.charCodeAt(state2.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state2.kind = "scalar";
  state2.result = "";
  captureStart = captureEnd = state2.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
=======
function q6(e) {
  var t, n;
  if (n = e.input.charCodeAt(e.position), n !== 38) return !1;
  for (e.anchor !== null && Q(e, "duplication of an anchor property"), n = e.input.charCodeAt(++e.position), t = e.position; n !== 0 && !Ze(n) && !mr(n); )
    n = e.input.charCodeAt(++e.position);
  return e.position === t && Q(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
function z6(e) {
  var t, n, r;
  if (r = e.input.charCodeAt(e.position), r !== 42) return !1;
  for (r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !Ze(r) && !mr(r); )
    r = e.input.charCodeAt(++e.position);
  return e.position === t && Q(e, "name of an alias node must contain at least one character"), n = e.input.slice(t, e.position), un.call(e.anchorMap, n) || Q(e, 'unidentified alias "' + n + '"'), e.result = e.anchorMap[n], Re(e, !0, -1), !0;
}
function Pr(e, t, n, r, i) {
  var a, o, c, s = 1, u = !1, l = !1, p, d, m, g, v, y;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, a = o = c = mo === n || kg === n, r && Re(e, !0, -1) && (u = !0, e.lineIndent > t ? s = 1 : e.lineIndent === t ? s = 0 : e.lineIndent < t && (s = -1)), s === 1)
    for (; M6(e) || q6(e); )
      Re(e, !0, -1) ? (u = !0, c = a, e.lineIndent > t ? s = 1 : e.lineIndent === t ? s = 0 : e.lineIndent < t && (s = -1)) : c = !1;
  if (c && (c = u || i), (s === 1 || mo === n) && (ho === n || Ng === n ? v = t : v = t + 1, y = e.position - e.lineStart, s === 1 ? c && (Fd(e, y) || j6(e, y, v)) || U6(e, v) ? l = !0 : (o && B6(e, v) || k6(e, v) || L6(e, v) ? l = !0 : z6(e) ? (l = !0, (e.tag !== null || e.anchor !== null) && Q(e, "alias node should not have any properties")) : N6(e, v, ho === n) && (l = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : s === 0 && (l = c && Fd(e, y))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && Q(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), p = 0, d = e.implicitTypes.length; p < d; p += 1)
      if (g = e.implicitTypes[p], g.resolve(e.result)) {
        e.result = g.construct(e.result), e.tag = g.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        break;
      }
  } else if (e.tag !== "!") {
    if (un.call(e.typeMap[e.kind || "fallback"], e.tag))
      g = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (g = null, m = e.typeMap.multi[e.kind || "fallback"], p = 0, d = m.length; p < d; p += 1)
        if (e.tag.slice(0, m[p].tag.length) === m[p].tag) {
          g = m[p];
          break;
        }
    g || Q(e, "unknown tag !<" + e.tag + ">"), e.result !== null && g.kind !== e.kind && Q(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + g.kind + '", not "' + e.kind + '"'), g.resolve(e.result, e.tag) ? (e.result = g.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : Q(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || l;
}
<<<<<<< HEAD
function readDocument(state2) {
  var documentStart = state2.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state2.version = null;
  state2.checkLineBreaks = state2.legacy;
  state2.tagMap = /* @__PURE__ */ Object.create(null);
  state2.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    skipSeparationSpace(state2, true, -1);
    ch = state2.input.charCodeAt(state2.position);
    if (state2.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state2.input.charCodeAt(++state2.position);
    _position = state2.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    directiveName = state2.input.slice(_position, state2.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state2, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      if (ch === 35) {
        do {
          ch = state2.input.charCodeAt(++state2.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state2.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      directiveArgs.push(state2.input.slice(_position, state2.position));
    }
    if (ch !== 0) readLineBreak(state2);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state2, directiveName, directiveArgs);
    } else {
      throwWarning(state2, 'unknown document directive "' + directiveName + '"');
=======
function H6(e) {
  var t = e.position, n, r, i, a = !1, o;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (o = e.input.charCodeAt(e.position)) !== 0 && (Re(e, !0, -1), o = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || o !== 37)); ) {
    for (a = !0, o = e.input.charCodeAt(++e.position), n = e.position; o !== 0 && !Ze(o); )
      o = e.input.charCodeAt(++e.position);
    for (r = e.input.slice(n, e.position), i = [], r.length < 1 && Q(e, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; Un(o); )
        o = e.input.charCodeAt(++e.position);
      if (o === 35) {
        do
          o = e.input.charCodeAt(++e.position);
        while (o !== 0 && !St(o));
        break;
      }
      if (St(o)) break;
      for (n = e.position; o !== 0 && !Ze(o); )
        o = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(n, e.position));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    o !== 0 && ku(e), un.call(Pd, r) ? Pd[r](e, r, i) : vo(e, 'unknown document directive "' + r + '"');
  }
<<<<<<< HEAD
  skipSeparationSpace(state2, true, -1);
  if (state2.lineIndent === 0 && state2.input.charCodeAt(state2.position) === 45 && state2.input.charCodeAt(state2.position + 1) === 45 && state2.input.charCodeAt(state2.position + 2) === 45) {
    state2.position += 3;
    skipSeparationSpace(state2, true, -1);
  } else if (hasDirectives) {
    throwError(state2, "directives end mark is expected");
  }
  composeNode(state2, state2.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state2, true, -1);
  if (state2.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state2.input.slice(documentStart, state2.position))) {
    throwWarning(state2, "non-ASCII line breaks are interpreted as content");
  }
  state2.documents.push(state2.result);
  if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
    if (state2.input.charCodeAt(state2.position) === 46) {
      state2.position += 3;
      skipSeparationSpace(state2, true, -1);
    }
=======
  if (Re(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, Re(e, !0, -1)) : a && Q(e, "directives end mark is expected"), Pr(e, e.lineIndent - 1, mo, !1, !0), Re(e, !0, -1), e.checkLineBreaks && C6.test(e.input.slice(t, e.position)) && vo(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && as(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, Re(e, !0, -1));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return;
  }
  if (e.position < e.length - 1)
    Q(e, "end of the stream or a document separator is expected");
  else
    return;
<<<<<<< HEAD
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state2 = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state2.position = nullpos;
    throwError(state2, "null byte is not allowed in input");
  }
  state2.input += "\0";
  while (state2.input.charCodeAt(state2.position) === 32) {
    state2.lineIndent += 1;
    state2.position += 1;
  }
  while (state2.position < state2.length - 1) {
    readDocument(state2);
  }
  return state2.documents;
}
function loadAll(input, iterator2, options) {
  if (iterator2 !== null && typeof iterator2 === "object" && typeof options === "undefined") {
    options = iterator2;
    iterator2 = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator2 !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator2(documents[index]);
  }
}
function load(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException$1("expected a single document in the stream, but found more");
}
loader$1.loadAll = loadAll;
loader$1.load = load;
var dumper$1 = {};
var common = common$5;
var YAMLException = exception;
var DEFAULT_SCHEMA = _default;
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
=======
}
function qg(e, t) {
  e = String(e), t = t || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var n = new F6(e, t), r = e.indexOf("\0");
  for (r !== -1 && (n.position = r, Q(n, "null byte is not allowed in input")), n.input += "\0"; n.input.charCodeAt(n.position) === 32; )
    n.lineIndent += 1, n.position += 1;
  for (; n.position < n.length - 1; )
    H6(n);
  return n.documents;
}
function G6(e, t, n) {
  t !== null && typeof t == "object" && typeof n > "u" && (n = t, t = null);
  var r = qg(e, n);
  if (typeof t != "function")
    return r;
  for (var i = 0, a = r.length; i < a; i += 1)
    t(r[i]);
}
function W6(e, t) {
  var n = qg(e, t);
  if (n.length !== 0) {
    if (n.length === 1)
      return n[0];
    throw new Fg("expected a single document in the stream, but found more");
  }
}
Du.loadAll = G6;
Du.load = W6;
var zg = {}, os = vt, Xi = Yi, V6 = Nu, Hg = Object.prototype.toString, Gg = Object.prototype.hasOwnProperty, Uu = 65279, Y6 = 9, wi = 10, X6 = 13, K6 = 32, J6 = 33, Z6 = 34, Tl = 35, Q6 = 37, eR = 38, tR = 39, nR = 42, Wg = 44, rR = 45, go = 58, iR = 61, aR = 62, oR = 63, sR = 64, Vg = 91, Yg = 93, cR = 96, Xg = 123, lR = 124, Kg = 125, Me = {};
Me[0] = "\\0";
Me[7] = "\\a";
Me[8] = "\\b";
Me[9] = "\\t";
Me[10] = "\\n";
Me[11] = "\\v";
Me[12] = "\\f";
Me[13] = "\\r";
Me[27] = "\\e";
Me[34] = '\\"';
Me[92] = "\\\\";
Me[133] = "\\N";
Me[160] = "\\_";
Me[8232] = "\\L";
Me[8233] = "\\P";
var uR = [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
<<<<<<< HEAD
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null) return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || DEFAULT_SCHEMA;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
=======
], pR = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function fR(e, t) {
  var n, r, i, a, o, c, s;
  if (t === null) return {};
  for (n = {}, r = Object.keys(t), i = 0, a = r.length; i < a; i += 1)
    o = r[i], c = String(t[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), s = e.compiledTypeMap.fallback[o], s && Gg.call(s.styleAliases, c) && (c = s.styleAliases[c]), n[o] = c;
  return n;
}
function dR(e) {
  var t, n, r;
  if (t = e.toString(16).toUpperCase(), e <= 255)
    n = "x", r = 2;
  else if (e <= 65535)
    n = "u", r = 4;
  else if (e <= 4294967295)
    n = "U", r = 8;
  else
    throw new Xi("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + n + os.repeat("0", r - t.length) + t;
}
var hR = 1, Ei = 2;
function mR(e) {
  this.schema = e.schema || V6, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = os.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = fR(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? Ei : hR, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer == "function" ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function Nd(e, t) {
  for (var n = os.repeat(" ", t), r = 0, i = -1, a = "", o, c = e.length; r < c; )
    i = e.indexOf(`
`, r), i === -1 ? (o = e.slice(r), r = c) : (o = e.slice(r, i + 1), r = i + 1), o.length && o !== `
` && (a += n), a += o;
  return a;
}
function Al(e, t) {
  return `
` + os.repeat(" ", e.indent * t);
}
<<<<<<< HEAD
function testImplicitResolving(state2, str2) {
  var index, length, type2;
  for (index = 0, length = state2.implicitTypes.length; index < length; index += 1) {
    type2 = state2.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
=======
function vR(e, t) {
  var n, r, i;
  for (n = 0, r = e.implicitTypes.length; n < r; n += 1)
    if (i = e.implicitTypes[n], i.resolve(t))
      return !0;
  return !1;
}
function xo(e) {
  return e === K6 || e === Y6;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function _i(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== Uu || 65536 <= e && e <= 1114111;
}
<<<<<<< HEAD
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
=======
function kd(e) {
  return _i(e) && e !== Uu && e !== X6 && e !== wi;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function Ld(e, t, n) {
  var r = kd(e), i = r && !xo(e);
  return (
    // ns-plain-safe
    (n ? (
      // c = flow-in
      r
    ) : r && e !== Wg && e !== Vg && e !== Yg && e !== Xg && e !== Kg) && e !== Tl && !(t === go && !i) || kd(t) && !xo(t) && e === Tl || t === go && i
  );
}
<<<<<<< HEAD
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
=======
function gR(e) {
  return _i(e) && e !== Uu && !xo(e) && e !== rR && e !== oR && e !== go && e !== Wg && e !== Vg && e !== Yg && e !== Xg && e !== Kg && e !== Tl && e !== eR && e !== nR && e !== J6 && e !== lR && e !== iR && e !== aR && e !== tR && e !== Z6 && e !== Q6 && e !== sR && e !== cR;
}
function xR(e) {
  return !xo(e) && e !== go;
}
function ni(e, t) {
  var n = e.charCodeAt(t), r;
  return n >= 55296 && n <= 56319 && t + 1 < e.length && (r = e.charCodeAt(t + 1), r >= 56320 && r <= 57343) ? (n - 55296) * 1024 + r - 56320 + 65536 : n;
}
function Jg(e) {
  var t = /^\n* /;
  return t.test(e);
}
var Zg = 1, Rl = 2, Qg = 3, ex = 4, pr = 5;
function yR(e, t, n, r, i, a, o, c) {
  var s, u = 0, l = null, p = !1, d = !1, m = r !== -1, g = -1, v = gR(ni(e, 0)) && xR(ni(e, e.length - 1));
  if (t || o)
    for (s = 0; s < e.length; u >= 65536 ? s += 2 : s++) {
      if (u = ni(e, s), !_i(u))
        return pr;
      v = v && Ld(u, l, c), l = u;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
  else {
    for (s = 0; s < e.length; u >= 65536 ? s += 2 : s++) {
      if (u = ni(e, s), u === wi)
        p = !0, m && (d = d || // Foldable line = too long, and not more-indented.
        s - g - 1 > r && e[g + 1] !== " ", g = s);
      else if (!_i(u))
        return pr;
      v = v && Ld(u, l, c), l = u;
    }
    d = d || m && s - g - 1 > r && e[g + 1] !== " ";
  }
  return !p && !d ? v && !o && !i(e) ? Zg : a === Ei ? pr : Rl : n > 9 && Jg(e) ? pr : o ? a === Ei ? pr : Rl : d ? ex : Qg;
}
<<<<<<< HEAD
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state2, string, level, iskey, inblock) {
  state2.dump = function() {
    if (string.length === 0) {
      return state2.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state2.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state2.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state2.indent * Math.max(1, level);
    var lineWidth = state2.lineWidth === -1 ? -1 : Math.max(Math.min(state2.lineWidth, 40), state2.lineWidth - indent);
    var singleLineOnly = iskey || state2.flowLevel > -1 && level >= state2.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state2, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state2.indent,
      lineWidth,
      testAmbiguity,
      state2.quotingType,
      state2.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
=======
function bR(e, t, n, r, i) {
  e.dump = function() {
    if (t.length === 0)
      return e.quotingType === Ei ? '""' : "''";
    if (!e.noCompatMode && (uR.indexOf(t) !== -1 || pR.test(t)))
      return e.quotingType === Ei ? '"' + t + '"' : "'" + t + "'";
    var a = e.indent * Math.max(1, n), o = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - a), c = r || e.flowLevel > -1 && n >= e.flowLevel;
    function s(u) {
      return vR(e, u);
    }
    switch (yR(
      t,
      c,
      e.indent,
      o,
      s,
      e.quotingType,
      e.forceQuotes && !r,
      i
    )) {
      case Zg:
        return t;
      case Rl:
        return "'" + t.replace(/'/g, "''") + "'";
      case Qg:
        return "|" + Ud(t, e.indent) + Bd(Nd(t, a));
      case ex:
        return ">" + Ud(t, e.indent) + Bd(Nd(wR(t, o), a));
      case pr:
        return '"' + ER(t) + '"';
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      default:
        throw new Xi("impossible error: invalid scalar style");
    }
  }();
}
function Ud(e, t) {
  var n = Jg(e) ? String(t) : "", r = e[e.length - 1] === `
`, i = r && (e[e.length - 2] === `
` || e === `
`), a = i ? "+" : r ? "" : "-";
  return n + a + `
`;
}
function Bd(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
<<<<<<< HEAD
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
=======
function wR(e, t) {
  for (var n = /(\n+)([^\n]*)/g, r = function() {
    var u = e.indexOf(`
`);
    return u = u !== -1 ? u : e.length, n.lastIndex = u, jd(e.slice(0, u), t);
  }(), i = e[0] === `
` || e[0] === " ", a, o; o = n.exec(e); ) {
    var c = o[1], s = o[2];
    a = s[0] === " ", r += c + (!i && !a && s !== "" ? `
` : "") + jd(s, t), i = a;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return r;
}
function jd(e, t) {
  if (e === "" || e[0] === " ") return e;
  for (var n = / [^ ]/g, r, i = 0, a, o = 0, c = 0, s = ""; r = n.exec(e); )
    c = r.index, c - i > t && (a = o > i ? o : c, s += `
` + e.slice(i, a), i = a + 1), o = c;
  return s += `
`, e.length - i > t && o > i ? s += e.slice(i, o) + `
` + e.slice(o + 1) : s += e.slice(i), s.slice(1);
}
<<<<<<< HEAD
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state2, level, object) {
  var _result = "", _tag = state2.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state2.replacer) {
      value = state2.replacer.call(object, String(index), value);
    }
    if (writeNode(state2, level, value, false, false) || typeof value === "undefined" && writeNode(state2, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state2.condenseFlow ? " " : "");
      _result += state2.dump;
    }
  }
  state2.tag = _tag;
  state2.dump = "[" + _result + "]";
}
function writeBlockSequence(state2, level, object, compact) {
  var _result = "", _tag = state2.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state2.replacer) {
      value = state2.replacer.call(object, String(index), value);
    }
    if (writeNode(state2, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state2, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state2, level);
=======
function ER(e) {
  for (var t = "", n = 0, r, i = 0; i < e.length; n >= 65536 ? i += 2 : i++)
    n = ni(e, i), r = Me[n], !r && _i(n) ? (t += e[i], n >= 65536 && (t += e[i + 1])) : t += r || dR(n);
  return t;
}
function _R(e, t, n) {
  var r = "", i = e.tag, a, o, c;
  for (a = 0, o = n.length; a < o; a += 1)
    c = n[a], e.replacer && (c = e.replacer.call(n, String(a), c)), (Lt(e, t, c, !1, !1) || typeof c > "u" && Lt(e, t, null, !1, !1)) && (r !== "" && (r += "," + (e.condenseFlow ? "" : " ")), r += e.dump);
  e.tag = i, e.dump = "[" + r + "]";
}
function Md(e, t, n, r) {
  var i = "", a = e.tag, o, c, s;
  for (o = 0, c = n.length; o < c; o += 1)
    s = n[o], e.replacer && (s = e.replacer.call(n, String(o), s)), (Lt(e, t + 1, s, !0, !0, !1, !0) || typeof s > "u" && Lt(e, t + 1, null, !0, !0, !1, !0)) && ((!r || i !== "") && (i += Al(e, t)), e.dump && wi === e.dump.charCodeAt(0) ? i += "-" : i += "- ", i += e.dump);
  e.tag = a, e.dump = i || "[]";
}
function SR(e, t, n) {
  var r = "", i = e.tag, a = Object.keys(n), o, c, s, u, l;
  for (o = 0, c = a.length; o < c; o += 1)
    l = "", r !== "" && (l += ", "), e.condenseFlow && (l += '"'), s = a[o], u = n[s], e.replacer && (u = e.replacer.call(n, s, u)), Lt(e, t, s, !1, !1) && (e.dump.length > 1024 && (l += "? "), l += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), Lt(e, t, u, !1, !1) && (l += e.dump, r += l));
  e.tag = i, e.dump = "{" + r + "}";
}
function TR(e, t, n, r) {
  var i = "", a = e.tag, o = Object.keys(n), c, s, u, l, p, d;
  if (e.sortKeys === !0)
    o.sort();
  else if (typeof e.sortKeys == "function")
    o.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new Xi("sortKeys must be a boolean or a function");
  for (c = 0, s = o.length; c < s; c += 1)
    d = "", (!r || i !== "") && (d += Al(e, t)), u = o[c], l = n[u], e.replacer && (l = e.replacer.call(n, u, l)), Lt(e, t + 1, u, !0, !0, !0) && (p = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, p && (e.dump && wi === e.dump.charCodeAt(0) ? d += "?" : d += "? "), d += e.dump, p && (d += Al(e, t)), Lt(e, t + 1, l, !0, p) && (e.dump && wi === e.dump.charCodeAt(0) ? d += ":" : d += ": ", d += e.dump, i += d));
  e.tag = a, e.dump = i || "{}";
}
function qd(e, t, n) {
  var r, i, a, o, c, s;
  for (i = n ? e.explicitTypes : e.implicitTypes, a = 0, o = i.length; a < o; a += 1)
    if (c = i[a], (c.instanceOf || c.predicate) && (!c.instanceOf || typeof t == "object" && t instanceof c.instanceOf) && (!c.predicate || c.predicate(t))) {
      if (n ? c.multi && c.representName ? e.tag = c.representName(t) : e.tag = c.tag : e.tag = "?", c.represent) {
        if (s = e.styleMap[c.tag] || c.defaultStyle, Hg.call(c.represent) === "[object Function]")
          r = c.represent(t, s);
        else if (Gg.call(c.represent, s))
          r = c.represent[s](t, s);
        else
          throw new Xi("!<" + c.tag + '> tag resolver accepts not "' + s + '" style');
        e.dump = r;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
      return !0;
    }
<<<<<<< HEAD
=======
  return !1;
}
function Lt(e, t, n, r, i, a, o) {
  e.tag = null, e.dump = n, qd(e, n, !1) || qd(e, n, !0);
  var c = Hg.call(e.dump), s = r, u;
  r && (r = e.flowLevel < 0 || e.flowLevel > t);
  var l = c === "[object Object]" || c === "[object Array]", p, d;
  if (l && (p = e.duplicates.indexOf(n), d = p !== -1), (e.tag !== null && e.tag !== "?" || d || e.indent !== 2 && t > 0) && (i = !1), d && e.usedDuplicates[p])
    e.dump = "*ref_" + p;
  else {
    if (l && d && !e.usedDuplicates[p] && (e.usedDuplicates[p] = !0), c === "[object Object]")
      r && Object.keys(e.dump).length !== 0 ? (TR(e, t, e.dump, i), d && (e.dump = "&ref_" + p + e.dump)) : (SR(e, t, e.dump), d && (e.dump = "&ref_" + p + " " + e.dump));
    else if (c === "[object Array]")
      r && e.dump.length !== 0 ? (e.noArrayIndent && !o && t > 0 ? Md(e, t - 1, e.dump, i) : Md(e, t, e.dump, i), d && (e.dump = "&ref_" + p + e.dump)) : (_R(e, t, e.dump), d && (e.dump = "&ref_" + p + " " + e.dump));
    else if (c === "[object String]")
      e.tag !== "?" && bR(e, e.dump, t, a, s);
    else {
      if (c === "[object Undefined]")
        return !1;
      if (e.skipInvalid) return !1;
      throw new Xi("unacceptable kind of an object to dump " + c);
    }
    e.tag !== null && e.tag !== "?" && (u = encodeURI(
      e.tag[0] === "!" ? e.tag.slice(1) : e.tag
    ).replace(/!/g, "%21"), e.tag[0] === "!" ? u = "!" + u : u.slice(0, 18) === "tag:yaml.org,2002:" ? u = "!!" + u.slice(18) : u = "!<" + u + ">", e.dump = u + " " + e.dump);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return !0;
}
<<<<<<< HEAD
function writeFlowMapping(state2, level, object) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state2.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state2.replacer) {
      objectValue = state2.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state2, level, objectKey, false, false)) {
      continue;
    }
    if (state2.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state2.dump + (state2.condenseFlow ? '"' : "") + ":" + (state2.condenseFlow ? "" : " ");
    if (!writeNode(state2, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state2.dump;
    _result += pairBuffer;
  }
  state2.tag = _tag;
  state2.dump = "{" + _result + "}";
=======
function AR(e, t) {
  var n = [], r = [], i, a;
  for (Cl(e, n, r), i = 0, a = r.length; i < a; i += 1)
    t.duplicates.push(n[r[i]]);
  t.usedDuplicates = new Array(a);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function Cl(e, t, n) {
  var r, i, a;
  if (e !== null && typeof e == "object")
    if (i = t.indexOf(e), i !== -1)
      n.indexOf(i) === -1 && n.push(i);
    else if (t.push(e), Array.isArray(e))
      for (i = 0, a = e.length; i < a; i += 1)
        Cl(e[i], t, n);
    else
      for (r = Object.keys(e), i = 0, a = r.length; i < a; i += 1)
        Cl(e[r[i]], t, n);
}
<<<<<<< HEAD
function detectType(state2, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state2.explicitTypes : state2.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state2.tag = type2.representName(object);
        } else {
          state2.tag = type2.tag;
        }
      } else {
        state2.tag = "?";
      }
      if (type2.represent) {
        style = state2.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state2.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state2, level, object, block, compact, iskey, isblockseq) {
  state2.tag = null;
  state2.dump = object;
  if (!detectType(state2, object, false)) {
    detectType(state2, object, true);
  }
  var type2 = _toString.call(state2.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state2.flowLevel < 0 || state2.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate2;
  if (objectOrArray) {
    duplicateIndex = state2.duplicates.indexOf(object);
    duplicate2 = duplicateIndex !== -1;
  }
  if (state2.tag !== null && state2.tag !== "?" || duplicate2 || state2.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate2 && state2.usedDuplicates[duplicateIndex]) {
    state2.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate2 && !state2.usedDuplicates[duplicateIndex]) {
      state2.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state2.dump).length !== 0) {
        writeBlockMapping(state2, level, state2.dump, compact);
        if (duplicate2) {
          state2.dump = "&ref_" + duplicateIndex + state2.dump;
        }
      } else {
        writeFlowMapping(state2, level, state2.dump);
        if (duplicate2) {
          state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state2.dump.length !== 0) {
        if (state2.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state2, level - 1, state2.dump, compact);
        } else {
          writeBlockSequence(state2, level, state2.dump, compact);
        }
        if (duplicate2) {
          state2.dump = "&ref_" + duplicateIndex + state2.dump;
        }
      } else {
        writeFlowSequence(state2, level, state2.dump);
        if (duplicate2) {
          state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state2.tag !== "?") {
        writeScalar(state2, state2.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state2.skipInvalid) return false;
      throw new YAMLException("unacceptable kind of an object to dump " + type2);
    }
    if (state2.tag !== null && state2.tag !== "?") {
      tagStr = encodeURI(
        state2.tag[0] === "!" ? state2.tag.slice(1) : state2.tag
      ).replace(/!/g, "%21");
      if (state2.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state2.dump = tagStr + " " + state2.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state2) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state2.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state2.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump(input, options) {
  options = options || {};
  var state2 = new State(options);
  if (!state2.noRefs) getDuplicateReferences(input, state2);
  var value = input;
  if (state2.replacer) {
    value = state2.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state2, 0, value, true, true)) return state2.dump + "\n";
  return "";
}
dumper$1.dump = dump;
var loader = loader$1;
var dumper = dumper$1;
function renamed(from, to) {
=======
function RR(e, t) {
  t = t || {};
  var n = new mR(t);
  n.noRefs || AR(e, n);
  var r = e;
  return n.replacer && (r = n.replacer.call({ "": r }, "", r)), Lt(n, 0, r, !0, !0) ? n.dump + `
` : "";
}
zg.dump = RR;
var tx = Du, CR = zg;
function Bu(e, t) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  return function() {
    throw new Error("Function yaml." + e + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.");
  };
}
<<<<<<< HEAD
jsYaml.Type = type;
jsYaml.Schema = schema;
jsYaml.FAILSAFE_SCHEMA = failsafe;
jsYaml.JSON_SCHEMA = json;
jsYaml.CORE_SCHEMA = core;
jsYaml.DEFAULT_SCHEMA = _default;
jsYaml.load = loader.load;
jsYaml.loadAll = loader.loadAll;
jsYaml.dump = dumper.dump;
jsYaml.YAMLException = exception;
jsYaml.types = {
  binary,
  float,
  map,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
jsYaml.safeLoad = renamed("safeLoad", "load");
jsYaml.safeLoadAll = renamed("safeLoadAll", "loadAll");
jsYaml.safeDump = renamed("safeDump", "dump");
var main = {};
Object.defineProperty(main, "__esModule", { value: true });
main.Lazy = void 0;
class Lazy {
  constructor(creator) {
    this._value = null;
    this.creator = creator;
=======
Ue.Type = Ye;
Ue.Schema = hg;
Ue.FAILSAFE_SCHEMA = xg;
Ue.JSON_SCHEMA = Sg;
Ue.CORE_SCHEMA = Tg;
Ue.DEFAULT_SCHEMA = Nu;
Ue.load = tx.load;
Ue.loadAll = tx.loadAll;
Ue.dump = CR.dump;
Ue.YAMLException = Yi;
Ue.types = {
  binary: $g,
  float: _g,
  map: gg,
  null: yg,
  pairs: Pg,
  set: Dg,
  timestamp: Cg,
  bool: bg,
  int: wg,
  merge: Og,
  omap: Ig,
  seq: vg,
  str: mg
};
Ue.safeLoad = Bu("safeLoad", "load");
Ue.safeLoadAll = Bu("safeLoadAll", "loadAll");
Ue.safeDump = Bu("safeDump", "dump");
var ss = {};
Object.defineProperty(ss, "__esModule", { value: !0 });
ss.Lazy = void 0;
class OR {
  constructor(t) {
    this._value = null, this.creator = t;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  get hasValue() {
    return this.creator == null;
  }
  get value() {
    if (this.creator == null)
      return this._value;
    const t = this.creator();
    return this.value = t, t;
  }
  set value(t) {
    this._value = t, this.creator = null;
  }
}
<<<<<<< HEAD
main.Lazy = Lazy;
var re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$1 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6;
const RELEASE_TYPES = [
=======
ss.Lazy = OR;
var Ol = { exports: {} };
const $R = "2.0.0", nx = 256, IR = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, PR = 16, DR = nx - 6, FR = [
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
<<<<<<< HEAD
var constants$1 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$1 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$1;
(function(module, exports) {
=======
var cs = {
  MAX_LENGTH: nx,
  MAX_SAFE_COMPONENT_LENGTH: PR,
  MAX_SAFE_BUILD_LENGTH: DR,
  MAX_SAFE_INTEGER: IR,
  RELEASE_TYPES: FR,
  SEMVER_SPEC_VERSION: $R,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const NR = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var ls = NR;
(function(e, t) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  const {
    MAX_SAFE_COMPONENT_LENGTH: n,
    MAX_SAFE_BUILD_LENGTH: r,
    MAX_LENGTH: i
  } = cs, a = ls;
  t = e.exports = {};
  const o = t.re = [], c = t.safeRe = [], s = t.src = [], u = t.safeSrc = [], l = t.t = {};
  let p = 0;
  const d = "[a-zA-Z0-9-]", m = [
    ["\\s", 1],
    ["\\d", i],
    [d, r]
  ], g = (y) => {
    for (const [x, w] of m)
      y = y.split(`${x}*`).join(`${x}{0,${w}}`).split(`${x}+`).join(`${x}{1,${w}}`);
    return y;
  }, v = (y, x, w) => {
    const A = g(x), O = p++;
    a(y, O, x), l[y] = O, s[O] = x, u[O] = A, o[O] = new RegExp(x, w ? "g" : void 0), c[O] = new RegExp(A, w ? "g" : void 0);
  };
<<<<<<< HEAD
  const createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R++;
    debug2(name, index, value);
    t2[name] = index;
    src2[index] = value;
    safeSrc[index] = safe;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})\\.(${src2[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src2[t2.NONNUMERICIDENTIFIER]}|${src2[t2.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t2.NONNUMERICIDENTIFIER]}|${src2[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src2[t2.PRERELEASEIDENTIFIER]}(?:\\.${src2[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src2[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src2[t2.BUILDIDENTIFIER]}(?:\\.${src2[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src2[t2.MAINVERSION]}${src2[t2.PRERELEASE]}?${src2[t2.BUILD]}?`);
  createToken("FULL", `^${src2[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src2[t2.MAINVERSIONLOOSE]}${src2[t2.PRERELEASELOOSE]}?${src2[t2.BUILD]}?`);
  createToken("LOOSE", `^${src2[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src2[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src2[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:\\.(${src2[t2.XRANGEIDENTIFIER]})(?:${src2[t2.PRERELEASE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t2.XRANGEIDENTIFIERLOOSE]})(?:${src2[t2.PRERELEASELOOSE]})?${src2[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src2[t2.GTLT]}\\s*${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?`);
  createToken("COERCE", `${src2[t2.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src2[t2.COERCEPLAIN] + `(?:${src2[t2.PRERELEASE]})?(?:${src2[t2.BUILD]})?(?:$|[^\\d])`);
  createToken("COERCERTL", src2[t2.COERCE], true);
  createToken("COERCERTLFULL", src2[t2.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src2[t2.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src2[t2.LONETILDE]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src2[t2.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src2[t2.LONECARET]}${src2[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src2[t2.GTLT]}\\s*(${src2[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src2[t2.GTLT]}\\s*(${src2[t2.LOOSEPLAIN]}|${src2[t2.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src2[t2.XRANGEPLAIN]})\\s+-\\s+(${src2[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src2[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src2[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({ loose: true });
const emptyOpts = Object.freeze({});
const parseOptions$1 = (options) => {
  if (!options) {
    return emptyOpts;
  }
  if (typeof options !== "object") {
    return looseOption;
  }
  return options;
};
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug = debug_1;
const { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$1;
const { safeRe: re$1, t: t$1 } = reExports;
const parseOptions = parseOptions_1;
const { compareIdentifiers } = identifiers$1;
let SemVer$d = class SemVer {
  constructor(version, options) {
    options = parseOptions(options);
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
=======
  v("NUMERICIDENTIFIER", "0|[1-9]\\d*"), v("NUMERICIDENTIFIERLOOSE", "\\d+"), v("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${d}*`), v("MAINVERSION", `(${s[l.NUMERICIDENTIFIER]})\\.(${s[l.NUMERICIDENTIFIER]})\\.(${s[l.NUMERICIDENTIFIER]})`), v("MAINVERSIONLOOSE", `(${s[l.NUMERICIDENTIFIERLOOSE]})\\.(${s[l.NUMERICIDENTIFIERLOOSE]})\\.(${s[l.NUMERICIDENTIFIERLOOSE]})`), v("PRERELEASEIDENTIFIER", `(?:${s[l.NONNUMERICIDENTIFIER]}|${s[l.NUMERICIDENTIFIER]})`), v("PRERELEASEIDENTIFIERLOOSE", `(?:${s[l.NONNUMERICIDENTIFIER]}|${s[l.NUMERICIDENTIFIERLOOSE]})`), v("PRERELEASE", `(?:-(${s[l.PRERELEASEIDENTIFIER]}(?:\\.${s[l.PRERELEASEIDENTIFIER]})*))`), v("PRERELEASELOOSE", `(?:-?(${s[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s[l.PRERELEASEIDENTIFIERLOOSE]})*))`), v("BUILDIDENTIFIER", `${d}+`), v("BUILD", `(?:\\+(${s[l.BUILDIDENTIFIER]}(?:\\.${s[l.BUILDIDENTIFIER]})*))`), v("FULLPLAIN", `v?${s[l.MAINVERSION]}${s[l.PRERELEASE]}?${s[l.BUILD]}?`), v("FULL", `^${s[l.FULLPLAIN]}$`), v("LOOSEPLAIN", `[v=\\s]*${s[l.MAINVERSIONLOOSE]}${s[l.PRERELEASELOOSE]}?${s[l.BUILD]}?`), v("LOOSE", `^${s[l.LOOSEPLAIN]}$`), v("GTLT", "((?:<|>)?=?)"), v("XRANGEIDENTIFIERLOOSE", `${s[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), v("XRANGEIDENTIFIER", `${s[l.NUMERICIDENTIFIER]}|x|X|\\*`), v("XRANGEPLAIN", `[v=\\s]*(${s[l.XRANGEIDENTIFIER]})(?:\\.(${s[l.XRANGEIDENTIFIER]})(?:\\.(${s[l.XRANGEIDENTIFIER]})(?:${s[l.PRERELEASE]})?${s[l.BUILD]}?)?)?`), v("XRANGEPLAINLOOSE", `[v=\\s]*(${s[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[l.XRANGEIDENTIFIERLOOSE]})(?:${s[l.PRERELEASELOOSE]})?${s[l.BUILD]}?)?)?`), v("XRANGE", `^${s[l.GTLT]}\\s*${s[l.XRANGEPLAIN]}$`), v("XRANGELOOSE", `^${s[l.GTLT]}\\s*${s[l.XRANGEPLAINLOOSE]}$`), v("COERCEPLAIN", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?`), v("COERCE", `${s[l.COERCEPLAIN]}(?:$|[^\\d])`), v("COERCEFULL", s[l.COERCEPLAIN] + `(?:${s[l.PRERELEASE]})?(?:${s[l.BUILD]})?(?:$|[^\\d])`), v("COERCERTL", s[l.COERCE], !0), v("COERCERTLFULL", s[l.COERCEFULL], !0), v("LONETILDE", "(?:~>?)"), v("TILDETRIM", `(\\s*)${s[l.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", v("TILDE", `^${s[l.LONETILDE]}${s[l.XRANGEPLAIN]}$`), v("TILDELOOSE", `^${s[l.LONETILDE]}${s[l.XRANGEPLAINLOOSE]}$`), v("LONECARET", "(?:\\^)"), v("CARETTRIM", `(\\s*)${s[l.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", v("CARET", `^${s[l.LONECARET]}${s[l.XRANGEPLAIN]}$`), v("CARETLOOSE", `^${s[l.LONECARET]}${s[l.XRANGEPLAINLOOSE]}$`), v("COMPARATORLOOSE", `^${s[l.GTLT]}\\s*(${s[l.LOOSEPLAIN]})$|^$`), v("COMPARATOR", `^${s[l.GTLT]}\\s*(${s[l.FULLPLAIN]})$|^$`), v("COMPARATORTRIM", `(\\s*)${s[l.GTLT]}\\s*(${s[l.LOOSEPLAIN]}|${s[l.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", v("HYPHENRANGE", `^\\s*(${s[l.XRANGEPLAIN]})\\s+-\\s+(${s[l.XRANGEPLAIN]})\\s*$`), v("HYPHENRANGELOOSE", `^\\s*(${s[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${s[l.XRANGEPLAINLOOSE]})\\s*$`), v("STAR", "(<|>)?=?\\s*\\*"), v("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), v("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Ol, Ol.exports);
var Ki = Ol.exports;
const kR = Object.freeze({ loose: !0 }), LR = Object.freeze({}), UR = (e) => e ? typeof e != "object" ? kR : e : LR;
var ju = UR;
const zd = /^[0-9]+$/, rx = (e, t) => {
  const n = zd.test(e), r = zd.test(t);
  return n && r && (e = +e, t = +t), e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1;
}, BR = (e, t) => rx(t, e);
var ix = {
  compareIdentifiers: rx,
  rcompareIdentifiers: BR
};
const Ca = ls, { MAX_LENGTH: Hd, MAX_SAFE_INTEGER: Oa } = cs, { safeRe: $a, t: Ia } = Ki, jR = ju, { compareIdentifiers: rr } = ix;
let MR = class Et {
  constructor(t, n) {
    if (n = jR(n), t instanceof Et) {
      if (t.loose === !!n.loose && t.includePrerelease === !!n.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > Hd)
      throw new TypeError(
        `version is longer than ${Hd} characters`
      );
    Ca("SemVer", t, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
    const r = t.trim().match(n.loose ? $a[Ia.LOOSE] : $a[Ia.FULL]);
    if (!r)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > Oa || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Oa || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Oa || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4] ? this.prerelease = r[4].split(".").map((i) => {
      if (/^[0-9]+$/.test(i)) {
        const a = +i;
        if (a >= 0 && a < Oa)
          return a;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
      return i;
    }) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
<<<<<<< HEAD
  compare(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer(other, this.options);
    }
    if (other.version === this.version) {
=======
  compare(t) {
    if (Ca("SemVer.compare", this.version, this.options, t), !(t instanceof Et)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new Et(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof Et || (t = new Et(t, this.options)), rr(this.major, t.major) || rr(this.minor, t.minor) || rr(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof Et || (t = new Et(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      return 0;
    let n = 0;
    do {
      const r = this.prerelease[n], i = t.prerelease[n];
      if (Ca("prerelease compare", n, r, i), r === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === i)
        continue;
      return rr(r, i);
    } while (++n);
  }
<<<<<<< HEAD
  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i = 0;
=======
  compareBuild(t) {
    t instanceof Et || (t = new Et(t, this.options));
    let n = 0;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    do {
      const r = this.build[n], i = t.build[n];
      if (Ca("build compare", n, r, i), r === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (r === void 0)
        return -1;
      if (r === i)
        continue;
      return rr(r, i);
    } while (++n);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, n, r) {
    if (t.startsWith("pre")) {
      if (!n && r === !1)
        throw new Error("invalid increment argument: identifier is empty");
      if (n) {
        const i = `-${n}`.match(this.options.loose ? $a[Ia.PRERELEASELOOSE] : $a[Ia.PRERELEASE]);
        if (!i || i[1] !== n)
          throw new Error(`invalid identifier: ${n}`);
      }
    }
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n, r);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n, r);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", n, r), this.inc("pre", n, r);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", n, r), this.inc("pre", n, r);
        break;
      case "release":
        if (this.prerelease.length === 0)
          throw new Error(`version ${this.raw} is not a prerelease`);
        this.prerelease.length = 0;
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const i = Number(r) ? 1 : 0;
        if (this.prerelease.length === 0)
          this.prerelease = [i];
        else {
          let a = this.prerelease.length;
          for (; --a >= 0; )
            typeof this.prerelease[a] == "number" && (this.prerelease[a]++, a = -2);
          if (a === -1) {
            if (n === this.prerelease.join(".") && r === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(i);
          }
        }
        if (n) {
          let a = [n, i];
          r === !1 && (a = [n]), rr(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = a) : this.prerelease = a;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
<<<<<<< HEAD
var semver$2 = SemVer$d;
const SemVer$c = semver$2;
const parse$6 = (version, options, throwErrors = false) => {
  if (version instanceof SemVer$c) {
    return version;
  }
=======
var Xe = MR;
const Gd = Xe, qR = (e, t, n = !1) => {
  if (e instanceof Gd)
    return e;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    return new Gd(e, t);
  } catch (r) {
    if (!n)
      return null;
    throw r;
  }
};
<<<<<<< HEAD
var parse_1 = parse$6;
const parse$5 = parse_1;
const valid$2 = (version, options) => {
  const v = parse$5(version, options);
  return v ? v.version : null;
};
var valid_1 = valid$2;
const parse$4 = parse_1;
const clean$1 = (version, options) => {
  const s = parse$4(version.trim().replace(/^[=v]+/, ""), options);
  return s ? s.version : null;
};
var clean_1 = clean$1;
const SemVer$b = semver$2;
const inc$1 = (version, release, options, identifier, identifierBase) => {
  if (typeof options === "string") {
    identifierBase = identifier;
    identifier = options;
    options = void 0;
  }
=======
var Ur = qR;
const zR = Ur, HR = (e, t) => {
  const n = zR(e, t);
  return n ? n.version : null;
};
var GR = HR;
const WR = Ur, VR = (e, t) => {
  const n = WR(e.trim().replace(/^[=v]+/, ""), t);
  return n ? n.version : null;
};
var YR = VR;
const Wd = Xe, XR = (e, t, n, r, i) => {
  typeof n == "string" && (i = r, r = n, n = void 0);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    return new Wd(
      e instanceof Wd ? e.version : e,
      n
    ).inc(t, r, i).version;
  } catch {
    return null;
  }
};
<<<<<<< HEAD
var inc_1 = inc$1;
const parse$3 = parse_1;
const diff$1 = (version1, version2) => {
  const v1 = parse$3(version1, null, true);
  const v2 = parse$3(version2, null, true);
  const comparison = v1.compare(v2);
  if (comparison === 0) {
=======
var KR = XR;
const Vd = Ur, JR = (e, t) => {
  const n = Vd(e, null, !0), r = Vd(t, null, !0), i = n.compare(r);
  if (i === 0)
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return null;
  const a = i > 0, o = a ? n : r, c = a ? r : n, s = !!o.prerelease.length;
  if (!!c.prerelease.length && !s) {
    if (!c.patch && !c.minor)
      return "major";
    if (c.compareMain(o) === 0)
      return c.minor && !c.patch ? "minor" : "patch";
  }
  const l = s ? "pre" : "";
  return n.major !== r.major ? l + "major" : n.minor !== r.minor ? l + "minor" : n.patch !== r.patch ? l + "patch" : "prerelease";
};
<<<<<<< HEAD
var diff_1 = diff$1;
const SemVer$a = semver$2;
const major$1 = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major$1;
const SemVer$9 = semver$2;
const minor$1 = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$2;
const patch$1 = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch$1;
const parse$2 = parse_1;
const prerelease$1 = (version, options) => {
  const parsed = parse$2(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$2;
const compare$b = (a, b, loose) => new SemVer$7(a, loose).compare(new SemVer$7(b, loose));
var compare_1 = compare$b;
const compare$a = compare_1;
const rcompare$1 = (a, b, loose) => compare$a(b, a, loose);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1;
const compareLoose$1 = (a, b) => compare$9(a, b, true);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$2;
const compareBuild$3 = (a, b, loose) => {
  const versionA = new SemVer$6(a, loose);
  const versionB = new SemVer$6(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$2(a, b, loose));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$1(b, a, loose));
var rsort_1 = rsort$1;
const compare$8 = compare_1;
const gt$4 = (a, b, loose) => compare$8(a, b, loose) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1;
const lt$3 = (a, b, loose) => compare$7(a, b, loose) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1;
const eq$2 = (a, b, loose) => compare$6(a, b, loose) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1;
const neq$2 = (a, b, loose) => compare$5(a, b, loose) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1;
const gte$3 = (a, b, loose) => compare$4(a, b, loose) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1;
const lte$3 = (a, b, loose) => compare$3(a, b, loose) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1;
const neq$1 = neq_1;
const gt$3 = gt_1;
const gte$2 = gte_1;
const lt$2 = lt_1;
const lte$2 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
=======
var ZR = JR;
const QR = Xe, eC = (e, t) => new QR(e, t).major;
var tC = eC;
const nC = Xe, rC = (e, t) => new nC(e, t).minor;
var iC = rC;
const aC = Xe, oC = (e, t) => new aC(e, t).patch;
var sC = oC;
const cC = Ur, lC = (e, t) => {
  const n = cC(e, t);
  return n && n.prerelease.length ? n.prerelease : null;
};
var uC = lC;
const Yd = Xe, pC = (e, t, n) => new Yd(e, n).compare(new Yd(t, n));
var gt = pC;
const fC = gt, dC = (e, t, n) => fC(t, e, n);
var hC = dC;
const mC = gt, vC = (e, t) => mC(e, t, !0);
var gC = vC;
const Xd = Xe, xC = (e, t, n) => {
  const r = new Xd(e, n), i = new Xd(t, n);
  return r.compare(i) || r.compareBuild(i);
};
var Mu = xC;
const yC = Mu, bC = (e, t) => e.sort((n, r) => yC(n, r, t));
var wC = bC;
const EC = Mu, _C = (e, t) => e.sort((n, r) => EC(r, n, t));
var SC = _C;
const TC = gt, AC = (e, t, n) => TC(e, t, n) > 0;
var us = AC;
const RC = gt, CC = (e, t, n) => RC(e, t, n) < 0;
var qu = CC;
const OC = gt, $C = (e, t, n) => OC(e, t, n) === 0;
var ax = $C;
const IC = gt, PC = (e, t, n) => IC(e, t, n) !== 0;
var ox = PC;
const DC = gt, FC = (e, t, n) => DC(e, t, n) >= 0;
var zu = FC;
const NC = gt, kC = (e, t, n) => NC(e, t, n) <= 0;
var Hu = kC;
const LC = ax, UC = ox, BC = us, jC = zu, MC = qu, qC = Hu, zC = (e, t, n, r) => {
  switch (t) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    case "===":
      return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e === n;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e !== n;
    case "":
    case "=":
    case "==":
<<<<<<< HEAD
      return eq$1(a, b, loose);
    case "!=":
      return neq$1(a, b, loose);
    case ">":
      return gt$3(a, b, loose);
    case ">=":
      return gte$2(a, b, loose);
    case "<":
      return lt$2(a, b, loose);
    case "<=":
      return lte$2(a, b, loose);
=======
      return LC(e, n, r);
    case "!=":
      return UC(e, n, r);
    case ">":
      return BC(e, n, r);
    case ">=":
      return jC(e, n, r);
    case "<":
      return MC(e, n, r);
    case "<=":
      return qC(e, n, r);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
<<<<<<< HEAD
var cmp_1 = cmp$1;
const SemVer$5 = semver$2;
const parse$1 = parse_1;
const { safeRe: re, t } = reExports;
const coerce$1 = (version, options) => {
  if (version instanceof SemVer$5) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
=======
var sx = zC;
const HC = Xe, GC = Ur, { safeRe: Pa, t: Da } = Ki, WC = (e, t) => {
  if (e instanceof HC)
    return e;
  if (typeof e == "number" && (e = String(e)), typeof e != "string")
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return null;
  t = t || {};
  let n = null;
  if (!t.rtl)
    n = e.match(t.includePrerelease ? Pa[Da.COERCEFULL] : Pa[Da.COERCE]);
  else {
    const s = t.includePrerelease ? Pa[Da.COERCERTLFULL] : Pa[Da.COERCERTL];
    let u;
    for (; (u = s.exec(e)) && (!n || n.index + n[0].length !== e.length); )
      (!n || u.index + u[0].length !== n.index + n[0].length) && (n = u), s.lastIndex = u.index + u[1].length + u[2].length;
    s.lastIndex = -1;
  }
<<<<<<< HEAD
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  } else {
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    let next;
    while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
    }
    coerceRtlRegex.lastIndex = -1;
  }
  if (match === null) {
    return null;
  }
  const major2 = match[2];
  const minor2 = match[3] || "0";
  const patch2 = match[4] || "0";
  const prerelease2 = options.includePrerelease && match[5] ? `-${match[5]}` : "";
  const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
  return parse$1(`${major2}.${minor2}.${patch2}${prerelease2}${build}`, options);
};
var coerce_1 = coerce$1;
class LRUCache {
  constructor() {
    this.max = 1e3;
    this.map = /* @__PURE__ */ new Map();
  }
  get(key2) {
    const value = this.map.get(key2);
    if (value === void 0) {
      return void 0;
    } else {
      this.map.delete(key2);
      this.map.set(key2, value);
      return value;
    }
  }
  delete(key2) {
    return this.map.delete(key2);
  }
  set(key2, value) {
    const deleted = this.delete(key2);
    if (!deleted && value !== void 0) {
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value;
        this.delete(firstKey);
      }
      this.map.set(key2, value);
=======
  if (n === null)
    return null;
  const r = n[2], i = n[3] || "0", a = n[4] || "0", o = t.includePrerelease && n[5] ? `-${n[5]}` : "", c = t.includePrerelease && n[6] ? `+${n[6]}` : "";
  return GC(`${r}.${i}.${a}${o}${c}`, t);
};
var VC = WC;
class YC {
  constructor() {
    this.max = 1e3, this.map = /* @__PURE__ */ new Map();
  }
  get(t) {
    const n = this.map.get(t);
    if (n !== void 0)
      return this.map.delete(t), this.map.set(t, n), n;
  }
  delete(t) {
    return this.map.delete(t);
  }
  set(t, n) {
    if (!this.delete(t) && n !== void 0) {
      if (this.map.size >= this.max) {
        const i = this.map.keys().next().value;
        this.delete(i);
      }
      this.map.set(t, n);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    return this;
  }
}
<<<<<<< HEAD
var lrucache = LRUCache;
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  const SPACE_CHARACTERS = /\s+/g;
  class Range2 {
    constructor(range2, options) {
      options = parseOptions2(options);
      if (range2 instanceof Range2) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range2(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator2) {
        this.raw = range2.value;
        this.set = [[range2]];
        this.formatted = void 0;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
      if (!this.set.length) {
=======
var XC = YC, Nc, Kd;
function xt() {
  if (Kd) return Nc;
  Kd = 1;
  const e = /\s+/g;
  class t {
    constructor($, D) {
      if (D = i(D), $ instanceof t)
        return $.loose === !!D.loose && $.includePrerelease === !!D.includePrerelease ? $ : new t($.raw, D);
      if ($ instanceof a)
        return this.raw = $.value, this.set = [[$]], this.formatted = void 0, this;
      if (this.options = D, this.loose = !!D.loose, this.includePrerelease = !!D.includePrerelease, this.raw = $.trim().replace(e, " "), this.set = this.raw.split("||").map((b) => this.parseRange(b.trim())).filter((b) => b.length), !this.set.length)
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const b = this.set[0];
        if (this.set = this.set.filter((E) => !v(E[0])), this.set.length === 0)
          this.set = [b];
        else if (this.set.length > 1) {
          for (const E of this.set)
            if (E.length === 1 && y(E[0])) {
              this.set = [E];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let $ = 0; $ < this.set.length; $++) {
          $ > 0 && (this.formatted += "||");
          const D = this.set[$];
          for (let b = 0; b < D.length; b++)
            b > 0 && (this.formatted += " "), this.formatted += D[b].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange($) {
      const b = ((this.options.includePrerelease && m) | (this.options.loose && g)) + ":" + $, E = r.get(b);
      if (E)
        return E;
      const R = this.options.loose, N = R ? s[u.HYPHENRANGELOOSE] : s[u.HYPHENRANGE];
      $ = $.replace(N, J(this.options.includePrerelease)), o("hyphen replace", $), $ = $.replace(s[u.COMPARATORTRIM], l), o("comparator trim", $), $ = $.replace(s[u.TILDETRIM], p), o("tilde trim", $), $ = $.replace(s[u.CARETTRIM], d), o("caret trim", $);
      let L = $.split(" ").map((M) => w(M, this.options)).join(" ").split(/\s+/).map((M) => j(M, this.options));
      R && (L = L.filter((M) => (o("loose invalid filter", M, this.options), !!M.match(s[u.COMPARATORLOOSE])))), o("range list", L);
      const B = /* @__PURE__ */ new Map(), K = L.map((M) => new a(M, this.options));
      for (const M of K) {
        if (v(M))
          return [M];
        B.set(M.value, M);
      }
      B.size > 1 && B.has("") && B.delete("");
      const Z = [...B.values()];
      return r.set(b, Z), Z;
    }
    intersects($, D) {
      if (!($ instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((b) => x(b, D) && $.set.some((E) => x(E, D) && b.every((R) => E.every((N) => R.intersects(N, D)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test($) {
      if (!$)
        return !1;
      if (typeof $ == "string")
        try {
          $ = new c($, this.options);
        } catch {
          return !1;
        }
      for (let D = 0; D < this.set.length; D++)
        if (ne(this.set[D], $, this.options))
          return !0;
      return !1;
    }
  }
<<<<<<< HEAD
  range = Range2;
  const LRU = lrucache;
  const cache = new LRU();
  const parseOptions2 = parseOptions_1;
  const Comparator2 = requireComparator();
  const debug2 = debug_1;
  const SemVer3 = semver$2;
  const {
    safeRe: re2,
    t: t2,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = reExports;
  const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = constants$1;
  const isNullSet = (c) => c.value === "<0.0.0-0";
  const isAny = (c) => c.value === "";
  const isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
=======
  Nc = t;
  const n = XC, r = new n(), i = ju, a = ps(), o = ls, c = Xe, {
    safeRe: s,
    t: u,
    comparatorTrimReplace: l,
    tildeTrimReplace: p,
    caretTrimReplace: d
  } = Ki, { FLAG_INCLUDE_PRERELEASE: m, FLAG_LOOSE: g } = cs, v = (F) => F.value === "<0.0.0-0", y = (F) => F.value === "", x = (F, $) => {
    let D = !0;
    const b = F.slice();
    let E = b.pop();
    for (; D && b.length; )
      D = b.every((R) => E.intersects(R, $)), E = b.pop();
    return D;
  }, w = (F, $) => (o("comp", F, $), F = q(F, $), o("caret", F), F = O(F, $), o("tildes", F), F = te(F, $), o("xrange", F), F = H(F, $), o("stars", F), F), A = (F) => !F || F.toLowerCase() === "x" || F === "*", O = (F, $) => F.trim().split(/\s+/).map((D) => k(D, $)).join(" "), k = (F, $) => {
    const D = $.loose ? s[u.TILDELOOSE] : s[u.TILDE];
    return F.replace(D, (b, E, R, N, L) => {
      o("tilde", F, b, E, R, N, L);
      let B;
      return A(E) ? B = "" : A(R) ? B = `>=${E}.0.0 <${+E + 1}.0.0-0` : A(N) ? B = `>=${E}.${R}.0 <${E}.${+R + 1}.0-0` : L ? (o("replaceTilde pr", L), B = `>=${E}.${R}.${N}-${L} <${E}.${+R + 1}.0-0`) : B = `>=${E}.${R}.${N} <${E}.${+R + 1}.0-0`, o("tilde return", B), B;
    });
  }, q = (F, $) => F.trim().split(/\s+/).map((D) => W(D, $)).join(" "), W = (F, $) => {
    o("caret", F, $);
    const D = $.loose ? s[u.CARETLOOSE] : s[u.CARET], b = $.includePrerelease ? "-0" : "";
    return F.replace(D, (E, R, N, L, B) => {
      o("caret", F, E, R, N, L, B);
      let K;
      return A(R) ? K = "" : A(N) ? K = `>=${R}.0.0${b} <${+R + 1}.0.0-0` : A(L) ? R === "0" ? K = `>=${R}.${N}.0${b} <${R}.${+N + 1}.0-0` : K = `>=${R}.${N}.0${b} <${+R + 1}.0.0-0` : B ? (o("replaceCaret pr", B), R === "0" ? N === "0" ? K = `>=${R}.${N}.${L}-${B} <${R}.${N}.${+L + 1}-0` : K = `>=${R}.${N}.${L}-${B} <${R}.${+N + 1}.0-0` : K = `>=${R}.${N}.${L}-${B} <${+R + 1}.0.0-0`) : (o("no pr"), R === "0" ? N === "0" ? K = `>=${R}.${N}.${L}${b} <${R}.${N}.${+L + 1}-0` : K = `>=${R}.${N}.${L}${b} <${R}.${+N + 1}.0-0` : K = `>=${R}.${N}.${L} <${+R + 1}.0.0-0`), o("caret return", K), K;
    });
  }, te = (F, $) => (o("replaceXRanges", F, $), F.split(/\s+/).map((D) => T(D, $)).join(" ")), T = (F, $) => {
    F = F.trim();
    const D = $.loose ? s[u.XRANGELOOSE] : s[u.XRANGE];
    return F.replace(D, (b, E, R, N, L, B) => {
      o("xRange", F, b, E, R, N, L, B);
      const K = A(R), Z = K || A(N), M = Z || A(L), le = M;
      return E === "=" && le && (E = ""), B = $.includePrerelease ? "-0" : "", K ? E === ">" || E === "<" ? b = "<0.0.0-0" : b = "*" : E && le ? (Z && (N = 0), L = 0, E === ">" ? (E = ">=", Z ? (R = +R + 1, N = 0, L = 0) : (N = +N + 1, L = 0)) : E === "<=" && (E = "<", Z ? R = +R + 1 : N = +N + 1), E === "<" && (B = "-0"), b = `${E + R}.${N}.${L}${B}`) : Z ? b = `>=${R}.0.0${B} <${+R + 1}.0.0-0` : M && (b = `>=${R}.${N}.0${B} <${R}.${+N + 1}.0-0`), o("xRange return", b), b;
    });
  }, H = (F, $) => (o("replaceStars", F, $), F.trim().replace(s[u.STAR], "")), j = (F, $) => (o("replaceGTE0", F, $), F.trim().replace(s[$.includePrerelease ? u.GTE0PRE : u.GTE0], "")), J = (F) => ($, D, b, E, R, N, L, B, K, Z, M, le) => (A(b) ? D = "" : A(E) ? D = `>=${b}.0.0${F ? "-0" : ""}` : A(R) ? D = `>=${b}.${E}.0${F ? "-0" : ""}` : N ? D = `>=${D}` : D = `>=${D}${F ? "-0" : ""}`, A(K) ? B = "" : A(Z) ? B = `<${+K + 1}.0.0-0` : A(M) ? B = `<${K}.${+Z + 1}.0-0` : le ? B = `<=${K}.${Z}.${M}-${le}` : F ? B = `<${K}.${Z}.${+M + 1}-0` : B = `<=${B}`, `${D} ${B}`.trim()), ne = (F, $, D) => {
    for (let b = 0; b < F.length; b++)
      if (!F[b].test($))
        return !1;
    if ($.prerelease.length && !D.includePrerelease) {
      for (let b = 0; b < F.length; b++)
        if (o(F[b].semver), F[b].semver !== a.ANY && F[b].semver.prerelease.length > 0) {
          const E = F[b].semver;
          if (E.major === $.major && E.minor === $.minor && E.patch === $.patch)
            return !0;
        }
      return !1;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    return !0;
  };
  return Nc;
}
var kc, Jd;
function ps() {
  if (Jd) return kc;
  Jd = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(l, p) {
      if (p = n(p), l instanceof t) {
        if (l.loose === !!p.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), o("comparator", l, p), this.options = p, this.loose = !!p.loose, this.parse(l), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(l) {
      const p = this.options.loose ? r[i.COMPARATORLOOSE] : r[i.COMPARATOR], d = l.match(p);
      if (!d)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = d[1] !== void 0 ? d[1] : "", this.operator === "=" && (this.operator = ""), d[2] ? this.semver = new c(d[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (o("Comparator.test", l, this.options.loose), this.semver === e || l === e)
        return !0;
      if (typeof l == "string")
        try {
          l = new c(l, this.options);
        } catch {
          return !1;
        }
      return a(l, this.operator, this.semver, this.options);
    }
    intersects(l, p) {
      if (!(l instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new s(l.value, p).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new s(this.value, p).test(l.semver) : (p = n(p), p.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !p.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || a(this.semver, "<", l.semver, p) && this.operator.startsWith(">") && l.operator.startsWith("<") || a(this.semver, ">", l.semver, p) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
<<<<<<< HEAD
  comparator = Comparator2;
  const parseOptions2 = parseOptions_1;
  const { safeRe: re2, t: t2 } = reExports;
  const cmp2 = cmp_1;
  const debug2 = debug_1;
  const SemVer3 = semver$2;
  const Range2 = requireRange();
  return comparator;
}
const Range$9 = requireRange();
const satisfies$4 = (version, range2, options) => {
  try {
    range2 = new Range$9(range2, options);
  } catch (er) {
    return false;
=======
  kc = t;
  const n = ju, { safeRe: r, t: i } = Ki, a = sx, o = ls, c = Xe, s = xt();
  return kc;
}
const KC = xt(), JC = (e, t, n) => {
  try {
    t = new KC(t, n);
  } catch {
    return !1;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return t.test(e);
};
<<<<<<< HEAD
var satisfies_1 = satisfies$4;
const Range$8 = requireRange();
const toComparators$1 = (range2, options) => new Range$8(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$2;
const Range$7 = requireRange();
const maxSatisfying$1 = (versions, range2, options) => {
  let max2 = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$7(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max2 || maxSV.compare(v) === -1) {
        max2 = v;
        maxSV = new SemVer$4(max2, options);
      }
    }
  });
  return max2;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$2;
const Range$6 = requireRange();
const minSatisfying$1 = (versions, range2, options) => {
  let min2 = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min2 || minSV.compare(v) === 1) {
        min2 = v;
        minSV = new SemVer$3(min2, options);
      }
    }
  });
  return min2;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$2;
const Range$5 = requireRange();
const gt$2 = gt_1;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$5(range2, loose);
  let minver = new SemVer$2("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$2("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$2(comparator2.semver.version);
      switch (comparator2.operator) {
=======
var fs = JC;
const ZC = xt(), QC = (e, t) => new ZC(e, t).set.map((n) => n.map((r) => r.value).join(" ").trim().split(" "));
var eO = QC;
const tO = Xe, nO = xt(), rO = (e, t, n) => {
  let r = null, i = null, a = null;
  try {
    a = new nO(t, n);
  } catch {
    return null;
  }
  return e.forEach((o) => {
    a.test(o) && (!r || i.compare(o) === -1) && (r = o, i = new tO(r, n));
  }), r;
};
var iO = rO;
const aO = Xe, oO = xt(), sO = (e, t, n) => {
  let r = null, i = null, a = null;
  try {
    a = new oO(t, n);
  } catch {
    return null;
  }
  return e.forEach((o) => {
    a.test(o) && (!r || i.compare(o) === 1) && (r = o, i = new aO(r, n));
  }), r;
};
var cO = sO;
const Lc = Xe, lO = xt(), Zd = us, uO = (e, t) => {
  e = new lO(e, t);
  let n = new Lc("0.0.0");
  if (e.test(n) || (n = new Lc("0.0.0-0"), e.test(n)))
    return n;
  n = null;
  for (let r = 0; r < e.set.length; ++r) {
    const i = e.set[r];
    let a = null;
    i.forEach((o) => {
      const c = new Lc(o.semver.version);
      switch (o.operator) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        case ">":
          c.prerelease.length === 0 ? c.patch++ : c.prerelease.push(0), c.raw = c.format();
        case "":
        case ">=":
          (!a || Zd(c, a)) && (a = c);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${o.operator}`);
      }
    }), a && (!n || Zd(n, a)) && (n = a);
  }
  return n && e.test(n) ? n : null;
};
<<<<<<< HEAD
var minVersion_1 = minVersion$1;
const Range$4 = requireRange();
const validRange$1 = (range2, options) => {
  try {
    return new Range$4(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$2;
const Comparator$2 = requireComparator();
const { ANY: ANY$1 } = Comparator$2;
const Range$3 = requireRange();
const satisfies$3 = satisfies_1;
const gt$1 = gt_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const gte$1 = gte_1;
const outside$3 = (version, range2, hilo, options) => {
  version = new SemVer$1(version, options);
  range2 = new Range$3(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$1;
      ltefn = lte$1;
      ltfn = lt$1;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$1;
      ltefn = gte$1;
      ltfn = gt$1;
      comp = "<";
      ecomp = "<=";
=======
var pO = uO;
const fO = xt(), dO = (e, t) => {
  try {
    return new fO(e, t).range || "*";
  } catch {
    return null;
  }
};
var hO = dO;
const mO = Xe, cx = ps(), { ANY: vO } = cx, gO = xt(), xO = fs, Qd = us, eh = qu, yO = Hu, bO = zu, wO = (e, t, n, r) => {
  e = new mO(e, r), t = new gO(t, r);
  let i, a, o, c, s;
  switch (n) {
    case ">":
      i = Qd, a = yO, o = eh, c = ">", s = ">=";
      break;
    case "<":
      i = eh, a = bO, o = Qd, c = "<", s = "<=";
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
<<<<<<< HEAD
  if (satisfies$3(version, range2, options)) {
    return false;
  }
  for (let i = 0; i < range2.set.length; ++i) {
    const comparators = range2.set[i];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$2(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
=======
  if (xO(e, t, r))
    return !1;
  for (let u = 0; u < t.set.length; ++u) {
    const l = t.set[u];
    let p = null, d = null;
    if (l.forEach((m) => {
      m.semver === vO && (m = new cx(">=0.0.0")), p = p || m, d = d || m, i(m.semver, p.semver, r) ? p = m : o(m.semver, d.semver, r) && (d = m);
    }), p.operator === c || p.operator === s || (!d.operator || d.operator === c) && a(e, d.semver))
      return !1;
    if (d.operator === s && o(e, d.semver))
      return !1;
  }
  return !0;
};
var Gu = wO;
const EO = Gu, _O = (e, t, n) => EO(e, t, ">", n);
var SO = _O;
const TO = Gu, AO = (e, t, n) => TO(e, t, "<", n);
var RO = AO;
const th = xt(), CO = (e, t, n) => (e = new th(e, n), t = new th(t, n), e.intersects(t, n));
var OO = CO;
const $O = fs, IO = gt;
var PO = (e, t, n) => {
  const r = [];
  let i = null, a = null;
  const o = e.sort((l, p) => IO(l, p, n));
  for (const l of o)
    $O(l, t, n) ? (a = l, i || (i = l)) : (a && r.push([i, a]), a = null, i = null);
  i && r.push([i, null]);
  const c = [];
  for (const [l, p] of r)
    l === p ? c.push(l) : !p && l === o[0] ? c.push("*") : p ? l === o[0] ? c.push(`<=${p}`) : c.push(`${l} - ${p}`) : c.push(`>=${l}`);
  const s = c.join(" || "), u = typeof t.raw == "string" ? t.raw : String(t);
  return s.length < u.length ? s : t;
};
const nh = xt(), Wu = ps(), { ANY: Uc } = Wu, Jr = fs, Vu = gt, DO = (e, t, n = {}) => {
  if (e === t)
    return !0;
  e = new nh(e, n), t = new nh(t, n);
  let r = !1;
  e: for (const i of e.set) {
    for (const a of t.set) {
      const o = NO(i, a, n);
      if (r = r || o !== null, o)
        continue e;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    if (r)
      return !1;
  }
<<<<<<< HEAD
  return true;
};
var outside_1 = outside$3;
const outside$2 = outside_1;
const gtr$1 = (version, range2, options) => outside$2(version, range2, ">", options);
var gtr_1 = gtr$1;
const outside$1 = outside_1;
const ltr$1 = (version, range2, options) => outside$1(version, range2, "<", options);
var ltr_1 = ltr$1;
const Range$2 = requireRange();
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$2(r1, options);
  r2 = new Range$2(r2, options);
  return r1.intersects(r2, options);
};
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1;
const compare$2 = compare_1;
var simplify = (versions, range2, options) => {
  const set2 = [];
  let first = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$2(a, b, options));
  for (const version of v) {
    const included = satisfies$2(version, range2, options);
    if (included) {
      prev = version;
      if (!first) {
        first = version;
      }
    } else {
      if (prev) {
        set2.push([first, prev]);
      }
      prev = null;
      first = null;
    }
=======
  return !0;
}, FO = [new Wu(">=0.0.0-0")], rh = [new Wu(">=0.0.0")], NO = (e, t, n) => {
  if (e === t)
    return !0;
  if (e.length === 1 && e[0].semver === Uc) {
    if (t.length === 1 && t[0].semver === Uc)
      return !0;
    n.includePrerelease ? e = FO : e = rh;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  if (t.length === 1 && t[0].semver === Uc) {
    if (n.includePrerelease)
      return !0;
    t = rh;
  }
  const r = /* @__PURE__ */ new Set();
  let i, a;
  for (const m of e)
    m.operator === ">" || m.operator === ">=" ? i = ih(i, m, n) : m.operator === "<" || m.operator === "<=" ? a = ah(a, m, n) : r.add(m.semver);
  if (r.size > 1)
    return null;
  let o;
  if (i && a) {
    if (o = Vu(i.semver, a.semver, n), o > 0)
      return null;
    if (o === 0 && (i.operator !== ">=" || a.operator !== "<="))
      return null;
  }
  for (const m of r) {
    if (i && !Jr(m, String(i), n) || a && !Jr(m, String(a), n))
      return null;
    for (const g of t)
      if (!Jr(m, String(g), n))
        return !1;
    return !0;
  }
  let c, s, u, l, p = a && !n.includePrerelease && a.semver.prerelease.length ? a.semver : !1, d = i && !n.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
  p && p.prerelease.length === 1 && a.operator === "<" && p.prerelease[0] === 0 && (p = !1);
  for (const m of t) {
    if (l = l || m.operator === ">" || m.operator === ">=", u = u || m.operator === "<" || m.operator === "<=", i) {
      if (d && m.semver.prerelease && m.semver.prerelease.length && m.semver.major === d.major && m.semver.minor === d.minor && m.semver.patch === d.patch && (d = !1), m.operator === ">" || m.operator === ">=") {
        if (c = ih(i, m, n), c === m && c !== i)
          return !1;
      } else if (i.operator === ">=" && !Jr(i.semver, String(m), n))
        return !1;
    }
    if (a) {
      if (p && m.semver.prerelease && m.semver.prerelease.length && m.semver.major === p.major && m.semver.minor === p.minor && m.semver.patch === p.patch && (p = !1), m.operator === "<" || m.operator === "<=") {
        if (s = ah(a, m, n), s === m && s !== a)
          return !1;
      } else if (a.operator === "<=" && !Jr(a.semver, String(m), n))
        return !1;
    }
    if (!m.operator && (a || i) && o !== 0)
      return !1;
  }
  return !(i && u && !a && o !== 0 || a && l && !i && o !== 0 || d || p);
}, ih = (e, t, n) => {
  if (!e)
    return t;
  const r = Vu(e.semver, t.semver, n);
  return r > 0 ? e : r < 0 || t.operator === ">" && e.operator === ">=" ? t : e;
}, ah = (e, t, n) => {
  if (!e)
    return t;
  const r = Vu(e.semver, t.semver, n);
  return r < 0 ? e : r > 0 || t.operator === "<" && e.operator === "<=" ? t : e;
};
<<<<<<< HEAD
const higherGT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a) {
    return b;
  }
  const comp = compare$1(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset$1;
const internalRe = reExports;
const constants = constants$1;
const SemVer2 = semver$2;
const identifiers = identifiers$1;
const parse = parse_1;
const valid = valid_1;
const clean = clean_1;
const inc = inc_1;
const diff = diff_1;
const major = major_1;
const minor = minor_1;
const patch = patch_1;
const prerelease = prerelease_1;
const compare = compare_1;
const rcompare = rcompare_1;
const compareLoose = compareLoose_1;
const compareBuild = compareBuild_1;
const sort = sort_1;
const rsort = rsort_1;
const gt = gt_1;
const lt = lt_1;
const eq = eq_1;
const neq = neq_1;
const gte = gte_1;
const lte = lte_1;
const cmp = cmp_1;
const coerce = coerce_1;
const Comparator = requireComparator();
const Range = requireRange();
const satisfies = satisfies_1;
const toComparators = toComparators_1;
const maxSatisfying = maxSatisfying_1;
const minSatisfying = minSatisfying_1;
const minVersion = minVersion_1;
const validRange = valid$1;
const outside = outside_1;
const gtr = gtr_1;
const ltr = ltr_1;
const intersects = intersects_1;
const simplifyRange = simplify;
const subset = subset_1;
var semver$1 = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer: SemVer2,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
var DownloadedUpdateHelper$1 = {};
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
=======
var kO = DO;
const Bc = Ki, oh = cs, LO = Xe, sh = ix, UO = Ur, BO = GR, jO = YR, MO = KR, qO = ZR, zO = tC, HO = iC, GO = sC, WO = uC, VO = gt, YO = hC, XO = gC, KO = Mu, JO = wC, ZO = SC, QO = us, e$ = qu, t$ = ax, n$ = ox, r$ = zu, i$ = Hu, a$ = sx, o$ = VC, s$ = ps(), c$ = xt(), l$ = fs, u$ = eO, p$ = iO, f$ = cO, d$ = pO, h$ = hO, m$ = Gu, v$ = SO, g$ = RO, x$ = OO, y$ = PO, b$ = kO;
var lx = {
  parse: UO,
  valid: BO,
  clean: jO,
  inc: MO,
  diff: qO,
  major: zO,
  minor: HO,
  patch: GO,
  prerelease: WO,
  compare: VO,
  rcompare: YO,
  compareLoose: XO,
  compareBuild: KO,
  sort: JO,
  rsort: ZO,
  gt: QO,
  lt: e$,
  eq: t$,
  neq: n$,
  gte: r$,
  lte: i$,
  cmp: a$,
  coerce: o$,
  Comparator: s$,
  Range: c$,
  satisfies: l$,
  toComparators: u$,
  maxSatisfying: p$,
  minSatisfying: f$,
  minVersion: d$,
  validRange: h$,
  outside: m$,
  gtr: v$,
  ltr: g$,
  intersects: x$,
  simplifyRange: y$,
  subset: b$,
  SemVer: LO,
  re: Bc.re,
  src: Bc.src,
  tokens: Bc.t,
  SEMVER_SPEC_VERSION: oh.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: oh.RELEASE_TYPES,
  compareIdentifiers: sh.compareIdentifiers,
  rcompareIdentifiers: sh.rcompareIdentifiers
}, Ji = {}, yo = { exports: {} };
yo.exports;
(function(e, t) {
  var n = 200, r = "__lodash_hash_undefined__", i = 1, a = 2, o = 9007199254740991, c = "[object Arguments]", s = "[object Array]", u = "[object AsyncFunction]", l = "[object Boolean]", p = "[object Date]", d = "[object Error]", m = "[object Function]", g = "[object GeneratorFunction]", v = "[object Map]", y = "[object Number]", x = "[object Null]", w = "[object Object]", A = "[object Promise]", O = "[object Proxy]", k = "[object RegExp]", q = "[object Set]", W = "[object String]", te = "[object Symbol]", T = "[object Undefined]", H = "[object WeakMap]", j = "[object ArrayBuffer]", J = "[object DataView]", ne = "[object Float32Array]", F = "[object Float64Array]", $ = "[object Int8Array]", D = "[object Int16Array]", b = "[object Int32Array]", E = "[object Uint8Array]", R = "[object Uint8ClampedArray]", N = "[object Uint16Array]", L = "[object Uint32Array]", B = /[\\^$.*+?()[\]{}|]/g, K = /^\[object .+?Constructor\]$/, Z = /^(?:0|[1-9]\d*)$/, M = {};
  M[ne] = M[F] = M[$] = M[D] = M[b] = M[E] = M[R] = M[N] = M[L] = !0, M[c] = M[s] = M[j] = M[l] = M[J] = M[p] = M[d] = M[m] = M[v] = M[y] = M[w] = M[k] = M[q] = M[W] = M[H] = !1;
  var le = typeof Te == "object" && Te && Te.Object === Object && Te, h = typeof self == "object" && self && self.Object === Object && self, f = le || h || Function("return this")(), C = t && !t.nodeType && t, S = C && !0 && e && !e.nodeType && e, G = S && S.exports === C, z = G && le.process, X = function() {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    try {
      return z && z.binding && z.binding("util");
    } catch {
    }
  }(), ve = X && X.isTypedArray;
  function Ae(_, I) {
    for (var U = -1, Y = _ == null ? 0 : _.length, fe = 0, ee = []; ++U < Y; ) {
      var ge = _[U];
      I(ge, U, _) && (ee[fe++] = ge);
    }
    return ee;
  }
<<<<<<< HEAD
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
=======
  function ct(_, I) {
    for (var U = -1, Y = I.length, fe = _.length; ++U < Y; )
      _[fe + U] = I[U];
    return _;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  function Se(_, I) {
    for (var U = -1, Y = _ == null ? 0 : _.length; ++U < Y; )
      if (I(_[U], U, _))
        return !0;
    return !1;
  }
  function qe(_, I) {
    for (var U = -1, Y = Array(_); ++U < _; )
      Y[U] = I(U);
    return Y;
  }
  function Jn(_) {
    return function(I) {
      return _(I);
    };
  }
<<<<<<< HEAD
  function cacheHas(cache, key2) {
    return cache.has(key2);
  }
  function getValue(object, key2) {
    return object == null ? void 0 : object[key2];
  }
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key2) {
      result[++index] = [key2, value];
    });
    return result;
=======
  function jt(_, I) {
    return _.has(I);
  }
  function Ot(_, I) {
    return _ == null ? void 0 : _[I];
  }
  function Mt(_) {
    var I = -1, U = Array(_.size);
    return _.forEach(function(Y, fe) {
      U[++I] = [fe, Y];
    }), U;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  function xn(_, I) {
    return function(U) {
      return _(I(U));
    };
  }
  function qt(_) {
    var I = -1, U = Array(_.size);
    return _.forEach(function(Y) {
      U[++I] = Y;
    }), U;
  }
<<<<<<< HEAD
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData = root2["__core-js_shared__"];
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root2, "DataView"), Map2 = getNative(root2, "Map"), Promise2 = getNative(root2, "Promise"), Set2 = getNative(root2, "Set"), WeakMap2 = getNative(root2, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
=======
  var yn = Array.prototype, Sx = Function.prototype, ta = Object.prototype, ws = f["__core-js_shared__"], Ju = Sx.toString, yt = ta.hasOwnProperty, Zu = function() {
    var _ = /[^.]+$/.exec(ws && ws.keys && ws.keys.IE_PROTO || "");
    return _ ? "Symbol(src)_1." + _ : "";
  }(), Qu = ta.toString, Tx = RegExp(
    "^" + Ju.call(yt).replace(B, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), ep = G ? f.Buffer : void 0, na = f.Symbol, tp = f.Uint8Array, np = ta.propertyIsEnumerable, Ax = yn.splice, bn = na ? na.toStringTag : void 0, rp = Object.getOwnPropertySymbols, Rx = ep ? ep.isBuffer : void 0, Cx = xn(Object.keys, Object), Es = Zn(f, "DataView"), jr = Zn(f, "Map"), _s = Zn(f, "Promise"), Ss = Zn(f, "Set"), Ts = Zn(f, "WeakMap"), Mr = Zn(Object, "create"), Ox = _n(Es), $x = _n(jr), Ix = _n(_s), Px = _n(Ss), Dx = _n(Ts), ip = na ? na.prototype : void 0, As = ip ? ip.valueOf : void 0;
  function wn(_) {
    var I = -1, U = _ == null ? 0 : _.length;
    for (this.clear(); ++I < U; ) {
      var Y = _[I];
      this.set(Y[0], Y[1]);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
  }
  function Fx() {
    this.__data__ = Mr ? Mr(null) : {}, this.size = 0;
  }
<<<<<<< HEAD
  function hashDelete(key2) {
    var result = this.has(key2) && delete this.__data__[key2];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet(key2) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key2];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key2) ? data[key2] : void 0;
  }
  function hashHas(key2) {
    var data = this.__data__;
    return nativeCreate ? data[key2] !== void 0 : hasOwnProperty2.call(data, key2);
  }
  function hashSet(key2, value) {
    var data = this.__data__;
    this.size += this.has(key2) ? 0 : 1;
    data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
=======
  function Nx(_) {
    var I = this.has(_) && delete this.__data__[_];
    return this.size -= I ? 1 : 0, I;
  }
  function kx(_) {
    var I = this.__data__;
    if (Mr) {
      var U = I[_];
      return U === r ? void 0 : U;
    }
    return yt.call(I, _) ? I[_] : void 0;
  }
  function Lx(_) {
    var I = this.__data__;
    return Mr ? I[_] !== void 0 : yt.call(I, _);
  }
  function Ux(_, I) {
    var U = this.__data__;
    return this.size += this.has(_) ? 0 : 1, U[_] = Mr && I === void 0 ? r : I, this;
  }
  wn.prototype.clear = Fx, wn.prototype.delete = Nx, wn.prototype.get = kx, wn.prototype.has = Lx, wn.prototype.set = Ux;
  function $t(_) {
    var I = -1, U = _ == null ? 0 : _.length;
    for (this.clear(); ++I < U; ) {
      var Y = _[I];
      this.set(Y[0], Y[1]);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
  }
  function Bx() {
    this.__data__ = [], this.size = 0;
  }
<<<<<<< HEAD
  function listCacheDelete(key2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key2) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key2) {
    return assocIndexOf(this.__data__, key2) > -1;
  }
  function listCacheSet(key2, value) {
    var data = this.__data__, index = assocIndexOf(data, key2);
    if (index < 0) {
      ++this.size;
      data.push([key2, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key2) {
    var result = getMapData(this, key2)["delete"](key2);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key2) {
    return getMapData(this, key2).get(key2);
  }
  function mapCacheHas(key2) {
    return getMapData(this, key2).has(key2);
  }
  function mapCacheSet(key2, value) {
    var data = getMapData(this, key2), size = data.size;
    data.set(key2, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
=======
  function jx(_) {
    var I = this.__data__, U = ia(I, _);
    if (U < 0)
      return !1;
    var Y = I.length - 1;
    return U == Y ? I.pop() : Ax.call(I, U, 1), --this.size, !0;
  }
  function Mx(_) {
    var I = this.__data__, U = ia(I, _);
    return U < 0 ? void 0 : I[U][1];
  }
  function qx(_) {
    return ia(this.__data__, _) > -1;
  }
  function zx(_, I) {
    var U = this.__data__, Y = ia(U, _);
    return Y < 0 ? (++this.size, U.push([_, I])) : U[Y][1] = I, this;
  }
  $t.prototype.clear = Bx, $t.prototype.delete = jx, $t.prototype.get = Mx, $t.prototype.has = qx, $t.prototype.set = zx;
  function En(_) {
    var I = -1, U = _ == null ? 0 : _.length;
    for (this.clear(); ++I < U; ) {
      var Y = _[I];
      this.set(Y[0], Y[1]);
    }
  }
  function Hx() {
    this.size = 0, this.__data__ = {
      hash: new wn(),
      map: new (jr || $t)(),
      string: new wn()
    };
  }
  function Gx(_) {
    var I = aa(this, _).delete(_);
    return this.size -= I ? 1 : 0, I;
  }
  function Wx(_) {
    return aa(this, _).get(_);
  }
  function Vx(_) {
    return aa(this, _).has(_);
  }
  function Yx(_, I) {
    var U = aa(this, _), Y = U.size;
    return U.set(_, I), this.size += U.size == Y ? 0 : 1, this;
  }
  En.prototype.clear = Hx, En.prototype.delete = Gx, En.prototype.get = Wx, En.prototype.has = Vx, En.prototype.set = Yx;
  function ra(_) {
    var I = -1, U = _ == null ? 0 : _.length;
    for (this.__data__ = new En(); ++I < U; )
      this.add(_[I]);
  }
  function Xx(_) {
    return this.__data__.set(_, r), this;
  }
  function Kx(_) {
    return this.__data__.has(_);
  }
  ra.prototype.add = ra.prototype.push = Xx, ra.prototype.has = Kx;
  function zt(_) {
    var I = this.__data__ = new $t(_);
    this.size = I.size;
  }
  function Jx() {
    this.__data__ = new $t(), this.size = 0;
  }
  function Zx(_) {
    var I = this.__data__, U = I.delete(_);
    return this.size = I.size, U;
  }
  function Qx(_) {
    return this.__data__.get(_);
  }
  function ey(_) {
    return this.__data__.has(_);
  }
  function ty(_, I) {
    var U = this.__data__;
    if (U instanceof $t) {
      var Y = U.__data__;
      if (!jr || Y.length < n - 1)
        return Y.push([_, I]), this.size = ++U.size, this;
      U = this.__data__ = new En(Y);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    return U.set(_, I), this.size = U.size, this;
  }
<<<<<<< HEAD
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key2) {
    var data = this.__data__, result = data["delete"](key2);
    this.size = data.size;
    return result;
  }
  function stackGet(key2) {
    return this.__data__.get(key2);
  }
  function stackHas(key2) {
    return this.__data__.has(key2);
  }
  function stackSet(key2, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs2 = data.__data__;
      if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key2, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs2);
    }
    data.set(key2, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key2 in value) {
      if (hasOwnProperty2.call(value, key2) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
      isIndex(key2, length)))) {
        result.push(key2);
      }
    }
    return result;
  }
  function assocIndexOf(array, key2) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key2)) {
        return length;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer2(object)) {
      if (!isBuffer2(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
=======
  zt.prototype.clear = Jx, zt.prototype.delete = Zx, zt.prototype.get = Qx, zt.prototype.has = ey, zt.prototype.set = ty;
  function ny(_, I) {
    var U = oa(_), Y = !U && gy(_), fe = !U && !Y && Rs(_), ee = !U && !Y && !fe && dp(_), ge = U || Y || fe || ee, Oe = ge ? qe(_.length, String) : [], Fe = Oe.length;
    for (var de in _)
      yt.call(_, de) && !(ge && // Safari 9 has enumerable `arguments.length` in strict mode.
      (de == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      fe && (de == "offset" || de == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      ee && (de == "buffer" || de == "byteLength" || de == "byteOffset") || // Skip index properties.
      fy(de, Fe))) && Oe.push(de);
    return Oe;
  }
  function ia(_, I) {
    for (var U = _.length; U--; )
      if (lp(_[U][0], I))
        return U;
    return -1;
  }
  function ry(_, I, U) {
    var Y = I(_);
    return oa(_) ? Y : ct(Y, U(_));
  }
  function qr(_) {
    return _ == null ? _ === void 0 ? T : x : bn && bn in Object(_) ? uy(_) : vy(_);
  }
  function ap(_) {
    return zr(_) && qr(_) == c;
  }
  function op(_, I, U, Y, fe) {
    return _ === I ? !0 : _ == null || I == null || !zr(_) && !zr(I) ? _ !== _ && I !== I : iy(_, I, U, Y, op, fe);
  }
  function iy(_, I, U, Y, fe, ee) {
    var ge = oa(_), Oe = oa(I), Fe = ge ? s : Ht(_), de = Oe ? s : Ht(I);
    Fe = Fe == c ? w : Fe, de = de == c ? w : de;
    var nt = Fe == w, lt = de == w, Be = Fe == de;
    if (Be && Rs(_)) {
      if (!Rs(I))
        return !1;
      ge = !0, nt = !1;
    }
    if (Be && !nt)
      return ee || (ee = new zt()), ge || dp(_) ? sp(_, I, U, Y, fe, ee) : cy(_, I, Fe, U, Y, fe, ee);
    if (!(U & i)) {
      var rt = nt && yt.call(_, "__wrapped__"), it = lt && yt.call(I, "__wrapped__");
      if (rt || it) {
        var Gt = rt ? _.value() : _, It = it ? I.value() : I;
        return ee || (ee = new zt()), fe(Gt, It, U, Y, ee);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
    }
    return Be ? (ee || (ee = new zt()), ly(_, I, U, Y, fe, ee)) : !1;
  }
  function ay(_) {
    if (!fp(_) || hy(_))
      return !1;
    var I = up(_) ? Tx : K;
    return I.test(_n(_));
  }
<<<<<<< HEAD
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key2 in Object(object)) {
      if (hasOwnProperty2.call(object, key2) && key2 != "constructor") {
        result.push(key2);
      }
    }
    return result;
  }
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
=======
  function oy(_) {
    return zr(_) && pp(_.length) && !!M[qr(_)];
  }
  function sy(_) {
    if (!my(_))
      return Cx(_);
    var I = [];
    for (var U in Object(_))
      yt.call(_, U) && U != "constructor" && I.push(U);
    return I;
  }
  function sp(_, I, U, Y, fe, ee) {
    var ge = U & i, Oe = _.length, Fe = I.length;
    if (Oe != Fe && !(ge && Fe > Oe))
      return !1;
    var de = ee.get(_);
    if (de && ee.get(I))
      return de == I;
    var nt = -1, lt = !0, Be = U & a ? new ra() : void 0;
    for (ee.set(_, I), ee.set(I, _); ++nt < Oe; ) {
      var rt = _[nt], it = I[nt];
      if (Y)
        var Gt = ge ? Y(it, rt, nt, I, _, ee) : Y(rt, it, nt, _, I, ee);
      if (Gt !== void 0) {
        if (Gt)
          continue;
        lt = !1;
        break;
      }
      if (Be) {
        if (!Se(I, function(It, Sn) {
          if (!jt(Be, Sn) && (rt === It || fe(rt, It, U, Y, ee)))
            return Be.push(Sn);
        })) {
          lt = !1;
          break;
        }
      } else if (!(rt === it || fe(rt, it, U, Y, ee))) {
        lt = !1;
        break;
      }
    }
    return ee.delete(_), ee.delete(I), lt;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  function cy(_, I, U, Y, fe, ee, ge) {
    switch (U) {
      case J:
        if (_.byteLength != I.byteLength || _.byteOffset != I.byteOffset)
          return !1;
        _ = _.buffer, I = I.buffer;
      case j:
        return !(_.byteLength != I.byteLength || !ee(new tp(_), new tp(I)));
      case l:
      case p:
      case y:
        return lp(+_, +I);
      case d:
        return _.name == I.name && _.message == I.message;
      case k:
      case W:
        return _ == I + "";
      case v:
        var Oe = Mt;
      case q:
        var Fe = Y & i;
        if (Oe || (Oe = qt), _.size != I.size && !Fe)
          return !1;
        var de = ge.get(_);
        if (de)
          return de == I;
        Y |= a, ge.set(_, I);
        var nt = sp(Oe(_), Oe(I), Y, fe, ee, ge);
        return ge.delete(_), nt;
      case te:
        if (As)
          return As.call(_) == As.call(I);
    }
    return !1;
  }
<<<<<<< HEAD
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key2 = objProps[index];
      if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2))) {
        return false;
      }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key2 = objProps[index];
      var objValue = object[key2], othValue = other[key2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key2 == "constructor");
=======
  function ly(_, I, U, Y, fe, ee) {
    var ge = U & i, Oe = cp(_), Fe = Oe.length, de = cp(I), nt = de.length;
    if (Fe != nt && !ge)
      return !1;
    for (var lt = Fe; lt--; ) {
      var Be = Oe[lt];
      if (!(ge ? Be in I : yt.call(I, Be)))
        return !1;
    }
    var rt = ee.get(_);
    if (rt && ee.get(I))
      return rt == I;
    var it = !0;
    ee.set(_, I), ee.set(I, _);
    for (var Gt = ge; ++lt < Fe; ) {
      Be = Oe[lt];
      var It = _[Be], Sn = I[Be];
      if (Y)
        var hp = ge ? Y(Sn, It, Be, I, _, ee) : Y(It, Sn, Be, _, I, ee);
      if (!(hp === void 0 ? It === Sn || fe(It, Sn, U, Y, ee) : hp)) {
        it = !1;
        break;
      }
      Gt || (Gt = Be == "constructor");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    if (it && !Gt) {
      var sa = _.constructor, ca = I.constructor;
      sa != ca && "constructor" in _ && "constructor" in I && !(typeof sa == "function" && sa instanceof sa && typeof ca == "function" && ca instanceof ca) && (it = !1);
    }
    return ee.delete(_), ee.delete(I), it;
  }
  function cp(_) {
    return ry(_, by, py);
  }
<<<<<<< HEAD
  function getMapData(map2, key2) {
    var data = map2.__data__;
    return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key2) {
    var value = getValue(object, key2);
    return baseIsNative(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
=======
  function aa(_, I) {
    var U = _.__data__;
    return dy(I) ? U[typeof I == "string" ? "string" : "hash"] : U.map;
  }
  function Zn(_, I) {
    var U = Ot(_, I);
    return ay(U) ? U : void 0;
  }
  function uy(_) {
    var I = yt.call(_, bn), U = _[bn];
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    try {
      _[bn] = void 0;
      var Y = !0;
    } catch {
    }
    var fe = Qu.call(_);
    return Y && (I ? _[bn] = U : delete _[bn]), fe;
  }
  var py = rp ? function(_) {
    return _ == null ? [] : (_ = Object(_), Ae(rp(_), function(I) {
      return np.call(_, I);
    }));
  } : wy, Ht = qr;
  (Es && Ht(new Es(new ArrayBuffer(1))) != J || jr && Ht(new jr()) != v || _s && Ht(_s.resolve()) != A || Ss && Ht(new Ss()) != q || Ts && Ht(new Ts()) != H) && (Ht = function(_) {
    var I = qr(_), U = I == w ? _.constructor : void 0, Y = U ? _n(U) : "";
    if (Y)
      switch (Y) {
        case Ox:
          return J;
        case $x:
          return v;
        case Ix:
          return A;
        case Px:
          return q;
        case Dx:
          return H;
      }
    return I;
  });
  function fy(_, I) {
    return I = I ?? o, !!I && (typeof _ == "number" || Z.test(_)) && _ > -1 && _ % 1 == 0 && _ < I;
  }
  function dy(_) {
    var I = typeof _;
    return I == "string" || I == "number" || I == "symbol" || I == "boolean" ? _ !== "__proto__" : _ === null;
  }
  function hy(_) {
    return !!Zu && Zu in _;
  }
  function my(_) {
    var I = _ && _.constructor, U = typeof I == "function" && I.prototype || ta;
    return _ === U;
  }
  function vy(_) {
    return Qu.call(_);
  }
  function _n(_) {
    if (_ != null) {
      try {
        return Ju.call(_);
      } catch {
      }
      try {
        return _ + "";
      } catch {
      }
    }
    return "";
  }
  function lp(_, I) {
    return _ === I || _ !== _ && I !== I;
  }
  var gy = ap(/* @__PURE__ */ function() {
    return arguments;
<<<<<<< HEAD
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
=======
  }()) ? ap : function(_) {
    return zr(_) && yt.call(_, "callee") && !np.call(_, "callee");
  }, oa = Array.isArray;
  function xy(_) {
    return _ != null && pp(_.length) && !up(_);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  var Rs = Rx || Ey;
  function yy(_, I) {
    return op(_, I);
  }
  function up(_) {
    if (!fp(_))
      return !1;
    var I = qr(_);
    return I == m || I == g || I == u || I == O;
  }
  function pp(_) {
    return typeof _ == "number" && _ > -1 && _ % 1 == 0 && _ <= o;
  }
  function fp(_) {
    var I = typeof _;
    return _ != null && (I == "object" || I == "function");
  }
  function zr(_) {
    return _ != null && typeof _ == "object";
  }
  var dp = ve ? Jn(ve) : oy;
  function by(_) {
    return xy(_) ? ny(_) : sy(_);
  }
  function wy() {
    return [];
  }
  function Ey() {
    return !1;
  }
<<<<<<< HEAD
  module.exports = isEqual2;
})(lodash_isequal, lodash_isequal.exports);
var lodash_isequalExports = lodash_isequal.exports;
Object.defineProperty(DownloadedUpdateHelper$1, "__esModule", { value: true });
DownloadedUpdateHelper$1.DownloadedUpdateHelper = void 0;
DownloadedUpdateHelper$1.createTempUpdateFile = createTempUpdateFile;
const crypto_1$2 = require$$0$4;
const fs_1$4 = fs$w;
const isEqual = lodash_isequalExports;
const fs_extra_1$6 = lib;
const path$8 = require$$1$4;
class DownloadedUpdateHelper {
  constructor(cacheDir) {
    this.cacheDir = cacheDir;
    this._file = null;
    this._packageFile = null;
    this.versionInfo = null;
    this.fileInfo = null;
    this._downloadedFileInfo = null;
=======
  e.exports = yy;
})(yo, yo.exports);
var w$ = yo.exports;
Object.defineProperty(Ji, "__esModule", { value: !0 });
Ji.DownloadedUpdateHelper = void 0;
Ji.createTempUpdateFile = A$;
const E$ = Dr, _$ = ae, ch = w$, Rn = vn, ci = oe;
class S$ {
  constructor(t) {
    this.cacheDir = t, this._file = null, this._packageFile = null, this.versionInfo = null, this.fileInfo = null, this._downloadedFileInfo = null;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  get downloadedFileInfo() {
    return this._downloadedFileInfo;
  }
  get file() {
    return this._file;
  }
  get packageFile() {
    return this._packageFile;
  }
  get cacheDirForPendingUpdate() {
    return ci.join(this.cacheDir, "pending");
  }
  async validateDownloadedPath(t, n, r, i) {
    if (this.versionInfo != null && this.file === t && this.fileInfo != null)
      return ch(this.versionInfo, n) && ch(this.fileInfo.info, r.info) && await (0, Rn.pathExists)(t) ? t : null;
    const a = await this.getValidCachedUpdateFile(r, i);
    return a === null ? null : (i.info(`Update has already been downloaded to ${t}).`), this._file = a, a);
  }
  async setDownloadedFile(t, n, r, i, a, o) {
    this._file = t, this._packageFile = n, this.versionInfo = r, this.fileInfo = i, this._downloadedFileInfo = {
      fileName: a,
      sha512: i.info.sha512,
      isAdminRightsRequired: i.info.isAdminRightsRequired === !0
    }, o && await (0, Rn.outputJson)(this.getUpdateInfoFile(), this._downloadedFileInfo);
  }
  async clear() {
    this._file = null, this._packageFile = null, this.versionInfo = null, this.fileInfo = null, await this.cleanCacheDirForPendingUpdate();
  }
  async cleanCacheDirForPendingUpdate() {
    try {
      await (0, Rn.emptyDir)(this.cacheDirForPendingUpdate);
    } catch {
    }
  }
  /**
   * Returns "update-info.json" which is created in the update cache directory's "pending" subfolder after the first update is downloaded.  If the update file does not exist then the cache is cleared and recreated.  If the update file exists then its properties are validated.
   * @param fileInfo
   * @param logger
   */
  async getValidCachedUpdateFile(t, n) {
    const r = this.getUpdateInfoFile();
    if (!await (0, Rn.pathExists)(r))
      return null;
<<<<<<< HEAD
    }
    let cachedInfo;
=======
    let a;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    try {
      a = await (0, Rn.readJson)(r);
    } catch (u) {
      let l = "No cached update info available";
      return u.code !== "ENOENT" && (await this.cleanCacheDirForPendingUpdate(), l += ` (error on read: ${u.message})`), n.info(l), null;
    }
<<<<<<< HEAD
    const isCachedInfoFileNameValid = (cachedInfo === null || cachedInfo === void 0 ? void 0 : cachedInfo.fileName) !== null;
    if (!isCachedInfoFileNameValid) {
      logger.warn(`Cached update info is corrupted: no fileName, directory for cached update will be cleaned`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    if (fileInfo.info.sha512 !== cachedInfo.sha512) {
      logger.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${cachedInfo.sha512}, expected: ${fileInfo.info.sha512}. Directory for cached update will be cleaned`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    const updateFile = path$8.join(this.cacheDirForPendingUpdate, cachedInfo.fileName);
    if (!await (0, fs_extra_1$6.pathExists)(updateFile)) {
      logger.info("Cached update file doesn't exist");
      return null;
    }
    const sha512 = await hashFile(updateFile);
    if (fileInfo.info.sha512 !== sha512) {
      logger.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    this._downloadedFileInfo = cachedInfo;
    return updateFile;
=======
    if (!((a == null ? void 0 : a.fileName) !== null))
      return n.warn("Cached update info is corrupted: no fileName, directory for cached update will be cleaned"), await this.cleanCacheDirForPendingUpdate(), null;
    if (t.info.sha512 !== a.sha512)
      return n.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${a.sha512}, expected: ${t.info.sha512}. Directory for cached update will be cleaned`), await this.cleanCacheDirForPendingUpdate(), null;
    const c = ci.join(this.cacheDirForPendingUpdate, a.fileName);
    if (!await (0, Rn.pathExists)(c))
      return n.info("Cached update file doesn't exist"), null;
    const s = await T$(c);
    return t.info.sha512 !== s ? (n.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${s}, expected: ${t.info.sha512}`), await this.cleanCacheDirForPendingUpdate(), null) : (this._downloadedFileInfo = a, c);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  getUpdateInfoFile() {
    return ci.join(this.cacheDirForPendingUpdate, "update-info.json");
  }
}
<<<<<<< HEAD
DownloadedUpdateHelper$1.DownloadedUpdateHelper = DownloadedUpdateHelper;
function hashFile(file2, algorithm = "sha512", encoding = "base64", options) {
  return new Promise((resolve, reject) => {
    const hash = (0, crypto_1$2.createHash)(algorithm);
    hash.on("error", reject).setEncoding(encoding);
    (0, fs_1$4.createReadStream)(file2, {
      ...options,
=======
Ji.DownloadedUpdateHelper = S$;
function T$(e, t = "sha512", n = "base64", r) {
  return new Promise((i, a) => {
    const o = (0, E$.createHash)(t);
    o.on("error", a).setEncoding(n), (0, _$.createReadStream)(e, {
      ...r,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      highWaterMark: 1024 * 1024
      /* better to use more memory but hash faster */
    }).on("error", a).on("end", () => {
      o.end(), i(o.read());
    }).pipe(o, { end: !1 });
  });
}
<<<<<<< HEAD
async function createTempUpdateFile(name, cacheDir, log) {
  let nameCounter = 0;
  let result = path$8.join(cacheDir, name);
  for (let i = 0; i < 3; i++) {
=======
async function A$(e, t, n) {
  let r = 0, i = ci.join(t, e);
  for (let a = 0; a < 3; a++)
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    try {
      return await (0, Rn.unlink)(i), i;
    } catch (o) {
      if (o.code === "ENOENT")
        return i;
      n.warn(`Error on remove temp update file: ${o}`), i = ci.join(t, `${r++}-${e}`);
    }
  return i;
}
<<<<<<< HEAD
var ElectronAppAdapter$1 = {};
var AppAdapter = {};
Object.defineProperty(AppAdapter, "__esModule", { value: true });
AppAdapter.getAppCacheDir = getAppCacheDir;
const path$7 = require$$1$4;
const os_1$1 = require$$2$2;
function getAppCacheDir() {
  const homedir = (0, os_1$1.homedir)();
  let result;
  if (process.platform === "win32") {
    result = process.env["LOCALAPPDATA"] || path$7.join(homedir, "AppData", "Local");
  } else if (process.platform === "darwin") {
    result = path$7.join(homedir, "Library", "Caches");
  } else {
    result = process.env["XDG_CACHE_HOME"] || path$7.join(homedir, ".cache");
  }
  return result;
}
Object.defineProperty(ElectronAppAdapter$1, "__esModule", { value: true });
ElectronAppAdapter$1.ElectronAppAdapter = void 0;
const path$6 = require$$1$4;
const AppAdapter_1 = AppAdapter;
class ElectronAppAdapter {
  constructor(app2 = require$$1$8.app) {
    this.app = app2;
=======
var ds = {}, Yu = {};
Object.defineProperty(Yu, "__esModule", { value: !0 });
Yu.getAppCacheDir = C$;
const jc = oe, R$ = Eo;
function C$() {
  const e = (0, R$.homedir)();
  let t;
  return process.platform === "win32" ? t = process.env.LOCALAPPDATA || jc.join(e, "AppData", "Local") : process.platform === "darwin" ? t = jc.join(e, "Library", "Caches") : t = process.env.XDG_CACHE_HOME || jc.join(e, ".cache"), t;
}
Object.defineProperty(ds, "__esModule", { value: !0 });
ds.ElectronAppAdapter = void 0;
const lh = oe, O$ = Yu;
class $$ {
  constructor(t = Bn.app) {
    this.app = t;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  whenReady() {
    return this.app.whenReady();
  }
  get version() {
    return this.app.getVersion();
  }
  get name() {
    return this.app.getName();
  }
  get isPackaged() {
    return this.app.isPackaged === !0;
  }
  get appUpdateConfigPath() {
    return this.isPackaged ? lh.join(process.resourcesPath, "app-update.yml") : lh.join(this.app.getAppPath(), "dev-app-update.yml");
  }
  get userDataPath() {
    return this.app.getPath("userData");
  }
  get baseCachePath() {
<<<<<<< HEAD
    return (0, AppAdapter_1.getAppCacheDir)();
=======
    return (0, O$.getAppCacheDir)();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  quit() {
    this.app.quit();
  }
  relaunch() {
    this.app.relaunch();
  }
  onQuit(t) {
    this.app.once("quit", (n, r) => t(r));
  }
}
<<<<<<< HEAD
ElectronAppAdapter$1.ElectronAppAdapter = ElectronAppAdapter;
var electronHttpExecutor = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ElectronHttpExecutor = exports.NET_SESSION_NAME = void 0;
  exports.getNetSession = getNetSession;
  const builder_util_runtime_12 = out;
  exports.NET_SESSION_NAME = "electron-updater";
  function getNetSession() {
    return require$$1$8.session.fromPartition(exports.NET_SESSION_NAME, {
      cache: false
=======
ds.ElectronAppAdapter = $$;
var ux = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ElectronHttpExecutor = e.NET_SESSION_NAME = void 0, e.getNetSession = n;
  const t = De;
  e.NET_SESSION_NAME = "electron-updater";
  function n() {
    return Bn.session.fromPartition(e.NET_SESSION_NAME, {
      cache: !1
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    });
  }
  class r extends t.HttpExecutor {
    constructor(a) {
      super(), this.proxyLoginCallback = a, this.cachedSession = null;
    }
    async download(a, o, c) {
      return await c.cancellationToken.createPromise((s, u, l) => {
        const p = {
          headers: c.headers || void 0,
          redirect: "manual"
        };
        (0, t.configureRequestUrl)(a, p), (0, t.configureRequestOptions)(p), this.doDownload(p, {
          destination: o,
          options: c,
          onCancel: l,
          callback: (d) => {
            d == null ? s(o) : u(d);
          },
          responseHandler: null
        }, 0);
      });
    }
<<<<<<< HEAD
    createRequest(options, callback) {
      if (options.headers && options.headers.Host) {
        options.host = options.headers.Host;
        delete options.headers.Host;
      }
      if (this.cachedSession == null) {
        this.cachedSession = getNetSession();
      }
      const request = require$$1$8.net.request({
        ...options,
=======
    createRequest(a, o) {
      a.headers && a.headers.Host && (a.host = a.headers.Host, delete a.headers.Host), this.cachedSession == null && (this.cachedSession = n());
      const c = Bn.net.request({
        ...a,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        session: this.cachedSession
      });
      return c.on("response", o), this.proxyLoginCallback != null && c.on("login", this.proxyLoginCallback), c;
    }
    addRedirectHandlers(a, o, c, s, u) {
      a.on("redirect", (l, p, d) => {
        a.abort(), s > this.maxRedirects ? c(this.createMaxRedirectError()) : u(t.HttpExecutor.prepareRedirectUrlOptions(d, o));
      });
    }
  }
<<<<<<< HEAD
  exports.ElectronHttpExecutor = ElectronHttpExecutor;
})(electronHttpExecutor);
var GenericProvider$1 = {};
var util = {};
var symbolTag = "[object Symbol]";
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var Symbol$1 = root.Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toString4(value) {
  return value == null ? "" : baseToString(value);
}
function escapeRegExp$1(string) {
  string = toString4(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
}
var lodash_escaperegexp = escapeRegExp$1;
Object.defineProperty(util, "__esModule", { value: true });
util.newBaseUrl = newBaseUrl;
util.newUrlFromBase = newUrlFromBase;
util.getChannelFilename = getChannelFilename;
util.blockmapFiles = blockmapFiles;
const url_1$4 = require$$0$3;
const escapeRegExp = lodash_escaperegexp;
function newBaseUrl(url2) {
  const result = new url_1$4.URL(url2);
  if (!result.pathname.endsWith("/")) {
    result.pathname += "/";
  }
  return result;
}
function newUrlFromBase(pathname, baseUrl, addRandomQueryToAvoidCaching = false) {
  const result = new url_1$4.URL(pathname, baseUrl);
  const search = baseUrl.search;
  if (search != null && search.length !== 0) {
    result.search = search;
  } else if (addRandomQueryToAvoidCaching) {
    result.search = `noCache=${Date.now().toString(32)}`;
  }
  return result;
}
function getChannelFilename(channel) {
  return `${channel}.yml`;
}
function blockmapFiles(baseUrl, oldVersion, newVersion) {
  const newBlockMapUrl = newUrlFromBase(`${baseUrl.pathname}.blockmap`, baseUrl);
  const oldBlockMapUrl = newUrlFromBase(`${baseUrl.pathname.replace(new RegExp(escapeRegExp(newVersion), "g"), oldVersion)}.blockmap`, baseUrl);
  return [oldBlockMapUrl, newBlockMapUrl];
}
var Provider$1 = {};
Object.defineProperty(Provider$1, "__esModule", { value: true });
Provider$1.Provider = void 0;
Provider$1.findFile = findFile;
Provider$1.parseUpdateInfo = parseUpdateInfo;
Provider$1.getFileList = getFileList;
Provider$1.resolveFiles = resolveFiles;
const builder_util_runtime_1$e = out;
const js_yaml_1$2 = jsYaml;
const util_1$6 = util;
class Provider {
  constructor(runtimeOptions) {
    this.runtimeOptions = runtimeOptions;
    this.requestHeaders = null;
    this.executor = runtimeOptions.executor;
=======
  e.ElectronHttpExecutor = r;
})(ux);
var Zi = {}, st = {}, I$ = "[object Symbol]", px = /[\\^$.*+?()[\]{}|]/g, P$ = RegExp(px.source), D$ = typeof Te == "object" && Te && Te.Object === Object && Te, F$ = typeof self == "object" && self && self.Object === Object && self, N$ = D$ || F$ || Function("return this")(), k$ = Object.prototype, L$ = k$.toString, uh = N$.Symbol, ph = uh ? uh.prototype : void 0, fh = ph ? ph.toString : void 0;
function U$(e) {
  if (typeof e == "string")
    return e;
  if (j$(e))
    return fh ? fh.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function B$(e) {
  return !!e && typeof e == "object";
}
function j$(e) {
  return typeof e == "symbol" || B$(e) && L$.call(e) == I$;
}
function M$(e) {
  return e == null ? "" : U$(e);
}
function q$(e) {
  return e = M$(e), e && P$.test(e) ? e.replace(px, "\\$&") : e;
}
var z$ = q$;
Object.defineProperty(st, "__esModule", { value: !0 });
st.newBaseUrl = G$;
st.newUrlFromBase = $l;
st.getChannelFilename = W$;
st.blockmapFiles = V$;
const fx = At, H$ = z$;
function G$(e) {
  const t = new fx.URL(e);
  return t.pathname.endsWith("/") || (t.pathname += "/"), t;
}
function $l(e, t, n = !1) {
  const r = new fx.URL(e, t), i = t.search;
  return i != null && i.length !== 0 ? r.search = i : n && (r.search = `noCache=${Date.now().toString(32)}`), r;
}
function W$(e) {
  return `${e}.yml`;
}
function V$(e, t, n) {
  const r = $l(`${e.pathname}.blockmap`, e);
  return [$l(`${e.pathname.replace(new RegExp(H$(n), "g"), t)}.blockmap`, e), r];
}
var Ce = {};
Object.defineProperty(Ce, "__esModule", { value: !0 });
Ce.Provider = void 0;
Ce.findFile = K$;
Ce.parseUpdateInfo = J$;
Ce.getFileList = dx;
Ce.resolveFiles = Z$;
const pn = De, Y$ = Ue, dh = st;
class X$ {
  constructor(t) {
    this.runtimeOptions = t, this.requestHeaders = null, this.executor = t.executor;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  get isUseMultipleRangeRequest() {
    return this.runtimeOptions.isUseMultipleRangeRequest !== !1;
  }
  getChannelFilePrefix() {
    if (this.runtimeOptions.platform === "linux") {
      const t = process.env.TEST_UPDATER_ARCH || process.arch;
      return "-linux" + (t === "x64" ? "" : `-${t}`);
    } else
      return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
  }
  // due to historical reasons for windows we use channel name without platform specifier
  getDefaultChannelName() {
    return this.getCustomChannelName("latest");
  }
  getCustomChannelName(t) {
    return `${t}${this.getChannelFilePrefix()}`;
  }
  get fileExtraDownloadHeaders() {
    return null;
  }
  setRequestHeaders(t) {
    this.requestHeaders = t;
  }
  /**
   * Method to perform API request only to resolve update info, but not to download update.
   */
  httpRequest(t, n, r) {
    return this.executor.request(this.createRequestOptions(t, n), r);
  }
  createRequestOptions(t, n) {
    const r = {};
    return this.requestHeaders == null ? n != null && (r.headers = n) : r.headers = n == null ? this.requestHeaders : { ...this.requestHeaders, ...n }, (0, pn.configureRequestUrl)(t, r), r;
  }
}
<<<<<<< HEAD
Provider$1.Provider = Provider;
function findFile(files, extension, not) {
  if (files.length === 0) {
    throw (0, builder_util_runtime_1$e.newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
  }
  const result = files.find((it) => it.url.pathname.toLowerCase().endsWith(`.${extension}`));
  if (result != null) {
    return result;
  } else if (not == null) {
    return files[0];
  } else {
    return files.find((fileInfo) => !not.some((ext) => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));
  }
}
function parseUpdateInfo(rawData, channelFile, channelFileUrl) {
  if (rawData == null) {
    throw (0, builder_util_runtime_1$e.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  }
  let result;
  try {
    result = (0, js_yaml_1$2.load)(rawData);
  } catch (e) {
    throw (0, builder_util_runtime_1$e.newError)(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
=======
Ce.Provider = X$;
function K$(e, t, n) {
  if (e.length === 0)
    throw (0, pn.newError)("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
  const r = e.find((i) => i.url.pathname.toLowerCase().endsWith(`.${t}`));
  return r ?? (n == null ? e[0] : e.find((i) => !n.some((a) => i.url.pathname.toLowerCase().endsWith(`.${a}`))));
}
function J$(e, t, n) {
  if (e == null)
    throw (0, pn.newError)(`Cannot parse update info from ${t} in the latest release artifacts (${n}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  let r;
  try {
    r = (0, Y$.load)(e);
  } catch (i) {
    throw (0, pn.newError)(`Cannot parse update info from ${t} in the latest release artifacts (${n}): ${i.stack || i.message}, rawData: ${e}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return r;
}
function dx(e) {
  const t = e.files;
  if (t != null && t.length > 0)
    return t;
  if (e.path != null)
    return [
      {
        url: e.path,
        sha2: e.sha2,
        sha512: e.sha512
      }
    ];
  throw (0, pn.newError)(`No files provided: ${(0, pn.safeStringifyJson)(e)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
}
<<<<<<< HEAD
function resolveFiles(updateInfo, baseUrl, pathTransformer = (p) => p) {
  const files = getFileList(updateInfo);
  const result = files.map((fileInfo) => {
    if (fileInfo.sha2 == null && fileInfo.sha512 == null) {
      throw (0, builder_util_runtime_1$e.newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, builder_util_runtime_1$e.safeStringifyJson)(fileInfo)}`, "ERR_UPDATER_NO_CHECKSUM");
    }
=======
function Z$(e, t, n = (r) => r) {
  const i = dx(e).map((c) => {
    if (c.sha2 == null && c.sha512 == null)
      throw (0, pn.newError)(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, pn.safeStringifyJson)(c)}`, "ERR_UPDATER_NO_CHECKSUM");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return {
      url: (0, dh.newUrlFromBase)(n(c.url), t),
      info: c
    };
  }), a = e.packages, o = a == null ? null : a[process.arch] || a.ia32;
  return o != null && (i[0].packageInfo = {
    ...o,
    path: (0, dh.newUrlFromBase)(n(o.path), t).href
  }), i;
}
<<<<<<< HEAD
Object.defineProperty(GenericProvider$1, "__esModule", { value: true });
GenericProvider$1.GenericProvider = void 0;
const builder_util_runtime_1$d = out;
const util_1$5 = util;
const Provider_1$a = Provider$1;
class GenericProvider extends Provider_1$a.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super(runtimeOptions);
    this.configuration = configuration;
    this.updater = updater;
    this.baseUrl = (0, util_1$5.newBaseUrl)(this.configuration.url);
=======
Object.defineProperty(Zi, "__esModule", { value: !0 });
Zi.GenericProvider = void 0;
const hh = De, Mc = st, qc = Ce;
class Q$ extends qc.Provider {
  constructor(t, n, r) {
    super(r), this.configuration = t, this.updater = n, this.baseUrl = (0, Mc.newBaseUrl)(this.configuration.url);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  get channel() {
    const t = this.updater.channel || this.configuration.channel;
    return t == null ? this.getDefaultChannelName() : this.getCustomChannelName(t);
  }
  async getLatestVersion() {
    const t = (0, Mc.getChannelFilename)(this.channel), n = (0, Mc.newUrlFromBase)(t, this.baseUrl, this.updater.isAddNoCacheQuery);
    for (let r = 0; ; r++)
      try {
        return (0, qc.parseUpdateInfo)(await this.httpRequest(n), t, n);
      } catch (i) {
        if (i instanceof hh.HttpError && i.statusCode === 404)
          throw (0, hh.newError)(`Cannot find channel "${t}" update info: ${i.stack || i.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        if (i.code === "ECONNREFUSED" && r < 3) {
          await new Promise((a, o) => {
            try {
              setTimeout(a, 1e3 * r);
            } catch (c) {
              o(c);
            }
          });
          continue;
        }
        throw i;
      }
  }
  resolveFiles(t) {
    return (0, qc.resolveFiles)(t, this.baseUrl);
  }
}
<<<<<<< HEAD
GenericProvider$1.GenericProvider = GenericProvider;
var providerFactory = {};
var BitbucketProvider$1 = {};
Object.defineProperty(BitbucketProvider$1, "__esModule", { value: true });
BitbucketProvider$1.BitbucketProvider = void 0;
const builder_util_runtime_1$c = out;
const util_1$4 = util;
const Provider_1$9 = Provider$1;
class BitbucketProvider extends Provider_1$9.Provider {
  constructor(configuration, updater, runtimeOptions) {
=======
Zi.GenericProvider = Q$;
var hs = {}, ms = {};
Object.defineProperty(ms, "__esModule", { value: !0 });
ms.BitbucketProvider = void 0;
const mh = De, zc = st, Hc = Ce;
class e3 extends Hc.Provider {
  constructor(t, n, r) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    super({
      ...r,
      isUseMultipleRangeRequest: !1
    }), this.configuration = t, this.updater = n;
    const { owner: i, slug: a } = t;
    this.baseUrl = (0, zc.newBaseUrl)(`https://api.bitbucket.org/2.0/repositories/${i}/${a}/downloads`);
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "latest";
  }
  async getLatestVersion() {
    const t = new mh.CancellationToken(), n = (0, zc.getChannelFilename)(this.getCustomChannelName(this.channel)), r = (0, zc.newUrlFromBase)(n, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const i = await this.httpRequest(r, void 0, t);
      return (0, Hc.parseUpdateInfo)(i, n, r);
    } catch (i) {
      throw (0, mh.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${i.stack || i.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(t) {
    return (0, Hc.resolveFiles)(t, this.baseUrl);
  }
  toString() {
    const { owner: t, slug: n } = this.configuration;
    return `Bitbucket (owner: ${t}, slug: ${n}, channel: ${this.channel})`;
  }
}
<<<<<<< HEAD
BitbucketProvider$1.BitbucketProvider = BitbucketProvider;
var GitHubProvider$1 = {};
Object.defineProperty(GitHubProvider$1, "__esModule", { value: true });
GitHubProvider$1.GitHubProvider = GitHubProvider$1.BaseGitHubProvider = void 0;
GitHubProvider$1.computeReleaseNotes = computeReleaseNotes;
const builder_util_runtime_1$b = out;
const semver = semver$1;
const url_1$3 = require$$0$3;
const util_1$3 = util;
const Provider_1$8 = Provider$1;
const hrefRegExp = /\/tag\/([^/]+)$/;
class BaseGitHubProvider extends Provider_1$8.Provider {
  constructor(options, defaultHost, runtimeOptions) {
=======
ms.BitbucketProvider = e3;
var fn = {};
Object.defineProperty(fn, "__esModule", { value: !0 });
fn.GitHubProvider = fn.BaseGitHubProvider = void 0;
fn.computeReleaseNotes = mx;
const Ft = De, gr = lx, t3 = At, xr = st, Il = Ce, Gc = /\/tag\/([^/]+)$/;
class hx extends Il.Provider {
  constructor(t, n, r) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    super({
      ...r,
      /* because GitHib uses S3 */
<<<<<<< HEAD
      isUseMultipleRangeRequest: false
    });
    this.options = options;
    this.baseUrl = (0, util_1$3.newBaseUrl)((0, builder_util_runtime_1$b.githubUrl)(options, defaultHost));
    const apiHost = defaultHost === "github.com" ? "api.github.com" : defaultHost;
    this.baseApiUrl = (0, util_1$3.newBaseUrl)((0, builder_util_runtime_1$b.githubUrl)(options, apiHost));
=======
      isUseMultipleRangeRequest: !1
    }), this.options = t, this.baseUrl = (0, xr.newBaseUrl)((0, Ft.githubUrl)(t, n));
    const i = n === "github.com" ? "api.github.com" : n;
    this.baseApiUrl = (0, xr.newBaseUrl)((0, Ft.githubUrl)(t, i));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  computeGithubBasePath(t) {
    const n = this.options.host;
    return n && !["github.com", "api.github.com"].includes(n) ? `/api/v3${t}` : t;
  }
}
<<<<<<< HEAD
GitHubProvider$1.BaseGitHubProvider = BaseGitHubProvider;
class GitHubProvider extends BaseGitHubProvider {
  constructor(options, updater, runtimeOptions) {
    super(options, "github.com", runtimeOptions);
    this.options = options;
    this.updater = updater;
=======
fn.BaseGitHubProvider = hx;
class n3 extends hx {
  constructor(t, n, r) {
    super(t, "github.com", r), this.options = t, this.updater = n;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  get channel() {
    const t = this.updater.channel || this.options.channel;
    return t == null ? this.getDefaultChannelName() : this.getCustomChannelName(t);
  }
  async getLatestVersion() {
<<<<<<< HEAD
    var _a, _b, _c, _d, _e;
    const cancellationToken = new builder_util_runtime_1$b.CancellationToken();
    const feedXml = await this.httpRequest((0, util_1$3.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl), {
      accept: "application/xml, application/atom+xml, text/xml, */*"
    }, cancellationToken);
    const feed = (0, builder_util_runtime_1$b.parseXml)(feedXml);
    let latestRelease = feed.element("entry", false, `No published versions on GitHub`);
    let tag = null;
=======
    var t, n, r, i, a;
    const o = new Ft.CancellationToken(), c = await this.httpRequest((0, xr.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl), {
      accept: "application/xml, application/atom+xml, text/xml, */*"
    }, o), s = (0, Ft.parseXml)(c);
    let u = s.element("entry", !1, "No published versions on GitHub"), l = null;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    try {
      if (this.updater.allowPrerelease) {
        const y = ((t = this.updater) === null || t === void 0 ? void 0 : t.channel) || ((n = gr.prerelease(this.updater.currentVersion)) === null || n === void 0 ? void 0 : n[0]) || null;
        if (y === null)
          l = Gc.exec(u.element("link").attribute("href"))[1];
        else
          for (const x of s.getElements("entry")) {
            const w = Gc.exec(x.element("link").attribute("href"));
            if (w === null)
              continue;
            const A = w[1], O = ((r = gr.prerelease(A)) === null || r === void 0 ? void 0 : r[0]) || null, k = !y || ["alpha", "beta"].includes(y), q = O !== null && !["alpha", "beta"].includes(String(O));
            if (k && !q && !(y === "beta" && O === "alpha")) {
              l = A;
              break;
            }
            if (O && O === y) {
              l = A;
              break;
            }
          }
      } else {
        l = await this.getLatestTagName(o);
        for (const y of s.getElements("entry"))
          if (Gc.exec(y.element("link").attribute("href"))[1] === l) {
            u = y;
            break;
          }
      }
<<<<<<< HEAD
    } catch (e) {
      throw (0, builder_util_runtime_1$b.newError)(`Cannot parse releases feed: ${e.stack || e.message},
=======
    } catch (y) {
      throw (0, Ft.newError)(`Cannot parse releases feed: ${y.stack || y.message},
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
XML:
${c}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
    }
<<<<<<< HEAD
    if (tag == null) {
      throw (0, builder_util_runtime_1$b.newError)(`No published versions on GitHub`, "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
    }
    let rawData;
    let channelFile = "";
    let channelFileUrl = "";
    const fetchData = async (channelName) => {
      channelFile = (0, util_1$3.getChannelFilename)(channelName);
      channelFileUrl = (0, util_1$3.newUrlFromBase)(this.getBaseDownloadPath(String(tag), channelFile), this.baseUrl);
      const requestOptions = this.createRequestOptions(channelFileUrl);
      try {
        return await this.executor.request(requestOptions, cancellationToken);
      } catch (e) {
        if (e instanceof builder_util_runtime_1$b.HttpError && e.statusCode === 404) {
          throw (0, builder_util_runtime_1$b.newError)(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        }
        throw e;
=======
    if (l == null)
      throw (0, Ft.newError)("No published versions on GitHub", "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
    let p, d = "", m = "";
    const g = async (y) => {
      d = (0, xr.getChannelFilename)(y), m = (0, xr.newUrlFromBase)(this.getBaseDownloadPath(String(l), d), this.baseUrl);
      const x = this.createRequestOptions(m);
      try {
        return await this.executor.request(x, o);
      } catch (w) {
        throw w instanceof Ft.HttpError && w.statusCode === 404 ? (0, Ft.newError)(`Cannot find ${d} in the latest release artifacts (${m}): ${w.stack || w.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND") : w;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
    };
    try {
      let y = this.channel;
      this.updater.allowPrerelease && (!((i = gr.prerelease(l)) === null || i === void 0) && i[0]) && (y = this.getCustomChannelName(String((a = gr.prerelease(l)) === null || a === void 0 ? void 0 : a[0]))), p = await g(y);
    } catch (y) {
      if (this.updater.allowPrerelease)
        p = await g(this.getDefaultChannelName());
      else
        throw y;
    }
    const v = (0, Il.parseUpdateInfo)(p, d, m);
    return v.releaseName == null && (v.releaseName = u.elementValueOrEmpty("title")), v.releaseNotes == null && (v.releaseNotes = mx(this.updater.currentVersion, this.updater.fullChangelog, s, u)), {
      tag: l,
      ...v
    };
  }
<<<<<<< HEAD
  async getLatestTagName(cancellationToken) {
    const options = this.options;
    const url2 = options.host == null || options.host === "github.com" ? (0, util_1$3.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl) : new url_1$3.URL(`${this.computeGithubBasePath(`/repos/${options.owner}/${options.repo}/releases`)}/latest`, this.baseApiUrl);
    try {
      const rawData = await this.httpRequest(url2, { Accept: "application/json" }, cancellationToken);
      if (rawData == null) {
        return null;
      }
      const releaseInfo = JSON.parse(rawData);
      return releaseInfo.tag_name;
    } catch (e) {
      throw (0, builder_util_runtime_1$b.newError)(`Unable to find latest version on GitHub (${url2}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
=======
  async getLatestTagName(t) {
    const n = this.options, r = n.host == null || n.host === "github.com" ? (0, xr.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl) : new t3.URL(`${this.computeGithubBasePath(`/repos/${n.owner}/${n.repo}/releases`)}/latest`, this.baseApiUrl);
    try {
      const i = await this.httpRequest(r, { Accept: "application/json" }, t);
      return i == null ? null : JSON.parse(i).tag_name;
    } catch (i) {
      throw (0, Ft.newError)(`Unable to find latest version on GitHub (${r}), please ensure a production release exists: ${i.stack || i.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
  }
  get basePath() {
    return `/${this.options.owner}/${this.options.repo}/releases`;
  }
  resolveFiles(t) {
    return (0, Il.resolveFiles)(t, this.baseUrl, (n) => this.getBaseDownloadPath(t.tag, n.replace(/ /g, "-")));
  }
  getBaseDownloadPath(t, n) {
    return `${this.basePath}/download/${t}/${n}`;
  }
}
<<<<<<< HEAD
GitHubProvider$1.GitHubProvider = GitHubProvider;
function getNoteValue(parent) {
  const result = parent.elementValueOrEmpty("content");
  return result === "No content." ? "" : result;
=======
fn.GitHubProvider = n3;
function vh(e) {
  const t = e.elementValueOrEmpty("content");
  return t === "No content." ? "" : t;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
function mx(e, t, n, r) {
  if (!t)
    return vh(r);
  const i = [];
  for (const a of n.getElements("entry")) {
    const o = /\/tag\/v?([^/]+)$/.exec(a.element("link").attribute("href"))[1];
    gr.lt(e, o) && i.push({
      version: o,
      note: vh(a)
    });
  }
  return i.sort((a, o) => gr.rcompare(a.version, o.version));
}
<<<<<<< HEAD
var KeygenProvider$1 = {};
Object.defineProperty(KeygenProvider$1, "__esModule", { value: true });
KeygenProvider$1.KeygenProvider = void 0;
const builder_util_runtime_1$a = out;
const util_1$2 = util;
const Provider_1$7 = Provider$1;
class KeygenProvider extends Provider_1$7.Provider {
  constructor(configuration, updater, runtimeOptions) {
=======
var vs = {};
Object.defineProperty(vs, "__esModule", { value: !0 });
vs.KeygenProvider = void 0;
const gh = De, Wc = st, Vc = Ce;
class r3 extends Vc.Provider {
  constructor(t, n, r) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    super({
      ...r,
      isUseMultipleRangeRequest: !1
    }), this.configuration = t, this.updater = n, this.defaultHostname = "api.keygen.sh";
    const i = this.configuration.host || this.defaultHostname;
    this.baseUrl = (0, Wc.newBaseUrl)(`https://${i}/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`);
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "stable";
  }
  async getLatestVersion() {
    const t = new gh.CancellationToken(), n = (0, Wc.getChannelFilename)(this.getCustomChannelName(this.channel)), r = (0, Wc.newUrlFromBase)(n, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const i = await this.httpRequest(r, {
        Accept: "application/vnd.api+json",
        "Keygen-Version": "1.1"
      }, t);
      return (0, Vc.parseUpdateInfo)(i, n, r);
    } catch (i) {
      throw (0, gh.newError)(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${i.stack || i.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(t) {
    return (0, Vc.resolveFiles)(t, this.baseUrl);
  }
  toString() {
    const { account: t, product: n, platform: r } = this.configuration;
    return `Keygen (account: ${t}, product: ${n}, platform: ${r}, channel: ${this.channel})`;
  }
}
<<<<<<< HEAD
KeygenProvider$1.KeygenProvider = KeygenProvider;
var PrivateGitHubProvider$1 = {};
Object.defineProperty(PrivateGitHubProvider$1, "__esModule", { value: true });
PrivateGitHubProvider$1.PrivateGitHubProvider = void 0;
const builder_util_runtime_1$9 = out;
const js_yaml_1$1 = jsYaml;
const path$5 = require$$1$4;
const url_1$2 = require$$0$3;
const util_1$1 = util;
const GitHubProvider_1$1 = GitHubProvider$1;
const Provider_1$6 = Provider$1;
class PrivateGitHubProvider extends GitHubProvider_1$1.BaseGitHubProvider {
  constructor(options, updater, token, runtimeOptions) {
    super(options, "api.github.com", runtimeOptions);
    this.updater = updater;
    this.token = token;
=======
vs.KeygenProvider = r3;
var gs = {};
Object.defineProperty(gs, "__esModule", { value: !0 });
gs.PrivateGitHubProvider = void 0;
const ir = De, i3 = Ue, a3 = oe, xh = At, yh = st, o3 = fn, s3 = Ce;
class c3 extends o3.BaseGitHubProvider {
  constructor(t, n, r, i) {
    super(t, "api.github.com", i), this.updater = n, this.token = r;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  createRequestOptions(t, n) {
    const r = super.createRequestOptions(t, n);
    return r.redirect = "manual", r;
  }
  async getLatestVersion() {
<<<<<<< HEAD
    const cancellationToken = new builder_util_runtime_1$9.CancellationToken();
    const channelFile = (0, util_1$1.getChannelFilename)(this.getDefaultChannelName());
    const releaseInfo = await this.getLatestVersionInfo(cancellationToken);
    const asset = releaseInfo.assets.find((it) => it.name === channelFile);
    if (asset == null) {
      throw (0, builder_util_runtime_1$9.newError)(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
=======
    const t = new ir.CancellationToken(), n = (0, yh.getChannelFilename)(this.getDefaultChannelName()), r = await this.getLatestVersionInfo(t), i = r.assets.find((c) => c.name === n);
    if (i == null)
      throw (0, ir.newError)(`Cannot find ${n} in the release ${r.html_url || r.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
    const a = new xh.URL(i.url);
    let o;
    try {
      o = (0, i3.load)(await this.httpRequest(a, this.configureHeaders("application/octet-stream"), t));
    } catch (c) {
      throw c instanceof ir.HttpError && c.statusCode === 404 ? (0, ir.newError)(`Cannot find ${n} in the latest release artifacts (${a}): ${c.stack || c.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND") : c;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    return o.assets = r.assets, o;
  }
  get fileExtraDownloadHeaders() {
    return this.configureHeaders("application/octet-stream");
  }
  configureHeaders(t) {
    return {
      accept: t,
      authorization: `token ${this.token}`
    };
  }
  async getLatestVersionInfo(t) {
    const n = this.updater.allowPrerelease;
    let r = this.basePath;
    n || (r = `${r}/latest`);
    const i = (0, yh.newUrlFromBase)(r, this.baseUrl);
    try {
      const a = JSON.parse(await this.httpRequest(i, this.configureHeaders("application/vnd.github.v3+json"), t));
      return n ? a.find((o) => o.prerelease) || a[0] : a;
    } catch (a) {
      throw (0, ir.newError)(`Unable to find latest version on GitHub (${i}), please ensure a production release exists: ${a.stack || a.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
  }
<<<<<<< HEAD
  resolveFiles(updateInfo) {
    return (0, Provider_1$6.getFileList)(updateInfo).map((it) => {
      const name = path$5.posix.basename(it.url).replace(/ /g, "-");
      const asset = updateInfo.assets.find((it2) => it2 != null && it2.name === name);
      if (asset == null) {
        throw (0, builder_util_runtime_1$9.newError)(`Cannot find asset "${name}" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
      }
=======
  resolveFiles(t) {
    return (0, s3.getFileList)(t).map((n) => {
      const r = a3.posix.basename(n.url).replace(/ /g, "-"), i = t.assets.find((a) => a != null && a.name === r);
      if (i == null)
        throw (0, ir.newError)(`Cannot find asset "${r}" in: ${JSON.stringify(t.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      return {
        url: new xh.URL(i.url),
        info: n
      };
    });
  }
}
<<<<<<< HEAD
PrivateGitHubProvider$1.PrivateGitHubProvider = PrivateGitHubProvider;
Object.defineProperty(providerFactory, "__esModule", { value: true });
providerFactory.isUrlProbablySupportMultiRangeRequests = isUrlProbablySupportMultiRangeRequests;
providerFactory.createClient = createClient;
const builder_util_runtime_1$8 = out;
const BitbucketProvider_1 = BitbucketProvider$1;
const GenericProvider_1$1 = GenericProvider$1;
const GitHubProvider_1 = GitHubProvider$1;
const KeygenProvider_1 = KeygenProvider$1;
const PrivateGitHubProvider_1 = PrivateGitHubProvider$1;
function isUrlProbablySupportMultiRangeRequests(url2) {
  return !url2.includes("s3.amazonaws.com");
}
function createClient(data, updater, runtimeOptions) {
  if (typeof data === "string") {
    throw (0, builder_util_runtime_1$8.newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
  }
  const provider = data.provider;
  switch (provider) {
    case "github": {
      const githubOptions = data;
      const token = (githubOptions.private ? process.env["GH_TOKEN"] || process.env["GITHUB_TOKEN"] : null) || githubOptions.token;
      if (token == null) {
        return new GitHubProvider_1.GitHubProvider(githubOptions, updater, runtimeOptions);
      } else {
        return new PrivateGitHubProvider_1.PrivateGitHubProvider(githubOptions, updater, token, runtimeOptions);
      }
    }
    case "bitbucket":
      return new BitbucketProvider_1.BitbucketProvider(data, updater, runtimeOptions);
    case "keygen":
      return new KeygenProvider_1.KeygenProvider(data, updater, runtimeOptions);
=======
gs.PrivateGitHubProvider = c3;
Object.defineProperty(hs, "__esModule", { value: !0 });
hs.isUrlProbablySupportMultiRangeRequests = vx;
hs.createClient = d3;
const Fa = De, l3 = ms, bh = Zi, u3 = fn, p3 = vs, f3 = gs;
function vx(e) {
  return !e.includes("s3.amazonaws.com");
}
function d3(e, t, n) {
  if (typeof e == "string")
    throw (0, Fa.newError)("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
  const r = e.provider;
  switch (r) {
    case "github": {
      const i = e, a = (i.private ? process.env.GH_TOKEN || process.env.GITHUB_TOKEN : null) || i.token;
      return a == null ? new u3.GitHubProvider(i, t, n) : new f3.PrivateGitHubProvider(i, t, a, n);
    }
    case "bitbucket":
      return new l3.BitbucketProvider(e, t, n);
    case "keygen":
      return new p3.KeygenProvider(e, t, n);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    case "s3":
    case "spaces":
      return new bh.GenericProvider({
        provider: "generic",
        url: (0, Fa.getS3LikeProviderBaseUrl)(e),
        channel: e.channel || null
      }, t, {
        ...n,
        // https://github.com/minio/minio/issues/5285#issuecomment-350428955
        isUseMultipleRangeRequest: !1
      });
    case "generic": {
      const i = e;
      return new bh.GenericProvider(i, t, {
        ...n,
        isUseMultipleRangeRequest: i.useMultipleRangeRequest !== !1 && vx(i.url)
      });
    }
    case "custom": {
      const i = e, a = i.updateProvider;
      if (!a)
        throw (0, Fa.newError)("Custom provider not specified", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
      return new a(i, t, n);
    }
    default:
      throw (0, Fa.newError)(`Unsupported provider: ${r}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
  }
}
<<<<<<< HEAD
var GenericDifferentialDownloader$1 = {};
var DifferentialDownloader$1 = {};
var DataSplitter$1 = {};
var downloadPlanBuilder = {};
Object.defineProperty(downloadPlanBuilder, "__esModule", { value: true });
downloadPlanBuilder.OperationKind = void 0;
downloadPlanBuilder.computeOperations = computeOperations;
var OperationKind$1;
(function(OperationKind2) {
  OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
  OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
})(OperationKind$1 || (downloadPlanBuilder.OperationKind = OperationKind$1 = {}));
function computeOperations(oldBlockMap, newBlockMap, logger) {
  const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);
  const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);
  let lastOperation = null;
  const blockMapFile = newBlockMap.files[0];
  const operations = [];
  const name = blockMapFile.name;
  const oldEntry = nameToOldBlocks.get(name);
  if (oldEntry == null) {
    throw new Error(`no file ${name} in old blockmap`);
  }
  const newFile = nameToNewBlocks.get(name);
  let changedBlockCount = 0;
  const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset, logger);
  let newOffset = blockMapFile.offset;
  for (let i = 0; i < newFile.checksums.length; newOffset += newFile.sizes[i], i++) {
    const blockSize = newFile.sizes[i];
    const checksum = newFile.checksums[i];
    let oldOffset = checksumToOldOffset.get(checksum);
    if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {
      logger.warn(`Checksum ("${checksum}") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);
      oldOffset = void 0;
    }
    if (oldOffset === void 0) {
      changedBlockCount++;
      if (lastOperation != null && lastOperation.kind === OperationKind$1.DOWNLOAD && lastOperation.end === newOffset) {
        lastOperation.end += blockSize;
      } else {
        lastOperation = {
          kind: OperationKind$1.DOWNLOAD,
          start: newOffset,
          end: newOffset + blockSize
          // oldBlocks: null,
        };
        validateAndAdd(lastOperation, operations, checksum, i);
      }
    } else {
      if (lastOperation != null && lastOperation.kind === OperationKind$1.COPY && lastOperation.end === oldOffset) {
        lastOperation.end += blockSize;
      } else {
        lastOperation = {
          kind: OperationKind$1.COPY,
          start: oldOffset,
          end: oldOffset + blockSize
          // oldBlocks: [checksum]
        };
        validateAndAdd(lastOperation, operations, checksum, i);
      }
    }
  }
  if (changedBlockCount > 0) {
    logger.info(`File${blockMapFile.name === "file" ? "" : " " + blockMapFile.name} has ${changedBlockCount} changed blocks`);
=======
var xs = {}, Qi = {}, Br = {}, Kn = {};
Object.defineProperty(Kn, "__esModule", { value: !0 });
Kn.OperationKind = void 0;
Kn.computeOperations = h3;
var Pn;
(function(e) {
  e[e.COPY = 0] = "COPY", e[e.DOWNLOAD = 1] = "DOWNLOAD";
})(Pn || (Kn.OperationKind = Pn = {}));
function h3(e, t, n) {
  const r = Eh(e.files), i = Eh(t.files);
  let a = null;
  const o = t.files[0], c = [], s = o.name, u = r.get(s);
  if (u == null)
    throw new Error(`no file ${s} in old blockmap`);
  const l = i.get(s);
  let p = 0;
  const { checksumToOffset: d, checksumToOldSize: m } = v3(r.get(s), u.offset, n);
  let g = o.offset;
  for (let v = 0; v < l.checksums.length; g += l.sizes[v], v++) {
    const y = l.sizes[v], x = l.checksums[v];
    let w = d.get(x);
    w != null && m.get(x) !== y && (n.warn(`Checksum ("${x}") matches, but size differs (old: ${m.get(x)}, new: ${y})`), w = void 0), w === void 0 ? (p++, a != null && a.kind === Pn.DOWNLOAD && a.end === g ? a.end += y : (a = {
      kind: Pn.DOWNLOAD,
      start: g,
      end: g + y
      // oldBlocks: null,
    }, wh(a, c, x, v))) : a != null && a.kind === Pn.COPY && a.end === w ? a.end += y : (a = {
      kind: Pn.COPY,
      start: w,
      end: w + y
      // oldBlocks: [checksum]
    }, wh(a, c, x, v));
  }
  return p > 0 && n.info(`File${o.name === "file" ? "" : " " + o.name} has ${p} changed blocks`), c;
}
const m3 = process.env.DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES === "true";
function wh(e, t, n, r) {
  if (m3 && t.length !== 0) {
    const i = t[t.length - 1];
    if (i.kind === e.kind && e.start < i.end && e.start > i.start) {
      const a = [i.start, i.end, e.start, e.end].reduce((o, c) => o < c ? o : c);
      throw new Error(`operation (block index: ${r}, checksum: ${n}, kind: ${Pn[e.kind]}) overlaps previous operation (checksum: ${n}):
abs: ${i.start} until ${i.end} and ${e.start} until ${e.end}
rel: ${i.start - a} until ${i.end - a} and ${e.start - a} until ${e.end - a}`);
    }
  }
  t.push(e);
}
function v3(e, t, n) {
  const r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  let a = t;
  for (let o = 0; o < e.checksums.length; o++) {
    const c = e.checksums[o], s = e.sizes[o], u = i.get(c);
    if (u === void 0)
      r.set(c, a), i.set(c, s);
    else if (n.debug != null) {
      const l = u === s ? "(same size)" : `(size: ${u}, this size: ${s})`;
      n.debug(`${c} duplicated in blockmap ${l}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
    }
    a += s;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  return { checksumToOffset: r, checksumToOldSize: i };
}
function Eh(e) {
  const t = /* @__PURE__ */ new Map();
  for (const n of e)
    t.set(n.name, n);
  return t;
}
<<<<<<< HEAD
function buildChecksumMap(file2, fileOffset, logger) {
  const checksumToOffset = /* @__PURE__ */ new Map();
  const checksumToSize = /* @__PURE__ */ new Map();
  let offset = fileOffset;
  for (let i = 0; i < file2.checksums.length; i++) {
    const checksum = file2.checksums[i];
    const size = file2.sizes[i];
    const existing = checksumToSize.get(checksum);
    if (existing === void 0) {
      checksumToOffset.set(checksum, offset);
      checksumToSize.set(checksum, size);
    } else if (logger.debug != null) {
      const sizeExplanation = existing === size ? "(same size)" : `(size: ${existing}, this size: ${size})`;
      logger.debug(`${checksum} duplicated in blockmap ${sizeExplanation}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
    }
    offset += size;
  }
  return { checksumToOffset, checksumToOldSize: checksumToSize };
}
function buildBlockFileMap(list) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    result.set(item.name, item);
  }
  return result;
}
Object.defineProperty(DataSplitter$1, "__esModule", { value: true });
DataSplitter$1.DataSplitter = void 0;
DataSplitter$1.copyData = copyData;
const builder_util_runtime_1$7 = out;
const fs_1$3 = fs$w;
const stream_1$1 = require$$1$2;
const downloadPlanBuilder_1$2 = downloadPlanBuilder;
const DOUBLE_CRLF = Buffer.from("\r\n\r\n");
var ReadState;
(function(ReadState2) {
  ReadState2[ReadState2["INIT"] = 0] = "INIT";
  ReadState2[ReadState2["HEADER"] = 1] = "HEADER";
  ReadState2[ReadState2["BODY"] = 2] = "BODY";
})(ReadState || (ReadState = {}));
function copyData(task, out2, oldFileFd, reject, resolve) {
  const readStream2 = (0, fs_1$3.createReadStream)("", {
    fd: oldFileFd,
    autoClose: false,
    start: task.start,
=======
Object.defineProperty(Br, "__esModule", { value: !0 });
Br.DataSplitter = void 0;
Br.copyData = gx;
const Na = De, g3 = ae, x3 = ie, y3 = Kn, _h = Buffer.from(`\r
\r
`);
var Kt;
(function(e) {
  e[e.INIT = 0] = "INIT", e[e.HEADER = 1] = "HEADER", e[e.BODY = 2] = "BODY";
})(Kt || (Kt = {}));
function gx(e, t, n, r, i) {
  const a = (0, g3.createReadStream)("", {
    fd: n,
    autoClose: !1,
    start: e.start,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    // end is inclusive
    end: e.end - 1
  });
  a.on("error", r), a.once("end", i), a.pipe(t, {
    end: !1
  });
}
<<<<<<< HEAD
class DataSplitter extends stream_1$1.Writable {
  constructor(out2, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {
    super();
    this.out = out2;
    this.options = options;
    this.partIndexToTaskIndex = partIndexToTaskIndex;
    this.partIndexToLength = partIndexToLength;
    this.finishHandler = finishHandler;
    this.partIndex = -1;
    this.headerListBuffer = null;
    this.readState = ReadState.INIT;
    this.ignoreByteCount = 0;
    this.remainingPartDataCount = 0;
    this.actualPartLength = 0;
    this.boundaryLength = boundary.length + 4;
    this.ignoreByteCount = this.boundaryLength - 2;
=======
class b3 extends x3.Writable {
  constructor(t, n, r, i, a, o) {
    super(), this.out = t, this.options = n, this.partIndexToTaskIndex = r, this.partIndexToLength = a, this.finishHandler = o, this.partIndex = -1, this.headerListBuffer = null, this.readState = Kt.INIT, this.ignoreByteCount = 0, this.remainingPartDataCount = 0, this.actualPartLength = 0, this.boundaryLength = i.length + 4, this.ignoreByteCount = this.boundaryLength - 2;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  get isFinished() {
    return this.partIndex === this.partIndexToLength.length;
  }
  // noinspection JSUnusedGlobalSymbols
  _write(t, n, r) {
    if (this.isFinished) {
      console.error(`Trailing ignored data: ${t.length} bytes`);
      return;
    }
    this.handleData(t).then(r).catch(r);
  }
  async handleData(t) {
    let n = 0;
    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0)
      throw (0, Na.newError)("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
    if (this.ignoreByteCount > 0) {
      const r = Math.min(this.ignoreByteCount, t.length);
      this.ignoreByteCount -= r, n = r;
    } else if (this.remainingPartDataCount > 0) {
      const r = Math.min(this.remainingPartDataCount, t.length);
      this.remainingPartDataCount -= r, await this.processPartData(t, 0, r), n = r;
    }
<<<<<<< HEAD
    if (start === chunk.length) {
      return;
    }
    if (this.readState === ReadState.HEADER) {
      const headerListEnd = this.searchHeaderListEnd(chunk, start);
      if (headerListEnd === -1) {
=======
    if (n !== t.length) {
      if (this.readState === Kt.HEADER) {
        const r = this.searchHeaderListEnd(t, n);
        if (r === -1)
          return;
        n = r, this.readState = Kt.BODY, this.headerListBuffer = null;
      }
      for (; ; ) {
        if (this.readState === Kt.BODY)
          this.readState = Kt.INIT;
        else {
          this.partIndex++;
          let o = this.partIndexToTaskIndex.get(this.partIndex);
          if (o == null)
            if (this.isFinished)
              o = this.options.end;
            else
              throw (0, Na.newError)("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
          const c = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
          if (c < o)
            await this.copyExistingData(c, o);
          else if (c > o)
            throw (0, Na.newError)("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
          if (this.isFinished) {
            this.onPartEnd(), this.finishHandler();
            return;
          }
          if (n = this.searchHeaderListEnd(t, n), n === -1) {
            this.readState = Kt.HEADER;
            return;
          }
        }
        const r = this.partIndexToLength[this.partIndex], i = n + r, a = Math.min(i, t.length);
        if (await this.processPartStarted(t, n, a), this.remainingPartDataCount = r - (a - n), this.remainingPartDataCount > 0)
          return;
        if (n = i + this.boundaryLength, n >= t.length) {
          this.ignoreByteCount = this.boundaryLength - (t.length - i);
          return;
        }
      }
    }
  }
  copyExistingData(t, n) {
    return new Promise((r, i) => {
      const a = () => {
        if (t === n) {
          r();
          return;
        }
        const o = this.options.tasks[t];
        if (o.kind !== y3.OperationKind.COPY) {
          i(new Error("Task kind must be COPY"));
          return;
        }
        gx(o, this.out, this.options.oldFileFd, i, () => {
          t++, a();
        });
      };
      a();
    });
  }
  searchHeaderListEnd(t, n) {
    const r = t.indexOf(_h, n);
    if (r !== -1)
      return r + _h.length;
    const i = n === 0 ? t : t.slice(n);
    return this.headerListBuffer == null ? this.headerListBuffer = i : this.headerListBuffer = Buffer.concat([this.headerListBuffer, i]), -1;
  }
  onPartEnd() {
    const t = this.partIndexToLength[this.partIndex - 1];
    if (this.actualPartLength !== t)
      throw (0, Na.newError)(`Expected length: ${t} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
    this.actualPartLength = 0;
  }
  processPartStarted(t, n, r) {
    return this.partIndex !== 0 && this.onPartEnd(), this.processPartData(t, n, r);
  }
  processPartData(t, n, r) {
    this.actualPartLength += r - n;
    const i = this.out;
    return i.write(n === 0 && t.length === r ? t : t.slice(n, r)) ? Promise.resolve() : new Promise((a, o) => {
      i.on("error", o), i.once("drain", () => {
        i.removeListener("error", o), a();
      });
    });
  }
}
Br.DataSplitter = b3;
var ys = {};
Object.defineProperty(ys, "__esModule", { value: !0 });
ys.executeTasksUsingMultipleRangeRequests = w3;
ys.checkIsRangesSupported = Dl;
const Pl = De, Sh = Br, Th = Kn;
function w3(e, t, n, r, i) {
  const a = (o) => {
    if (o >= t.length) {
      e.fileMetadataBuffer != null && n.write(e.fileMetadataBuffer), n.end();
      return;
    }
    const c = o + 1e3;
    E3(e, {
      tasks: t,
      start: o,
      end: Math.min(t.length, c),
      oldFileFd: r
    }, n, () => a(c), i);
  };
  return a;
}
function E3(e, t, n, r, i) {
  let a = "bytes=", o = 0;
  const c = /* @__PURE__ */ new Map(), s = [];
  for (let p = t.start; p < t.end; p++) {
    const d = t.tasks[p];
    d.kind === Th.OperationKind.DOWNLOAD && (a += `${d.start}-${d.end - 1}, `, c.set(o, p), o++, s.push(d.end - d.start));
  }
  if (o <= 1) {
    const p = (d) => {
      if (d >= t.end) {
        r();
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        return;
      }
      const m = t.tasks[d++];
      if (m.kind === Th.OperationKind.COPY)
        (0, Sh.copyData)(m, n, t.oldFileFd, i, () => p(d));
      else {
        const g = e.createRequestOptions();
        g.headers.Range = `bytes=${m.start}-${m.end - 1}`;
        const v = e.httpExecutor.createRequest(g, (y) => {
          Dl(y, i) && (y.pipe(n, {
            end: !1
          }), y.once("end", () => p(d)));
        });
        e.httpExecutor.addErrorAndTimeoutHandlers(v, i), v.end();
      }
    };
    p(t.start);
    return;
  }
  const u = e.createRequestOptions();
  u.headers.Range = a.substring(0, a.length - 2);
  const l = e.httpExecutor.createRequest(u, (p) => {
    if (!Dl(p, i))
      return;
    const d = (0, Pl.safeGetHeader)(p, "content-type"), m = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(d);
    if (m == null) {
      i(new Error(`Content-Type "multipart/byteranges" is expected, but got "${d}"`));
      return;
    }
    const g = new Sh.DataSplitter(n, t, c, m[1] || m[2], s, r);
    g.on("error", i), p.pipe(g), p.on("end", () => {
      setTimeout(() => {
        l.abort(), i(new Error("Response ends without calling any handlers"));
      }, 1e4);
    });
  });
  e.httpExecutor.addErrorAndTimeoutHandlers(l, i), l.end();
}
function Dl(e, t) {
  if (e.statusCode >= 400)
    return t((0, Pl.createHttpError)(e)), !1;
  if (e.statusCode !== 206) {
    const n = (0, Pl.safeGetHeader)(e, "accept-ranges");
    if (n == null || n === "none")
      return t(new Error(`Server doesn't support Accept-Ranges (response code ${e.statusCode})`)), !1;
  }
  return !0;
}
<<<<<<< HEAD
var ProgressDifferentialDownloadCallbackTransform$1 = {};
Object.defineProperty(ProgressDifferentialDownloadCallbackTransform$1, "__esModule", { value: true });
ProgressDifferentialDownloadCallbackTransform$1.ProgressDifferentialDownloadCallbackTransform = void 0;
const stream_1 = require$$1$2;
var OperationKind;
(function(OperationKind2) {
  OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
  OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
})(OperationKind || (OperationKind = {}));
class ProgressDifferentialDownloadCallbackTransform extends stream_1.Transform {
  constructor(progressDifferentialDownloadInfo, cancellationToken, onProgress) {
    super();
    this.progressDifferentialDownloadInfo = progressDifferentialDownloadInfo;
    this.cancellationToken = cancellationToken;
    this.onProgress = onProgress;
    this.start = Date.now();
    this.transferred = 0;
    this.delta = 0;
    this.expectedBytes = 0;
    this.index = 0;
    this.operationType = OperationKind.COPY;
    this.nextUpdate = this.start + 1e3;
=======
var bs = {};
Object.defineProperty(bs, "__esModule", { value: !0 });
bs.ProgressDifferentialDownloadCallbackTransform = void 0;
const _3 = ie;
var yr;
(function(e) {
  e[e.COPY = 0] = "COPY", e[e.DOWNLOAD = 1] = "DOWNLOAD";
})(yr || (yr = {}));
class S3 extends _3.Transform {
  constructor(t, n, r) {
    super(), this.progressDifferentialDownloadInfo = t, this.cancellationToken = n, this.onProgress = r, this.start = Date.now(), this.transferred = 0, this.delta = 0, this.expectedBytes = 0, this.index = 0, this.operationType = yr.COPY, this.nextUpdate = this.start + 1e3;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  _transform(t, n, r) {
    if (this.cancellationToken.cancelled) {
      r(new Error("cancelled"), null);
      return;
    }
    if (this.operationType == yr.COPY) {
      r(null, t);
      return;
    }
    this.transferred += t.length, this.delta += t.length;
    const i = Date.now();
    i >= this.nextUpdate && this.transferred !== this.expectedBytes && this.transferred !== this.progressDifferentialDownloadInfo.grandTotal && (this.nextUpdate = i + 1e3, this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
      bytesPerSecond: Math.round(this.transferred / ((i - this.start) / 1e3))
    }), this.delta = 0), r(null, t);
  }
  beginFileCopy() {
    this.operationType = yr.COPY;
  }
  beginRangeDownload() {
    this.operationType = yr.DOWNLOAD, this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];
  }
  endRangeDownload() {
    this.transferred !== this.progressDifferentialDownloadInfo.grandTotal && this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
  }
  // Called when we are 100% done with the connection/download
  _flush(t) {
    if (this.cancellationToken.cancelled) {
      t(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    }), this.delta = 0, this.transferred = 0, t(null);
  }
}
<<<<<<< HEAD
ProgressDifferentialDownloadCallbackTransform$1.ProgressDifferentialDownloadCallbackTransform = ProgressDifferentialDownloadCallbackTransform;
Object.defineProperty(DifferentialDownloader$1, "__esModule", { value: true });
DifferentialDownloader$1.DifferentialDownloader = void 0;
const builder_util_runtime_1$5 = out;
const fs_extra_1$5 = lib;
const fs_1$2 = fs$w;
const DataSplitter_1 = DataSplitter$1;
const url_1$1 = require$$0$3;
const downloadPlanBuilder_1 = downloadPlanBuilder;
const multipleRangeDownloader_1 = multipleRangeDownloader;
const ProgressDifferentialDownloadCallbackTransform_1 = ProgressDifferentialDownloadCallbackTransform$1;
class DifferentialDownloader {
=======
bs.ProgressDifferentialDownloadCallbackTransform = S3;
Object.defineProperty(Qi, "__esModule", { value: !0 });
Qi.DifferentialDownloader = void 0;
const Zr = De, Yc = vn, T3 = ae, A3 = Br, R3 = At, ka = Kn, Ah = ys, C3 = bs;
class O3 {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  // noinspection TypeScriptAbstractClassConstructorCanBeMadeProtected
  constructor(t, n, r) {
    this.blockAwareFileInfo = t, this.httpExecutor = n, this.options = r, this.fileMetadataBuffer = null, this.logger = r.logger;
  }
  createRequestOptions() {
    const t = {
      headers: {
        ...this.options.requestHeaders,
        accept: "*/*"
      }
    };
    return (0, Zr.configureRequestUrl)(this.options.newUrl, t), (0, Zr.configureRequestOptions)(t), t;
  }
  doDownload(t, n) {
    if (t.version !== n.version)
      throw new Error(`version is different (${t.version} - ${n.version}), full download is required`);
    const r = this.logger, i = (0, ka.computeOperations)(t, n, r);
    r.debug != null && r.debug(JSON.stringify(i, null, 2));
    let a = 0, o = 0;
    for (const s of i) {
      const u = s.end - s.start;
      s.kind === ka.OperationKind.DOWNLOAD ? a += u : o += u;
    }
    const c = this.blockAwareFileInfo.size;
    if (a + o + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== c)
      throw new Error(`Internal error, size mismatch: downloadSize: ${a}, copySize: ${o}, newSize: ${c}`);
    return r.info(`Full: ${Rh(c)}, To download: ${Rh(a)} (${Math.round(a / (c / 100))}%)`), this.downloadFile(i);
  }
  downloadFile(t) {
    const n = [], r = () => Promise.all(n.map((i) => (0, Yc.close)(i.descriptor).catch((a) => {
      this.logger.error(`cannot close file "${i.path}": ${a}`);
    })));
    return this.doDownloadFile(t, n).then(r).catch((i) => r().catch((a) => {
      try {
        this.logger.error(`cannot close files: ${a}`);
      } catch (o) {
        try {
<<<<<<< HEAD
          this.logger.error(`cannot close files: ${closeFilesError}`);
        } catch (errorOnLog) {
=======
          console.error(o);
        } catch {
        }
      }
      throw i;
    }).then(() => {
      throw i;
    }));
  }
  async doDownloadFile(t, n) {
    const r = await (0, Yc.open)(this.options.oldFile, "r");
    n.push({ descriptor: r, path: this.options.oldFile });
    const i = await (0, Yc.open)(this.options.newFile, "w");
    n.push({ descriptor: i, path: this.options.newFile });
    const a = (0, T3.createWriteStream)(this.options.newFile, { fd: i });
    await new Promise((o, c) => {
      const s = [];
      let u;
      if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
        const x = [];
        let w = 0;
        for (const O of t)
          O.kind === ka.OperationKind.DOWNLOAD && (x.push(O.end - O.start), w += O.end - O.start);
        const A = {
          expectedByteCounts: x,
          grandTotal: w
        };
        u = new C3.ProgressDifferentialDownloadCallbackTransform(A, this.options.cancellationToken, this.options.onProgress), s.push(u);
      }
      const l = new Zr.DigestTransform(this.blockAwareFileInfo.sha512);
      l.isValidateOnEnd = !1, s.push(l), a.on("finish", () => {
        a.close(() => {
          n.splice(1, 1);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
          try {
            l.validate();
          } catch (x) {
            c(x);
            return;
          }
          o(void 0);
        });
      }), s.push(a);
      let p = null;
      for (const x of s)
        x.on("error", c), p == null ? p = x : p = p.pipe(x);
      const d = s[0];
      let m;
      if (this.options.isUseMultipleRangeRequest) {
        m = (0, Ah.executeTasksUsingMultipleRangeRequests)(this, t, d, r, c), m(0);
        return;
      }
      let g = 0, v = null;
      this.logger.info(`Differential download: ${this.options.newUrl}`);
      const y = this.createRequestOptions();
      y.redirect = "manual", m = (x) => {
        var w, A;
        if (x >= t.length) {
          this.fileMetadataBuffer != null && d.write(this.fileMetadataBuffer), d.end();
          return;
        }
<<<<<<< HEAD
        const operation = tasks[index++];
        if (operation.kind === downloadPlanBuilder_1.OperationKind.COPY) {
          if (downloadInfoTransform) {
            downloadInfoTransform.beginFileCopy();
          }
          (0, DataSplitter_1.copyData)(operation, firstStream, oldFileFd, reject, () => w(index));
=======
        const O = t[x++];
        if (O.kind === ka.OperationKind.COPY) {
          u && u.beginFileCopy(), (0, A3.copyData)(O, d, r, c, () => m(x));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
          return;
        }
        const k = `bytes=${O.start}-${O.end - 1}`;
        y.headers.range = k, (A = (w = this.logger) === null || w === void 0 ? void 0 : w.debug) === null || A === void 0 || A.call(w, `download range: ${k}`), u && u.beginRangeDownload();
        const q = this.httpExecutor.createRequest(y, (W) => {
          W.on("error", c), W.on("aborted", () => {
            c(new Error("response has been aborted by the server"));
          }), W.statusCode >= 400 && c((0, Zr.createHttpError)(W)), W.pipe(d, {
            end: !1
          }), W.once("end", () => {
            u && u.endRangeDownload(), ++g === 100 ? (g = 0, setTimeout(() => m(x), 1e3)) : m(x);
          });
        });
<<<<<<< HEAD
        request.on("redirect", (statusCode, method, redirectUrl) => {
          this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);
          actualUrl = redirectUrl;
          (0, builder_util_runtime_1$5.configureRequestUrl)(new url_1$1.URL(actualUrl), requestOptions);
          request.followRedirect();
        });
        this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
        request.end();
      };
      w(0);
    });
  }
  async readRemoteBytes(start, endInclusive) {
    const buffer2 = Buffer.allocUnsafe(endInclusive + 1 - start);
    const requestOptions = this.createRequestOptions();
    requestOptions.headers.range = `bytes=${start}-${endInclusive}`;
    let position = 0;
    await this.request(requestOptions, (chunk) => {
      chunk.copy(buffer2, position);
      position += chunk.length;
    });
    if (position !== buffer2.length) {
      throw new Error(`Received data length ${position} is not equal to expected ${buffer2.length}`);
    }
    return buffer2;
=======
        q.on("redirect", (W, te, T) => {
          this.logger.info(`Redirect to ${$3(T)}`), v = T, (0, Zr.configureRequestUrl)(new R3.URL(v), y), q.followRedirect();
        }), this.httpExecutor.addErrorAndTimeoutHandlers(q, c), q.end();
      }, m(0);
    });
  }
  async readRemoteBytes(t, n) {
    const r = Buffer.allocUnsafe(n + 1 - t), i = this.createRequestOptions();
    i.headers.range = `bytes=${t}-${n}`;
    let a = 0;
    if (await this.request(i, (o) => {
      o.copy(r, a), a += o.length;
    }), a !== r.length)
      throw new Error(`Received data length ${a} is not equal to expected ${r.length}`);
    return r;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  request(t, n) {
    return new Promise((r, i) => {
      const a = this.httpExecutor.createRequest(t, (o) => {
        (0, Ah.checkIsRangesSupported)(o, i) && (o.on("error", i), o.on("aborted", () => {
          i(new Error("response has been aborted by the server"));
        }), o.on("data", n), o.on("end", () => r()));
      });
      this.httpExecutor.addErrorAndTimeoutHandlers(a, i), a.end();
    });
  }
}
<<<<<<< HEAD
DifferentialDownloader$1.DifferentialDownloader = DifferentialDownloader;
function formatBytes(value, symbol = " KB") {
  return new Intl.NumberFormat("en").format((value / 1024).toFixed(2)) + symbol;
}
function removeQuery(url2) {
  const index = url2.indexOf("?");
  return index < 0 ? url2 : url2.substring(0, index);
}
Object.defineProperty(GenericDifferentialDownloader$1, "__esModule", { value: true });
GenericDifferentialDownloader$1.GenericDifferentialDownloader = void 0;
const DifferentialDownloader_1$1 = DifferentialDownloader$1;
class GenericDifferentialDownloader extends DifferentialDownloader_1$1.DifferentialDownloader {
  download(oldBlockMap, newBlockMap) {
    return this.doDownload(oldBlockMap, newBlockMap);
  }
}
GenericDifferentialDownloader$1.GenericDifferentialDownloader = GenericDifferentialDownloader;
var types = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdaterSignal = exports.UPDATE_DOWNLOADED = exports.DOWNLOAD_PROGRESS = exports.CancellationToken = void 0;
  exports.addHandler = addHandler;
  const builder_util_runtime_12 = out;
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return builder_util_runtime_12.CancellationToken;
  } });
  exports.DOWNLOAD_PROGRESS = "download-progress";
  exports.UPDATE_DOWNLOADED = "update-downloaded";
  class UpdaterSignal {
    constructor(emitter) {
      this.emitter = emitter;
=======
Qi.DifferentialDownloader = O3;
function Rh(e, t = " KB") {
  return new Intl.NumberFormat("en").format((e / 1024).toFixed(2)) + t;
}
function $3(e) {
  const t = e.indexOf("?");
  return t < 0 ? e : e.substring(0, t);
}
Object.defineProperty(xs, "__esModule", { value: !0 });
xs.GenericDifferentialDownloader = void 0;
const I3 = Qi;
class P3 extends I3.DifferentialDownloader {
  download(t, n) {
    return this.doDownload(t, n);
  }
}
xs.GenericDifferentialDownloader = P3;
var gn = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.UpdaterSignal = e.UPDATE_DOWNLOADED = e.DOWNLOAD_PROGRESS = e.CancellationToken = void 0, e.addHandler = r;
  const t = De;
  Object.defineProperty(e, "CancellationToken", { enumerable: !0, get: function() {
    return t.CancellationToken;
  } }), e.DOWNLOAD_PROGRESS = "download-progress", e.UPDATE_DOWNLOADED = "update-downloaded";
  class n {
    constructor(a) {
      this.emitter = a;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    }
    /**
     * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).
     */
    login(a) {
      r(this.emitter, "login", a);
    }
    progress(a) {
      r(this.emitter, e.DOWNLOAD_PROGRESS, a);
    }
    updateDownloaded(a) {
      r(this.emitter, e.UPDATE_DOWNLOADED, a);
    }
    updateCancelled(a) {
      r(this.emitter, "update-cancelled", a);
    }
  }
  e.UpdaterSignal = n;
  function r(i, a, o) {
    i.on(a, o);
  }
<<<<<<< HEAD
})(types);
Object.defineProperty(AppUpdater$1, "__esModule", { value: true });
AppUpdater$1.NoOpLogger = AppUpdater$1.AppUpdater = void 0;
const builder_util_runtime_1$4 = out;
const crypto_1$1 = require$$0$4;
const os_1 = require$$2$2;
const events_1 = require$$0$6;
const fs_extra_1$4 = lib;
const js_yaml_1 = jsYaml;
const lazy_val_1 = main;
const path$4 = require$$1$4;
const semver_1 = semver$1;
const DownloadedUpdateHelper_1 = DownloadedUpdateHelper$1;
const ElectronAppAdapter_1 = ElectronAppAdapter$1;
const electronHttpExecutor_1 = electronHttpExecutor;
const GenericProvider_1 = GenericProvider$1;
const providerFactory_1 = providerFactory;
const zlib_1$1 = zlib$4;
const util_1 = util;
const GenericDifferentialDownloader_1 = GenericDifferentialDownloader$1;
const types_1$5 = types;
class AppUpdater extends events_1.EventEmitter {
=======
})(gn);
Object.defineProperty(cn, "__esModule", { value: !0 });
cn.NoOpLogger = cn.AppUpdater = void 0;
const ze = De, D3 = Dr, F3 = Eo, N3 = Hn, ar = vn, k3 = Ue, Xc = ss, An = oe, Cn = lx, Ch = Ji, L3 = ds, Oh = ux, U3 = Zi, Kc = hs, B3 = Qe, j3 = st, M3 = xs, or = gn;
class Xu extends N3.EventEmitter {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  /**
   * Get the update channel. Doesn't return `channel` from the update configuration, only if was previously set.
   */
  get channel() {
    return this._channel;
  }
  /**
   * Set the update channel. Overrides `channel` in the update configuration.
   *
   * `allowDowngrade` will be automatically set to `true`. If this behavior is not suitable for you, simple set `allowDowngrade` explicitly after.
   */
  set channel(t) {
    if (this._channel != null) {
      if (typeof t != "string")
        throw (0, ze.newError)(`Channel must be a string, but got: ${t}`, "ERR_UPDATER_INVALID_CHANNEL");
      if (t.length === 0)
        throw (0, ze.newError)("Channel must be not an empty string", "ERR_UPDATER_INVALID_CHANNEL");
    }
    this._channel = t, this.allowDowngrade = !0;
  }
  /**
   *  Shortcut for explicitly adding auth tokens to request headers
   */
  addAuthHeader(t) {
    this.requestHeaders = Object.assign({}, this.requestHeaders, {
      authorization: t
    });
  }
  // noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
  get netSession() {
    return (0, Oh.getNetSession)();
  }
  /**
   * The logger. You can pass [electron-log](https://github.com/megahertz/electron-log), [winston](https://github.com/winstonjs/winston) or another logger with the following interface: `{ info(), warn(), error() }`.
   * Set it to `null` if you would like to disable a logging feature.
   */
  get logger() {
    return this._logger;
  }
  set logger(t) {
    this._logger = t ?? new xx();
  }
  // noinspection JSUnusedGlobalSymbols
  /**
   * test only
   * @private
   */
  set updateConfigPath(t) {
    this.clientPromise = null, this._appUpdateConfigPath = t, this.configOnDisk = new Xc.Lazy(() => this.loadUpdateConfig());
  }
  /**
   * Allows developer to override default logic for determining if an update is supported.
   * The default logic compares the `UpdateInfo` minimum system version against the `os.release()` with `semver` package
   */
  get isUpdateSupported() {
    return this._isUpdateSupported;
  }
  set isUpdateSupported(t) {
    t && (this._isUpdateSupported = t);
  }
<<<<<<< HEAD
  constructor(options, app2) {
    super();
    this.autoDownload = true;
    this.autoInstallOnAppQuit = true;
    this.autoRunAppAfterInstall = true;
    this.allowPrerelease = false;
    this.fullChangelog = false;
    this.allowDowngrade = false;
    this.disableWebInstaller = false;
    this.disableDifferentialDownload = false;
    this.forceDevUpdateConfig = false;
    this._channel = null;
    this.downloadedUpdateHelper = null;
    this.requestHeaders = null;
    this._logger = console;
    this.signals = new types_1$5.UpdaterSignal(this);
    this._appUpdateConfigPath = null;
    this._isUpdateSupported = (updateInfo) => this.checkIfUpdateSupported(updateInfo);
    this.clientPromise = null;
    this.stagingUserIdPromise = new lazy_val_1.Lazy(() => this.getOrCreateStagingUserId());
    this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
    this.checkForUpdatesPromise = null;
    this.downloadPromise = null;
    this.updateInfoAndProvider = null;
    this._testOnlyOptions = null;
    this.on("error", (error2) => {
      this._logger.error(`Error: ${error2.stack || error2.message}`);
    });
    if (app2 == null) {
      this.app = new ElectronAppAdapter_1.ElectronAppAdapter();
      this.httpExecutor = new electronHttpExecutor_1.ElectronHttpExecutor((authInfo, callback) => this.emit("login", authInfo, callback));
    } else {
      this.app = app2;
      this.httpExecutor = null;
    }
    const currentVersionString = this.app.version;
    const currentVersion = (0, semver_1.parse)(currentVersionString);
    if (currentVersion == null) {
      throw (0, builder_util_runtime_1$4.newError)(`App version is not a valid semver version: "${currentVersionString}"`, "ERR_UPDATER_INVALID_VERSION");
    }
    this.currentVersion = currentVersion;
    this.allowPrerelease = hasPrereleaseComponents(currentVersion);
    if (options != null) {
      this.setFeedURL(options);
      if (typeof options !== "string" && options.requestHeaders) {
        this.requestHeaders = options.requestHeaders;
      }
    }
=======
  constructor(t, n) {
    super(), this.autoDownload = !0, this.autoInstallOnAppQuit = !0, this.autoRunAppAfterInstall = !0, this.allowPrerelease = !1, this.fullChangelog = !1, this.allowDowngrade = !1, this.disableWebInstaller = !1, this.disableDifferentialDownload = !1, this.forceDevUpdateConfig = !1, this._channel = null, this.downloadedUpdateHelper = null, this.requestHeaders = null, this._logger = console, this.signals = new or.UpdaterSignal(this), this._appUpdateConfigPath = null, this._isUpdateSupported = (a) => this.checkIfUpdateSupported(a), this.clientPromise = null, this.stagingUserIdPromise = new Xc.Lazy(() => this.getOrCreateStagingUserId()), this.configOnDisk = new Xc.Lazy(() => this.loadUpdateConfig()), this.checkForUpdatesPromise = null, this.downloadPromise = null, this.updateInfoAndProvider = null, this._testOnlyOptions = null, this.on("error", (a) => {
      this._logger.error(`Error: ${a.stack || a.message}`);
    }), n == null ? (this.app = new L3.ElectronAppAdapter(), this.httpExecutor = new Oh.ElectronHttpExecutor((a, o) => this.emit("login", a, o))) : (this.app = n, this.httpExecutor = null);
    const r = this.app.version, i = (0, Cn.parse)(r);
    if (i == null)
      throw (0, ze.newError)(`App version is not a valid semver version: "${r}"`, "ERR_UPDATER_INVALID_VERSION");
    this.currentVersion = i, this.allowPrerelease = q3(i), t != null && (this.setFeedURL(t), typeof t != "string" && t.requestHeaders && (this.requestHeaders = t.requestHeaders));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  //noinspection JSMethodCanBeStatic,JSUnusedGlobalSymbols
  getFeedURL() {
    return "Deprecated. Do not use it.";
  }
  /**
   * Configure update provider. If value is `string`, [GenericServerOptions](./publish.md#genericserveroptions) will be set with value as `url`.
   * @param options If you want to override configuration in the `app-update.yml`.
   */
<<<<<<< HEAD
  setFeedURL(options) {
    const runtimeOptions = this.createProviderRuntimeOptions();
    let provider;
    if (typeof options === "string") {
      provider = new GenericProvider_1.GenericProvider({ provider: "generic", url: options }, this, {
        ...runtimeOptions,
        isUseMultipleRangeRequest: (0, providerFactory_1.isUrlProbablySupportMultiRangeRequests)(options)
      });
    } else {
      provider = (0, providerFactory_1.createClient)(options, this, runtimeOptions);
    }
    this.clientPromise = Promise.resolve(provider);
=======
  setFeedURL(t) {
    const n = this.createProviderRuntimeOptions();
    let r;
    typeof t == "string" ? r = new U3.GenericProvider({ provider: "generic", url: t }, this, {
      ...n,
      isUseMultipleRangeRequest: (0, Kc.isUrlProbablySupportMultiRangeRequests)(t)
    }) : r = (0, Kc.createClient)(t, this, n), this.clientPromise = Promise.resolve(r);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  /**
   * Asks the server whether there is an update.
   * @returns null if the updater is disabled, otherwise info about the latest version
   */
  checkForUpdates() {
    if (!this.isUpdaterActive())
      return Promise.resolve(null);
    let t = this.checkForUpdatesPromise;
    if (t != null)
      return this._logger.info("Checking for update (already in progress)"), t;
    const n = () => this.checkForUpdatesPromise = null;
    return this._logger.info("Checking for update"), t = this.doCheckForUpdates().then((r) => (n(), r)).catch((r) => {
      throw n(), this.emit("error", r, `Cannot check for updates: ${(r.stack || r).toString()}`), r;
    }), this.checkForUpdatesPromise = t, t;
  }
  isUpdaterActive() {
    return this.app.isPackaged || this.forceDevUpdateConfig ? !0 : (this._logger.info("Skip checkForUpdates because application is not packed and dev update config is not forced"), !1);
  }
  // noinspection JSUnusedGlobalSymbols
<<<<<<< HEAD
  checkForUpdatesAndNotify(downloadNotification) {
    return this.checkForUpdates().then((it) => {
      if (!(it === null || it === void 0 ? void 0 : it.downloadPromise)) {
        if (this._logger.debug != null) {
          this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null");
        }
        return it;
      }
      void it.downloadPromise.then(() => {
        const notificationContent = AppUpdater.formatDownloadNotification(it.updateInfo.version, this.app.name, downloadNotification);
        new require$$1$8.Notification(notificationContent).show();
      });
      return it;
    });
  }
  static formatDownloadNotification(version, appName, downloadNotification) {
    if (downloadNotification == null) {
      downloadNotification = {
        title: "A new update is ready to install",
        body: `{appName} version {version} has been downloaded and will be automatically installed on exit`
      };
    }
    downloadNotification = {
      title: downloadNotification.title.replace("{appName}", appName).replace("{version}", version),
      body: downloadNotification.body.replace("{appName}", appName).replace("{version}", version)
    };
    return downloadNotification;
  }
  async isStagingMatch(updateInfo) {
    const rawStagingPercentage = updateInfo.stagingPercentage;
    let stagingPercentage = rawStagingPercentage;
    if (stagingPercentage == null) {
      return true;
    }
    stagingPercentage = parseInt(stagingPercentage, 10);
    if (isNaN(stagingPercentage)) {
      this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);
      return true;
    }
    stagingPercentage = stagingPercentage / 100;
    const stagingUserId = await this.stagingUserIdPromise.value;
    const val = builder_util_runtime_1$4.UUID.parse(stagingUserId).readUInt32BE(12);
    const percentage = val / 4294967295;
    this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);
    return percentage < stagingPercentage;
  }
  computeFinalHeaders(headers2) {
    if (this.requestHeaders != null) {
      Object.assign(headers2, this.requestHeaders);
    }
    return headers2;
  }
  async isUpdateAvailable(updateInfo) {
    const latestVersion = (0, semver_1.parse)(updateInfo.version);
    if (latestVersion == null) {
      throw (0, builder_util_runtime_1$4.newError)(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${updateInfo.version}"`, "ERR_UPDATER_INVALID_VERSION");
    }
    const currentVersion = this.currentVersion;
    if ((0, semver_1.eq)(latestVersion, currentVersion)) {
      return false;
    }
    if (!await Promise.resolve(this.isUpdateSupported(updateInfo))) {
      return false;
    }
    const isStagingMatch = await this.isStagingMatch(updateInfo);
    if (!isStagingMatch) {
      return false;
    }
    const isLatestVersionNewer = (0, semver_1.gt)(latestVersion, currentVersion);
    const isLatestVersionOlder = (0, semver_1.lt)(latestVersion, currentVersion);
    if (isLatestVersionNewer) {
      return true;
    }
    return this.allowDowngrade && isLatestVersionOlder;
  }
  checkIfUpdateSupported(updateInfo) {
    const minimumSystemVersion = updateInfo === null || updateInfo === void 0 ? void 0 : updateInfo.minimumSystemVersion;
    const currentOSVersion = (0, os_1.release)();
    if (minimumSystemVersion) {
      try {
        if ((0, semver_1.lt)(currentOSVersion, minimumSystemVersion)) {
          this._logger.info(`Current OS version ${currentOSVersion} is less than the minimum OS version required ${minimumSystemVersion} for version ${currentOSVersion}`);
          return false;
        }
      } catch (e) {
        this._logger.warn(`Failed to compare current OS version(${currentOSVersion}) with minimum OS version(${minimumSystemVersion}): ${(e.message || e).toString()}`);
      }
    }
    return true;
=======
  checkForUpdatesAndNotify(t) {
    return this.checkForUpdates().then((n) => n != null && n.downloadPromise ? (n.downloadPromise.then(() => {
      const r = Xu.formatDownloadNotification(n.updateInfo.version, this.app.name, t);
      new Bn.Notification(r).show();
    }), n) : (this._logger.debug != null && this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null"), n));
  }
  static formatDownloadNotification(t, n, r) {
    return r == null && (r = {
      title: "A new update is ready to install",
      body: "{appName} version {version} has been downloaded and will be automatically installed on exit"
    }), r = {
      title: r.title.replace("{appName}", n).replace("{version}", t),
      body: r.body.replace("{appName}", n).replace("{version}", t)
    }, r;
  }
  async isStagingMatch(t) {
    const n = t.stagingPercentage;
    let r = n;
    if (r == null)
      return !0;
    if (r = parseInt(r, 10), isNaN(r))
      return this._logger.warn(`Staging percentage is NaN: ${n}`), !0;
    r = r / 100;
    const i = await this.stagingUserIdPromise.value, o = ze.UUID.parse(i).readUInt32BE(12) / 4294967295;
    return this._logger.info(`Staging percentage: ${r}, percentage: ${o}, user id: ${i}`), o < r;
  }
  computeFinalHeaders(t) {
    return this.requestHeaders != null && Object.assign(t, this.requestHeaders), t;
  }
  async isUpdateAvailable(t) {
    const n = (0, Cn.parse)(t.version);
    if (n == null)
      throw (0, ze.newError)(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${t.version}"`, "ERR_UPDATER_INVALID_VERSION");
    const r = this.currentVersion;
    if ((0, Cn.eq)(n, r) || !await Promise.resolve(this.isUpdateSupported(t)) || !await this.isStagingMatch(t))
      return !1;
    const a = (0, Cn.gt)(n, r), o = (0, Cn.lt)(n, r);
    return a ? !0 : this.allowDowngrade && o;
  }
  checkIfUpdateSupported(t) {
    const n = t == null ? void 0 : t.minimumSystemVersion, r = (0, F3.release)();
    if (n)
      try {
        if ((0, Cn.lt)(r, n))
          return this._logger.info(`Current OS version ${r} is less than the minimum OS version required ${n} for version ${r}`), !1;
      } catch (i) {
        this._logger.warn(`Failed to compare current OS version(${r}) with minimum OS version(${n}): ${(i.message || i).toString()}`);
      }
    return !0;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  async getUpdateInfoAndProvider() {
    await this.app.whenReady(), this.clientPromise == null && (this.clientPromise = this.configOnDisk.value.then((r) => (0, Kc.createClient)(r, this, this.createProviderRuntimeOptions())));
    const t = await this.clientPromise, n = await this.stagingUserIdPromise.value;
    return t.setRequestHeaders(this.computeFinalHeaders({ "x-user-staging-id": n })), {
      info: await t.getLatestVersion(),
      provider: t
    };
  }
  createProviderRuntimeOptions() {
    return {
      isUseMultipleRangeRequest: !0,
      platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,
      executor: this.httpExecutor
    };
  }
  async doCheckForUpdates() {
    this.emit("checking-for-update");
    const t = await this.getUpdateInfoAndProvider(), n = t.info;
    if (!await this.isUpdateAvailable(n))
      return this._logger.info(`Update for version ${this.currentVersion.format()} is not available (latest version: ${n.version}, downgrade is ${this.allowDowngrade ? "allowed" : "disallowed"}).`), this.emit("update-not-available", n), {
        isUpdateAvailable: !1,
        versionInfo: n,
        updateInfo: n
      };
    this.updateInfoAndProvider = t, this.onUpdateAvailable(n);
    const r = new ze.CancellationToken();
    return {
      isUpdateAvailable: !0,
      versionInfo: n,
      updateInfo: n,
      cancellationToken: r,
      downloadPromise: this.autoDownload ? this.downloadUpdate(r) : null
    };
  }
  onUpdateAvailable(t) {
    this._logger.info(`Found version ${t.version} (url: ${(0, ze.asArray)(t.files).map((n) => n.url).join(", ")})`), this.emit("update-available", t);
  }
  /**
   * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.
   * @returns {Promise<Array<string>>} Paths to downloaded files.
   */
  downloadUpdate(t = new ze.CancellationToken()) {
    const n = this.updateInfoAndProvider;
    if (n == null) {
      const i = new Error("Please check update first");
      return this.dispatchError(i), Promise.reject(i);
    }
    if (this.downloadPromise != null)
      return this._logger.info("Downloading update (already in progress)"), this.downloadPromise;
    this._logger.info(`Downloading update from ${(0, ze.asArray)(n.info.files).map((i) => i.url).join(", ")}`);
    const r = (i) => {
      if (!(i instanceof ze.CancellationError))
        try {
          this.dispatchError(i);
        } catch (a) {
          this._logger.warn(`Cannot dispatch error event: ${a.stack || a}`);
        }
      return i;
    };
    return this.downloadPromise = this.doDownloadUpdate({
      updateInfoAndProvider: n,
      requestHeaders: this.computeRequestHeaders(n.provider),
      cancellationToken: t,
      disableWebInstaller: this.disableWebInstaller,
      disableDifferentialDownload: this.disableDifferentialDownload
    }).catch((i) => {
      throw r(i);
    }).finally(() => {
      this.downloadPromise = null;
    }), this.downloadPromise;
  }
  dispatchError(t) {
    this.emit("error", t, (t.stack || t).toString());
  }
  dispatchUpdateDownloaded(t) {
    this.emit(or.UPDATE_DOWNLOADED, t);
  }
  async loadUpdateConfig() {
<<<<<<< HEAD
    if (this._appUpdateConfigPath == null) {
      this._appUpdateConfigPath = this.app.appUpdateConfigPath;
    }
    return (0, js_yaml_1.load)(await (0, fs_extra_1$4.readFile)(this._appUpdateConfigPath, "utf-8"));
=======
    return this._appUpdateConfigPath == null && (this._appUpdateConfigPath = this.app.appUpdateConfigPath), (0, k3.load)(await (0, ar.readFile)(this._appUpdateConfigPath, "utf-8"));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  computeRequestHeaders(t) {
    const n = t.fileExtraDownloadHeaders;
    if (n != null) {
      const r = this.requestHeaders;
      return r == null ? n : {
        ...n,
        ...r
      };
    }
    return this.computeFinalHeaders({ accept: "*/*" });
  }
  async getOrCreateStagingUserId() {
    const t = An.join(this.app.userDataPath, ".updaterId");
    try {
      const r = await (0, ar.readFile)(t, "utf-8");
      if (ze.UUID.check(r))
        return r;
      this._logger.warn(`Staging user id file exists, but content was invalid: ${r}`);
    } catch (r) {
      r.code !== "ENOENT" && this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${r}`);
    }
<<<<<<< HEAD
    const id = builder_util_runtime_1$4.UUID.v5((0, crypto_1$1.randomBytes)(4096), builder_util_runtime_1$4.UUID.OID);
    this._logger.info(`Generated new staging user ID: ${id}`);
=======
    const n = ze.UUID.v5((0, D3.randomBytes)(4096), ze.UUID.OID);
    this._logger.info(`Generated new staging user ID: ${n}`);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    try {
      await (0, ar.outputFile)(t, n);
    } catch (r) {
      this._logger.warn(`Couldn't write out staging user ID: ${r}`);
    }
    return n;
  }
  /** @internal */
  get isAddNoCacheQuery() {
    const t = this.requestHeaders;
    if (t == null)
      return !0;
    for (const n of Object.keys(t)) {
      const r = n.toLowerCase();
      if (r === "authorization" || r === "private-token")
        return !1;
    }
    return !0;
  }
  async getOrCreateDownloadHelper() {
    let t = this.downloadedUpdateHelper;
    if (t == null) {
      const n = (await this.configOnDisk.value).updaterCacheDirName, r = this._logger;
      n == null && r.error("updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?");
      const i = An.join(this.app.baseCachePath, n || this.app.name);
      r.debug != null && r.debug(`updater cache dir: ${i}`), t = new Ch.DownloadedUpdateHelper(i), this.downloadedUpdateHelper = t;
    }
    return t;
  }
  async executeDownload(t) {
    const n = t.fileInfo, r = {
      headers: t.downloadUpdateOptions.requestHeaders,
      cancellationToken: t.downloadUpdateOptions.cancellationToken,
      sha2: n.info.sha2,
      sha512: n.info.sha512
    };
    this.listenerCount(or.DOWNLOAD_PROGRESS) > 0 && (r.onProgress = (w) => this.emit(or.DOWNLOAD_PROGRESS, w));
    const i = t.downloadUpdateOptions.updateInfoAndProvider.info, a = i.version, o = n.packageInfo;
    function c() {
      const w = decodeURIComponent(t.fileInfo.url.pathname);
      return w.endsWith(`.${t.fileExtension}`) ? An.basename(w) : t.fileInfo.info.url;
    }
    const s = await this.getOrCreateDownloadHelper(), u = s.cacheDirForPendingUpdate;
    await (0, ar.mkdir)(u, { recursive: !0 });
    const l = c();
    let p = An.join(u, l);
    const d = o == null ? null : An.join(u, `package-${a}${An.extname(o.path) || ".7z"}`), m = async (w) => (await s.setDownloadedFile(p, d, i, n, l, w), await t.done({
      ...i,
      downloadedFile: p
    }), d == null ? [p] : [p, d]), g = this._logger, v = await s.validateDownloadedPath(p, i, n, g);
    if (v != null)
      return p = v, await m(!1);
    const y = async () => (await s.clear().catch(() => {
    }), await (0, ar.unlink)(p).catch(() => {
    })), x = await (0, Ch.createTempUpdateFile)(`temp-${l}`, u, g);
    try {
      await t.task(x, r, d, y), await (0, ze.retry)(() => (0, ar.rename)(x, p), 60, 500, 0, 0, (w) => w instanceof Error && /^EBUSY:/.test(w.message));
    } catch (w) {
      throw await y(), w instanceof ze.CancellationError && (g.info("cancelled"), this.emit("update-cancelled", i)), w;
    }
    return g.info(`New version ${a} has been downloaded to ${p}`), await m(!0);
  }
  async differentialDownloadInstaller(t, n, r, i, a) {
    try {
<<<<<<< HEAD
      if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload) {
        return true;
      }
      const blockmapFileUrls = (0, util_1.blockmapFiles)(fileInfo.url, this.app.version, downloadUpdateOptions.updateInfoAndProvider.info.version);
      this._logger.info(`Download block maps (old: "${blockmapFileUrls[0]}", new: ${blockmapFileUrls[1]})`);
      const downloadBlockMap = async (url2) => {
        const data = await this.httpExecutor.downloadToBuffer(url2, {
          headers: downloadUpdateOptions.requestHeaders,
          cancellationToken: downloadUpdateOptions.cancellationToken
        });
        if (data == null || data.length === 0) {
          throw new Error(`Blockmap "${url2.href}" is empty`);
        }
        try {
          return JSON.parse((0, zlib_1$1.gunzipSync)(data).toString());
        } catch (e) {
          throw new Error(`Cannot parse blockmap "${url2.href}", error: ${e}`);
        }
      };
      const downloadOptions = {
        newUrl: fileInfo.url,
        oldFile: path$4.join(this.downloadedUpdateHelper.cacheDir, oldInstallerFileName),
=======
      if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload)
        return !0;
      const o = (0, j3.blockmapFiles)(t.url, this.app.version, n.updateInfoAndProvider.info.version);
      this._logger.info(`Download block maps (old: "${o[0]}", new: ${o[1]})`);
      const c = async (l) => {
        const p = await this.httpExecutor.downloadToBuffer(l, {
          headers: n.requestHeaders,
          cancellationToken: n.cancellationToken
        });
        if (p == null || p.length === 0)
          throw new Error(`Blockmap "${l.href}" is empty`);
        try {
          return JSON.parse((0, B3.gunzipSync)(p).toString());
        } catch (d) {
          throw new Error(`Cannot parse blockmap "${l.href}", error: ${d}`);
        }
      }, s = {
        newUrl: t.url,
        oldFile: An.join(this.downloadedUpdateHelper.cacheDir, a),
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
        logger: this._logger,
        newFile: r,
        isUseMultipleRangeRequest: i.isUseMultipleRangeRequest,
        requestHeaders: n.requestHeaders,
        cancellationToken: n.cancellationToken
      };
<<<<<<< HEAD
      if (this.listenerCount(types_1$5.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(types_1$5.DOWNLOAD_PROGRESS, it);
      }
      const blockMapDataList = await Promise.all(blockmapFileUrls.map((u2) => downloadBlockMap(u2)));
      await new GenericDifferentialDownloader_1.GenericDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download(blockMapDataList[0], blockMapDataList[1]);
      return false;
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      if (this._testOnlyOptions != null) {
        throw e;
      }
      return true;
    }
  }
}
AppUpdater$1.AppUpdater = AppUpdater;
function hasPrereleaseComponents(version) {
  const versionPrereleaseComponent = (0, semver_1.prerelease)(version);
  return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;
=======
      this.listenerCount(or.DOWNLOAD_PROGRESS) > 0 && (s.onProgress = (l) => this.emit(or.DOWNLOAD_PROGRESS, l));
      const u = await Promise.all(o.map((l) => c(l)));
      return await new M3.GenericDifferentialDownloader(t.info, this.httpExecutor, s).download(u[0], u[1]), !1;
    } catch (o) {
      if (this._logger.error(`Cannot download differentially, fallback to full download: ${o.stack || o}`), this._testOnlyOptions != null)
        throw o;
      return !0;
    }
  }
}
cn.AppUpdater = Xu;
function q3(e) {
  const t = (0, Cn.prerelease)(e);
  return t != null && t.length > 0;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
}
class xx {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  info(t) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  warn(t) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  error(t) {
  }
}
<<<<<<< HEAD
AppUpdater$1.NoOpLogger = NoOpLogger;
Object.defineProperty(BaseUpdater$1, "__esModule", { value: true });
BaseUpdater$1.BaseUpdater = void 0;
const child_process_1$3 = require$$1$9;
const AppUpdater_1$1 = AppUpdater$1;
class BaseUpdater extends AppUpdater_1$1.AppUpdater {
  constructor(options, app2) {
    super(options, app2);
    this.quitAndInstallCalled = false;
    this.quitHandlerAdded = false;
  }
  quitAndInstall(isSilent = false, isForceRunAfter = false) {
    this._logger.info(`Install on explicit quitAndInstall`);
    const isInstalled = this.install(isSilent, isSilent ? isForceRunAfter : this.autoRunAppAfterInstall);
    if (isInstalled) {
      setImmediate(() => {
        require$$1$8.autoUpdater.emit("before-quit-for-update");
        this.app.quit();
      });
    } else {
      this.quitAndInstallCalled = false;
    }
=======
cn.NoOpLogger = xx;
Object.defineProperty(Bt, "__esModule", { value: !0 });
Bt.BaseUpdater = void 0;
const $h = _o, z3 = cn;
class H3 extends z3.AppUpdater {
  constructor(t, n) {
    super(t, n), this.quitAndInstallCalled = !1, this.quitHandlerAdded = !1;
  }
  quitAndInstall(t = !1, n = !1) {
    this._logger.info("Install on explicit quitAndInstall"), this.install(t, t ? n : this.autoRunAppAfterInstall) ? setImmediate(() => {
      Bn.autoUpdater.emit("before-quit-for-update"), this.app.quit();
    }) : this.quitAndInstallCalled = !1;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  executeDownload(t) {
    return super.executeDownload({
      ...t,
      done: (n) => (this.dispatchUpdateDownloaded(n), this.addQuitHandler(), Promise.resolve())
    });
  }
  get installerPath() {
    return this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.file;
  }
  // must be sync (because quit even handler is not async)
  install(t = !1, n = !1) {
    if (this.quitAndInstallCalled)
      return this._logger.warn("install call ignored: quitAndInstallCalled is set to true"), !1;
    const r = this.downloadedUpdateHelper, i = this.installerPath, a = r == null ? null : r.downloadedFileInfo;
    if (i == null || a == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    this.quitAndInstallCalled = !0;
    try {
      return this._logger.info(`Install: isSilent: ${t}, isForceRunAfter: ${n}`), this.doInstall({
        isSilent: t,
        isForceRunAfter: n,
        isAdminRightsRequired: a.isAdminRightsRequired
      });
    } catch (o) {
      return this.dispatchError(o), !1;
    }
  }
  addQuitHandler() {
    this.quitHandlerAdded || !this.autoInstallOnAppQuit || (this.quitHandlerAdded = !0, this.app.onQuit((t) => {
      if (this.quitAndInstallCalled) {
        this._logger.info("Update installer has already been triggered. Quitting application.");
        return;
      }
      if (!this.autoInstallOnAppQuit) {
        this._logger.info("Update will not be installed on quit because autoInstallOnAppQuit is set to false.");
        return;
      }
      if (t !== 0) {
        this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${t}`);
        return;
      }
      this._logger.info("Auto install update on quit"), this.install(!0, !1);
    }));
  }
  wrapSudo() {
    const { name: t } = this.app, n = `"${t} would like to update"`, r = this.spawnSyncLog("which gksudo || which kdesudo || which pkexec || which beesu"), i = [r];
    return /kdesudo/i.test(r) ? (i.push("--comment", n), i.push("-c")) : /gksudo/i.test(r) ? i.push("--message", n) : /pkexec/i.test(r) && i.push("--disable-internal-agent"), i.join(" ");
  }
  spawnSyncLog(t, n = [], r = {}) {
    this._logger.info(`Executing: ${t} with args: ${n}`);
    const i = (0, $h.spawnSync)(t, n, {
      env: { ...process.env, ...r },
      encoding: "utf-8",
      shell: !0
    }), { error: a, status: o, stdout: c, stderr: s } = i;
    if (a != null)
      throw this._logger.error(s), a;
    if (o != null && o !== 0)
      throw this._logger.error(s), new Error(`Command ${t} exited with code ${o}`);
    return c.trim();
  }
  /**
   * This handles both node 8 and node 10 way of emitting error when spawning a process
   *   - node 8: Throws the error
   *   - node 10: Emit the error(Need to listen with on)
   */
  // https://github.com/electron-userland/electron-builder/issues/1129
  // Node 8 sends errors: https://nodejs.org/dist/latest-v8.x/docs/api/errors.html#errors_common_system_errors
  async spawnLog(t, n = [], r = void 0, i = "ignore") {
    return this._logger.info(`Executing: ${t} with args: ${n}`), new Promise((a, o) => {
      try {
        const c = { stdio: i, env: r, detached: !0 }, s = (0, $h.spawn)(t, n, c);
        s.on("error", (u) => {
          o(u);
        }), s.unref(), s.pid !== void 0 && a(!0);
      } catch (c) {
        o(c);
      }
    });
  }
}
<<<<<<< HEAD
BaseUpdater$1.BaseUpdater = BaseUpdater;
var AppImageUpdater$1 = {};
var FileWithEmbeddedBlockMapDifferentialDownloader$1 = {};
Object.defineProperty(FileWithEmbeddedBlockMapDifferentialDownloader$1, "__esModule", { value: true });
FileWithEmbeddedBlockMapDifferentialDownloader$1.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
const fs_extra_1$3 = lib;
const DifferentialDownloader_1 = DifferentialDownloader$1;
const zlib_1 = zlib$4;
class FileWithEmbeddedBlockMapDifferentialDownloader extends DifferentialDownloader_1.DifferentialDownloader {
  async download() {
    const packageInfo = this.blockAwareFileInfo;
    const fileSize = packageInfo.size;
    const offset = fileSize - (packageInfo.blockMapSize + 4);
    this.fileMetadataBuffer = await this.readRemoteBytes(offset, fileSize - 1);
    const newBlockMap = readBlockMap(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
    await this.doDownload(await readEmbeddedBlockMapData(this.options.oldFile), newBlockMap);
  }
}
FileWithEmbeddedBlockMapDifferentialDownloader$1.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader;
function readBlockMap(data) {
  return JSON.parse((0, zlib_1.inflateRawSync)(data).toString());
}
async function readEmbeddedBlockMapData(file2) {
  const fd = await (0, fs_extra_1$3.open)(file2, "r");
=======
Bt.BaseUpdater = H3;
var Si = {}, ea = {};
Object.defineProperty(ea, "__esModule", { value: !0 });
ea.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
const sr = vn, G3 = Qi, W3 = Qe;
class V3 extends G3.DifferentialDownloader {
  async download() {
    const t = this.blockAwareFileInfo, n = t.size, r = n - (t.blockMapSize + 4);
    this.fileMetadataBuffer = await this.readRemoteBytes(r, n - 1);
    const i = yx(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
    await this.doDownload(await Y3(this.options.oldFile), i);
  }
}
ea.FileWithEmbeddedBlockMapDifferentialDownloader = V3;
function yx(e) {
  return JSON.parse((0, W3.inflateRawSync)(e).toString());
}
async function Y3(e) {
  const t = await (0, sr.open)(e, "r");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  try {
    const n = (await (0, sr.fstat)(t)).size, r = Buffer.allocUnsafe(4);
    await (0, sr.read)(t, r, 0, r.length, n - r.length);
    const i = Buffer.allocUnsafe(r.readUInt32BE(0));
    return await (0, sr.read)(t, i, 0, i.length, n - r.length - i.length), await (0, sr.close)(t), yx(i);
  } catch (n) {
    throw await (0, sr.close)(t), n;
  }
}
<<<<<<< HEAD
Object.defineProperty(AppImageUpdater$1, "__esModule", { value: true });
AppImageUpdater$1.AppImageUpdater = void 0;
const builder_util_runtime_1$3 = out;
const child_process_1$2 = require$$1$9;
const fs_extra_1$2 = lib;
const fs_1$1 = fs$w;
const path$3 = require$$1$4;
const BaseUpdater_1$4 = BaseUpdater$1;
const FileWithEmbeddedBlockMapDifferentialDownloader_1$1 = FileWithEmbeddedBlockMapDifferentialDownloader$1;
const Provider_1$5 = Provider$1;
const types_1$4 = types;
class AppImageUpdater extends BaseUpdater_1$4.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
=======
Object.defineProperty(Si, "__esModule", { value: !0 });
Si.AppImageUpdater = void 0;
const Ih = De, Ph = _o, X3 = vn, K3 = ae, Qr = oe, J3 = Bt, Z3 = ea, Q3 = Ce, Dh = gn;
class eI extends J3.BaseUpdater {
  constructor(t, n) {
    super(t, n);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  isUpdaterActive() {
    return process.env.APPIMAGE == null ? (process.env.SNAP == null ? this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage") : this._logger.info("SNAP env is defined, updater is disabled"), !1) : super.isUpdaterActive();
  }
  /*** @private */
<<<<<<< HEAD
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$5.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "AppImage", ["rpm", "deb", "pacman"]);
    return this.executeDownload({
      fileExtension: "AppImage",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        const oldFile = process.env["APPIMAGE"];
        if (oldFile == null) {
          throw (0, builder_util_runtime_1$3.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        }
        if (downloadUpdateOptions.disableDifferentialDownload || await this.downloadDifferential(fileInfo, oldFile, updateFile, provider, downloadUpdateOptions)) {
          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
        }
        await (0, fs_extra_1$2.chmod)(updateFile, 493);
=======
  doDownloadUpdate(t) {
    const n = t.updateInfoAndProvider.provider, r = (0, Q3.findFile)(n.resolveFiles(t.updateInfoAndProvider.info), "AppImage", ["rpm", "deb", "pacman"]);
    return this.executeDownload({
      fileExtension: "AppImage",
      fileInfo: r,
      downloadUpdateOptions: t,
      task: async (i, a) => {
        const o = process.env.APPIMAGE;
        if (o == null)
          throw (0, Ih.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        (t.disableDifferentialDownload || await this.downloadDifferential(r, o, i, n, t)) && await this.httpExecutor.download(r.url, i, a), await (0, X3.chmod)(i, 493);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
    });
  }
  async downloadDifferential(t, n, r, i, a) {
    try {
      const o = {
        newUrl: t.url,
        oldFile: n,
        logger: this._logger,
        newFile: r,
        isUseMultipleRangeRequest: i.isUseMultipleRangeRequest,
        requestHeaders: a.requestHeaders,
        cancellationToken: a.cancellationToken
      };
<<<<<<< HEAD
      if (this.listenerCount(types_1$4.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(types_1$4.DOWNLOAD_PROGRESS, it);
      }
      await new FileWithEmbeddedBlockMapDifferentialDownloader_1$1.FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download();
      return false;
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      return process.platform === "linux";
    }
  }
  doInstall(options) {
    const appImageFile = process.env["APPIMAGE"];
    if (appImageFile == null) {
      throw (0, builder_util_runtime_1$3.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
    }
    (0, fs_1$1.unlinkSync)(appImageFile);
    let destination;
    const existingBaseName = path$3.basename(appImageFile);
    const installerPath = this.installerPath;
    if (installerPath == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    if (path$3.basename(installerPath) === existingBaseName || !/\d+\.\d+\.\d+/.test(existingBaseName)) {
      destination = appImageFile;
    } else {
      destination = path$3.join(path$3.dirname(appImageFile), path$3.basename(installerPath));
    }
    (0, child_process_1$2.execFileSync)("mv", ["-f", installerPath, destination]);
    if (destination !== appImageFile) {
      this.emit("appimage-filename-updated", destination);
    }
    const env = {
=======
      return this.listenerCount(Dh.DOWNLOAD_PROGRESS) > 0 && (o.onProgress = (c) => this.emit(Dh.DOWNLOAD_PROGRESS, c)), await new Z3.FileWithEmbeddedBlockMapDifferentialDownloader(t.info, this.httpExecutor, o).download(), !1;
    } catch (o) {
      return this._logger.error(`Cannot download differentially, fallback to full download: ${o.stack || o}`), process.platform === "linux";
    }
  }
  doInstall(t) {
    const n = process.env.APPIMAGE;
    if (n == null)
      throw (0, Ih.newError)("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
    (0, K3.unlinkSync)(n);
    let r;
    const i = Qr.basename(n), a = this.installerPath;
    if (a == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    Qr.basename(a) === i || !/\d+\.\d+\.\d+/.test(i) ? r = n : r = Qr.join(Qr.dirname(n), Qr.basename(a)), (0, Ph.execFileSync)("mv", ["-f", a, r]), r !== n && this.emit("appimage-filename-updated", r);
    const o = {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      ...process.env,
      APPIMAGE_SILENT_INSTALL: "true"
    };
    return t.isForceRunAfter ? this.spawnLog(r, [], o) : (o.APPIMAGE_EXIT_AFTER_INSTALL = "true", (0, Ph.execFileSync)(r, [], { env: o })), !0;
  }
}
<<<<<<< HEAD
AppImageUpdater$1.AppImageUpdater = AppImageUpdater;
var DebUpdater$1 = {};
Object.defineProperty(DebUpdater$1, "__esModule", { value: true });
DebUpdater$1.DebUpdater = void 0;
const BaseUpdater_1$3 = BaseUpdater$1;
const Provider_1$4 = Provider$1;
const types_1$3 = types;
class DebUpdater extends BaseUpdater_1$3.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  /*** @private */
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$4.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "deb", ["AppImage", "rpm", "pacman"]);
=======
Si.AppImageUpdater = eI;
var Ti = {};
Object.defineProperty(Ti, "__esModule", { value: !0 });
Ti.DebUpdater = void 0;
const tI = Bt, nI = Ce, Fh = gn;
class rI extends tI.BaseUpdater {
  constructor(t, n) {
    super(t, n);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const n = t.updateInfoAndProvider.provider, r = (0, nI.findFile)(n.resolveFiles(t.updateInfoAndProvider.info), "deb", ["AppImage", "rpm", "pacman"]);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return this.executeDownload({
      fileExtension: "deb",
      fileInfo: r,
      downloadUpdateOptions: t,
      task: async (i, a) => {
        this.listenerCount(Fh.DOWNLOAD_PROGRESS) > 0 && (a.onProgress = (o) => this.emit(Fh.DOWNLOAD_PROGRESS, o)), await this.httpExecutor.download(r.url, i, a);
      }
    });
  }
  get installerPath() {
    var t, n;
    return (n = (t = super.installerPath) === null || t === void 0 ? void 0 : t.replace(/ /g, "\\ ")) !== null && n !== void 0 ? n : null;
  }
  doInstall(t) {
    const n = this.wrapSudo(), r = /pkexec/i.test(n) ? "" : '"', i = this.installerPath;
    if (i == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    const a = ["dpkg", "-i", i, "||", "apt-get", "install", "-f", "-y"];
    return this.spawnSyncLog(n, [`${r}/bin/bash`, "-c", `'${a.join(" ")}'${r}`]), t.isForceRunAfter && this.app.relaunch(), !0;
  }
}
<<<<<<< HEAD
DebUpdater$1.DebUpdater = DebUpdater;
var PacmanUpdater$1 = {};
Object.defineProperty(PacmanUpdater$1, "__esModule", { value: true });
PacmanUpdater$1.PacmanUpdater = void 0;
const BaseUpdater_1$2 = BaseUpdater$1;
const types_1$2 = types;
const Provider_1$3 = Provider$1;
class PacmanUpdater extends BaseUpdater_1$2.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  /*** @private */
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$3.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "pacman", ["AppImage", "deb", "rpm"]);
=======
Ti.DebUpdater = rI;
var Ai = {};
Object.defineProperty(Ai, "__esModule", { value: !0 });
Ai.PacmanUpdater = void 0;
const iI = Bt, Nh = gn, aI = Ce;
class oI extends iI.BaseUpdater {
  constructor(t, n) {
    super(t, n);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const n = t.updateInfoAndProvider.provider, r = (0, aI.findFile)(n.resolveFiles(t.updateInfoAndProvider.info), "pacman", ["AppImage", "deb", "rpm"]);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return this.executeDownload({
      fileExtension: "pacman",
      fileInfo: r,
      downloadUpdateOptions: t,
      task: async (i, a) => {
        this.listenerCount(Nh.DOWNLOAD_PROGRESS) > 0 && (a.onProgress = (o) => this.emit(Nh.DOWNLOAD_PROGRESS, o)), await this.httpExecutor.download(r.url, i, a);
      }
    });
  }
  get installerPath() {
    var t, n;
    return (n = (t = super.installerPath) === null || t === void 0 ? void 0 : t.replace(/ /g, "\\ ")) !== null && n !== void 0 ? n : null;
  }
  doInstall(t) {
    const n = this.wrapSudo(), r = /pkexec/i.test(n) ? "" : '"', i = this.installerPath;
    if (i == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    const a = ["pacman", "-U", "--noconfirm", i];
    return this.spawnSyncLog(n, [`${r}/bin/bash`, "-c", `'${a.join(" ")}'${r}`]), t.isForceRunAfter && this.app.relaunch(), !0;
  }
}
<<<<<<< HEAD
PacmanUpdater$1.PacmanUpdater = PacmanUpdater;
var RpmUpdater$1 = {};
Object.defineProperty(RpmUpdater$1, "__esModule", { value: true });
RpmUpdater$1.RpmUpdater = void 0;
const BaseUpdater_1$1 = BaseUpdater$1;
const types_1$1 = types;
const Provider_1$2 = Provider$1;
class RpmUpdater extends BaseUpdater_1$1.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  /*** @private */
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1$2.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "rpm", ["AppImage", "deb", "pacman"]);
=======
Ai.PacmanUpdater = oI;
var Ri = {};
Object.defineProperty(Ri, "__esModule", { value: !0 });
Ri.RpmUpdater = void 0;
const sI = Bt, kh = gn, cI = Ce;
class lI extends sI.BaseUpdater {
  constructor(t, n) {
    super(t, n);
  }
  /*** @private */
  doDownloadUpdate(t) {
    const n = t.updateInfoAndProvider.provider, r = (0, cI.findFile)(n.resolveFiles(t.updateInfoAndProvider.info), "rpm", ["AppImage", "deb", "pacman"]);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return this.executeDownload({
      fileExtension: "rpm",
      fileInfo: r,
      downloadUpdateOptions: t,
      task: async (i, a) => {
        this.listenerCount(kh.DOWNLOAD_PROGRESS) > 0 && (a.onProgress = (o) => this.emit(kh.DOWNLOAD_PROGRESS, o)), await this.httpExecutor.download(r.url, i, a);
      }
    });
  }
  get installerPath() {
    var t, n;
    return (n = (t = super.installerPath) === null || t === void 0 ? void 0 : t.replace(/ /g, "\\ ")) !== null && n !== void 0 ? n : null;
  }
  doInstall(t) {
    const n = this.wrapSudo(), r = /pkexec/i.test(n) ? "" : '"', i = this.spawnSyncLog("which zypper"), a = this.installerPath;
    if (a == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    let o;
    return i ? o = [i, "--no-refresh", "install", "--allow-unsigned-rpm", "-y", "-f", a] : o = [this.spawnSyncLog("which dnf || which yum"), "-y", "install", a], this.spawnSyncLog(n, [`${r}/bin/bash`, "-c", `'${o.join(" ")}'${r}`]), t.isForceRunAfter && this.app.relaunch(), !0;
  }
}
<<<<<<< HEAD
RpmUpdater$1.RpmUpdater = RpmUpdater;
var MacUpdater$1 = {};
Object.defineProperty(MacUpdater$1, "__esModule", { value: true });
MacUpdater$1.MacUpdater = void 0;
const builder_util_runtime_1$2 = out;
const fs_extra_1$1 = lib;
const fs_1 = fs$w;
const path$2 = require$$1$4;
const http_1 = require$$3$2;
const AppUpdater_1 = AppUpdater$1;
const Provider_1$1 = Provider$1;
const child_process_1$1 = require$$1$9;
const crypto_1 = require$$0$4;
class MacUpdater extends AppUpdater_1.AppUpdater {
  constructor(options, app2) {
    super(options, app2);
    this.nativeUpdater = require$$1$8.autoUpdater;
    this.squirrelDownloadedUpdate = false;
    this.nativeUpdater.on("error", (it) => {
      this._logger.warn(it);
      this.emit("error", it);
    });
    this.nativeUpdater.on("update-downloaded", () => {
      this.squirrelDownloadedUpdate = true;
      this.debug("nativeUpdater.update-downloaded");
=======
Ri.RpmUpdater = lI;
var Ci = {};
Object.defineProperty(Ci, "__esModule", { value: !0 });
Ci.MacUpdater = void 0;
const Lh = De, Jc = vn, uI = ae, Uh = oe, pI = bo, fI = cn, dI = Ce, Bh = _o, jh = Dr;
class hI extends fI.AppUpdater {
  constructor(t, n) {
    super(t, n), this.nativeUpdater = Bn.autoUpdater, this.squirrelDownloadedUpdate = !1, this.nativeUpdater.on("error", (r) => {
      this._logger.warn(r), this.emit("error", r);
    }), this.nativeUpdater.on("update-downloaded", () => {
      this.squirrelDownloadedUpdate = !0, this.debug("nativeUpdater.update-downloaded");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    });
  }
  debug(t) {
    this._logger.debug != null && this._logger.debug(t);
  }
  closeServerIfExists() {
    this.server && (this.debug("Closing proxy server"), this.server.close((t) => {
      t && this.debug("proxy server wasn't already open, probably attempted closing again as a safety check before quit");
    }));
  }
  async doDownloadUpdate(t) {
    let n = t.updateInfoAndProvider.provider.resolveFiles(t.updateInfoAndProvider.info);
    const r = this._logger, i = "sysctl.proc_translated";
    let a = !1;
    try {
      this.debug("Checking for macOS Rosetta environment"), a = (0, Bh.execFileSync)("sysctl", [i], { encoding: "utf8" }).includes(`${i}: 1`), r.info(`Checked for macOS Rosetta environment (isRosetta=${a})`);
    } catch (p) {
      r.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${p}`);
    }
    let o = !1;
    try {
      this.debug("Checking for arm64 in uname");
      const d = (0, Bh.execFileSync)("uname", ["-a"], { encoding: "utf8" }).includes("ARM");
      r.info(`Checked 'uname -a': arm64=${d}`), o = o || d;
    } catch (p) {
      r.warn(`uname shell command to check for arm64 failed: ${p}`);
    }
    o = o || process.arch === "arm64" || a;
    const c = (p) => {
      var d;
      return p.url.pathname.includes("arm64") || ((d = p.info.url) === null || d === void 0 ? void 0 : d.includes("arm64"));
    };
<<<<<<< HEAD
    if (isArm64Mac && files.some(isArm64)) {
      files = files.filter((file2) => isArm64Mac === isArm64(file2));
    } else {
      files = files.filter((file2) => !isArm64(file2));
    }
    const zipFileInfo = (0, Provider_1$1.findFile)(files, "zip", ["pkg", "dmg"]);
    if (zipFileInfo == null) {
      throw (0, builder_util_runtime_1$2.newError)(`ZIP file not provided: ${(0, builder_util_runtime_1$2.safeStringifyJson)(files)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
    }
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const CURRENT_MAC_APP_ZIP_FILE_NAME = "update.zip";
=======
    o && n.some(c) ? n = n.filter((p) => o === c(p)) : n = n.filter((p) => !c(p));
    const s = (0, dI.findFile)(n, "zip", ["pkg", "dmg"]);
    if (s == null)
      throw (0, Lh.newError)(`ZIP file not provided: ${(0, Lh.safeStringifyJson)(n)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
    const u = t.updateInfoAndProvider.provider, l = "update.zip";
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return this.executeDownload({
      fileExtension: "zip",
      fileInfo: s,
      downloadUpdateOptions: t,
      task: async (p, d) => {
        const m = Uh.join(this.downloadedUpdateHelper.cacheDir, l), g = () => (0, Jc.pathExistsSync)(m) ? !t.disableDifferentialDownload : (r.info("Unable to locate previous update.zip for differential download (is this first install?), falling back to full download"), !1);
        let v = !0;
        g() && (v = await this.differentialDownloadInstaller(s, t, p, u, l)), v && await this.httpExecutor.download(s.url, p, d);
      },
      done: async (p) => {
        if (!t.disableDifferentialDownload)
          try {
            const d = Uh.join(this.downloadedUpdateHelper.cacheDir, l);
            await (0, Jc.copyFile)(p.downloadedFile, d);
          } catch (d) {
            this._logger.warn(`Unable to copy file for caching for future differential downloads: ${d.message}`);
          }
        return this.updateDownloaded(s, p);
      }
    });
  }
<<<<<<< HEAD
  async updateDownloaded(zipFileInfo, event) {
    var _a;
    const downloadedFile = event.downloadedFile;
    const updateFileSize = (_a = zipFileInfo.info.size) !== null && _a !== void 0 ? _a : (await (0, fs_extra_1$1.stat)(downloadedFile)).size;
    const log = this._logger;
    const logContext = `fileToProxy=${zipFileInfo.url.href}`;
    this.closeServerIfExists();
    this.debug(`Creating proxy server for native Squirrel.Mac (${logContext})`);
    this.server = (0, http_1.createServer)();
    this.debug(`Proxy server for native Squirrel.Mac is created (${logContext})`);
    this.server.on("close", () => {
      log.info(`Proxy server for native Squirrel.Mac is closed (${logContext})`);
=======
  async updateDownloaded(t, n) {
    var r;
    const i = n.downloadedFile, a = (r = t.info.size) !== null && r !== void 0 ? r : (await (0, Jc.stat)(i)).size, o = this._logger, c = `fileToProxy=${t.url.href}`;
    this.closeServerIfExists(), this.debug(`Creating proxy server for native Squirrel.Mac (${c})`), this.server = (0, pI.createServer)(), this.debug(`Proxy server for native Squirrel.Mac is created (${c})`), this.server.on("close", () => {
      o.info(`Proxy server for native Squirrel.Mac is closed (${c})`);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    });
    const s = (u) => {
      const l = u.address();
      return typeof l == "string" ? l : `http://127.0.0.1:${l == null ? void 0 : l.port}`;
    };
    return await new Promise((u, l) => {
      const p = (0, jh.randomBytes)(64).toString("base64").replace(/\//g, "_").replace(/\+/g, "-"), d = Buffer.from(`autoupdater:${p}`, "ascii"), m = `/${(0, jh.randomBytes)(64).toString("hex")}.zip`;
      this.server.on("request", (g, v) => {
        const y = g.url;
        if (o.info(`${y} requested`), y === "/") {
          if (!g.headers.authorization || g.headers.authorization.indexOf("Basic ") === -1) {
            v.statusCode = 401, v.statusMessage = "Invalid Authentication Credentials", v.end(), o.warn("No authenthication info");
            return;
          }
          const A = g.headers.authorization.split(" ")[1], O = Buffer.from(A, "base64").toString("ascii"), [k, q] = O.split(":");
          if (k !== "autoupdater" || q !== p) {
            v.statusCode = 401, v.statusMessage = "Invalid Authentication Credentials", v.end(), o.warn("Invalid authenthication credentials");
            return;
          }
          const W = Buffer.from(`{ "url": "${s(this.server)}${m}" }`);
          v.writeHead(200, { "Content-Type": "application/json", "Content-Length": W.length }), v.end(W);
          return;
        }
        if (!y.startsWith(m)) {
          o.warn(`${y} requested, but not supported`), v.writeHead(404), v.end();
          return;
        }
        o.info(`${m} requested by Squirrel.Mac, pipe ${i}`);
        let x = !1;
        v.on("finish", () => {
          x || (this.nativeUpdater.removeListener("error", l), u([]));
        });
<<<<<<< HEAD
        const readStream2 = (0, fs_1.createReadStream)(downloadedFile);
        readStream2.on("error", (error2) => {
=======
        const w = (0, uI.createReadStream)(i);
        w.on("error", (A) => {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
          try {
            v.end();
          } catch (O) {
            o.warn(`cannot end response: ${O}`);
          }
          x = !0, this.nativeUpdater.removeListener("error", l), l(new Error(`Cannot pipe "${i}": ${A}`));
        }), v.writeHead(200, {
          "Content-Type": "application/zip",
          "Content-Length": a
        }), w.pipe(v);
      }), this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${c})`), this.server.listen(0, "127.0.0.1", () => {
        this.debug(`Proxy server for native Squirrel.Mac is listening (address=${s(this.server)}, ${c})`), this.nativeUpdater.setFeedURL({
          url: s(this.server),
          headers: {
            "Cache-Control": "no-cache",
            Authorization: `Basic ${d.toString("base64")}`
          }
        }), this.dispatchUpdateDownloaded(n), this.autoInstallOnAppQuit ? (this.nativeUpdater.once("error", l), this.nativeUpdater.checkForUpdates()) : u([]);
      });
    });
  }
  handleUpdateDownloaded() {
    this.autoRunAppAfterInstall ? this.nativeUpdater.quitAndInstall() : this.app.quit(), this.closeServerIfExists();
  }
  quitAndInstall() {
    this.squirrelDownloadedUpdate ? this.handleUpdateDownloaded() : (this.nativeUpdater.on("update-downloaded", () => this.handleUpdateDownloaded()), this.autoInstallOnAppQuit || this.nativeUpdater.checkForUpdates());
  }
}
<<<<<<< HEAD
MacUpdater$1.MacUpdater = MacUpdater;
var NsisUpdater$1 = {};
var windowsExecutableCodeSignatureVerifier = {};
Object.defineProperty(windowsExecutableCodeSignatureVerifier, "__esModule", { value: true });
windowsExecutableCodeSignatureVerifier.verifySignature = verifySignature;
const builder_util_runtime_1$1 = out;
const child_process_1 = require$$1$9;
const os = require$$2$2;
const path$1 = require$$1$4;
function verifySignature(publisherNames, unescapedTempUpdateFile, logger) {
  return new Promise((resolve, reject) => {
    const tempUpdateFile = unescapedTempUpdateFile.replace(/'/g, "''");
    logger.info(`Verifying signature ${tempUpdateFile}`);
    (0, child_process_1.execFile)(`set "PSModulePath=" & chcp 65001 >NUL & powershell.exe`, ["-NoProfile", "-NonInteractive", "-InputFormat", "None", "-Command", `"Get-AuthenticodeSignature -LiteralPath '${tempUpdateFile}' | ConvertTo-Json -Compress"`], {
      shell: true,
=======
Ci.MacUpdater = hI;
var Oi = {}, Ku = {};
Object.defineProperty(Ku, "__esModule", { value: !0 });
Ku.verifySignature = vI;
const Mh = De, bx = _o, mI = Eo, qh = oe;
function vI(e, t, n) {
  return new Promise((r, i) => {
    const a = t.replace(/'/g, "''");
    n.info(`Verifying signature ${a}`), (0, bx.execFile)('set "PSModulePath=" & chcp 65001 >NUL & powershell.exe', ["-NoProfile", "-NonInteractive", "-InputFormat", "None", "-Command", `"Get-AuthenticodeSignature -LiteralPath '${a}' | ConvertTo-Json -Compress"`], {
      shell: !0,
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      timeout: 20 * 1e3
    }, (o, c, s) => {
      var u;
      try {
        if (o != null || s) {
          Zc(n, o, s, i), r(null);
          return;
        }
<<<<<<< HEAD
        const data = parseOut(stdout);
        if (data.Status === 0) {
=======
        const l = gI(c);
        if (l.Status === 0) {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
          try {
            const g = qh.normalize(l.Path), v = qh.normalize(t);
            if (n.info(`LiteralPath: ${g}. Update Path: ${v}`), g !== v) {
              Zc(n, new Error(`LiteralPath of ${g} is different than ${v}`), s, i), r(null);
              return;
            }
          } catch (g) {
            n.warn(`Unable to verify LiteralPath of update asset due to missing data.Path. Skipping this step of validation. Message: ${(u = g.message) !== null && u !== void 0 ? u : g.stack}`);
          }
<<<<<<< HEAD
          const subject = (0, builder_util_runtime_1$1.parseDn)(data.SignerCertificate.Subject);
          let match = false;
          for (const name of publisherNames) {
            const dn = (0, builder_util_runtime_1$1.parseDn)(name);
            if (dn.size) {
              const allKeys = Array.from(dn.keys());
              match = allKeys.every((key2) => {
                return dn.get(key2) === subject.get(key2);
              });
            } else if (name === subject.get("CN")) {
              logger.warn(`Signature validated using only CN ${name}. Please add your full Distinguished Name (DN) to publisherNames configuration`);
              match = true;
            }
            if (match) {
              resolve(null);
=======
          const d = (0, Mh.parseDn)(l.SignerCertificate.Subject);
          let m = !1;
          for (const g of e) {
            const v = (0, Mh.parseDn)(g);
            if (v.size ? m = Array.from(v.keys()).every((x) => v.get(x) === d.get(x)) : g === d.get("CN") && (n.warn(`Signature validated using only CN ${g}. Please add your full Distinguished Name (DN) to publisherNames configuration`), m = !0), m) {
              r(null);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
              return;
            }
          }
        }
        const p = `publisherNames: ${e.join(" | ")}, raw info: ` + JSON.stringify(l, (d, m) => d === "RawData" ? void 0 : m, 2);
        n.warn(`Sign verification failed, installer signed with incorrect certificate: ${p}`), r(p);
      } catch (l) {
        Zc(n, l, null, i), r(null);
        return;
      }
    });
  });
}
<<<<<<< HEAD
function parseOut(out2) {
  const data = JSON.parse(out2);
  delete data.PrivateKey;
  delete data.IsOSBinary;
  delete data.SignatureType;
  const signerCertificate = data.SignerCertificate;
  if (signerCertificate != null) {
    delete signerCertificate.Archived;
    delete signerCertificate.Extensions;
    delete signerCertificate.Handle;
    delete signerCertificate.HasPrivateKey;
    delete signerCertificate.SubjectName;
  }
  return data;
}
function handleError(logger, error2, stderr, reject) {
  if (isOldWin6()) {
    logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error2 || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
=======
function gI(e) {
  const t = JSON.parse(e);
  delete t.PrivateKey, delete t.IsOSBinary, delete t.SignatureType;
  const n = t.SignerCertificate;
  return n != null && (delete n.Archived, delete n.Extensions, delete n.Handle, delete n.HasPrivateKey, delete n.SubjectName), t;
}
function Zc(e, t, n, r) {
  if (xI()) {
    e.warn(`Cannot execute Get-AuthenticodeSignature: ${t || n}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return;
  }
  try {
    (0, bx.execFileSync)("powershell.exe", ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"], { timeout: 10 * 1e3 });
  } catch (i) {
    e.warn(`Cannot execute ConvertTo-Json: ${i.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  t != null && r(t), n && r(new Error(`Cannot execute Get-AuthenticodeSignature, stderr: ${n}. Failing signature validation due to unknown stderr.`));
}
<<<<<<< HEAD
function isOldWin6() {
  const winVersion = os.release();
  return winVersion.startsWith("6.") && !winVersion.startsWith("6.3");
}
Object.defineProperty(NsisUpdater$1, "__esModule", { value: true });
NsisUpdater$1.NsisUpdater = void 0;
const builder_util_runtime_1 = out;
const path = require$$1$4;
const BaseUpdater_1 = BaseUpdater$1;
const FileWithEmbeddedBlockMapDifferentialDownloader_1 = FileWithEmbeddedBlockMapDifferentialDownloader$1;
const types_1 = types;
const Provider_1 = Provider$1;
const fs_extra_1 = lib;
const windowsExecutableCodeSignatureVerifier_1 = windowsExecutableCodeSignatureVerifier;
const url_1 = require$$0$3;
class NsisUpdater extends BaseUpdater_1.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
    this._verifyUpdateCodeSignature = (publisherNames, unescapedTempUpdateFile) => (0, windowsExecutableCodeSignatureVerifier_1.verifySignature)(publisherNames, unescapedTempUpdateFile, this._logger);
=======
function xI() {
  const e = mI.release();
  return e.startsWith("6.") && !e.startsWith("6.3");
}
Object.defineProperty(Oi, "__esModule", { value: !0 });
Oi.NsisUpdater = void 0;
const La = De, zh = oe, yI = Bt, bI = ea, Hh = gn, wI = Ce, EI = vn, _I = Ku, Gh = At;
class SI extends yI.BaseUpdater {
  constructor(t, n) {
    super(t, n), this._verifyUpdateCodeSignature = (r, i) => (0, _I.verifySignature)(r, i, this._logger);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  }
  /**
   * The verifyUpdateCodeSignature. You can pass [win-verify-signature](https://github.com/beyondkmp/win-verify-trust) or another custom verify function: ` (publisherName: string[], path: string) => Promise<string | null>`.
   * The default verify function uses [windowsExecutableCodeSignatureVerifier](https://github.com/electron-userland/electron-builder/blob/master/packages/electron-updater/src/windowsExecutableCodeSignatureVerifier.ts)
   */
  get verifyUpdateCodeSignature() {
    return this._verifyUpdateCodeSignature;
  }
  set verifyUpdateCodeSignature(t) {
    t && (this._verifyUpdateCodeSignature = t);
  }
  /*** @private */
<<<<<<< HEAD
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = (0, Provider_1.findFile)(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "exe");
=======
  doDownloadUpdate(t) {
    const n = t.updateInfoAndProvider.provider, r = (0, wI.findFile)(n.resolveFiles(t.updateInfoAndProvider.info), "exe");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    return this.executeDownload({
      fileExtension: "exe",
      downloadUpdateOptions: t,
      fileInfo: r,
      task: async (i, a, o, c) => {
        const s = r.packageInfo, u = s != null && o != null;
        if (u && t.disableWebInstaller)
          throw (0, La.newError)(`Unable to download new version ${t.updateInfoAndProvider.info.version}. Web Installers are disabled`, "ERR_UPDATER_WEB_INSTALLER_DISABLED");
        !u && !t.disableWebInstaller && this._logger.warn("disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version."), (u || t.disableDifferentialDownload || await this.differentialDownloadInstaller(r, t, i, n, La.CURRENT_APP_INSTALLER_FILE_NAME)) && await this.httpExecutor.download(r.url, i, a);
        const l = await this.verifySignature(i);
        if (l != null)
          throw await c(), (0, La.newError)(`New version ${t.updateInfoAndProvider.info.version} is not signed by the application owner: ${l}`, "ERR_UPDATER_INVALID_SIGNATURE");
        if (u && await this.differentialDownloadWebPackage(t, s, o, n))
          try {
            await this.httpExecutor.download(new Gh.URL(s.path), o, {
              headers: t.requestHeaders,
              cancellationToken: t.cancellationToken,
              sha512: s.sha512
            });
          } catch (p) {
            try {
<<<<<<< HEAD
              await this.httpExecutor.download(new url_1.URL(packageInfo.path), packageFile, {
                headers: downloadUpdateOptions.requestHeaders,
                cancellationToken: downloadUpdateOptions.cancellationToken,
                sha512: packageInfo.sha512
              });
            } catch (e) {
              try {
                await (0, fs_extra_1.unlink)(packageFile);
              } catch (_ignored) {
              }
              throw e;
=======
              await (0, EI.unlink)(o);
            } catch {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
            }
            throw p;
          }
      }
    });
  }
  // $certificateInfo = (Get-AuthenticodeSignature 'xxx\yyy.exe'
  // | where {$_.Status.Equals([System.Management.Automation.SignatureStatus]::Valid) -and $_.SignerCertificate.Subject.Contains("CN=siemens.com")})
  // | Out-String ; if ($certificateInfo) { exit 0 } else { exit 1 }
  async verifySignature(t) {
    let n;
    try {
      if (n = (await this.configOnDisk.value).publisherName, n == null)
        return null;
    } catch (r) {
      if (r.code === "ENOENT")
        return null;
      throw r;
    }
    return await this._verifyUpdateCodeSignature(Array.isArray(n) ? n : [n], t);
  }
  doInstall(t) {
    const n = this.installerPath;
    if (n == null)
      return this.dispatchError(new Error("No valid update available, can't quit and install")), !1;
    const r = ["--updated"];
    t.isSilent && r.push("/S"), t.isForceRunAfter && r.push("--force-run"), this.installDirectory && r.push(`/D=${this.installDirectory}`);
    const i = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;
    i != null && r.push(`--package-file=${i}`);
    const a = () => {
      this.spawnLog(zh.join(process.resourcesPath, "elevate.exe"), [n].concat(r)).catch((o) => this.dispatchError(o));
    };
<<<<<<< HEAD
    if (options.isAdminRightsRequired) {
      this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe");
      callUsingElevation();
      return true;
    }
    this.spawnLog(installerPath, args).catch((e) => {
      const errorCode = e.code;
      this._logger.info(`Cannot run installer: error code: ${errorCode}, error message: "${e.message}", will be executed again using elevate if EACCES, and will try to use electron.shell.openItem if ENOENT`);
      if (errorCode === "UNKNOWN" || errorCode === "EACCES") {
        callUsingElevation();
      } else if (errorCode === "ENOENT") {
        require$$1$8.shell.openPath(installerPath).catch((err) => this.dispatchError(err));
      } else {
        this.dispatchError(e);
      }
    });
    return true;
  }
  async differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packagePath, provider) {
    if (packageInfo.blockMapSize == null) {
      return true;
    }
    try {
      const downloadOptions = {
        newUrl: new url_1.URL(packageInfo.path),
        oldFile: path.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_PACKAGE_FILE_NAME),
        logger: this._logger,
        newFile: packagePath,
        requestHeaders: this.requestHeaders,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
      if (this.listenerCount(types_1.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(types_1.DOWNLOAD_PROGRESS, it);
      }
      await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, this.httpExecutor, downloadOptions).download();
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      return process.platform === "win32";
    }
    return false;
  }
}
NsisUpdater$1.NsisUpdater = NsisUpdater;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NsisUpdater = exports.MacUpdater = exports.RpmUpdater = exports.PacmanUpdater = exports.DebUpdater = exports.AppImageUpdater = exports.Provider = exports.NoOpLogger = exports.AppUpdater = exports.BaseUpdater = void 0;
  const fs_extra_12 = lib;
  const path2 = require$$1$4;
  var BaseUpdater_12 = BaseUpdater$1;
  Object.defineProperty(exports, "BaseUpdater", { enumerable: true, get: function() {
    return BaseUpdater_12.BaseUpdater;
=======
    return t.isAdminRightsRequired ? (this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe"), a(), !0) : (this.spawnLog(n, r).catch((o) => {
      const c = o.code;
      this._logger.info(`Cannot run installer: error code: ${c}, error message: "${o.message}", will be executed again using elevate if EACCES, and will try to use electron.shell.openItem if ENOENT`), c === "UNKNOWN" || c === "EACCES" ? a() : c === "ENOENT" ? Bn.shell.openPath(n).catch((s) => this.dispatchError(s)) : this.dispatchError(o);
    }), !0);
  }
  async differentialDownloadWebPackage(t, n, r, i) {
    if (n.blockMapSize == null)
      return !0;
    try {
      const a = {
        newUrl: new Gh.URL(n.path),
        oldFile: zh.join(this.downloadedUpdateHelper.cacheDir, La.CURRENT_APP_PACKAGE_FILE_NAME),
        logger: this._logger,
        newFile: r,
        requestHeaders: this.requestHeaders,
        isUseMultipleRangeRequest: i.isUseMultipleRangeRequest,
        cancellationToken: t.cancellationToken
      };
      this.listenerCount(Hh.DOWNLOAD_PROGRESS) > 0 && (a.onProgress = (o) => this.emit(Hh.DOWNLOAD_PROGRESS, o)), await new bI.FileWithEmbeddedBlockMapDifferentialDownloader(n, this.httpExecutor, a).download();
    } catch (a) {
      return this._logger.error(`Cannot download differentially, fallback to full download: ${a.stack || a}`), process.platform === "win32";
    }
    return !1;
  }
}
Oi.NsisUpdater = SI;
(function(e) {
  var t = Te && Te.__createBinding || (Object.create ? function(y, x, w, A) {
    A === void 0 && (A = w);
    var O = Object.getOwnPropertyDescriptor(x, w);
    (!O || ("get" in O ? !x.__esModule : O.writable || O.configurable)) && (O = { enumerable: !0, get: function() {
      return x[w];
    } }), Object.defineProperty(y, A, O);
  } : function(y, x, w, A) {
    A === void 0 && (A = w), y[A] = x[w];
  }), n = Te && Te.__exportStar || function(y, x) {
    for (var w in y) w !== "default" && !Object.prototype.hasOwnProperty.call(x, w) && t(x, y, w);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.NsisUpdater = e.MacUpdater = e.RpmUpdater = e.PacmanUpdater = e.DebUpdater = e.AppImageUpdater = e.Provider = e.NoOpLogger = e.AppUpdater = e.BaseUpdater = void 0;
  const r = vn, i = oe;
  var a = Bt;
  Object.defineProperty(e, "BaseUpdater", { enumerable: !0, get: function() {
    return a.BaseUpdater;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  } });
  var o = cn;
  Object.defineProperty(e, "AppUpdater", { enumerable: !0, get: function() {
    return o.AppUpdater;
  } }), Object.defineProperty(e, "NoOpLogger", { enumerable: !0, get: function() {
    return o.NoOpLogger;
  } });
  var c = Ce;
  Object.defineProperty(e, "Provider", { enumerable: !0, get: function() {
    return c.Provider;
  } });
  var s = Si;
  Object.defineProperty(e, "AppImageUpdater", { enumerable: !0, get: function() {
    return s.AppImageUpdater;
  } });
  var u = Ti;
  Object.defineProperty(e, "DebUpdater", { enumerable: !0, get: function() {
    return u.DebUpdater;
  } });
  var l = Ai;
  Object.defineProperty(e, "PacmanUpdater", { enumerable: !0, get: function() {
    return l.PacmanUpdater;
  } });
  var p = Ri;
  Object.defineProperty(e, "RpmUpdater", { enumerable: !0, get: function() {
    return p.RpmUpdater;
  } });
  var d = Ci;
  Object.defineProperty(e, "MacUpdater", { enumerable: !0, get: function() {
    return d.MacUpdater;
  } });
  var m = Oi;
  Object.defineProperty(e, "NsisUpdater", { enumerable: !0, get: function() {
    return m.NsisUpdater;
  } }), n(gn, e);
  let g;
  function v() {
    if (process.platform === "win32")
      g = new Oi.NsisUpdater();
    else if (process.platform === "darwin")
      g = new Ci.MacUpdater();
    else {
      g = new Si.AppImageUpdater();
      try {
        const y = i.join(process.resourcesPath, "package-type");
        if (!(0, r.existsSync)(y))
          return g;
        console.info("Checking for beta autoupdate feature for deb/rpm distributions");
        const x = (0, r.readFileSync)(y).toString().trim();
        switch (console.info("Found package-type:", x), x) {
          case "deb":
            g = new Ti.DebUpdater();
            break;
          case "rpm":
            g = new Ri.RpmUpdater();
            break;
          case "pacman":
            g = new Ai.PacmanUpdater();
            break;
          default:
            break;
        }
      } catch (y) {
        console.warn("Unable to detect 'package-type' for autoUpdater (beta rpm/deb support). If you'd like to expand support, please consider contributing to electron-builder", y.message);
      }
    }
    return g;
  }
  Object.defineProperty(e, "autoUpdater", {
    enumerable: !0,
    get: () => g || v()
  });
<<<<<<< HEAD
})(main$1);
class ElectronUpdate extends DevTools {
  constructor(win2) {
    super(win2);
    __publicField(this, "updateInProgress");
    __publicField(this, "proxyurl");
    __publicField(this, "is_download");
    __publicField(this, "setUpdatSetFeedUrl", async () => {
      var _a, _b;
      const tag = await this.getLatestVersion();
      const proxyurl = ((_a = this.runConfig) == null ? void 0 : _a.proxy_url) ? ((_b = this.runConfig) == null ? void 0 : _b.proxy_url) + "/" : "";
      if (tag) {
        const url2 = `${proxyurl}https://github.com/forget-pro/sync-code-tool/releases/download/${tag}`;
        if (url2 === this.proxyurl) return;
        this.proxyurl = url2;
        main$1.autoUpdater.setFeedURL({
=======
})(wt);
class TI extends hv {
  constructor(n) {
    super(n);
    xe(this, "updateInProgress");
    xe(this, "proxyurl");
    xe(this, "is_download");
    xe(this, "setUpdatSetFeedUrl", async () => {
      var i, a;
      const n = await this.getLatestVersion();
      this.sendLog(`: ${n}`);
      const r = (i = this.runConfig) != null && i.proxy_url ? ((a = this.runConfig) == null ? void 0 : a.proxy_url) + "/" : "";
      if (n) {
        const o = `${r}https://github.com/forget-pro/sync-code-tool/releases/download/${n}`;
        if (o === this.proxyurl) return;
        this.proxyurl = o, wt.autoUpdater.setFeedURL({
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
          provider: "generic",
          url: o,
          requestHeaders: {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36"
          }
<<<<<<< HEAD
        });
        this.sendLog(`: ${tag}`);
=======
        }), this.sendLog("", "INFO");
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
      }
    });
    // APP
    xe(this, "getLatestVersion", async () => {
      try {
        const r = await Ee.get("https://api.github.com/repos/forget-pro/sync-code-tool/releases", { timeout: 6e3 });
        return r.status !== 200 ? (this.sendLog("", "ERROR"), null) : (r.data.filter((o) => /^app-v/.test(o.tag_name))[0] || null).tag_name || null;
      } catch (n) {
        return this.sendLog(n.message, "ERROR"), null;
      }
    });
    // 
    xe(this, "checkElectronUpdate", async () => {
      try {
        if (!rn.isPackaged) return 0;
        if (this.updateInProgress) return 2;
        if (this.is_download) return 3;
<<<<<<< HEAD
        this.updateInProgress = true;
        await this.setUpdatSetFeedUrl();
        const res = await main$1.autoUpdater.checkForUpdatesAndNotify();
        this.updateInProgress = false;
        main$1.autoUpdater.on("checking-for-update", () => {
          var _a;
          (_a = this.windown) == null ? void 0 : _a.webContents.send("main-process-message", " ...");
        });
        main$1.autoUpdater.on("update-available", () => {
          var _a;
          (_a = this.windown) == null ? void 0 : _a.webContents.send("main-process-message", "update-available");
        });
        main$1.autoUpdater.on("update-not-available", () => {
          var _a;
          (_a = this.windown) == null ? void 0 : _a.webContents.send("main-process-message", "update-not-available");
        });
        main$1.autoUpdater.on("download-progress", () => {
          this.is_download = true;
        });
        main$1.autoUpdater.on("error", (err) => {
          var _a;
          this.is_download = false;
          this.updateInProgress = false;
          (_a = this.windown) == null ? void 0 : _a.webContents.send("main-process-message", err.message);
        });
        main$1.autoUpdater.on("update-downloaded", () => {
          this.is_download = false;
          dialog.showMessageBox({
=======
        this.updateInProgress = !0, await this.setUpdatSetFeedUrl();
        const n = await wt.autoUpdater.checkForUpdatesAndNotify();
        return this.updateInProgress = !1, wt.autoUpdater.on("checking-for-update", () => {
          var r;
          (r = this.windown) == null || r.webContents.send("main-process-message", " ...");
        }), wt.autoUpdater.on("update-available", () => {
          var r;
          (r = this.windown) == null || r.webContents.send("main-process-message", "update-available");
        }), wt.autoUpdater.on("update-not-available", () => {
          var r;
          (r = this.windown) == null || r.webContents.send("main-process-message", "update-not-available");
        }), wt.autoUpdater.on("download-progress", () => {
          this.is_download = !0;
        }), wt.autoUpdater.on("error", (r) => {
          var i;
          this.is_download = !1, this.updateInProgress = !1, (i = this.windown) == null || i.webContents.send("main-process-message", r.message);
        }), wt.autoUpdater.on("update-downloaded", () => {
          this.is_download = !1, Wh.showMessageBox({
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
            type: "info",
            title: "",
            message: "",
            buttons: ["", ""]
<<<<<<< HEAD
          }).then((result) => {
            if (result.response === 0) {
              main$1.autoUpdater.quitAndInstall();
            }
            this.updateInProgress = false;
=======
          }).then((r) => {
            r.response === 0 && wt.autoUpdater.quitAndInstall(), this.updateInProgress = !1;
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
          });
        }), n && (n == null ? void 0 : n.updateInfo.version) !== rn.getVersion() ? 1 : 0;
      } catch (n) {
        this.updateInProgress = !1, this.sendLog(n.message, "ERROR");
      }
    });
    this.updateInProgress = !1, this.proxyurl = "", this.is_download = !1;
  }
}
<<<<<<< HEAD
createRequire(import.meta.url);
const __dirname = path$t.dirname(fileURLToPath(import.meta.url));
process.env.APP_ROOT = path$t.join(__dirname, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path$t.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path$t.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path$t.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
let devTools = null;
let electronUpdate = null;
function createWindow() {
  win = new BrowserWindow({
=======
Xh(import.meta.url);
const wx = ot.dirname(Ry(import.meta.url));
process.env.APP_ROOT = ot.join(wx, "..");
const Fl = process.env.VITE_DEV_SERVER_URL, RP = ot.join(process.env.APP_ROOT, "dist-electron"), Ex = ot.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = Fl ? ot.join(process.env.APP_ROOT, "public") : Ex;
let at, ye = null, Ua = null;
function _x() {
  at = new Yh({
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    width: 1200,
    height: 800,
    minWidth: 1200,
    minHeight: 800,
<<<<<<< HEAD
    icon: path$t.join(process.env.VITE_PUBLIC || "", "logo.png"),
    webPreferences: {
      preload: path$t.join(__dirname, "preload.mjs")
    }
  });
  devTools = new DevTools(win);
  electronUpdate = new ElectronUpdate(win);
  win.webContents.on("did-finish-load", () => {
    electronUpdate == null ? void 0 : electronUpdate.checkElectronUpdate();
    devTools == null ? void 0 : devTools.reportConfig();
    devTools == null ? void 0 : devTools.sendLog(" ");
  });
  globalShortcut.register("CommandOrControl+Shift+I", () => {
    win == null ? void 0 : win.webContents.toggleDevTools();
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
    win.webContents.openDevTools();
  } else {
    win.loadFile(path$t.join(RENDERER_DIST, "index.html"));
  }
}
const menu = Menu.buildFromTemplate([]);
Menu.setApplicationMenu(menu);
ipcMain.handle("downloadFile", async (_, data) => {
  const app_dir = path$t.join(app.getPath("documents"), "code-sync");
  const filepath = path$t.join(app_dir, `${data.type}/${data.appid}`);
  if (!fs$x.existsSync(filepath)) {
    fs$x.mkdirSync(filepath, { recursive: true });
  }
  const dest = path$t.join(filepath, "code.tar.gz");
  const result = await (devTools == null ? void 0 : devTools.downloadFile(data.url, dest));
=======
    icon: ot.join(process.env.VITE_PUBLIC || "", "logo.png"),
    webPreferences: {
      preload: ot.join(wx, "preload.mjs")
    }
  }), ye = new hv(at), Ua = new TI(at), at.webContents.on("did-finish-load", () => {
    Ua == null || Ua.checkElectronUpdate(), ye == null || ye.reportConfig(), ye == null || ye.sendLog(" ");
  }), Ay.register("CommandOrControl+Shift+I", () => {
    at == null || at.webContents.toggleDevTools();
  }), Fl ? (at.loadURL(Fl), at.webContents.openDevTools()) : at.loadFile(ot.join(Ex, "index.html"));
}
const AI = Vh.buildFromTemplate([]);
Vh.setApplicationMenu(AI);
zn.handle("downloadFile", async (e, t) => {
  const n = ot.join(rn.getPath("documents"), "code-sync"), r = ot.join(n, `${t.type}/${t.appid}`);
  vp.existsSync(r) || vp.mkdirSync(r, { recursive: !0 });
  const i = ot.join(r, "code.tar.gz"), a = await (ye == null ? void 0 : ye.downloadFile(t.url, i));
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
  return {
    path: i,
    result: a
  };
});
<<<<<<< HEAD
ipcMain.handle("unzipFile", async (_, data) => {
  return await (devTools == null ? void 0 : devTools.unzipFile(data.filepath, path$t.dirname(data.filepath)));
=======
zn.handle("unzipFile", async (e, t) => await (ye == null ? void 0 : ye.unzipFile(t.filepath, ot.dirname(t.filepath))));
zn.handle("DevToolsOpen", async (e, t) => {
  ye == null || ye.startDevTool(t.type, t.url);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
});
zn.handle("open:url", (e, t) => {
  Ty.openExternal(t);
});
zn.handle("saveConfig", (e, t) => {
  ye == null || ye.writeConfig(t);
});
<<<<<<< HEAD
ipcMain.handle("saveConfig", (_, data) => {
  devTools == null ? void 0 : devTools.writeConfig(data);
});
ipcMain.handle("getConfig", () => {
  return (devTools == null ? void 0 : devTools.reportConfig()) || {};
});
ipcMain.handle("dialog:open", async (_, type2) => {
  const result = await dialog.showOpenDialog(win, {
=======
zn.handle("getConfig", () => (ye == null ? void 0 : ye.reportConfig()) || {});
zn.handle("dialog:open", async (e, t) => {
  const n = await Wh.showOpenDialog(at, {
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
    title: "",
    properties: [t, "showHiddenFiles", "createDirectory", "treatPackageAsDirectory"],
    filters: [
      { name: "", extensions: ["app"] },
      { name: "", extensions: ["*"] }
    ]
  });
  if (n.filePaths.length)
    return n.filePaths[0];
});
<<<<<<< HEAD
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
    win = null;
  }
=======
rn.on("window-all-closed", () => {
  process.platform !== "darwin" && (rn.quit(), at = null);
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
});
rn.on("activate", () => {
  Yh.getAllWindows().length === 0 && _x();
});
rn.whenReady().then(_x);
export {
<<<<<<< HEAD
  MAIN_DIST,
  RENDERER_DIST,
  VITE_DEV_SERVER_URL
=======
  RP as MAIN_DIST,
  Ex as RENDERER_DIST,
  Fl as VITE_DEV_SERVER_URL
>>>>>>> 5a127124068313599c6d4b1493ecf328d5712c28
};
